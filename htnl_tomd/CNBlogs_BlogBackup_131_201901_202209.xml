<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-南宫乘风</title><link>https://www.cnblogs.com/heian99/</link><description /><language>zh-cn</language><lastBuildDate>Tue, 20 Sep 2022 12:38:25 GMT</lastBuildDate><pubDate>Tue, 20 Sep 2022 12:38:25 GMT</pubDate><ttl>60</ttl><item><title>Prometheus监控MongoDB数据库</title><link>http://www.cnblogs.com/heian99/archive/2022/09/20/16712479.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 20 Sep 2022 12:38:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/09/20/16712479.html</guid><description><![CDATA[
                    <p>监控环境：Prometheus</p> 
<p>数据库：MongoDB 3.4.6 集群，3个节点</p> 
<p>监控工具：mongodb_exporter</p> 
<p></p> 
<h2>1、创建Mongodb监控可读账号</h2> 
<pre><code class="language-bash">mongodb admin 库中执行

use admin
db.createUser({ 
    user: "prometheus",
    pwd: "prometheus",
    roles: [
        { role: "read", db: "admin" },
        { role: "readAnyDatabase", db: "admin" },
        { role: "clusterMonitor", db: "admin" }
    ]
});</code></pre> 
<h2>2、下载MongoDB监控软件</h2> 
<pre><code class="language-bash">地址：  https://github.com/percona/mongodb_exporter
</code></pre> 
<p>我使用的：mongodb_exporter-0.11.2.linux-amd64.tar.gz 版本</p> 
<h2>3、配置文件</h2> 
<pre><code class="language-bash">nohup  ./mongodb_exporter --mongodb.uri mongodb://root:heian@192.168.82.105:27017/admin --collect.database --collect.collection --collect.topmetrics  --collect.indexusage  --collect.connpoolstats --suppress.collectshardingstatus  &amp;</code></pre> 
<p>mongodb_exporter暴露的endpoint端口默认为9216</p> 
<pre><code class="language-bash">[root@prometheus-server exporter]# ./mongodb_exporter --help
usage: mongodb_exporter [&lt;flags&gt;]

exports various MongoDB metrics in Prometheus format.

Flags:
  -h, --help                   Show context-sensitive help (also try --help-long and --help-man).
      --web.auth-file=WEB.AUTH-FILE  
                               Path to YAML file with server_user, server_password keys for HTTP Basic authentication (overrides HTTP_AUTH environment variable).
      --web.ssl-cert-file=WEB.SSL-CERT-FILE  
                               Path to SSL certificate file.
      --web.ssl-key-file=WEB.SSL-KEY-FILE  
                               Path to SSL key file.
      --web.listen-address=":9216"  
                               Address to listen on for web interface and telemetry.
      --web.telemetry-path="/metrics"  
                               Path under which to expose metrics.
      --collect.database       Enable collection of Database metrics
      --collect.collection     Enable collection of Collection metrics
      --collect.topmetrics     Enable collection of table top metrics
      --collect.indexusage     Enable collection of per index usage stats
      --collect.connpoolstats  Collect MongoDB connpoolstats
      --suppress.collectshardingstatus  
                               Suppress the collection of Sharding Status
      --mongodb.uri=[mongodb://][user:pass@]host1[:port1][,host2[:port2],...][/database][?options]  
                               MongoDB URI, format
      --test                   Check MongoDB connection, print buildInfo() information and exit.
      --version                Show application version.
      --log.level="info"       Only log messages with the given severity or above. Valid levels: [debug, info, warn, error, fatal]
      --log.format="logger:stderr"  
                               Set the log target and format. Example: "logger:syslog?appname=bob&amp;local=7" or "logger:stdout?json=true"

</code></pre> 
<p></p> 
<pre><code class="language-bash">配置启动服务
vim /usr/lib/systemd/system/mongodb_exporter.service
[Unit]
Description=mongodb_exporter
Documentation=https://github.com/percona/mongodb_exporter
After=network.target

[Service]
Type=simple
User=prometheus
Environment="MONGODB_URI=mongodb://mongodb_exporter:123456@localhost:27017"
ExecStart=/usr/local/bin/mongodb_exporter --log.level=error \
  --collect.database \
  --collect.collection \
  --collect.topmetrics \
  --collect.indexusage \
  --collect.connpoolstats

Restart=on-failure

[Install]
WantedBy=multi-user.target
</code></pre> 
<h2>4、prometheus配置基于文件的自动发现</h2> 
<pre><code class="language-bash">  - job_name: 'mongo_cluster'
    file_sd_configs:
      - files: ['/usr/local/prometheus/sd_config/mongo_cluster.yaml']
        refresh_interval: 5s
root:/usr/local/prometheus# cat /usr/local/prometheus/sd_config/mongo_cluster.yaml
- targets:
        - "192.168.88.140:9216"
        - "192.168.88.141:9216"
        - "192.168.88.142:9216"
  labels:
          project: mongo
          unitname: "Mongodb_exporter"
          service: mongo</code></pre> 
<h2>5、grafana配置mongo展示图</h2> 
<p>导入图：16974</p> 
<p><a href="https://grafana.com/grafana/dashboards/16974-mongodb/" title="MongoDB信息 | Grafana Labs">MongoDB信息 | Grafana Labs</a>&nbsp; （这个模板是自己绘制的，有基础的可以二次开发）</p> 
<p><img alt="" height="1200" src="https://img-blog.csdnimg.cn/fd85eb5bedd246eb9a8de07cfb05e449.png" width="1200"></p> 
<p>&nbsp;</p> 
<p></p> 
<p></p>
                ]]></description></item><item><title>Python开发mysql和mongo 连接类</title><link>http://www.cnblogs.com/heian99/archive/2022/09/20/16712480.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 20 Sep 2022 12:38:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/09/20/16712480.html</guid><description><![CDATA[
                    <p>因为业务需求，需要连接数据库查询数据</p> 
<p>数据库类型：mysql，mongodb</p> 
<p>需求：有中连机制，读取配置文件，可实例化，有日志记录</p> 
<p><img alt="" height="369" src="https://img-blog.csdnimg.cn/e42eaabb593245b2a93aecbc1baac682.png" width="402"></p> 
<p>&nbsp;</p> 
<h2>配置文件</h2> 
<p>dbconfig.conf</p> 
<pre><code>[Mongodbtest]
host=192.168.99.42
port=27018
user=
password=
database=ace_sms


[mysql]
host=192.168.99.42
port=27018
user=
password=
database=ace_sms</code></pre> 
<h2>日志类</h2> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
# @Time    : 2022/7/12 18:13
# @File    : Loggers.py
# @Software: PyCharm
# 加入日志
# 获取logger实例
import logging
import os
import sys

logger = logging.getLogger("baseSpider")
# 指定输出格式
formatter = logging.Formatter('%(asctime)s\
            %(filename)s-%(lineno)d\
            %(levelname)s\
            %(message)s')
# 文件日志
# 获取当前文件路径
current_path = os.path.abspath(os.path.dirname(__file__))
father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + ".")
log_file_path = os.path.join(father_path + "\logs\dingding_message.log")

file_handler = logging.FileHandler(log_file_path)
file_handler.setFormatter(formatter)
# 控制台日志
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setFormatter(formatter)

# 为logge添加具体的日志处理器
logger.addHandler(file_handler)
logger.addHandler(console_handler)

logger.setLevel(logging.INFO)
</code></pre> 
<h2>mysql连接类</h2> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
# @Time    : 2022-07-08 21:32

# @File    : MyDB.py
# @Software: PyCharm
import time

import pymysql

import configparser
import logging
import sys

from tool.Loggers import logger


class mysql:
    def __init__(self, config_file, db):
        """

        :param config_file:
        :param db:
        """
        # 实例化configparser
        config = configparser.ConfigParser()
        # 从配置文件中读取数据库的相关信息

        config.read(config_file, encoding='utf-8')
        self.host = config[db]['host']
        self.port = int(config[db]['port'])
        self.user = config[db]['user']
        self.password = config[db]['password']
        self.database = config[db]['database']
        self.db = db
        self.conn = None
        self._conn()

    def _conn(self):
        try:
            logger.info(f"读取环境：{self.db}，连接信息：主机ip：{self.host},端口：{self.port},用户：{self.user},连接数据库：{self.database}")
            self.conn = pymysql.Connection(host=self.host, user=self.user, password=self.password,
                                           database=self.database, port=self.port)
            logger.info(f"数据库: {self.database}初始化连接成功")
            return True
        except  Exception as e:
            logger.error(f"数据库: {self.database}初始化连接失败，错误：{e}")
            return False

    def close(self):
        self.conn.close()
        logger.info(f"数据库关闭成功")

    def _reConn(self, num=28800, stime=3):  # 重试连接总次数为1天,这里根据实际情况自己设置,如果服务器宕机1天都没发现就......
        _number = 0
        _status = True
        logger.info(f"检查数据库{self.database}连通性,连接IP：{self.host}")
        while _status and _number &lt;= num:
            try:
                self.conn.ping()  # cping 校验连接是否异常
                _status = False
                logger.info(f"数据库{self.database}连接============正常,连接IP：{self.host} ")
            except:
                if self._conn() == True:  # 重新连接,成功退出
                    _status = False
                    break
                _number += 1
                logger.info(f"数据库{self.database}连接============失败,连接IP：{self.host} ")
                time.sleep(stime)  # 连接不成功,休眠3秒钟,继续循环，知道成功或重试次数结束

    def select(self, sql=''):
        try:
            self._reConn()
            logger.info('查询的语句:%s' % sql)
            # 建立游标
            db_cursor = self.conn.cursor()
            db_cursor.execute(sql)
            result = db_cursor.fetchall()
            # 返回值和数据表字段组成json格式
            lists = []
            t = 0
            for x in result:
                i = 0
                onelist = {}
                for field in db_cursor.description:
                    onelist[field[0]] = x[i]
                    i = i + 1
                lists.append(onelist)
            logger.info('组合数据:%s' % lists)
            return lists
            # return result
        except pymysql.Error as e:
            logger.error('数据库查询数据失败：%s' % e)
            return False

    def select_limit(self, sql='', offset=0, length=20):
        sql = '%s limit %d , %d ;' % (sql, offset, length)
        return self.select(sql)

    # # 插入
    # def execute_insert(self, query):
    #     print('query:%s' % query)
    #     try:
    #         # 建立游标
    #         db_cursor = self.dbconn.cursor()
    #         db_cursor.execute(query)
    #         db_cursor.execute('commit')
    #         return True
    #     except Exception as e:
    #         print('数据库插入数据失败：%s' % e)
    #         # 事务回滚
    #         db_cursor.execute('rollback')
    #         db_cursor.close()
    #         exit()
</code></pre> 
<h2>MongoDB连接类</h2> 
<p></p> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
# @Time    : 2022/7/12 10:44
# @File    : MongoDB.py
# @Software: PyCharm


import configparser
import time

import pymongo

from alarm.tool.Loggers import logger


class mongo(object):
    def __init__(self, config_file, db):
        """

        :param config_file: 配置文件路径
        :param db: 获取配置的环境
        """
        # 实例化configparser
        config = configparser.ConfigParser()
        # 从配置文件中读取数据库的相关信息

        config.read(config_file, encoding='utf-8')
        self.host = config[db]['host']
        self.port = int(config[db]['port'])
        self.user = config[db]['user']
        self.password = config[db]['password']
        self.database = config[db]['database']
        self.db = db
        self.conn = None
        self._conn()

    def _conn(self):
        try:
            logger.info(f"读取环境：{self.db}，连接信息：主机ip：{self.host},端口：{self.port},用户：{self.user},连接数据库：{self.database}")
            # self.conn = pymongo.MongoClient(host=self.host,
            #                                 port=self.port)
            self.conn = pymongo.MongoClient(host=self.host,
                                            port=self.port)  # username=self.user, password=self.password
            # self.db_conn = self.conn[self.database]
            # self.db_conn=self.db_conn.authenticate(self.user,self.password)
            self.conn[self.database].authenticate(self.user, self.password, self.database)
            self.db_conn = self.conn[self.database]
            if self.conn.server_info():
                logger.info(f"数据库: {self.database}初始化连接成功")
                return True
        except  Exception as e:
            logger.error(f"数据库: {self.database}初始化连接失败，错误：{e}")
            return False

    # MongoDB数据库关闭
    def close(self):
        self.conn.close()
        logger.info(f"数据库关闭成功")

    # 查询调用状态
    def get_state(self):
        return self.conn is not None  # and self.db_conn is not None

    def _reConn(self, num=28800, stime=3):  # 重试连接总次数为1天,这里根据实际情况自己设置,如果服务器宕机1天都没发现就......
        _number = 0
        _status = True
        logger.info(f"检查数据库{self.database}连通性,连接IP：{self.host}")
        while _status and _number &lt;= num:
            try:
                self.conn.server_info()  # 检查数据库是否正常连通
                _status = False
                logger.info(f"数据库{self.database}连接============正常,连接IP：{self.host} ")
            except:
                if self._conn() == True:  # 重新连接,成功退出
                    _status = False
                    break
                _number += 1
                logger.info(f"数据库{self.database}连接============失败,连接IP：{self.host} ")
                time.sleep(stime)  # 连接不成功,休眠3秒钟,继续循环，知道成功或重试次数结束

    def insert_one(self, collection, data):
        self._reConn()
        if self.get_state():
            ret = self.db_conn[collection].insert_one(data)
            return ret.inserted_id
        else:
            return ""

    def insert_many(self, collection, data):
        if self.get_state():
            ret = self.db_conn[collection].insert_many(data)
            return ret.inserted_id
        else:
            return ""

    def update(self, collection, data):
        # data format:
        # {key:[old_data,new_data]}
        data_filter = {}
        data_revised = {}
        for key in data.keys():
            data_filter[key] = data[key][0]
            data_revised[key] = data[key][1]
        if self.get_state():
            return self.db_conn[collection].update_many(data_filter, {"$set": data_revised}).modified_count
        return 0

    def find(self, col, condition, column=None):
        """
        查询数据代码
        :param col: 数据库中的集合
        :param condition: 查询条件,查询条件必须是个字典
        :param column: find 的第二个参数是可选的，可以指定需要返回的键。这个特别的 "$slice" 运算符可以返回一个数组键中元素的子集。
        :return: list 返回查询到记录的列表
        """
        # print(col, condition)
        # data= self.db_conn["sms_log"]
        # data=self.db_conn["sms_log"].find({"status":"2","createTime":{"$gte": "2022/07/12 22:18:26"}},{"status":1,"channelCode":1,"_id":0})
        # data = self.db_conn["authCode"].find({"use": False,"createdTime": {"$gte": 1657865035}})
        # print(list(data))
        self._reConn()
        if self.get_state():
            if column is None:
                return list(self.db_conn[col].find(condition))
            else:
                return list(self.db_conn[col].find(condition, column))
        else:
            return None

    def get_last_data(self, col, number=1):
        if self.get_state():
            # last_data = list(self.db_conn["authCode"].find().sort("_id", -1 ).limit(50))

            last_data = list(self.db_conn[col].find().sort("_id", -1).limit(number))
            return last_data

    def delete(self, col, condition):
        if self.get_state():
            return self.db_conn[col].delete_many(filter=condition).deleted_count
        return 0

    def aggregate(self, col, condition):
        if self.get_state():
            return list(self.db_conn[col].aggregate(condition))


# 时间戳转换时间
def timestamp_to_time(timestamp):
    timeArray = time.localtime(timestamp)  # 转换为可用的时间，就是下面的%Y %m %d
    # day_time = time.strftime("%Y-%m-%d", timeArray)  # 取上面的timeArray中的对应值0
    second_time = time.strftime("%Y-%m-%d %H:%M:%S", timeArray)  # 这个一样的
    return second_time  # 返回相应的值


# 时间转换时间戳
def time_to_timestamp(time_str):
    # 转换成时间数组
    timeArray = time.strptime(time_str, "%Y-%m-%d %H:%M:%S")
    # 转换成时间戳
    timestamp = time.mktime(timeArray)
    # print(timestamp)
    return timestamp


if __name__ == '__main__':
    logger.info("开始实例化数据库对象 ")
    config_file = '../config/dbconfig.conf'
    db = 'Devfubaodai'
    db = mongo(config_file, db)

    # 获取时间
    data_time = '2022-07-18 00:00:00'
    timestamp = time_to_timestamp(data_time)
    # print(timestamp)
    data = db.get_last_data("authCode", 1)
    last_time_data = data[0]["createdTime"]
    satrt_time_data = data[0]["createdTime"]-600
    print(timestamp_to_time(last_time_data))
    print(timestamp_to_time(satrt_time_data))
    data = db.find("authCode", {"createdTime": {"$gte": satrt_time_data, "$lte": last_time_data}}, {"name": 1, "use": 1, "_id": 0})
    num, fail = 0, 0
    for i in data:
        num += 1
        print(i)
    print(num)
    # logger.info(f"短信---最新50条数据，成功使用数量：{num}，未使用的数量：{fail}")

    db.close()
    logger.info("--------------------------------------------------------------------------------------------------")
</code></pre> 
<h2>mian类</h2> 
<pre><code class="language-python">def main():
    #mysqld_test()
     schedule.every(1).minutes.do(mysqld_test)
     while True:
         schedule.run_pending()
         time.sleep(1)


if __name__ == '__main__':
    res = os.path.abspath(__file__)  # 获取当前文件的绝对路径
    print(res)
    base_path = os.path.dirname(os.path.dirname(res))  # 获取当前文件的上两级目录
    print(base_path)
    base_path2 = os.path.dirname(res)
    print(base_path2)
    sys.path.append(base_path2)
    sys.path.append(base_path)
    sys.path.insert(0, base_path)  # 加入环境变量
    # 以上5行代码必须要加入到文件的最上方
    print(sys.path)
    main()
</code></pre> 
<p></p>
                ]]></description></item><item><title>Python编写告警信息，整合Alertmanager告警</title><link>http://www.cnblogs.com/heian99/archive/2022/09/20/16712481.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 20 Sep 2022 12:38:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/09/20/16712481.html</guid><description><![CDATA[
                    <p></p> 
<p><img alt="" height="435" src="https://img-blog.csdnimg.cn/813725adf5d84c97ab5eeedb87375685.png" width="816"></p> 
<h1>&nbsp;Alertmanager告警 系统整合</h1> 
<h2>流程</h2> 
<p>（1）监控端，可以使用Python 或者 shell 进行监控，把 相关的json数据推送到Alertmanager</p> 
<p>（2）Alertmanager端 进行 汇总，发送，后续可以静默，抑制等功能</p> 
<p>（3）把告警的数据发送到prometheusalert，进行钉钉的发送</p> 
<h2>环境</h2> 
<p>软件</p> 
<p><a class="link-info" href="https://github.com/feiyu563/PrometheusAlert" title="prometheusalert 告警系统">prometheusalert 告警系统</a> ：主要是数据的各个渠道发送</p> 
<p><a class="link-info" href="https://github.com/prometheus/alertmanager" title="Alertmanager 告警处理">Alertmanager 告警处理</a>：主要汇总数据，抑制，静默</p> 
<h2>思路</h2> 
<p>编写告警测试数据时，我们可以不用生成时间，仅生成相关的告警指标，时间程序会帮忙生成（待测试）</p> 
<p></p> 
<h1>步骤</h1> 
<h2>获取Alertmanager数据格式</h2> 
<p>方法，通过flask 编写接口，Alertmanager配置，告警时回把数据发送到此接口 ，进行展示查看</p> 
<p></p> 
<pre><code class="language-python">from flask import Flask, request
import json

app = Flask(__name__)


@app.route("/send/", methods=["POST"])
def send():
    try:
        data = json.loads(request.data)
        print(data)
        alerts = data['alerts']
        for i in alerts:
            print('SEND SMS: ' + str(i))
    except Exception as e:
        print(e)
    return 'ok'


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8082)
</code></pre> 
<p>在Alertmanager配置</p> 
<pre><code class="language-bash">[root@prometheus-server alertmanager-0.24.0.linux-amd64]# cat alertmanager.yml
global:
  resolve_timeout: 5m
route:
  group_by: ['instance']
  group_wait: 30s
  group_interval: 10s
  repeat_interval: 10m
  receiver: 'web.hook.prometheusalert'
receivers:
- name: 'web.hook.prometheusalert'
  webhook_configs:
   - url: http://192.168.96.19:8082/send/
</code></pre> 
<p>产生prometheus的测试数据</p> 
<p>关闭客户端，产生告警&nbsp;</p> 
<p><img alt="" height="273" src="https://img-blog.csdnimg.cn/8631635087364da6af41e3d05958e483.png" width="1200"></p> 
<p><strong>告警数据</strong></p> 
<pre><code class="language-bash">{
	'receiver': 'web\\.hook\\.prometheusalert',
	'status': 'firing',
	'alerts': [{
		'status': 'firing',
		'labels': {
			'alertname': '主机存活状态警告！',
			'cloud': '乘风-Dev环境',
			'instance': '192.168.82.105:9100',
			'job': 'node_exporter',
			'severity': '非常严重',
			'team': 'ops'
		},
		'annotations': {
			'description': '192.168.82.105:9100:服务器延时超过5分钟',
			'summary': '192.168.82.105:9100:服务器宕机'
		},
		'startsAt': '2022-07-05T05:54:37.452Z',
		'endsAt': '0001-01-01T00:00:00Z',
		'generatorURL': 'http://prometheus-server.0101101300.fjf:9090/graph?g0.expr=up+%3D%3D+0&amp;g0.tab=1',
		'fingerprint': '4a890f7c225c3bef'
	}],
	'groupLabels': {
		'instance': '192.168.82.105:9100'
	},
	'commonLabels': {
		'alertname': '主机存活状态警告！',
		'cloud': '乘风-Dev环境',
		'instance': '192.168.82.105:9100',
		'job': 'node_exporter',
		'severity': '非常严重',
		'team': 'ops'
	},
	'commonAnnotations': {
		'description': '192.168.82.105:9100:服务器延时超过5分钟',
		'summary': '192.168.82.105:9100:服务器宕机'
	},
	'externalURL': 'http://prometheus-server.0101101300.fjf:9093',
	'version': '4',
	'groupKey': '{}:{instance="192.168.82.105:9100"}',
	'truncatedAlerts': 0
}</code></pre> 
<p><strong>有用的告警数据</strong></p> 
<pre><code class="language-bash">{
		'status': 'firing',
		'labels': {
			'alertname': '主机存活状态警告！',
			'cloud': '乘风-Dev环境',
			'instance': '192.168.82.105:9100',
			'job': 'node_exporter',
			'severity': '非常严重',
			'team': 'ops'
		},
		'annotations': {
			'description': '192.168.82.105:9100:服务器延时超过5分钟',
			'summary': '192.168.82.105:9100:服务器宕机'
		},
		'startsAt': '2022-07-05T05:54:37.452Z',
		'endsAt': '0001-01-01T00:00:00Z',
		'generatorURL': 'http://prometheus-server.0101101300.fjf:9090/graph?g0.expr=up+%3D%3D+0&amp;g0.tab=1',
		'fingerprint': '4a890f7c225c3bef'
	}</code></pre> 
<p><strong>恢复数据</strong></p> 
<pre><code class="language-bash">{
	'receiver': 'web\\.hook\\.prometheusalert',
	'status': 'resolved',
	'alerts': [{
		'status': 'resolved',
		'labels': {
			'alertname': '主机存活状态警告！',
			'cloud': '乘风-Dev环境',
			'instance': '192.168.82.105:9100',
			'job': 'node_exporter',
			'severity': '非常严重',
			'team': 'ops'
		},
		'annotations': {
			'description': '192.168.82.105:9100:服务器延时超过5分钟',
			'summary': '192.168.82.105:9100:服务器宕机'
		},
		'startsAt': '2022-07-05T05:54:37.452Z',
		'endsAt': '2022-07-05T05:56:52.452Z',
		'generatorURL': 'http://prometheus-server.0101101300.fjf:9090/graph?g0.expr=up+%3D%3D+0&amp;g0.tab=1',
		'fingerprint': '4a890f7c225c3bef'
	}],
	'groupLabels': {
		'instance': '192.168.82.105:9100'
	},
	'commonLabels': {
		'alertname': '主机存活状态警告！',
		'cloud': '乘风-Dev环境',
		'instance': '192.168.82.105:9100',
		'job': 'node_exporter',
		'severity': '非常严重',
		'team': 'ops'
	},
	'commonAnnotations': {
		'description': '192.168.82.105:9100:服务器延时超过5分钟',
		'summary': '192.168.82.105:9100:服务器宕机'
	},
	'externalURL': 'http://prometheus-server.0101101300.fjf:9093',
	'version': '4',
	'groupKey': '{}:{instance="192.168.82.105:9100"}',
	'truncatedAlerts': 0
}</code></pre> 
<p><strong>有用的恢复数据</strong></p> 
<pre><code class="language-bash">{
		'status': 'resolved',
		'labels': {
			'alertname': '主机存活状态警告！',
			'cloud': '乘风-Dev环境',
			'instance': '192.168.82.105:9100',
			'job': 'node_exporter',
			'severity': '非常严重',
			'team': 'ops'
		},
		'annotations': {
			'description': '192.168.82.105:9100:服务器延时超过5分钟',
			'summary': '192.168.82.105:9100:服务器宕机'
		},
		'startsAt': '2022-07-05T05:54:37.452Z',
		'endsAt': '2022-07-05T05:56:52.452Z',
		'generatorURL': 'http://prometheus-server.0101101300.fjf:9090/graph?g0.expr=up+%3D%3D+0&amp;g0.tab=1',
		'fingerprint': '4a890f7c225c3bef'
	}</code></pre> 
<h2>Python发送告警数据</h2> 
<h2>发送告警信息</h2> 
<pre><code class="language-python">import json
import requests

new_packinf = [{
		'status': 'firing',
		'labels': {
			'alertname': '主机存活状态警告！',
			'cloud': '乘风小贷-Dev环境',
			'instance': '192.168.82.105:9100',
			'job': 'node_exporter',
			'severity': '非常严重',
			'team': 'ops'
		},
		'annotations': {
			'description': '192.168.82.105:9100:服务器延时超过5分钟',
			'summary': '192.168.82.105:9100:服务器宕机'
		},
		'startsAt': '2022-07-05T05:54:37.452Z',
		'endsAt': '0001-01-01T00:00:00Z',
		'generatorURL': 'http://prometheus-server.0101101300.fjf:9090/graph?g0.expr=up+%3D%3D+0&amp;g0.tab=1',
		'fingerprint': '4a890f7c225c3bef'
	}]
jsons = json.dumps(new_packinf)
url = "http://192.168.82.105:9093/api/v2/alerts"
headers = {'Content-Type': 'application/json'}
responses = requests.post(url=url, headers=headers, data=jsons)
print(responses.status_code, responses.url)
# print(responses.json())
</code></pre> 
<p><img alt="" height="757" src="https://img-blog.csdnimg.cn/3d025ff87b69479da1d6e5d8998449b2.png" width="1200"></p> 
<p>&nbsp;<img alt="" height="317" src="https://img-blog.csdnimg.cn/9f5ad9c41e8a41b9b373bd27fc479306.png" width="512"></p> 
<h2>&nbsp;发送恢复告警信息</h2> 
<pre><code class="language-python">import json
import requests

new_packinf = [{
		'status': 'resolved',
		'labels': {
			'alertname': '主机存活状态警告！',
			'cloud': '乘风-Dev环境',
			'instance': '192.168.82.105:9100',
			'job': 'node_exporter',
			'severity': '非常严重',
			'team': 'ops'
		},
		'annotations': {
			'description': '192.168.82.105:9100:服务器延时超过5分钟',
			'summary': '192.168.82.105:9100:服务器宕机'
		},
		'startsAt': '2022-07-05T05:54:37.452Z',
		'endsAt': '2022-07-05T05:56:52.452Z',
		'generatorURL': 'http://prometheus-server.0101101300.fjf:9090/graph?g0.expr=up+%3D%3D+0&amp;g0.tab=1',
		'fingerprint': '4a890f7c225c3bef'
	}]
jsons = json.dumps(new_packinf)
url = "http://192.168.82.105:9093/api/v2/alerts"
headers = {'Content-Type': 'application/json'}
responses = requests.post(url=url, headers=headers, data=jsons)
print(responses.status_code, responses.url)
# print(responses.json())
</code></pre> 
<p><img alt="" height="704" src="https://img-blog.csdnimg.cn/16a0b2ba1dc04d90b0325d634200fbb3.png" width="1094"></p> 
<p>&nbsp;<img alt="" height="255" src="https://img-blog.csdnimg.cn/3198e394e11b408fa08d25390b373a75.png" width="373"></p> 
<pre><code class="language-python">import json
import requests
import time

year_time = time.strftime('%Y-%m-%d', time.localtime())
now_time = time.strftime('%H:%M:%S', time.localtime())
start_time = year_time + "T" + now_time + ".000+08:00"
is_end_time = False
if is_end_time:
    print("告警未解决")
    end_time = '0001-01-01T00:00:00Z'
else:
    print("告警已经解决")
    end_time = start_time
new_packinf = [{
    'labels': {
        'alertname': '主机存活状态警告！',
        'cloud': '小贷-Dev环境',
        'instance': '192.168.82.105:9100',
        'job': 'node_exporter',
        'severity': '非常严重',
        'team': 'ops'
    },
    'annotations': {
        'description': '192.168.82.105:9100:服务器延时超过5分钟',
        'summary': '192.168.82.105:9100:服务器宕机'
    },
    'endsAt': end_time,
}]
jsons = json.dumps(new_packinf)
url = "http://192.168.82.105:9093/api/v2/alerts"
headers = {'Content-Type': 'application/json'}
responses = requests.post(url=url, headers=headers, data=jsons)
print(responses.status_code, responses.url)
# print(responses.json())
</code></pre> 
<p></p> 
<p></p> 
<h1>钉钉告警模板</h1> 
<pre><code class="language-bash">{<!-- -->{ $var := .externalURL}}{<!-- -->{ range $k,$v:=.alerts }}
{<!-- -->{if eq $v.status "resolved"}}
#### [Prometheus恢复信息]({<!-- -->{$v.generatorURL}})

##### &lt;font color="#02b340"&gt;告警名称&lt;/font&gt;：[{<!-- -->{$v.labels.alertname}}]({<!-- -->{$var}})
##### &lt;font color="#02b340"&gt;告警级别&lt;/font&gt;：{<!-- -->{$v.labels.severity}}
##### &lt;font color="#02b340"&gt;开始时间&lt;/font&gt;：{<!-- -->{TimeFormat $v.startsAt "2006-01-02 15:04:05"}}
##### &lt;font color="#02b340"&gt;结束时间&lt;/font&gt;：{<!-- -->{TimeFormat $v.endsAt "2006-01-02 15:04:05"}} 
##### &lt;font color="#02b340"&gt;实例地址&lt;/font&gt;：{<!-- -->{$v.labels.instance}}
##### &lt;font color="#02b340"&gt;主机名称&lt;/font&gt;：{<!-- -->{$v.labels.hostname}}

**{<!-- -->{$v.annotations.description}}**
{<!-- -->{else}}
#### [Prometheus告警信息]({<!-- -->{$v.generatorURL}})

##### &lt;font color="#FF0000"&gt;告警名称&lt;/font&gt;：[{<!-- -->{$v.labels.alertname}}]({<!-- -->{$var}})
##### &lt;font color="#FF0000"&gt;告警级别&lt;/font&gt;：{<!-- -->{$v.labels.severity}}
##### &lt;font color="#FF0000"&gt;开始时间&lt;/font&gt;：{<!-- -->{ TimeFormat $v.startsAt "2006-01-02 15:04:05"}}
##### &lt;font color="#FF0000"&gt;结束时间&lt;/font&gt;：{<!-- -->{TimeFormat $v.endsAt "2006-01-02 15:04:05"}} 
##### &lt;font color="#FF0000"&gt;实例地址&lt;/font&gt;：{<!-- -->{$v.labels.instance}}
##### &lt;font color="#FF0000"&gt;主机名称&lt;/font&gt;：{<!-- -->{$v.labels.hostname}}

**{<!-- -->{$v.annotations.description}}**
{<!-- -->{end}}
{<!-- -->{ end }}
{<!-- -->{ $urimsg:=""}}{<!-- -->{ range $key,$value:=.commonLabels }}{<!-- -->{$urimsg =  print $urimsg $key "%3D%22" $value "%22%2C" }}{<!-- -->{end}}[*** 点我屏蔽该告警]({<!-- -->{$var}}/#/silences/new?filter=%7B{<!-- -->{SplitString $urimsg 0 -3}}%7D)</code></pre> 
<p></p>
                ]]></description></item><item><title>Confluence升级方案</title><link>http://www.cnblogs.com/heian99/archive/2022/09/20/16712482.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 20 Sep 2022 12:38:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/09/20/16712482.html</guid><description><![CDATA[
                    <h2>Confluence目前版本</h2> 
<p>Confluence的授权信息<br> Confluence 6.9.3<br> 版权声明； 2003 - 2018 Atlassian 股份有限公司</p> 
<p><img alt="" height="188" src="https://img-blog.csdnimg.cn/a77130ec53334b82a6a1c1daa7b39e90.png" width="793"></p> 
<h2>&nbsp;Confluence最新版本</h2> 
<p>Confluence 7.13.7<br> 地址：https://www.atlassian.com/zh/software/confluence/download-archives</p> 
<p><img alt="" height="295" src="https://img-blog.csdnimg.cn/68dfe15137984fb6919eb252ada6a638.png" width="793"></p> 
<h2>升级版本选择</h2> 
<p>原 &nbsp;Confluence 6.9.3 地址下载：https://product-downloads.atlassian.com/software/confluence/do<br> wnloads/atlassian-confluence-6.9.3-x64.bin</p> 
<p>新 &nbsp;Confluence 7.13.7 地址下载：https://product-downloads.atlassian.com/software/confluence/d<br> ownloads/atlassian-confluence-7.13.7-x64.bin</p> 
<h2>数据备份</h2> 
<p>生产环境：127.0.0.1<br> 程序目录：/opt/atlassian<br> 数据目录：/var/atlassian<br> 数据库：mysql 5.6</p> 
<p><img alt="" height="167" src="https://img-blog.csdnimg.cn/c3e593a2fa1844dba095cafa16c1fb9e.png" width="664"></p> 
<h2>&nbsp;mysql数据备份</h2> 
<pre><code class="language-bash">cd /opt/mysql_backup
mysqldump -uroot -hlocalhost -p confluence &gt; confluence-20220616.sql
scp confluence-20220616.sql 目标机器</code></pre> 
<h2>数据还原</h2> 
<p>注意：数据库必须使用root 才行，不然会报 数据库触发器失败的错误（错误如下图）</p> 
<h2><img alt="" height="730" src="https://img-blog.csdnimg.cn/3a382943611e4e21926f0c177656203d.png" width="1148"></h2> 
<pre><code class="language-bash">[root@localhost ~]# mysql -u root -p
mysql&gt; CREATE DATABASE IF NOT EXISTS confluence DEFAULT CHARSET utf8 COLLATE 
utf8_general_ci;
mysql&gt; use confluence;
mysql&gt; source /root/confluence-20220616.sql; &nbsp; &nbsp;#注意，这里需要写入confluence.sql的
绝对路径</code></pre> 
<p>&nbsp;修改Confluence配置文件中数据库连接为新数据库</p> 
<pre><code class="language-bash">vi /var/atlassian/application-data/confluence/confluence.cfg.xml</code></pre> 
<h2><img alt="" height="203" src="https://img-blog.csdnimg.cn/c40d4c67d99b4292af43791a18047cfb.png" width="1193"></h2> 
<h2>&nbsp;启动Conflucence</h2> 
<pre><code class="language-bash">授权
chown -R confluence:confluence /opt/atlassian
chown -R confluence:confluence /var/atlassian
切换用户启动
su confluence
/opt/atlassian/confluence/bin/startup.sh</code></pre> 
<h2><img alt="" height="823" src="https://img-blog.csdnimg.cn/9ad51aae5d104ef7ad5689ea73b5df0b.png" width="1200"></h2> 
<h2>&nbsp;版本更新（ 7.13.7）</h2> 
<pre><code class="language-bash">开始升级
[root@prometheus-server confluence]# ls
atlassian-confluence-6.9.3-x64.bin  atlassian-confluence-7.13.7-x64.bin
[root@prometheus-server confluence]# ./atlassian-confluence-7.13.7-x64.bin </code></pre> 
<h2><img alt="" height="595" src="https://img-blog.csdnimg.cn/a7046acedd7e4231980bd3a3820c7816.png" width="1200"></h2> 
<p>&nbsp;<img alt="" height="575" src="https://img-blog.csdnimg.cn/76b402923ebe4d7eab63bf4105c3c460.png" width="1200"></p> 
<h2>&nbsp;访问页面（key失效）</h2> 
<h2><img alt="" height="482" src="https://img-blog.csdnimg.cn/1d9b2a8d8dd24fd9b67b25da6e53d7ee.png" width="1200"></h2> 
<h2>进行破解恢复&nbsp;</h2> 
<p>&nbsp;注意：数据库必须使用root 才行，不然会报 数据库触发器失败的错误</p> 
<pre><code class="language-bash">vim confluence.cfg.xml
查询新的server.id
 &nbsp;  &lt;property name="confluence.setup.server.id"&gt;BJ5V-W7UB-4PO5-2J39&lt;/property&gt;</code></pre> 
<p><img alt="" height="378" src="https://img-blog.csdnimg.cn/0b3fa80d06d74f099a3790f6dacfa550.png" width="1186"></p> 
<h2>&nbsp;备份jar包破解</h2> 
<pre><code class="language-bash">sz /opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-decoder-v2-
3.4.1.jar</code></pre> 
<p><img alt="" height="730" src="https://img-blog.csdnimg.cn/da890dcdc2144adba0b8b047ea247c15.png" width="1101"></p> 
<p>&nbsp;<img alt="" height="500" src="https://img-blog.csdnimg.cn/1474799696ed4e75946f2c27de0cf13d.png" width="1200"></p> 
<p>破解完成的包 上传到其相应目录 &nbsp;进行重启&nbsp;</p> 
<p><img alt="" height="304" src="https://img-blog.csdnimg.cn/b53d045039404c778387807ee26c313e.png" width="1200"></p> 
<pre><code class="language-bash">[root@prometheus-server ~]# mv atlassian-extras-decoder-v2-3.4.1.jar  
/opt/atlassian/confluence/confluence/WEB-INF/lib/
mv: overwrite ‘/opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-decoder-v2-3.4.1.jar’? y</code></pre> 
<p>&nbsp;<img alt="" height="494" src="https://img-blog.csdnimg.cn/d984601444fa41b2829c9a693eefc894.png" width="1200"></p> 
<h2>&nbsp;成功测试</h2> 
<p>新版测试地址（http://127.0.0.1:8090/） 账号和密码 原有的即可登陆</p> 
<p><img alt="" height="1200" src="https://img-blog.csdnimg.cn/a5ffbafb766f43b8a2b1d83af24ef043.png" width="836"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Jenkins集成Kubernetes集群</title><link>http://www.cnblogs.com/heian99/archive/2022/05/26/16315302.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 26 May 2022 13:27:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/26/16315302.html</guid><description><![CDATA[
                    <p class="img-center"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/fe9a4e6c8758a9eaa52ada11f8a537ea.webp?x-oss-process=image/format,png"></p> 
<h1>前文</h1> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124808858" title="Jenkins安装部署使用_南宫乘风的博客-CSDN博客">Jenkins安装部署使用_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124809338" title="Jenkins入门配置_南宫乘风的博客-CSDN博客">Jenkins入门配置_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124814780" title="Jenkins集成Sonar Qube_南宫乘风的博客-CSDN博客">Jenkins集成Sonar Qube_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124815450" title="Jenkins的流水线（Pipeline）">Jenkins的流水线（Pipeline）</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124816190?spm=1001.2014.3001.5501" title="Jenkins流水线整合钉钉_南宫乘风的博客-CSDN博客">Jenkins流水线整合钉钉_南宫乘风的博客-CSDN博客</a><a href="https://blog.csdn.net/heian_99/article/details/124985786?spm=1001.2014.3001.5501" title="Kubernetes安装Jenkins_南宫乘风的博客-CSDN博客">Kubernetes安装Jenkins_南宫乘风的博客-CSDN博客</a></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="1%E3%80%81Kubernetes%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%20Jenkins-toc" style="margin-left:40px;"><a href="#1%E3%80%81Kubernetes%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%20Jenkins">1、Kubernetes 环境安装 Jenkins</a></p> 
<p id="2%E3%80%81Jenkins%20%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81Jenkins%20%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6">2、Jenkins 安装插件</a></p> 
<p id="3%E3%80%81%E4%BA%91%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BA%91%E9%85%8D%E7%BD%AE">3、云配置</a></p> 
<p id="4%E3%80%81Template%20%E6%A8%A1%E6%9D%BF%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#4%E3%80%81Template%20%E6%A8%A1%E6%9D%BF%E9%85%8D%E7%BD%AE">4、Template 模板配置</a></p> 
<p id="5%E3%80%81Jenkins-slave%20%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#5%E3%80%81Jenkins-slave%20%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95">5、Jenkins-slave 启动测试</a></p> 
<p id="6%E3%80%81%E5%AE%9E%E6%88%98%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%AE%9E%E6%88%98%E7%8E%AF%E5%A2%83">6、实战环境</a></p> 
<p id="7%E3%80%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">7、运行结果</a></p> 
<hr id="hr-toc">
<p></p> 
<p></p> 
<h2 id="1%E3%80%81Kubernetes%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%20Jenkins">1、Kubernetes 环境安装 Jenkins</h2> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124985786" title="https://blog.csdn.net/heian_99/article/details/124985786">https://blog.csdn.net/heian_99/article/details/124985786</a></p> 
<h2 id="2%E3%80%81Jenkins%20%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6">2、Jenkins 安装插件</h2> 
<pre><code class="language-bash">插件:
kubernets
pipeline
docker pipeline
docker
Kubernetes Cli
Config File Provider
Pipeline Utility Steps

Jenkins源：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code></pre> 
<p></p> 
<h2 id="3%E3%80%81%E4%BA%91%E9%85%8D%E7%BD%AE">3、云配置</h2> 
<p>Dashboard &gt; 系统管理 &gt; 节点管理 &gt; configureClouds</p> 
<p>参考：<a href="https://github.com/jenkinsci/kubernetes-plugin" title="https://github.com/jenkinsci/kubernetes-plugin">https://github.com/jenkinsci/kubernetes-plugin</a></p> 
<p>&nbsp;</p> 
<p><img alt="" height="775" src="https://img-blog.csdnimg.cn/c32d4eee445f444ea7f1eeba1fff7352.png" width="1200"></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p><img alt="" height="1200" src="https://img-blog.csdnimg.cn/d916244ad3fe47cca2e5659f2b0c8c81.png" width="1200"></p> 
<p>&nbsp;<img alt="" height="752" src="https://img-blog.csdnimg.cn/3dccc5fd059841f7962a43f73faccda2.png" width="1200"></p> 
<p>&nbsp;</p> 
<p>这里是配置连接Kubernetes集群，启动 Jenkins Slave 代理的相关配置。</p> 
<ul><li><strong>名称：</strong>&nbsp;kubernetes</li><li><strong>Kubernetes 地址：</strong>&nbsp;<a href="https://link.juejin.cn/?target=https%3A%2F%2Fkubernetes.default.svc.cluster.local%2F" title="kubernetes.default.svc.cluster.local">kubernetes.default.svc.cluster.local</a>&nbsp;(默认集群内调用 k8s api 地址)</li><li><strong>禁用 HTTPS 证书检查：</strong>&nbsp;勾选 (不验证https)</li><li><strong>凭据：</strong>&nbsp;新增凭据—&gt;Secret text—&gt;Secret 设置 kubernetes 的 Token (进入 k8s dashboard 的 token 等都行)</li><li><strong>Jenkins地址：</strong>&nbsp;<a href="https://link.juejin.cn/?target=http%3A%2F%2Fjenkins.mydlqcloud%3A8080%2Fjenkins" title="jenkins.mydlqcloud:8080/jenkins">jenkins.mydlqcloud:8080/jenkins</a>&nbsp;(用于代理与 Jenkins 连接的地址，用的是 k8s 集群中 jenkins 服务的地址为“<a href="https://link.juejin.cn/?target=http%3A%2F%2Fxn--jenkins-6k1lv9hx32e.xn--jenkinsnamespace-k412at47l%3Ajenkins%25E7%25AB%25AF%25E5%258F%25A3%25E5%258F%25B7%2Fjenkins%25E5%2590%258E%25E7%25BC%2580%25E2%2580%259D" title="http://jenkins服务名.jenkins所在namespace:jenkins端口号/jenkins后缀”">http://jenkins服务名.jenkins所在namespace:jenkins端口号/jenkins后缀”</a>)</li><li><strong>其他：</strong>&nbsp;默认即可</li></ul>
<h2 id="4%E3%80%81Template%20%E6%A8%A1%E6%9D%BF%E9%85%8D%E7%BD%AE">4、Template 模板配置</h2> 
<p>这里配置 Jenkins Slave 在 kubernetes 集群中启动的 Pod 的配置，这里将设置四个镜像，分别是：</p> 
<ul><li><strong>Jenkins Slave：</strong>&nbsp;用于执行 Jenkins Job 命令。</li><li><strong>Helm-Kubectl：</strong>&nbsp;用于执行 Helm 命令。</li><li><strong>Docker</strong>&nbsp;用于编译、推送 Docker 镜像</li><li><strong>Maven：</strong>&nbsp;用于Maven编译、打包。</li></ul>
<p>这里将这四个镜像融入到一个 Pod 之中，方便执行各种命令来完成持续部署交互过程。</p> 
<p><img alt="" height="664" src="https://img-blog.csdnimg.cn/99a44e897ff3408aa9f104bc20537141.png" width="1200"></p> 
<p>&nbsp;<img alt="" height="1200" src="https://img-blog.csdnimg.cn/1caad9c3f6e148108a3c385f5681ad7c.png" width="1200"></p> 
<p>&nbsp;</p> 
<p></p> 
<p></p> 
<pre><code class="language-bash">[root@master01 Jenkins]# cat maven.yaml 
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: maven-pvc
  namespace: jenkins
spec:
  storageClassName: "nfsdata"
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi
</code></pre> 
<pre><code class="language-bash">Kubernetes地址：https://kubernetes.default.svc.cluster.local/

Jenkins-master：http://jenkins.jenkins.svc.cluster.local:8080

Jenkins-slave：jenkins.jenkins.svc.cluster.local:50000



jnlp-slave
cnych/jenkins:jnlp6

maven
maven:3.8.5-openjdk-8-slim

docker
registry.cn-shanghai.aliyuncs.com/mydlq/docker:18.06.2-dind

helm-kubectl
registry.cn-shanghai.aliyuncs.com/mydlq/helm-kubectl:2.13.1


/var/run/docker.sock
/usr/bin/docker
/etc/docker</code></pre> 
<p>注意：docker需要填写sleep</p> 
<p><img alt="" height="765" src="https://img-blog.csdnimg.cn/3c80db3bbb944ffc99377165b62b73f9.png" width="1200">&nbsp;</p> 
<p>&nbsp;</p> 
<h2 id="5%E3%80%81Jenkins-slave%20%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95">5、Jenkins-slave 启动测试</h2> 
<p><img alt="" height="331" src="https://img-blog.csdnimg.cn/36810bad770a413997062f38a7adb49e.png" width="1200"></p> 
<p>&nbsp;<img alt="" height="540" src="https://img-blog.csdnimg.cn/aa9d30d73b694f81a8558e98807064c6.png" width="1200"></p> 
<p></p> 
<pre><code class="language-bash">def label = "jnlp-slave"

podTemplate(label: label,cloud: 'kubernetes' ){
    node (label) {
        stage('Git阶段'){
            echo "1、开始拉取代码"
            sh "git version"
        }
        stage('Maven阶段'){
            container('maven') {
                echo "2、开始Maven编译、推送到本地库"
                sh "mvn -version"
            }
        }
        stage('Docker阶段'){
            container('docker') {
                echo "3、开始读取Maven pom变量，并执行Docker编译、推送、删除"
                sh "docker version"
            }
        }
         stage('Helm阶段'){
            container('helm-kubectl') {
                echo "4、开始检测Kubectl环境，测试执行Helm部署，与执行部署"
                sh "helm version"
            }
        }
    }
}</code></pre> 
<p><img alt="" height="723" src="https://img-blog.csdnimg.cn/b0324852234442f8a3c14e8da79a4440.png" width="1136"></p> 
<p>&nbsp;</p> 
<p></p> 
<h2 id="6%E3%80%81%E5%AE%9E%E6%88%98%E7%8E%AF%E5%A2%83">6、实战环境</h2> 
<p>&nbsp;</p> 
<p><img alt="" height="819" src="https://img-blog.csdnimg.cn/5b06bece890a495f98271d74623437a6.png" width="1200"></p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">pipeline {
        agent 
        {
        label 'jnlp-slave'
        }
 
    // 存放所有任务的合集
    stages {
        stage('拉取Git代码') {
            steps {
                echo '拉取Git代码'
				 sh 'git clone https://gitee.com/chengfeng99/java-demo.git'
            }
        }
 
        stage('检测代码质量') {
            steps {
                echo '检测代码质量'
                withSonarQubeEnv('sonarqube') { // Will pick the global server connection you have configured       
            // 这里使用名字叫做maven的容器运行
            container("maven") {
                sh '''
				cd /home/jenkins/agent/workspace/k8s-demo/java-demo
				mvn sonar:sonar  -Dsonar.projectname=${JOB_NAME} -Dsonar.projectKey=${JOB_NAME} -Dsonar.java.binaries=target/ -Dsonar.login=19d0d6b885e18455d257d61da08776bd4e180c04
				'''
            }
            }
        }
 }
        stage('构建代码') {
            steps {
                echo '构建代码'
                   container('maven') {
                    sh ''' 
					cd /home/jenkins/agent/workspace/k8s-demo/java-demo
					mvn clean  package  -Dmaven.test.skip=true
					'''
                    //打包跳过测试
                }
            }
        }
 
        stage('制作自定义镜像并发布Harbor') {
            steps {
                echo '制作自定义镜像并发布Harbor'
            }
        }
 
        stage('基于Harbor部署工程') {
            steps {
                echo '基于Harbor部署工程'
            }
        }
    }
}</code></pre> 
<h2 id="7%E3%80%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">7、运行结果</h2> 
<p><img alt="" height="787" src="https://img-blog.csdnimg.cn/77b033106c3749538159eeb6c5f803ce.png" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="331" src="https://img-blog.csdnimg.cn/36810bad770a413997062f38a7adb49e.png" width="1200"></p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/8ca6ab5caeac4a33819290d82400e416.png"></p> 
<p>&nbsp;</p> 
<p></p>
                ]]></description></item><item><title>Kubernetes安装Jenkins</title><link>http://www.cnblogs.com/heian99/archive/2022/05/26/16315303.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 26 May 2022 13:27:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/26/16315303.html</guid><description><![CDATA[
                    <h1>前文</h1> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124808858" title="Jenkins安装部署使用_南宫乘风的博客-CSDN博客">Jenkins安装部署使用_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124809338" title="Jenkins入门配置_南宫乘风的博客-CSDN博客">Jenkins入门配置_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124814780" title="Jenkins集成Sonar Qube_南宫乘风的博客-CSDN博客">Jenkins集成Sonar Qube_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124815450" title="Jenkins的流水线（Pipeline）">Jenkins的流水线（Pipeline）</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124816190?spm=1001.2014.3001.5501" title="Jenkins流水线整合钉钉_南宫乘风的博客-CSDN博客">Jenkins流水线整合钉钉_南宫乘风的博客-CSDN博客</a>&nbsp;</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#%E7%8E%AF%E5%A2%83">环境</a></p> 
<p id="%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF">思路</a></p> 
<p id="1%E3%80%81NFS%EF%BC%88%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81NFS%EF%BC%88%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%EF%BC%89">1、NFS（动态存储）</a></p> 
<p id="2%E3%80%81helm%E5%AE%89%E8%A3%85nfs-client-toc" style="margin-left:40px;"><a href="#2%E3%80%81helm%E5%AE%89%E8%A3%85nfs-client">2、helm安装nfs-client</a></p> 
<p id="3%E3%80%81%E5%88%9B%E5%BB%BAnamespace%C2%A0-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%88%9B%E5%BB%BAnamespace%C2%A0">3、创建namespace&nbsp;</a></p> 
<p id="4%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96Jenkins%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96Jenkins%E6%95%B0%E6%8D%AE">4、持久化Jenkins数据</a></p> 
<p id="5%E3%80%81%E5%88%9B%E5%BB%BAservice%20account-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%88%9B%E5%BB%BAservice%20account">5、创建service account</a></p> 
<p id="6%E3%80%81%E5%AE%89%E8%A3%85Jenkins-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%AE%89%E8%A3%85Jenkins">6、安装Jenkins</a></p> 
<p id="7%E3%80%81%E6%8E%88%E6%9D%83%E5%AF%B9Jenkins%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E6%8E%88%E6%9D%83%E5%AF%B9Jenkins%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">7、授权对Jenkins服务的访问权限</a></p> 
<p id="8%E3%80%81%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8IP%3A31400%2F-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8IP%3A31400%2F">8、打开浏览器IP:31400/</a></p> 
<hr id="hr-toc">
<p></p> 
<hr>
<h2 id="%E7%8E%AF%E5%A2%83">环境</h2> 
<p>生产实践-k8s安装Jenkins和Jenkins Kubernetes插件<br> 环境要求：你需要一个正常可以使用的Kubernetes集群，集群中可以使用的内存大于等于4G。<br> Kubernetes版本1.18</p> 
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2> 
<p>Jenkins插件可以在Kubernetes集群中运行动态jenkins-slave代理。</p> 
<p>基于Kubernetes的docker，自动化在Kubernetes中运行的Jenkins-slave代理的缩放。</p> 
<p>该插件为每个jenkins-slave代理创建Kubernetes Pod，并在每个构建后停止它。</p> 
<p>在Kubernetes中jenkins-slave代理启动，会自动连接到Jenkins主控制器。 对于某些环境变量，会自动注入：</p> 
<p>Jenkins_URL：Jenkins Web界面URL<br> jenkins_secret：身份验证的秘密密钥<br> jenkins_agent_name：jenkins代理的名称<br> jenkins_name：jenkins代理的名称（已弃用。仅用于向后兼容性）<br> 不需要在Kubernetes内运行Jenkins Controller。</p> 
<h2 id="1%E3%80%81NFS%EF%BC%88%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%EF%BC%89">1、NFS（动态存储）</h2> 
<pre><code class="language-bash">#安装
yum install -y nfs-utils rpcbind
 
mkdir -p /data/nfsdata
 
# 修改配置
$ vim /etc/exports
/data/nfsdata 192.168.31.* (rw,async,no_root_squash)
 
# 使配置生效
$ exportfs -r
 
# 服务端查看下是否生效
$ showmount -e localhost
 
Export list for localhost:
/data/nfsdata (everyone)</code></pre> 
<h2 id="2%E3%80%81helm%E5%AE%89%E8%A3%85nfs-client">2、helm安装nfs-client</h2> 
<pre><code class="language-bash">stable       	https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts
helm添加这个源</code></pre> 
<pre><code class="language-bash">下载helm包
helm pull aliyuncs/nfs-client-provisioner
解压
tar -zxvf nfs-client-provisioner-1.2.8.tgz
 
修复values.yaml 三处
image:
  repository: quay.io/external_storage/nfs-client-provisioner
  tag: v3.1.0-k8s1.11
  pullPolicy: IfNotPresent
 
nfs:
  server: 192.168.31.73
  path: /data/nfsdata
 
 
  reclaimPolicy: Retain</code></pre> 
<p>&nbsp;<img alt="" height="177" src="https://img-blog.csdnimg.cn/9475e0d59fc842f38b056d4766e0e606.png" width="1200"></p> 
<h2 id="3%E3%80%81%E5%88%9B%E5%BB%BAnamespace%C2%A0">3、创建namespace&nbsp;</h2> 
<pre><code class="language-bash">kubectl create namespace jenkins
kubectl get namespaces</code></pre> 
<h2 id="4%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96Jenkins%E6%95%B0%E6%8D%AE">4、持久化Jenkins数据</h2> 
<p>pvc.yaml</p> 
<pre><code class="language-bash">
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: jenkins-pvc
  namespace: jenkins
spec:
  storageClassName: "nfsdata"
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi
</code></pre> 
<p>通过kubectl部署volume</p> 
<pre><code class="language-bash">kubectl apply -f pvc.yaml</code></pre> 
<h2 id="5%E3%80%81%E5%88%9B%E5%BB%BAservice%20account">5、创建service account</h2> 
<p>创建pod时，如果不指定服务账户，则会自动为其分配一个名为default的同一namespace中的服务账户。但是通常应用程序时存在权限不足的情况，所以需要我们自己创建一个服务账户。<br> ①下载jenkins-sa.yaml</p> 
<pre><code>wget https://raw.githubusercontent.com/jenkins-infra/jenkins.io/master/content/doc/tutorials/kubernetes/installing-jenkins-on-kubernetes/jenkins-sa.yaml
</code></pre> 
<p>②通过kubectl部署jenkins-sa.yaml</p> 
<pre><code>kubectl apply -f jenkins-sa.yaml</code></pre> 
<p>或者使用下面的文件</p> 
<p>jenkins-sa.yaml&nbsp;</p> 
<pre><code class="language-bash">
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: jenkins
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: jenkins
rules:
- apiGroups:
  - '*'
  resources:
  - statefulsets
  - services
  - replicationcontrollers
  - replicasets
  - podtemplates
  - podsecuritypolicies
  - pods
  - pods/log
  - pods/exec
  - podpreset
  - poddisruptionbudget
  - persistentvolumes
  - persistentvolumeclaims
  - jobs
  - endpoints
  - deployments
  - deployments/scale
  - daemonsets
  - cronjobs
  - configmaps
  - namespaces
  - events
  - secrets
  verbs:
  - create
  - get
  - watch
  - delete
  - list
  - patch
  - update
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - get
  - list
  - watch
  - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: jenkins
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: jenkins
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:serviceaccounts:jenkins
</code></pre> 
<h2 id="6%E3%80%81%E5%AE%89%E8%A3%85Jenkins">6、安装Jenkins</h2> 
<p>jenkins-deployment.yaml&nbsp;</p> 
<pre><code class="language-bash">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jenkins
  namespace: jenkins
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jenkins
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      serviceAccountName: jenkins   #指定我们前面创建的服务账号
      containers:
      - name: jenkins
        image: registry.cn-hangzhou.aliyuncs.com/s-ops/jenkins:2.346
        ports:
        - containerPort: 8080
        - containerPort: 50000
        volumeMounts:
        - name: jenkins-home
          mountPath: /var/jenkins_home
      volumes:
      - name: jenkins-home
        persistentVolumeClaim:
          claimName: jenkins-pvc     #指定前面创建的PVC
</code></pre> 
<p>通过kubectl部署jenkins-deployment.yaml</p> 
<pre><code>kubectl create -f jenkins-deployment.yaml -n jenkins</code></pre> 
<h2 id="7%E3%80%81%E6%8E%88%E6%9D%83%E5%AF%B9Jenkins%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">7、授权对Jenkins服务的访问权限</h2> 
<p><br> 主要目的暴露外部访问Jenkins的8080端口，我将31400定义为8080的映射端口。</p> 
<p>jenkins-service.yaml</p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: jenkins
  namespace: jenkins
spec:
  type: NodePort
  ports:
  - name: http
    port: 8080
    targetPort: 8080
    nodePort: 31400
  - name: agent
    port: 50000
    targetPort: 50000
    nodePort: 31401
  selector:
    app: jenkins
</code></pre> 
<p>通过kubectl部署服务</p> 
<pre><code>kubectl create -f jenkins-service.yaml -n jenkins</code></pre> 
<h2 id="8%E3%80%81%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8IP%3A31400%2F">8、打开浏览器IP:31400/</h2> 
<p>查看密码</p> 
<pre><code class="language-bash">kubectl get pod -n jenkins  //查询podname
kubectl logs podname -n jenkins

*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

cf8d9da9de0346fd90461be366915d76

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword

*************************************************************</code></pre> 
<p>选择推荐插件安装，创建管理员~完成！</p> 
<p><img alt="" height="875" src="https://img-blog.csdnimg.cn/160c828b8b82433699b8ecd834d22f33.png" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Jenkins流水线整合钉钉</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295726.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295726.html</guid><description><![CDATA[
                    <h1>前文</h1> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124808858" title="Jenkins安装部署使用_南宫乘风的博客-CSDN博客">Jenkins安装部署使用_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124809338" title="Jenkins入门配置_南宫乘风的博客-CSDN博客">Jenkins入门配置_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124814780" title="Jenkins集成Sonar Qube_南宫乘风的博客-CSDN博客">Jenkins集成Sonar Qube_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124815450" title="Jenkins的流水线（Pipeline）">Jenkins的流水线（Pipeline）</a></p> 
<p></p> 
<p>在程序部署成功后，可以通过钉钉的机器人及时向群众发送部署的最终结果通知</p> 
<ul><li> <p>安装插件</p> </li></ul>
<p><img alt="" height="233" src="https://img-blog.csdnimg.cn/7b31facb4d9d40df9a951722e33a2b75.png" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="461" src="https://img-blog.csdnimg.cn/4bd3565abe544a219c70b6cbf90a4ce0.png" width="897"></p> 
<p>&nbsp;钉钉内部创建群组并构建机器人</p> 
<p></p> 
<p>&nbsp;<img alt="" height="797" src="https://img-blog.csdnimg.cn/06d15202c344408bb986e510b815faea.png" width="621"></p> 
<p>&nbsp;<img alt="" height="534" src="https://img-blog.csdnimg.cn/2846639eff97423a820bfb0ab1f4f3f9.png" width="691"></p> 
<p>&nbsp;最终或获取到Webhook信息</p> 
<pre><code class="language-bash">https://oapi.dingtalk.com/robot/send?access_token=kej4ehkj34gjhg34jh5bh5jb34hj53b4</code></pre> 
<p>系统配置添加钉钉通知</p> 
<p><img alt="" height="810" src="https://img-blog.csdnimg.cn/5c7548d451d84ca5a38e7d2bc9975d55.png" width="1200"></p> 
<p>&nbsp;任务中追加流水线配置</p> 
<pre><code class="language-bash">pipeline {

    agent any
        environment{
        harborRepo = 'heianapp'
        harborUser = 'heian99'
        harborPasswd = 'NG+.mK4M-(s4CYX'
    }
    // 存放所有任务的合集
    stages {
        stage('拉取Git代码') {
            steps {
                echo '拉取Git代码'
                checkout([$class: 'GitSCM', branches: [[name: '${tag}']], extensions: [], userRemoteConfigs: [[url: 'https://gitee.com/chengfeng99/java-demo.git']]])
            }
        }

        stage('检测代码质量') {
            steps {
                echo '检测代码质量'
                 sh '/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=${JOB_NAME} -Dsonar.projectKey=${JOB_NAME} -Dsonar.java.binaries=target/ -Dsonar.login=19d0d6b885e18455d257d61da08776bd4e180c04'
            }
        }

        stage('构建代码') {
            steps {
                echo '构建代码'
                 sh '/var/jenkins_home/maven/bin/mvn clean package -DskipTests'
            }
        }

        stage('制作自定义镜像并发布Harbor') {
                        steps {
                echo '制作自定义镜像并发布Harbor'
                sh '''
                cp ./target/*.jar ./docker/demo.jar
                cd ./docker
                docker build -t ${JOB_NAME}:${BUILD_NUMBER} . '''
                
                 sh '''docker login -u ${harborUser} -p ${harborPasswd} 
                docker tag ${JOB_NAME}:${BUILD_NUMBER} ${harborUser}/${harborRepo}:${JOB_NAME}_${BUILD_NUMBER}
                docker push ${harborUser}/${harborRepo}:${JOB_NAME}_${BUILD_NUMBER}'''
            }
        }

        stage('基于Harbor部署工程') {
            steps {
                echo '基于Harbor部署工程'
				sshPublisher(publishers: [sshPublisherDesc(configName: 'node-Linux32', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: '''cd /opt/java/
echo "测试成功" &gt;&gt; log.txt
 date &gt;&gt; log.txt''', execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: 'target/*.jar,docker/*')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
            }
        }
    }
	post {
        success {
            dingtalk (
                robot: 'Jenkins-DingDing',
                type:'MARKDOWN',
                title: "success: ${JOB_NAME}",
                text: ["- 成功构建:${JOB_NAME}项目!\n- 版本:${tag}\n- 持续时间:${currentBuild.durationString}\n- 任务:#${JOB_NAME}"]
            )
        }
        failure {
            dingtalk (
                robot: 'Jenkins-DingDing',
                type:'MARKDOWN',
                title: "fail: ${JOB_NAME}",
                text: ["- 失败构建:${JOB_NAME}项目!\n- 版本:${tag}\n- 持续时间:${currentBuild.durationString}\n- 任务:#${JOB_NAME}"]
            )
        }
    }
}</code></pre> 
<p>查看效果</p> 
<p><img alt="" height="625" src="https://img-blog.csdnimg.cn/d8e0b41b4ec04af888df95b0a3f88c26.png" width="793"></p> 
<p>&nbsp;<img alt="" height="767" src="https://img-blog.csdnimg.cn/3bc24a4879ca41029deafb2049b392eb.png" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Jenkins的流水线（Pipeline）</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295727.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295727.html</guid><description><![CDATA[
                    <h1>目录</h1> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124808858" title="Jenkins安装部署使用_南宫乘风的博客-CSDN博客">Jenkins安装部署使用_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124809338" title="Jenkins入门配置_南宫乘风的博客-CSDN博客">Jenkins入门配置_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124814780" title="Jenkins集成Sonar Qube_南宫乘风的博客-CSDN博客">Jenkins集成Sonar Qube_南宫乘风的博客-CSDN博客</a></p> 
<p></p> 
<h1>Jenkins流水线</h1> 
<h2>Jenkins流水线任务介绍</h2> 
<p></p> 
<p>之前采用Jenkins的自由风格构建的项目，每个步骤流程都要通过不同的方式设置，并且构建过程中整体流程是不可见的，无法确认每个流程花费的时间，并且问题不方便定位问题。</p> 
<p>Jenkins的Pipeline可以让项目的发布整体流程可视化，明确执行的阶段，可以快速的定位问题。并且整个项目的生命周期可以通过一个Jenkinsfile文件管理，而且Jenkinsfile文件是可以放在项目中维护。</p> 
<p>所以Pipeline相对自由风格或者其他的项目风格更容易操作。</p> 
<p><img alt="" height="810" src="https://img-blog.csdnimg.cn/a1efec7060a74096836cbb23bcdc0b1b.png" width="1200"></p> 
<p></p> 
<h1>Jenkins流水线任务</h1> 
<h2>构建Jenkins流水线任务</h2> 
<p>构建任务</p> 
<p><img alt="" height="821" src="https://img-blog.csdnimg.cn/11c73103b86243adaf390cd586e076b4.png" width="1200"></p> 
<p>&nbsp;生成Groovy脚本</p> 
<p>Hello World脚本生成</p> 
<p><img alt="" height="756" src="https://img-blog.csdnimg.cn/107b9a30323b4b70827c0b1b804a25fd.png" width="1200"></p> 
<p>&nbsp;构建后查看视图</p> 
<p><img alt="" height="534" src="https://img-blog.csdnimg.cn/c56ca4673c6348f8992bd6f07c8cd2e3.png" width="1195"></p> 
<h1>Groovy脚本</h1> 
<p>Groovy脚本基础语法</p> 
<pre><code class="language-bash">// 所有脚本命令包含在pipeline{}中
pipeline {  
	// 指定任务在哪个节点执行（Jenkins支持分布式）
    agent any
    
    // 配置全局环境，指定变量名=变量值信息
    environment{
    	host = '172.17.1.22'
    }

    // 存放所有任务的合集
    stages {
    	// 单个任务
        stage('任务1') {
        	// 实现任务的具体流程
            steps {
                echo 'do something'
            }
        }
		// 单个任务
        stage('任务2') {
        	// 实现任务的具体流程
            steps {
                echo 'do something'
            }
        }
        // ……
    }
}</code></pre> 
<h2>编写例子测试</h2> 
<pre><code class="language-bash">pipeline {
    agent any

    // 存放所有任务的合集
    stages {
        stage('拉取Git代码') {
            steps {
                echo '拉取Git代码'
            }
        }

        stage('检测代码质量') {
            steps {
                echo '检测代码质量'
            }
        }

        stage('构建代码') {
            steps {
                echo '构建代码'
            }
        }

        stage('制作自定义镜像并发布Harbor') {
            steps {
                echo '制作自定义镜像并发布Harbor'
            }
        }

        stage('基于Harbor部署工程') {
            steps {
                echo '基于Harbor部署工程'
            }
        }
    }
}</code></pre> 
<p>配置Grovvy脚本</p> 
<p><img alt="" height="634" src="https://img-blog.csdnimg.cn/6538958ea23c43fa814956a52001f208.png" width="1200"></p> 
<p>&nbsp;查看效果</p> 
<p><img alt="" height="593" src="https://img-blog.csdnimg.cn/fde345cff9464a4caa0a8c588a9bd915.png" width="1200"></p> 
<p>&nbsp;<a href="">Ps：涉及到特定脚本，Jenkins给予了充足的提示，可以自动生成命令</a></p> 
<p>生成命令位置</p> 
<p><img alt="" height="707" src="https://img-blog.csdnimg.cn/c1d8b5f0bd2b47a78155339f92a28d82.png" width="1200"></p> 
<p></p> 
<h1>Jenkinsfile实现</h1> 
<p>Jenkinsfile方式需要将脚本内容编写到项目中的Jenkinsfile文件中，每次构建会自动拉取项目并且获取项目中Jenkinsfile文件对项目进行构建</p> 
<p>配置pipeline</p> 
<p><img alt="" height="852" src="https://img-blog.csdnimg.cn/60c19e380c214266b7ab1634d0e6d582.png" width="1200"></p> 
<p>&nbsp;准备Jenkinsfile</p> 
<p><img alt="" height="1200" src="https://img-blog.csdnimg.cn/d5272fbd9d0c45f0b97fe8972540c76f.png" width="1200"></p> 
<p>&nbsp;<a href="https://gitee.com/chengfeng99/java-demo/blob/master/Jenkinsfile" title="Jenkinsfile · 南宫乘风/java-demo - Gitee.com">Jenkinsfile · 南宫乘风/java-demo - Gitee.com</a></p> 
<p>测试效果</p> 
<p><img alt="" height="459" src="https://img-blog.csdnimg.cn/07f4398072da46d3a02d5a8af60b887b.png" width="1200"></p> 
<p></p> 
<h1>Jenkins流水线任务实现</h1> 
<p>参数化构建</p> 
<p>添加参数化构建，方便选择不的项目版本</p> 
<p><img alt="" height="770" src="https://img-blog.csdnimg.cn/48ff368ad442429f882d65fe0fb7d637.png" width="1070"></p> 
<p></p> 
<p>拉取Git代码</p> 
<p>通过流水线语法生成Checkout代码的脚本</p> 
<p>&nbsp;<img alt="" height="810" src="https://img-blog.csdnimg.cn/c242282cd1994ff9a1368e3faa78a94a.png" width="1200"></p> 
<p>&nbsp;<img alt="" height="1200" src="https://img-blog.csdnimg.cn/1411ecf68f69499dbcb8db331577dbbe.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="1200" src="https://img-blog.csdnimg.cn/a74b0c6dddda4f17af940df460e31446.png" width="1200"></p> 
<p>&nbsp;&nbsp;将*/master更改为标签<a href="">${tag}</a></p> 
<pre><code class="language-bash">pipeline {

    agent any
        environment{
        harborRepo = 'heianapp'
        harborUser = 'heian99'
        harborPasswd = 'NG+.mK4M-(s4CYX'
    }
    // 存放所有任务的合集
    stages {
        stage('拉取Git代码') {
            steps {
                echo '拉取Git代码'
                checkout([$class: 'GitSCM', branches: [[name: '${tag}']], extensions: [], userRemoteConfigs: [[url: 'https://gitee.com/chengfeng99/java-demo.git']]])
            }
        }

        stage('检测代码质量') {
            steps {
                echo '检测代码质量'
                 sh '/var/jenkins_home/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=${JOB_NAME} -Dsonar.projectKey=${JOB_NAME} -Dsonar.java.binaries=target/ -Dsonar.login=19d0d6b885e18455d257d61da08776bd4e180c04'
            }
        }

        stage('构建代码') {
            steps {
                echo '构建代码'
                 sh '/var/jenkins_home/maven/bin/mvn clean package -DskipTests'
            }
        }

        stage('制作自定义镜像并发布Harbor') {
                        steps {
                echo '制作自定义镜像并发布Harbor'
                sh '''
                cp ./target/*.jar ./docker/demo.jar
                cd ./docker
                docker build -t ${JOB_NAME}:${BUILD_NUMBER} . '''
                
                 sh '''docker login -u ${harborUser} -p ${harborPasswd} 
                docker tag ${JOB_NAME}:${BUILD_NUMBER} ${harborUser}/${harborRepo}:${JOB_NAME}_${BUILD_NUMBER}
                docker push ${harborUser}/${harborRepo}:${JOB_NAME}_${BUILD_NUMBER}'''
            }
        }

        stage('基于Harbor部署工程') {
            steps {
                echo '基于Harbor部署工程'
               sshPublisher(publishers: [sshPublisherDesc(configName: 'node-Linux32', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: '''cd /opt/java/
echo "测试成功" &gt;&gt; log.txt
 date &gt;&gt; log.txt''', execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: 'target/*.jar,docker/*')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
            }
        }
    }
}</code></pre> 
<p><a href="%0A">Ps：由于采用变量，记得使用双引号</a></p> 
<p></p> 
<p>进行构建</p> 
<p><img alt="" height="805" src="https://img-blog.csdnimg.cn/10b06733348c46119c01d568ab90082e.png" width="1200"></p> 
<p>&nbsp;已经成功</p> 
<p><img alt="" height="682" src="https://img-blog.csdnimg.cn/93a1fd1e19164ff487ab75d0daacfd8a.png" width="1200"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                ]]></description></item><item><title>Jenkins集成Sonar Qube</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295728.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295728.html</guid><description><![CDATA[
                    <h1>前文目录</h1> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124808858" title="Jenkins安装部署使用_南宫乘风的博客-CSDN博客">Jenkins安装部署使用_南宫乘风的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/124809338" title="Jenkins入门配置_南宫乘风的博客-CSDN博客">Jenkins入门配置_南宫乘风的博客-CSDN博客</a></p> 
<h1>Sonar Qube介绍</h1> 
<p>Sonar Qube是一个开源的代码分析平台，支持Java、Python、PHP、JavaScript、CSS等25种以上的语言，可以检测出重复代码、代码漏洞、代码规范和安全性漏洞的问题。</p> 
<p>Sonar Qube可以与多种软件整合进行代码扫描，比如Maven，Gradle，Git，Jenkins等，并且会将代码检测结果推送回Sonar Qube并且在系统提供的UI界面上显示出来</p> 
<p><img alt="" height="887" src="https://img-blog.csdnimg.cn/8ca6ab5caeac4a33819290d82400e416.png" width="1200"></p> 
<p>&nbsp;</p> 
<h1>Sonar Qube环境搭建</h1> 
<p>Sonar Qube安装</p> 
<p>Sonar Qube在7.9版本中已经放弃了对MySQL的支持，并且建议在商业环境中采用PostgreSQL，那么安装Sonar Qube时需要依赖PostgreSQL。</p> 
<p>并且这里会安装Sonar Qube的长期支持版本<a href="">8.9</a></p> 
<ul><li> <p>拉取镜像</p> </li></ul>
<pre><code class="language-bash">docker pull postgres
docker pull sonarqube:8.9.3-community</code></pre> 
<p>编写docker-compose.yml</p> 
<pre><code class="language-bash">version: "3.1"
services:
  db:
    image: postgres
    container_name: db
    ports:
      - 5432:5432
    networks:
      - sonarnet
    environment:
      POSTGRES_USER: sonar
      POSTGRES_PASSWORD: sonar
  sonarqube:
    image: sonarqube:8.9.3-community
    container_name: sonarqube
    depends_on:
      - db
    ports:
      - "9000:9000"
    networks:
      - sonarnet
    environment:
      SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar
      SONAR_JDBC_USERNAME: sonar
      SONAR_JDBC_PASSWORD: sonar
networks:
  sonarnet:
    driver: bridge</code></pre> 
<p>启动容器</p> 
<pre><code class="language-bash">docker-compose up -d</code></pre> 
<p>需要设置sysctl.conf文件信息</p> 
<p>设置vm.max_map_count</p> 
<p><img alt="" height="525" src="https://img-blog.csdnimg.cn/31649b32f80f48dc89aa370d701adfa4.png" width="1200"></p> 
<p>&nbsp;并执行命令刷新</p> 
<pre><code class="language-bash">sysctl -p</code></pre> 
<p>重新启动需要一定时间启动，可以可以查看容器日志，看到如下内容代表启动成功</p> 
<p>容器日志</p> 
<p><img alt="" height="335" src="https://img-blog.csdnimg.cn/3dd7b55369524f7e9408b0df578897a3.png" width="1200"></p> 
<p>&nbsp;访问Sonar Qube首页</p> 
<p><img alt="" height="378" src="https://img-blog.csdnimg.cn/2b30dc4d08ce4142a169549e1b5319cb.png" width="1200"></p> 
<p>&nbsp;</p> 
<p>还需要重新设置一次密码 <img alt="" height="504" src="https://img-blog.csdnimg.cn/fe9085ce4e634ebdb8e559a7d6ad47f8.png" width="1200"></p> 
<p>&nbsp;Sonar Qube首页</p> 
<p><img alt="" height="480" src="https://img-blog.csdnimg.cn/4f533f30087841a7ae5b98f1d2b99d37.png" width="1200"></p> 
<p>&nbsp;</p> 
<p>安装中文插件</p> 
<p><img alt="" height="817" src="https://img-blog.csdnimg.cn/9f7e9aec00634d43bf690217d42040cf.png" width="1200"></p> 
<p>&nbsp;</p> 
<p>安装成功后需要重启，安装失败重新点击install重装即可。</p> 
<p>安装成功后，会查看到重启按钮，点击即可</p> 
<p><img alt="" height="767" src="https://img-blog.csdnimg.cn/e3536c65b6cb403d83011da3d9404b61.png" width="1200"></p> 
<p>&nbsp;重启后查看效果</p> 
<p><img alt="" height="656" src="https://img-blog.csdnimg.cn/cdfbb859c349429d83e3090e9b9f4de0.png" width="1200"></p> 
<p>&nbsp;</p> 
<h2>Sonar Qube基本使用</h2> 
<h1></h1> 
<p>Sonar Qube的使用方式很多，Maven可以整合，也可以采用sonar-scanner的方式，再查看Sonar Qube的检测效果</p> 
<h2>Maven实现代码检测</h2> 
<ul><li> <p>修改Maven的settings.xml文件配置Sonar Qube信息</p> </li></ul>
<pre><code class="language-bash">&lt;profile&gt;
    &lt;id&gt;sonar&lt;/id&gt;
    &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;/activation&gt;
    &lt;properties&gt;
        &lt;sonar.login&gt;admin&lt;/sonar.login&gt;
        &lt;sonar.password&gt;admin123456&lt;/sonar.password&gt;
        &lt;sonar.host.url&gt;http://172.17.1.22:9000&lt;/sonar.host.url&gt;
    &lt;/properties&gt;
&lt;/profile&gt;</code></pre> 
<p>在代码位置执行命令：mvn sonar:sonar</p> 
<p><img alt="" height="733" src="https://img-blog.csdnimg.cn/5ebc436dfe5d4ed0a994b2e534c98db9.png" width="1200"></p> 
<p>&nbsp;查看Sonar Qube界面检测结果</p> 
<p><img alt="" height="505" src="https://img-blog.csdnimg.cn/4a691677a8d74e00a2089e7f496815e0.png" width="1200"></p> 
<p>&nbsp;</p> 
<h2>Sonar-scanner实现代码检测</h2> 
<h2></h2> 
<ul><li> <p>下载Sonar-scanner：<a href="https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/" title="https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/">https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/</a></p> <p>下载4.6.x版本即可，要求Linux版本</p> </li><li> <p>解压并配置sonar服务端信息</p> 
  <ul><li> <p>由于是zip压缩包，需要安装unzip解压插件&nbsp; &nbsp; &nbsp;</p> </li></ul></li></ul>
<pre><code class="language-bash">yum -y install unzip</code></pre> 
<p>解压压缩包</p> 
<pre><code class="language-bash">unzip sonar-scanner-cli/sonar-scanner-cli-4.6.0.2311-linux.zip</code></pre> 
<p>配置sonarQube服务端地址，修改conf下的sonar-scanner.properties</p> 
<p><img alt="" height="204" src="https://img-blog.csdnimg.cn/b0f89eb4e7d7432d90f38ddeae1d647a.png" width="1095"></p> 
<p>&nbsp;</p> 
<p>执行命令检测代码</p> 
<pre><code class="language-bash"># 在项目所在目录执行以下命令
~/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=demo -Dsonar.projectKey=java -Dsonar.java.binaries=target/</code></pre> 
<p>查看日志信息</p> 
<p><img alt="" height="584" src="https://img-blog.csdnimg.cn/f2f928ad1af34e5fb26eaad897850e1b.png" width="1200"></p> 
<p>&nbsp;查看SonarQube界面检测结果</p> 
<p><img alt="" height="480" src="https://img-blog.csdnimg.cn/bf4673fda3164d289dad73bff4610ca0.png" width="1200"></p> 
<p>&nbsp;</p> 
<h1>Jenkins集成Sonar Qube</h1> 
<p>Jenkins继承Sonar Qube实现代码扫描需要先下载整合插件</p> 
<p>Jenkins安装插件</p> 
<p><img alt="" height="517" src="https://img-blog.csdnimg.cn/73e7e4c30fac4b2d91895ea7a70cffb0.png" width="1200"></p> 
<p>&nbsp;</p> 
<p>Jenkins配置Sonar Qube</p> 
<p>开启Sonar Qube权限验证</p> 
<p><img alt="" height="801" src="https://img-blog.csdnimg.cn/618cd3f1cec44319b5fb47a88fd079cc.png" width="1200"></p> 
<p>&nbsp;获取Sonar Qube的令牌</p> 
<p><img alt="" height="419" src="https://img-blog.csdnimg.cn/7d5cc9a2e4b74b30a1c08617b458b4a5.png" width="1200"></p> 
<p>&nbsp;配置Jenkins的Sonar Qube信息</p> 
<p><img alt="" height="461" src="https://img-blog.csdnimg.cn/2c8ec7a11b574c7d97abb8d01c069ea8.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="665" src="https://img-blog.csdnimg.cn/b146b6549894423fa65deb5a06d0b6a3.png" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="731" src="https://img-blog.csdnimg.cn/6be851129a93498fa47164082700717d.png" width="955"></p> 
<p>&nbsp;</p> 
<p>配置Sonar-scanner</p> 
<ul><li> <p>将Sonar-scaner添加到Jenkins数据卷中并配置全局配置</p> </li></ul>
<p>&nbsp;<img alt="" height="596" src="https://img-blog.csdnimg.cn/260c400694784b5fa48108bf9916c40b.png" width="1200"></p> 
<p>配置任务的Sonar-scanner &nbsp;</p> 
<p><img alt="" height="544" src="https://img-blog.csdnimg.cn/abfb1624026742649689eae2ab81ef97.png" width="1200"></p> 
<pre><code class="language-bash">~/sonar-scanner/bin/sonar-scanner -Dsonar.sources=./ -Dsonar.projectname=demo -Dsonar.projectKey=java -Dsonar.java.binaries=target/


#主要下面这个
sonar.projectname=${JOB_NAME}
sonar.projectKey=${JOB_NAME}
sources=./
sonar.java.binaries=target/</code></pre> 
<p>构建任务</p> 
<p>&nbsp;<img alt="" height="781" src="https://img-blog.csdnimg.cn/5777ed541ffb4a01b8b8970630f5c593.png" width="1200"></p> 
<p><img alt="" height="725" src="https://img-blog.csdnimg.cn/279a56a4e4804b7c97a7525c4f8ab923.png" width="1200"></p> 
<p>已经上传镜像包</p> 
<p><img alt="" height="333" src="https://img-blog.csdnimg.cn/931d6c12d1aa497ea2c91f625a5adbc1.png" width="873">&nbsp;</p> 
<p>&nbsp;<img alt="" height="284" src="https://img-blog.csdnimg.cn/398317c8afd647f8bb3ed893b0cb39a7.png" width="1194"></p> 
<p></p> 
<p><strong>注意：我这里代码编译这一块，缺少那个 切换分支编译，如果有需要，需要自己配置</strong>&nbsp;</p> 
<p><img alt="" height="1200" src="https://img-blog.csdnimg.cn/a43bfb64795148819d7e5361ed6a1b1d.png" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Jenkins入门配置</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295729.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295729.html</guid><description><![CDATA[
                    <p><a href="https://blog.csdn.net/heian_99/article/details/124808858" title="Jenkins安装部署使用_南宫乘风的博客-CSDN博客">Jenkins安装部署使用_南宫乘风的博客-CSDN博客</a></p> 
<p>安装可以参考这篇文章，后续在这基础进行构建</p> 
<p></p> 
<p>由于Jenkins需要从Git拉取代码、需要本地构建、甚至需要直接发布自定义镜像到Docker仓库，所以Jenkins需要配置大量内容。</p> 
<h2>构建任务</h2> 
<p>准备好GitLab仓库中的项目，并且通过Jenkins配置项目的实现当前项目的<a href="">DevOps</a>基本流程。</p> 
<ul><li> <p>构建Maven工程发布到GitLab（Gitee、Github均可）</p> </li></ul>
<p><a href="https://gitee.com/chengfeng99/java-demo.git" title="java-demo: api-gateway-demo">java-demo: api-gateway-demo</a></p> 
<p><img alt="" height="804" src="https://img-blog.csdnimg.cn/68376a7ce8ca4c899fab549b343f8d99.png" width="1170"></p> 
<p></p> 
<p>Jenkins点击左侧导航新建任务</p> 
<p><img alt="" height="494" src="https://img-blog.csdnimg.cn/c2c788114a9a4d34adda9b09b04d4368.png" width="1200"></p> 
<p></p> 
<p>选择自由风格构建任务</p> 
<p><img alt="" height="815" src="https://img-blog.csdnimg.cn/d7dc787fda9f488590cb170d6c204511.png" width="1171"></p> 
<p></p> 
<h2>配置源码拉取地址</h2> 
<p>Jenkins需要将Git上存放的源码存储到Jenkins服务所在磁盘的本地</p> 
<ul><li> <p>配置任务源码拉取的地址</p> </li></ul>
<p><img alt="" height="586" src="https://img-blog.csdnimg.cn/659875aca631427e9080a73110077e9f.png" width="1060"></p> 
<p></p> 
<p>Jenkins立即构建</p> 
<p>点击任务demo中的立即构建</p> 
<p><img alt="" height="684" src="https://img-blog.csdnimg.cn/12c022a48dcb41fa9a4f8c6ccb96df39.png" width="938"></p> 
<p>&nbsp;查看构建工程的日志，点击上述的任务条即可</p> 
<p><img alt="" height="846" src="https://img-blog.csdnimg.cn/3c9b59ae6e764ed2a98e5d4e38a82319.png" width="1200"></p> 
<p></p> 
<ul><li> <p>可以看到源码已经拉取带Jenkins本地，可以根据第三行日志信息，查看Jenkins本地拉取到的源码。</p> </li><li> <p>查看Jenkins容器中<a href="">/var/jenkins_home/workspace/d</a>emo的源码</p> </li></ul>
<p>源码存放位置</p> 
<p><img alt="" height="83" src="https://img-blog.csdnimg.cn/fae77044512140059555ef614c6a4993.png" width="528"></p> 
<p></p> 
<h2>配置Maven构建代码</h2> 
<p>代码拉取到Jenkins本地后，需要在Jenkins中对代码进行构建，这里需要Maven的环境，而Maven需要Java的环境，接下来需要在Jenkins中安装JDK和Maven，并且配置到Jenkins服务。</p> 
<ul><li> <p>准备JDK、Maven压缩包通过数据卷映射到Jenkins容器内部</p> </li></ul>
<p><img alt="" height="563" src="https://img-blog.csdnimg.cn/fdd9f7d5b22047918505ade55ba777ab.png" width="1171"></p> 
<p>&nbsp;解压压缩包，并配置Maven的settings.xml</p> 
<pre><code class="language-bash">&lt;!-- 阿里云镜像地址 --&gt;
&lt;mirror&gt;  
    &lt;id&gt;alimaven&lt;/id&gt;  
    &lt;name&gt;aliyun maven&lt;/name&gt;  
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          
&lt;/mirror&gt;
&lt;!-- JDK1.8编译插件 --&gt;
&lt;profile&gt;
    &lt;id&gt;jdk-1.8&lt;/id&gt;
    &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
        &lt;jdk&gt;1.8&lt;/jdk&gt;
    &lt;/activation&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
    &lt;/properties&gt;        
&lt;/profile&gt;</code></pre> 
<p>Jenkins配置JDK&amp;Maven并保存</p> 
<p><img alt="" height="806" src="https://img-blog.csdnimg.cn/d2e8f8a9ffa34c38b8aac8833aa69821.png" width="1200"></p> 
<p>&nbsp;配置Jenkins任务构建代码</p> 
<p><img alt="" height="561" src="https://img-blog.csdnimg.cn/2f68bbdb25aa478986424f9a06558099.png" width="1084"></p> 
<p>&nbsp;立即构建测试，查看target下的jar包</p> 
<p><a href="https://gitee.com/chengfeng99/java-demo.git" title="java-demo: api-gateway-demo">java-demo: api-gateway-demo</a></p> 
<p><img alt="" height="668" src="https://img-blog.csdnimg.cn/c323a7c4561e44dfb6c1a2caecd8acd8.png" width="1129"></p> 
<h2>配置Publish发布&amp;远程操作</h2> 
<p>jar包构建好之后，就可以根据情况发布到测试或生产环境，这里需要用到之前下载好的插件Publish Over SSH。</p> 
<ul><li> <p>配置Publish Over SSH连接测试、生产环境</p> </li></ul>
<p>Publish Over SSH配置</p> 
<p><img alt="" height="796" src="https://img-blog.csdnimg.cn/04aa8a0941584adeb2060edcf22a85f3.png" width="1200"></p> 
<p>&nbsp;<img alt="" height="800" src="https://img-blog.csdnimg.cn/f2eea35e4f034083959f283638e6f5bf.png" width="1200"></p> 
<p></p> 
<p>&nbsp;配置任务的构建后操作，发布jar包到目标服务</p> 
<p><img alt="" height="726" src="https://img-blog.csdnimg.cn/238250c6ba2944d19002ad5e0fb42bb9.png" width="1090"></p> 
<p>&nbsp;<img alt="" height="1200" src="https://img-blog.csdnimg.cn/4102647d71ac41e2be4e45b7b2e1e601.png" width="1200"></p> 
<p>&nbsp;<img alt="" height="726" src="https://img-blog.csdnimg.cn/5094833367134c6086282d76db0fd132.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="698" src="https://img-blog.csdnimg.cn/6dabff682161452e9b7ee1027f9b7aa5.png" width="877"></p> 
<p>&nbsp;已经完成一次简单的构建交付</p> 
<h2>持续交付、部署</h2> 
<p>程序代码在经过多次集成操作到达最终可以交付，持续交付整体流程和持续集成类似，不过需要选取指定的发行版本</p> 
<ul><li> <p>下载Git Parameter插件</p> </li></ul>
<p><img alt="" height="616" src="https://img-blog.csdnimg.cn/1f595b7b5a0d404b8a6144ffd057d941.png" width="1200"></p> 
<p>&nbsp;</p> 
<p>设置项目参数化构建</p> 
<p>基于Git标签构建</p> 
<p><img alt="" height="542" src="https://img-blog.csdnimg.cn/2fa818313a774b98acc2cbb5f5aba000.png" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="682" src="https://img-blog.csdnimg.cn/2c864ec677da4947a5168b76f12201af.png" width="1200"></p> 
<p>&nbsp;给项目添加tag版本</p> 
<p><img alt="" height="626" src="https://img-blog.csdnimg.cn/ce487a64e8c14962b199940e75a5aa3e.png" width="1200"></p> 
<p>&nbsp;任务构建时，采用Shell方式构建，拉取指定tag版本代码</p> 
<p><img alt="" height="535" src="https://img-blog.csdnimg.cn/099dbd89f8ce41f980a6f0272bb732fc.png" width="1160"></p> 
<p>&nbsp;基于Parameter构建任务，任务发布到目标服务器</p> 
<p><img alt="" height="273" src="https://img-blog.csdnimg.cn/54a960e298ab425598b3062eeba170b3.png" width="924"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Jenkins安装部署使用</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295730.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295730.html</guid><description><![CDATA[
                    <h2>介绍</h2> 
<p>Jenkins是一个独立的开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。前身是Hudson是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。Jenkins可以通过本机系统包Docker安装，甚至可以通过安装Java Runtime Environment的任何机器独立运行。</p> 
<h2><strong>Jenkins特点</strong></h2> 
<ul><li>开源免费;</li><li>跨平台，支持所有的平台;</li><li>master/slave支持分布式的build;</li><li>web形式的可视化的管理页面;</li><li>安装配置超级简单;</li><li>tips及时快速的帮助；</li><li>已有的200多个插件</li></ul>
<p><img alt="" height="522" src="https://img-blog.csdnimg.cn/86052dfea3b0439bbca0450729bbbb67.png" width="927"></p> 
<p>&nbsp;</p> 
<h2 id="blogTitle2">安装教程</h2> 
<p>这里我们使用的是离线包方式安装。</p> 
<p>官网镜像地址:&nbsp;<a href="https://mirrors.jenkins.io/" title="Index of /">Index of /</a><br> 下载地址：&nbsp;<a href="https://jenkins.io/download/" title="Jenkins download and deployment">Jenkins download and deployment</a><br> 华为镜像地址:&nbsp;<a href="https://mirrors.huaweicloud.com/home" title="华为开源镜像站_软件开发服务_华为云">华为开源镜像站_软件开发服务_华为云</a></p> 
<p>直接下载war包，并安装好jdk之后，输入:nohup java -jar jenkins.war --httpPort=8888 &amp;<br> 进行启动，然后网页浏览器输入 ip:8888打开设置好账号密码之后登录即可，插件安装推荐使用官方推荐。</p> 
<p></p> 
<p><img alt="" height="836" src="https://img-blog.csdnimg.cn/07ec709025734dc3abde51e5eea918e7.png" width="1200"></p> 
<p>&nbsp;</p> 
<h2>&nbsp;Docker安装</h2> 
<p></p> 
<p>拉取Jenkins镜像</p> 
<pre><code class="language-bash">docker pull jenkins/jenkins</code></pre> 
<p>编写docker-compose.yml</p> 
<pre><code class="language-bash">version: "3.1"
services:
  jenkins:
    image: jenkins/jenkins
    container_name: jenkins
    ports:
      - 8080:8080
      - 50000:50000
    volumes:
      - ./data/:/var/jenkins_home/
      - /usr/bin/docker:/usr/bin/docker
      - /var/run/docker.sock:/var/run/docker.sock
      - /etc/docker/daemon.json:/etc/docker/daemon.json
</code></pre> 
<p><img alt="" height="347" src="https://img-blog.csdnimg.cn/62f58ce9ce6d41a58af241b832b40ee0.png" width="515"></p> 
<p>&nbsp;</p> 
<p>首次启动会因为数据卷data目录没有权限导致启动失败，设置data目录写权限</p> 
<p><img alt="" height="93" src="https://img-blog.csdnimg.cn/661580a6b2534c2888bfb7a2e03155e3.png" width="897"></p> 
<pre><code class="language-bash">chmod -R a+w data/&nbsp;</code></pre> 
<p>重新启动Jenkins容器后，由于Jenkins需要下载大量内容，但是由于默认下载地址下载速度较慢，需要重新设置下载地址为国内镜像站</p> 
<pre><code class="language-bash"># 修改数据卷中的hudson.model.UpdateCenter.xml文件
&lt;?xml version='1.1' encoding='UTF-8'?&gt;
&lt;sites&gt;
  &lt;site&gt;
    &lt;id&gt;default&lt;/id&gt;
    &lt;url&gt;https://updates.jenkins.io/update-center.json&lt;/url&gt;
  &lt;/site&gt;
&lt;/sites&gt;
# 将下载地址替换为http://mirror.esuni.jp/jenkins/updates/update-center.json
&lt;?xml version='1.1' encoding='UTF-8'?&gt;
&lt;sites&gt;
  &lt;site&gt;
    &lt;id&gt;default&lt;/id&gt;
    &lt;url&gt;http://mirror.esuni.jp/jenkins/updates/update-center.json&lt;/url&gt;
  &lt;/site&gt;
&lt;/sites&gt;
# 清华大学的插件源也可以https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code></pre> 
<p>再次重启Jenkins容器，访问Jenkins（需要稍微等会）</p> 
<pre><code class="language-bash">docker-compose restart</code></pre> 
<p><img alt="" height="292" src="https://img-blog.csdnimg.cn/7ce8b117fb53454e8058546550c9fe0e.png" width="908"></p> 
<p>&nbsp;查看密码登录Jenkins，并登录下载插件</p> 
<pre><code class="language-bash">docker exec -it jenkins cat /var/jenkins_home/secrets/initialAdminPassword</code></pre> 
<p><img alt="" height="634" src="https://img-blog.csdnimg.cn/fa7589e1e1394ff8b6d2714363813f7c.png" width="1200"></p> 
<p><img alt="" height="491" src="https://img-blog.csdnimg.cn/5abb45aa916a4a128883e68eed03fab5.png" width="1200">&nbsp;</p> 
<p>&nbsp;<img alt="" height="343" src="https://img-blog.csdnimg.cn/4b4be6f3cd8641c291b3c1a3eb6cfbee.png" width="1087"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="398" src="https://img-blog.csdnimg.cn/3a2abc00ac6d4289b96654fcea395fed.png" width="1156"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="614" src="https://img-blog.csdnimg.cn/4ae63c3c631d42e5a67b96c810a22ace.png" width="797"></p> 
<p><img alt="" height="286" src="https://img-blog.csdnimg.cn/86d90cfe377942d3ade053fd48f021fd.png" width="729">&nbsp;</p> 
<p>&nbsp;<img alt="" height="258" src="https://img-blog.csdnimg.cn/935c92d6ed8249e9acef95793cc67cdf.png" width="719"></p> 
<p>&nbsp;</p> 
<p></p> 
<p><img alt="" height="507" src="https://img-blog.csdnimg.cn/59d332cba48f4a648a538bc891b6e6f4.png" width="1200"></p> 
<p>&nbsp;</p> 
<p></p>
                ]]></description></item><item><title>Mysql主从同步复制（快速构建，基于CP数据备份 恢复）</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295731.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295731.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E7%9B%B8%E5%85%B3%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%9B%B8%E5%85%B3%C2%A0">相关&nbsp;</a></p> 
<p id="%E6%80%9D%E8%B7%AF-toc" style="margin-left:0px;"><a href="#%E6%80%9D%E8%B7%AF">思路</a></p> 
<p id="%E4%B8%BB%E5%BA%93-toc" style="margin-left:0px;"><a href="#%E4%B8%BB%E5%BA%93">主库</a></p> 
<p id="1%E3%80%81%E6%A3%80%E6%9F%A5%E4%B8%BB%E5%BA%93%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AFlog-bin-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%A3%80%E6%9F%A5%E4%B8%BB%E5%BA%93%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AFlog-bin">1、检查主库是否开启log-bin</a></p> 
<p id="2%E3%80%81%E5%BC%80%E5%90%AFlog-bin-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%BC%80%E5%90%AFlog-bin">2、开启log-bin</a></p> 
<p id="3%E3%80%81%E9%87%8D%E5%90%AFMySQL-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E9%87%8D%E5%90%AFMySQL">3、重启MySQL</a></p> 
<p id="4%E3%80%81%E6%A3%80%E6%9F%A5%E7%94%9F%E6%88%90%E7%9A%84log-bin%E7%9B%AE%E5%BD%95-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%A3%80%E6%9F%A5%E7%94%9F%E6%88%90%E7%9A%84log-bin%E7%9B%AE%E5%BD%95">4、检查生成的log-bin目录</a></p> 
<p id="5%E3%80%81%E8%BF%9B%E5%85%A5MySQL%EF%BC%8C%E9%94%81%E8%A1%A8%EF%BC%8C%E8%AE%B0%E5%BD%95POS%E5%8F%B7-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E8%BF%9B%E5%85%A5MySQL%EF%BC%8C%E9%94%81%E8%A1%A8%EF%BC%8C%E8%AE%B0%E5%BD%95POS%E5%8F%B7">5、进入MySQL，锁表，记录POS号</a></p> 
<p id="6%E3%80%81%E5%A4%87%E4%BB%BDmysql%E6%96%87%E4%BB%B6%EF%BC%8C%E8%A7%A3%E8%A1%A8-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%A4%87%E4%BB%BDmysql%E6%96%87%E4%BB%B6%EF%BC%8C%E8%A7%A3%E8%A1%A8">6、备份mysql文件，解表</a></p> 
<p id="7%E3%80%81%E4%B8%BB%E5%BA%93%E4%BC%A0%E8%BE%93mysql%E6%96%87%E4%BB%B6%E5%88%B0%E4%BB%8E%E5%BA%93-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E4%B8%BB%E5%BA%93%E4%BC%A0%E8%BE%93mysql%E6%96%87%E4%BB%B6%E5%88%B0%E4%BB%8E%E5%BA%93">7、主库传输mysql文件到从库</a></p> 
<p id="8%E3%80%81%E6%B7%BB%E5%8A%A0iptables%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%EF%BC%88ip%E4%B8%BA%E4%BB%8E%E5%BA%93IP%EF%BC%89-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E6%B7%BB%E5%8A%A0iptables%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%EF%BC%88ip%E4%B8%BA%E4%BB%8E%E5%BA%93IP%EF%BC%89">8、添加iptables防火墙规则（ip为从库IP）</a></p> 
<p id="%E4%BB%8E%E5%BA%93-toc" style="margin-left:0px;"><a href="#%E4%BB%8E%E5%BA%93">从库</a></p> 
<p id="1%E3%80%81%E5%81%9C%E6%AD%A2%E4%BB%8E%E5%BA%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%81%9C%E6%AD%A2%E4%BB%8E%E5%BA%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E7%A8%8B%E5%BA%8F">1、停止从库的业务程序</a></p> 
<p id="2%E3%80%81%E5%81%9C%E6%AD%A2%E7%A5%A8%E5%8A%A1%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%81%9C%E6%AD%A2%E7%A5%A8%E5%8A%A1%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%A8%8B%E5%BA%8F">2、停止票务开机自启程序</a></p> 
<p id="3%E3%80%81%E6%A3%80%E6%9F%A5%E4%B8%BB%E5%BA%93%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AFlog-bin-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%A3%80%E6%9F%A5%E4%B8%BB%E5%BA%93%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AFlog-bin">3、检查主库是否开启log-bin</a></p> 
<p id="4%E3%80%81%E5%BC%80%E5%90%AFlog-bin%EF%BC%8C%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BF%AE%E6%94%B9id-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%BC%80%E5%90%AFlog-bin%EF%BC%8C%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BF%AE%E6%94%B9id">4、开启log-bin，添加配置，修改id</a></p> 
<p id="4%E3%80%81%E5%81%9C%E6%AD%A2mysql%20%EF%BC%8C%E5%A4%87%E4%BB%BD%E7%9B%AE%E5%BD%95-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%81%9C%E6%AD%A2mysql%20%EF%BC%8C%E5%A4%87%E4%BB%BD%E7%9B%AE%E5%BD%95">4、停止mysql ，备份目录</a></p> 
<p id="5%E3%80%81%E8%A6%86%E7%9B%96mysql%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%88%A0%E9%99%A4auto.cnf-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E8%A6%86%E7%9B%96mysql%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%88%A0%E9%99%A4auto.cnf">5、覆盖mysql目录，删除auto.cnf</a></p> 
<p id="6%E3%80%81%E5%90%AF%E5%8A%A8mysql-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%90%AF%E5%8A%A8mysql">6、启动mysql</a></p> 
<p id="7%E3%80%81%E5%90%AF%E5%8A%A8%E4%B8%BB%E4%BB%8E-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E5%90%AF%E5%8A%A8%E4%B8%BB%E4%BB%8E">7、启动主从</a></p> 
<hr id="hr-toc">
<p></p> 
<h1 id="%E7%9B%B8%E5%85%B3%C2%A0">相关&nbsp;</h1> 
<p>相关原理可以查看此博客&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
<p><a class="link-info has-card" href="http://xn--mysql-ni1h1kkd34cien8anzj00an2yqrx8k1a1u9c2j7e9svvilaaa" title="https://blog.csdn.net/heian_99/article/details/106647572"><span class="link-card-box"><span class="link-title">https://blog.csdn.net/heian_99/article/details/106647572</span><span class="link-link"><img alt="" class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.1.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M4AD">http://xn--mysql-ni1h1kkd34cien8anzj00an2yqrx8k1a1u9c2j7e9svvilaaa</span></span></a></p> 
<p>以下作为 实际操作</p> 
<p style="margin-left:0;text-align:justify;">环境：</p> 
<p style="margin-left:0;text-align:justify;">主库：&nbsp;&nbsp;&nbsp; mysql</p> 
<p style="margin-left:0;text-align:justify;">从库： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mysql</p> 
<h1 id="%E6%80%9D%E8%B7%AF" style="margin-left:0px;text-align:justify;">思路</h1> 
<p>（1）主库A数据全，数据库B空的</p> 
<p>（2）锁表数据库A，记录pos号</p> 
<p>（3）复制数据库A目录数据（进行cp备份）然后 解锁表</p> 
<p>（4）把数据库A备份的数据进行scp 数据库B</p> 
<p>（5）把数据库A的目录，进行覆盖数据库B的目录。（数据覆盖，相当于备份恢复）</p> 
<p>（6）进行主共同步</p> 
<p><span style="color:#fe2c24;"><strong>注意：日志格式&nbsp;</strong></span>statement&nbsp;&nbsp;row&nbsp;mixed&nbsp; &nbsp;建议使用 <strong>mixed</strong></p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20200609163414418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p> 
<p></p> 
<h1 id="%E4%B8%BB%E5%BA%93" style="margin-left:0px;text-align:center;">主库</h1> 
<h2 id="1%E3%80%81%E6%A3%80%E6%9F%A5%E4%B8%BB%E5%BA%93%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AFlog-bin" style="text-align:justify;"><strong>1、检查主库是否开启log-bin</strong></h2> 
<pre><code class="language-bash">[root@92-69-xy-bak ~]# cat /etc/my.cnf | grep log-bin
log-bin=/databak/mysql-bin/mysql-bin
</code></pre> 
<h2 id="2%E3%80%81%E5%BC%80%E5%90%AFlog-bin" style="text-align:justify;"><strong>2、开启log-bin</strong></h2> 
<p style="margin-left:0;text-align:justify;">如果上面没有显示，需要开启log-bin</p> 
<pre><code class="language-bash">开启
vim /etc/my.cnf
log-bin=/databak/mysql-bin/mysql-bin
创建目录，授权
mkdir  /databak/mysql-bin
chown  mysql.mysql  /databak/mysql-bin   -R
</code></pre> 
<h2 id="3%E3%80%81%E9%87%8D%E5%90%AFMySQL">3、重启MySQL</h2> 
<p style="margin-left:0;text-align:justify;">重启mysql是因为刚开启log-bin日志，需要生成数据</p> 
<pre><code>service  mysql restart</code></pre> 
<h2 id="4%E3%80%81%E6%A3%80%E6%9F%A5%E7%94%9F%E6%88%90%E7%9A%84log-bin%E7%9B%AE%E5%BD%95" style="text-align:justify;"><strong>4、检查生成的log-bin</strong><strong>目录</strong></h2> 
<pre><code class="language-bash">目的：是否开启log-bin成功，是否生成日志数据</code></pre> 
<pre><code> ls /databak/mysql-bin/

生成的数据
mysql-bin.000001  mysql-bin.000002  mysql-bin.000003  mysql-bin.index
</code></pre> 
<h2 id="5%E3%80%81%E8%BF%9B%E5%85%A5MySQL%EF%BC%8C%E9%94%81%E8%A1%A8%EF%BC%8C%E8%AE%B0%E5%BD%95POS%E5%8F%B7">5、<strong>进入MySQL，锁表，记录POS</strong><strong>号</strong></h2> 
<pre><code class="language-bash">mysql -ucpms -pudqjHDMkxQfGP4iy
FLUSH TABLES WITH READ LOCK;
show master status;
echo  "日志名字    偏移量"   &gt;  /var/lib/mysql/记录文件
</code></pre> 
<h2 id="6%E3%80%81%E5%A4%87%E4%BB%BDmysql%E6%96%87%E4%BB%B6%EF%BC%8C%E8%A7%A3%E8%A1%A8">6、<strong>备份mysql文件，解表</strong></h2> 
<pre><code class="language-bash">cp  -r    /var/lib/mysql /opt/mysql_bak

UNLOCK TABLES;
</code></pre> 
<h2 id="7%E3%80%81%E4%B8%BB%E5%BA%93%E4%BC%A0%E8%BE%93mysql%E6%96%87%E4%BB%B6%E5%88%B0%E4%BB%8E%E5%BA%93" style="text-align:justify;"><strong>7、主库传输mysql</strong><strong>文件到从库</strong></h2> 
<pre><code class="language-bash">cd /opt
scp -r mysql_bak soft CMS3.10.21 192.168.0.3:/opt
</code></pre> 
<h2 id="8%E3%80%81%E6%B7%BB%E5%8A%A0iptables%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%EF%BC%88ip%E4%B8%BA%E4%BB%8E%E5%BA%93IP%EF%BC%89" style="text-align:justify;"><strong>8、添加iptables</strong><strong>防火墙规则（ip</strong><strong>为从库IP</strong><strong>）</strong></h2> 
<pre><code class="language-bash"> vim /etc/sysconfig/iptables
-A INPUT -s 10.92.69.3 -p tcp --dport 3306 -j ACCEPT
/etc/init.d/iptables restart
</code></pre> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#ff0000;">以上操作主库完成</span></strong></p> 
<h1 id="%E4%BB%8E%E5%BA%93" style="text-align:center;">从库</h1> 
<h2 id="1%E3%80%81%E5%81%9C%E6%AD%A2%E4%BB%8E%E5%BA%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E7%A8%8B%E5%BA%8F"><strong>1、停止从库的业务程序</strong></h2> 
<pre><code>pkill java
</code></pre> 
<h2 id="2%E3%80%81%E5%81%9C%E6%AD%A2%E7%A5%A8%E5%8A%A1%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%A8%8B%E5%BA%8F"><strong>2、停止票务开机自启程序</strong></h2> 
<pre><code class="language-bash">chkconfig --list | grep cms |awk '{print "chkconfig",$1,"off"}'|bash</code></pre> 
<h2 id="3%E3%80%81%E6%A3%80%E6%9F%A5%E4%B8%BB%E5%BA%93%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AFlog-bin">3、<strong>检查主库是否开启log-bin</strong></h2> 
<pre><code class="language-bash">[root@92-69-xy-bak ~]# cat /etc/my.cnf | grep log-bin
log-bin=/databak/mysql-bin/mysql-bin
</code></pre> 
<h2 id="4%E3%80%81%E5%BC%80%E5%90%AFlog-bin%EF%BC%8C%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BF%AE%E6%94%B9id">4、<strong>开启log-bin，添加配置，修改id</strong></h2> 
<p>如果上面没有显示，需要开启log-bin</p> 
<pre><code class="language-bash">开启
vim /etc/my.cnf
log-bin=/databak/mysql-bin/mysql-bin

server-id=2

replicate_ignore_table=CMS.QC_TEMP
replicate_ignore_table=CMS.QM_TEMP
replicate_ignore_table=CMS.STORE_IN_TEMP
replicate_ignore_table=CMS.TEMP_POS_SALE_GOODS_ITEM_COST
replicate_ignore_table=CMS.TEMP_POS_REJECT_GOODS_ITEM_COST
replicate_ignore_table=CMS.MER_INTERFACE_DAY_STORE_CHECK
slave-skip-errors = 1062


创建目录，授权
mkdir  /databak/mysql-bin
chown  mysql.mysql  /databak/mysql-bin   -R
</code></pre> 
<h2 id="4%E3%80%81%E5%81%9C%E6%AD%A2mysql%20%EF%BC%8C%E5%A4%87%E4%BB%BD%E7%9B%AE%E5%BD%95">4、<strong>停止mysql ，备份目录</strong></h2> 
<pre><code>service mysql stop

mv /var/lib/mysql /var/lib/bak_mysql
</code></pre> 
<h2 id="5%E3%80%81%E8%A6%86%E7%9B%96mysql%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%88%A0%E9%99%A4auto.cnf">5、<strong>覆盖mysql目录，删除auto.cnf</strong></h2> 
<pre><code>cp -r /opt/mysql_bak /var/lib/mysql

\rm   /var/lib/mysql/auto.cnf
</code></pre> 
<h2 id="6%E3%80%81%E5%90%AF%E5%8A%A8mysql"><strong>6、启动mysql</strong></h2> 
<pre><code>service mysql start</code></pre> 
<h2 id="7%E3%80%81%E5%90%AF%E5%8A%A8%E4%B8%BB%E4%BB%8E">7、<strong>启动主从</strong></h2> 
<pre><code>进入mysql
mysql -uroot -p^passswd
停止slave
stop  slave;
写入 配置信息（注意pos号，账号，主库ip 端口）
change master to
master_host='10.92.69.2',
master_port=3306,
master_user='admin',
master_password='udq5545adadefiy',
master_log_file='mysql-bin.000001',
master_log_pos=17503;
开启从库
start  slave;
查看状态
show slave status\G
两个yes为正常，检查pos号是否已经和主库同步
</code></pre> 
<p><span style="color:#ff0000;">以上操作需谨慎，尤其主库上，输入命令需三思（文档仅供参考）</span></p>
                ]]></description></item><item><title>Linux任务分析脚本</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295732.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295732.html</guid><description><![CDATA[
                    <p>首先我们日常运维中，服务器会跑大量的任务。</p> 
<p>（1）我们可以通prometheus和grafana 展示整个服务器的cpu 内存 和磁盘IO的趋势</p> 
<p>（2）可以每台部署相应的脚本，可以定位到每个时间段执行的业务，所消耗的各项资源</p> 
<p></p> 
<h1>统计前十的CUP消耗应用（降序 ）</h1> 
<pre><code class="language-bash">ps aux|head -1 &amp;&amp; ps aux|grep -v PID|sort -rn -k +3|head</code></pre> 
<p></p> 
<p><img alt="" height="227" src="https://img-blog.csdnimg.cn/c0b10584b7c74e3ead9efe214b64fab2.png" width="1133"></p> 
<h1>统计前十的内存消耗应用（降序&nbsp;）</h1> 
<pre><code class="language-bash">ps aux|head -1 &amp;&amp;  ps aux|grep -v PID|sort -rn -k +4|head</code></pre> 
<h1><img alt="" height="301" src="https://img-blog.csdnimg.cn/adc8cabd72284c58bc6575e2234db291.png" width="1200">统计前十的磁盘IO消耗应用（降序&nbsp;）</h1> 
<p></p> 
<p></p> 
<p></p> 
<pre><code class="language-bash">/usr/sbin/iotop -btoq --iter=1 |awk 'NR&gt;3{print}'|sort -rn -k 11</code></pre> 
<p>切记需要安装iotop</p> 
<p><img alt="" height="518" src="https://img-blog.csdnimg.cn/096d5156682a41a9bbcf6bf34183479f.png" width="1200"></p> 
<h1>统计网络状态标识（状态）&nbsp;</h1> 
<pre><code class="language-bash">netstat  -nt | grep -e 127.0.0.1 -e 0.0.0.0 -e ::: -v | awk '/^tcp/ {++state[$NF]} END {for(i in state) print i,"\t",state[i]}'</code></pre> 
<p><img alt="" height="130" src="https://img-blog.csdnimg.cn/5f5e6644c9d8485ea6a9458caa27355d.png" width="1174"></p> 
<p></p> 
<h1>&nbsp;统计网络状态标识（IP）</h1> 
<pre><code class="language-bash">netstat -n | awk '/^tcp/ {print $0}'  | awk '{print $(NF-1),$NF}' |  awk -F ':| ' '{print $1,$NF}' |awk 'BEGIN{print "IP\t\t状态\t次数统计"} {a[$1" "$2]++}END{for(i in a) print(i,a[i])}' |sort -nk 3</code></pre> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/c8d1612f342f3e22cfad05e7abd808ed.png"></p> 
<p><a class="has-card" href="https://blog.csdn.net/weixin_31304599/article/details/112671431?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" title="连接状态_学习笔记-TCP连接状态解析_六十度灰的博客-CSDN博客"><span class="link-card-box"><span class="link-title">连接状态_学习笔记-TCP连接状态解析_六十度灰的博客-CSDN博客</span><span class="link-desc">前面两篇详细的给大家介绍过了TCP的三次握手和四次挥手流程(详见学习笔记-TCP三次握手， 学习笔记-TCP四次挥手 )，本文主要是介绍在TCP连接过程中的各种状态变化。状态介绍CLOSED:表示初始状态。LISTEN:表示服务器端的某个SOCKET处于，可以接受连接了。SYN_RCVD:这个状态表示接受到了SYN，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的会话过程中的一个...</span><span class="link-link"><img alt="" class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico">https://blog.csdn.net/weixin_31304599/article/details/112671431?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</span></span></a></p> 
<h1>相关脚本</h1> 
<pre><code class="language-bash">#!/bin/bash
#时间
time=$(date "+%Y-%m-%d %H:%M:%S")
day=$(date "+%Y-%m-%d")
#首生成日志目录
mkdir -p /system/log/{cpu,mem,io,net}
cpudir='/system/log/cpu'
memdir='/system/log/mem'
iodir='/system/log/io'
netdir='/system/log/net'
#统计前10的cpu
echo "=========================================${time}======================================================" &gt;&gt; ${cpudir}/${day}.log
ps aux|head -1 &gt;&gt; ${cpudir}/${day}.log
ps aux|grep -v PID|sort -rn -k +3|head &gt;&gt; ${cpudir}/${day}.log
#统计前10的内存
echo "=========================================${time}======================================================" &gt;&gt; ${memdir}/${day}.log
ps aux|head -1 &gt;&gt; ${memdir}/${day}.log
ps aux|grep -v PID|sort -rn -k +4|head &gt;&gt; ${memdir}/${day}.log
#统计前10的磁盘io
echo "=========================================${time}======================================================" &gt;&gt; ${iodir}/${day}.log
/usr/sbin/iotop -btoq --iter=1 |head -n 3 &gt;&gt; ${iodir}/${day}.log
/usr/sbin/iotop -btoq --iter=1 |awk 'NR&gt;3{print}'|sort -rn -k 11 &gt;&gt; ${iodir}/${day}.log
#统计机器的网络状态(ip,状态)

echo "=========================================${time}======================================================" &gt;&gt; ${netdir}/${day}.log
netstat  -nt | grep -e 127.0.0.1 -e 0.0.0.0 -e ::: -v | awk '/^tcp/ {++state[$NF]} END {for(i in state) print i,"\t",state[i]}' &gt;&gt; ${netdir}/${day}.log
echo  -n " "  &gt;&gt; ${netdir}/${day}.log
netstat -n | awk '/^tcp/ {print $0}'  | awk '{print $(NF-1),$NF}' |  awk -F ':| ' '{print $1,$NF}' |awk 'BEGIN{print "IP\t\t状态\t次数统计"} {a[$1" "$2]++}END{for(i in a) print(i,a[i])}' |sort -nk 3 &gt;&gt; ${netdir}/${day}.log

#删除老化的文件（保留7天）
find /system/log/ -type f -mtime +7  -exec rm -f {} \;
</code></pre> 
<h1>设置定时任务</h1> 
<pre><code>#拷贝文件
ansible hadoop -i ./hadoopip -m copy -a "src=/system/check_system.sh dest=/system/check_system.sh " -f 20
#给权限
ansible hadoop -i ./hadoopip -m shell  -a "chmod a+x /system/check_system.sh " -f 20
#安装依赖
 ansible hadoop -i ./hadoopip -m shell  -a "yum install -y iotop " -f 20
#设置定时任务
ansible hadoop -i ./hadoopip -m cron -a "minute=*/5 job='sh /system/check_system.sh' name=check_system disabled=no" -f 20</code></pre> 
<p><img alt="" height="181" src="https://img-blog.csdnimg.cn/1567b8bc824e42ef99838e47e024f1ac.png" width="1200"></p> 
<h1>&nbsp;运行结果</h1> 
<p><img alt="" height="944" src="https://img-blog.csdnimg.cn/f027112e1cea4ee78bf0ae854e5513d4.png" width="501"></p> 
<h1>日志格式&nbsp;</h1> 
<p><img alt="" height="704" src="https://img-blog.csdnimg.cn/f68b6de6deaf494980f25e7646e80d55.png" width="1198"></p> 
<p><img alt="" height="1057" src="https://img-blog.csdnimg.cn/aaa67ceeddef4538be43439caa654105.png" width="1001"></p> 
<p></p>
                ]]></description></item><item><title>Django开发告警接口（webhook）对接Altermanager告警</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295733.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295733.html</guid><description><![CDATA[
                    <p><strong>告警日志统计 </strong></p> 
<p><img alt="" height="803" src="https://img-blog.csdnimg.cn/9a058cb81d1e4927962dd821620de729.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p></p> 
<h2><strong>告警去重统计</strong></h2> 
<p><img alt="" height="818" src="https://img-blog.csdnimg.cn/2f39bbf2119340eca6893509c0786d08.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<h2>告警人分组邮件</h2> 
<p><img alt="" height="760" src="https://img-blog.csdnimg.cn/3884b0ac152a4f1faa0ece0429c7595c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p></p> 
<p><strong>原理图</strong></p> 
<p class="img-center"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/c92b80dd349003cbac81d33d021a1c14.png"></p> 
<p></p> 
<p>此项目主要使用Django开发告警接口，对接Altermanager告警，实现告警人分组，邮件等</p> 
<p>告警信息日志，告警信息统计等等</p> 
<p><img alt="" height="603" src="https://img-blog.csdnimg.cn/344863fab8814d1288e7c4e6b8814ab6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="853"></p> 
<p>开发过程</p> 
<p>model</p> 
<pre><code class="language-python">from django.db import models


# Create your models here.
class alerts(models.Model):
    startsAt = models.DateTimeField(verbose_name='告警产生时间')
    endsAt = models.DateTimeField(verbose_name='告警恢复时间')
    instance = models.CharField(max_length=50, verbose_name='实例', blank=True)
    alertname = models.CharField(max_length=100, verbose_name='告警名称')
    status = models.CharField(max_length=20, verbose_name='状态', blank=True)
    severity = models.CharField(max_length=20, verbose_name='告警级别', blank=True)
    message = models.CharField(max_length=1000, verbose_name='告警信息', blank=True)
    known = models.BooleanField(default=False, verbose_name='知悉')
    memo = models.CharField(max_length=50, verbose_name='知悉备注', blank=True)

    def __str__(self):
        return self.message

    class Meta:
        db_table = 'alerts'
        verbose_name = '告警日志'
        verbose_name_plural = verbose_name
        # ordering = ['-startsAt']  # 按故障时间倒排


class production(models.Model):
    startsAt = models.DateTimeField(verbose_name='告警产生时间')
    endsAt = models.DateTimeField(verbose_name='告警恢复时间')
    instance = models.CharField(max_length=50, verbose_name='实例', blank=True)
    alertname = models.CharField(max_length=100, verbose_name='告警名称')
    status = models.CharField(max_length=20, verbose_name='状态', blank=True)
    severity = models.CharField(max_length=20, verbose_name='告警级别', blank=True)
    message = models.CharField(max_length=1000, verbose_name='告警信息', blank=True)
    known = models.BooleanField(default=False, verbose_name='知悉')

    # memo = models.CharField(max_length=50, verbose_name='知悉备注', blank=True)

    def __str__(self):
        return self.message

    class Meta:
        db_table = 'production'
        verbose_name = '告警统计'
        verbose_name_plural = verbose_name


class alarmuser(models.Model):
    username = models.CharField(max_length=20, verbose_name='告警人', blank=True)
    useremail = models.EmailField(max_length=20, verbose_name='告警邮件', blank=True)
    group = models.CharField(max_length=20, verbose_name='分组', blank=True)

    def __str__(self):
        return self.username

    class Meta:
        db_table = 'alarmuser'
        verbose_name = '告警人配置'
        verbose_name_plural = verbose_name
</code></pre> 
<p>注册xadmin后台</p> 
<pre><code class="language-python">import xadmin

from django.contrib import admin

from xadmin import views
from webhook.models import alerts, production, alarmuser


class GlobalSetting:
    site_title = "长风破浪"
    site_footer = "长风破浪"
    menu_style = "accordion"  # 这个是设置菜单主题
    enable_themes = True
    use_bootswatch = True
    refresh_times = [5, 10, 30, 60]


xadmin.site.register(views.CommAdminView, GlobalSetting)


class AlertsAdmin(object):
    """xadmin的全局配置"""
    site_title = "长风破浪"  # 设置站点标题
    site_footer = "长风破浪"  # 设置站点的页脚
    menu_style = "accordion"  # 设置菜单折叠
    '''设置列表可显示的字段'''
    list_display = ('startsAt', 'endsAt', 'instance', 'alertname', 'status', 'severity', 'message', 'known', 'memo',)

    list_filter = ['status', 'severity', 'startsAt', 'endsAt']
    search_fields = ['instance', 'alertname']
    # list_per_page设置每页显示多少条记录，默认是100条
    list_per_page = 50


class ProductionAdmin(object):
    menu_style = "accordion"  # 设置菜单折叠
    list_display = ('startsAt', 'endsAt', 'instance', 'alertname', 'status', 'severity', 'message', 'known',)

    list_filter = ['status', 'severity', 'startsAt', 'endsAt']
    search_fields = ['instance', 'alertname']
    # list_per_page设置每页显示多少条记录，默认是100条
    list_per_page = 50


class AlarmuserAdmin(object):
    list_display = ('username', 'useremail', 'group')


xadmin.site.register(alerts, AlertsAdmin)
xadmin.site.register(production, ProductionAdmin)
xadmin.site.register(alarmuser, AlarmuserAdmin)
</code></pre> 
<p>view视图</p> 
<pre><code class="language-python">import json
import smtplib
from email.mime.text import MIMEText

import yaml
from dateutil import parser
from django.http import HttpResponse
from webhook.models import alerts as alerts_t, alarmuser
from webhook.models import production
import datetime
from jinja2 import Environment, FileSystemLoader


# 获取html目录
class ParseingTemplate:
    def __init__(self, templatefile):
        self.templatefile = templatefile

    def template(self, **kwargs):
        try:
            env = Environment(loader=FileSystemLoader('templates'))
            template = env.get_template(self.templatefile)
            template_content = template.render(kwargs)
            return template_content
        except Exception as error:
            raise error


# 时区转换（增加八个小时）
def time_zone_conversion(utctime):
    format_time = parser.parse(utctime).strftime('%Y-%m-%dT%H:%M:%SZ')
    time_format = datetime.datetime.strptime(format_time, "%Y-%m-%dT%H:%M:%SZ")
    return str(time_format + datetime.timedelta(hours=8))


# 获取告警人的分组和邮件
def get_email(email_name=None, action=0):
    """
    :param email_name: 发送的邮件列表名
    :param action: 操作类型，0: 查询收件人的邮件地址列表, 1: 查询收件人的列表名称, 2: 获取邮件账号信息
    :return: 根据action的值，返回不通的数据结构
    """
    if action == 0:
        email = alarmuser.objects.filter(group=email_name)
        email_lsit = []
        for i in email:
            email_lsit.append(i.useremail)
        print('显示邮件', email_lsit)
        return email_lsit
    elif action == 1:
        group_list = []
        group = alarmuser.objects.values("group").distinct()
        for i in group:
            group_list.append(i['group'])
        print('显示组:', group_list)


# 获取邮件的地址的配置
def get_email_conf(file, email_name=None, action=0):
    """
    :param file: yaml格式的文件类型
    :param email_name: 发送的邮件列表名
    :param action: 操作类型，0: 查询收件人的邮件地址列表, 1: 查询收件人的列表名称, 2: 获取邮件账号信息
    :return: 根据action的值，返回不通的数据结构
    """
    try:
        with open(file, 'r', encoding='utf-8') as fr:
            read_conf = yaml.safe_load(fr)
            if action == 0:
                for email in read_conf['email']:
                    if email['name'] == email_name:
                        return email['receive_addr']
                    else:
                        print("%s does not match for %s" % (email_name, file))
                else:
                    print("No recipient address configured")
            elif action == 1:
                return [items['name'] for items in read_conf['email']]
            elif action == 2:
                return read_conf['send']
    except KeyError:
        print("%s not exist" % email_name)
        exit(-1)
    except FileNotFoundError:
        print("%s file not found" % file)
        exit(-2)
    except Exception as e:
        raise e


# 发送邮件地址
def sendEmail(title, content, receivers=None):
    if receivers is None:
        receivers = ['chenf-o@glodon.com']
    send_dict = get_email_conf('email.yaml', action=2)
    mail_host = send_dict['smtp_host']
    mail_user = send_dict['send_user']
    mail_pass = send_dict['send_pass']
    sender = send_dict['send_addr']
    print(mail_host, mail_user, mail_pass, sender)
    msg = MIMEText(content, 'html', 'utf-8')
    msg['From'] = "{}".format(sender)
    msg['To'] = ",".join(receivers)
    print(receivers)
    print(msg['To'])
    msg['Subject'] = title
    try:
        smtpObj = smtplib.SMTP_SSL(mail_host, 465)
        smtpObj.login(mail_user, mail_pass)
        smtpObj.sendmail(sender, receivers, msg.as_string())
        print('mail send successful.')
    except smtplib.SMTPException as e:
        print(e)


# 先保存，后发邮件
def webhook(request):
    if request.method == "GET":
        # email = get_email(action=1)
        return HttpResponse('禁止get')
    if request.method == 'POST':
        try:
            request_data = request.body
            print(request_data.decode())
            request_dict = json.loads(request_data.decode('utf-8'))
            alerts = request_dict['alerts']

            prometheus_data = json.loads(request.body)

            for i in alerts:
                msg = i['annotations']['message'] if 'message' in i['annotations'] else 'null'
                if msg == 'null' and 'summary' in i['annotations']:
                    msg = i['annotations']['summary']
                print(i['startsAt'][0:19] + i['status'] + " :" + msg)
                if msg == 'null': print(i)
                ints = i['labels']['instance'] if 'instance' in i['labels'] else 'unknown'

                print(ints + " --- " + i['labels']['alertname'] + " ---- " + i['labels']['severity'])
                print(i['endsAt'])
                a = alerts_t()
                a.startsAt = time_zone_conversion(i['startsAt'])
                str = '0001-01-01'
                print(str in i['endsAt'])
                if (str in i['endsAt']):
                    a.endsAt = '0001-01-01 00:00:00'
                else:
                    a.endsAt = time_zone_conversion(i['endsAt'])
                print(a.endsAt)
                a.instance = ints
                a.alertname = i['labels']['alertname']
                if i['status'] == 'firing':
                    a.status = '告警中'
                if i['status'] == 'resolved':
                    a.status = '已恢复'
                    a.known = True
                a.severity = i['labels']['severity']
                a.message = msg
                a.save()

                startime = time_zone_conversion(i['startsAt'])
                endtime = a.endsAt
                instances = ints
                AlarmObject = production.objects.filter(startsAt=startime, endsAt=endtime, instance=instances)
                print(AlarmObject)
                if AlarmObject.exists():
                    pass
                else:
                    b = production()
                    b.startsAt = time_zone_conversion(i['startsAt'])
                    # print(str in i['endsAt'])
                    if (str in i['endsAt']):
                        b.endsAt = '0001-01-01 00:00:00'
                    else:
                        b.endsAt = time_zone_conversion(i['endsAt'])
                    # print(b.endsAt)
                    b.instance = ints
                    b.alertname = i['labels']['alertname']
                    if i['status'] == 'firing':
                        b.status = '告警中'
                    if i['status'] == 'resolved':
                        b.status = '已恢复'
                        b.known = True
                    b.severity = i['labels']['severity']
                    b.message = msg
                    b.save()
                print('显示a:', a)
                # 时间转换，转换成东八区时间
            for k, v in prometheus_data.items():
                if k == 'alerts':
                    for items in v:
                        if items['status'] == 'firing':
                            items['startsAt'] = time_zone_conversion(items['startsAt'])
                        else:
                            items['startsAt'] = time_zone_conversion(items['startsAt'])
                            items['endsAt'] = time_zone_conversion(items['endsAt'])
            print(prometheus_data)
            team_name = prometheus_data["commonLabels"]["team"]
            print(team_name)
            generate_html_template_subj = ParseingTemplate('email_template_firing.html')
            html_template_content = generate_html_template_subj.template(
                prometheus_monitor_info=prometheus_data
            )
            # 获取收件人邮件列表
            email_list = get_email(email_name=team_name, action=0)
            print(email_list)
            print(prometheus_data['commonLabels']['alertname'])
            sendEmail(
                prometheus_data['commonLabels']['alertname'],
                html_template_content,
                receivers=email_list
            )
            # return "prometheus monitor"
            return HttpResponse(1)
        except Exception as e:
            print(e)
            raise e
        # finally:
        #     return HttpResponse(1)
</code></pre> 
<p>需要完整代码，请留言</p> 
<p>稍后整理完毕传到github上</p>
                ]]></description></item><item><title>Django admin极简美化</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295734.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295734.html</guid><description><![CDATA[
                    <h1></h1> 
<p>1.Admin组件使用</p> 
<p>　　Django内集成了web管理工具，Django在启动过程中会执行setting.py文件，初始化Django内置组件、注册APP、添加环境变量等</p> 
<h2><strong>极简美化</strong></h2> 
<p><strong>效果图</strong></p> 
<p><strong>登录页面</strong></p> 
<p><img alt="" height="494" src="https://img-blog.csdnimg.cn/20a4ac473af44d8587b65f007c67bdcb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1083"></p> 
<p></p> 
<p><strong>主页面</strong></p> 
<p><img alt="" height="789" src="https://img-blog.csdnimg.cn/9b631272724348e4b0e3cf14626c7b2c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>使用django-simpleui模块；</p> 
<p>直接pip安装即可：</p> 
<pre><code class="language-python">pip install django-simpleui</code></pre> 
<p>然后在setting.py中注册即可：</p> 
<pre><code class="language-python">INSTALLED_APPS = [
    'simpleui', #主要是这个美化页面的
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog.apps.BlogConfig',  # 注册app应用
    'DjangoUeditor',  # 注册APP应用
]</code></pre> 
<p>然后就完事了，打开admin即可，如下：</p> 
<p><img alt="" height="631" src="https://img-blog.csdnimg.cn/deac3cc0e43341999409c0ad79f7dc96.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1130"></p> 
<p>&nbsp;<img alt="" height="907" src="https://img-blog.csdnimg.cn/bde8460124fd47bd839c0841a1db421f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="727" src="https://img-blog.csdnimg.cn/179ce877005d497da40af113370ceb60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Zabbix的API批量添加，删除主机（生产实战）</title><link>http://www.cnblogs.com/heian99/archive/2022/05/21/16295735.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 21 May 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/05/21/16295735.html</guid><description><![CDATA[
                    <h1><strong>场景：</strong></h1> 
<p>公司业务变更，部分机器需要变更，下线重新调整相关的业务。</p> 
<p>我们机器上有zabbix和prometheus监控，下线需要清空这些监控。</p> 
<p>prometheus比较监控，可以直接使用consul自动注册。</p> 
<p>zabbix 删除下线就很麻烦。一台就可以手动删除，但是上百台那，一个个手动吗，很麻烦的。</p> 
<p></p> 
<p><img alt="" height="374" src="https://img-blog.csdnimg.cn/5c5d840479354526b422f02688b48c41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="865"></p> 
<p>&nbsp;<img alt="" height="581" src="https://img-blog.csdnimg.cn/9445ceb49f6941099cd8edd4b26a108f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>所以直接考虑zabbix的APi来批量删除主机</p> 
<h2>介绍</h2> 
<p><strong>代码放在下方</strong></p> 
<p>代码使用的是python2.0的</p> 
<p>因为我是纯内网环境需要先在外网部署好环境 ，然后打包使用的。</p> 
<pre><code class="language-bash">Python3虚拟环境创建

/usr/local/python3/bin/python3.7 -m venv py3

加载虚拟环境

source py3/bin/activate


安装依赖

pip install -r requirements.txt


生成依赖

pip freeze &gt; requirements.txt


python2 虚拟环境
1.安装virtualenv

pip install virtualenv

2.创建虚拟环境

virtualenv 虚拟环境名称 

3.激活虚拟环境

source 虚拟环境目录/bin/activate  （./虚拟环境目录/bin/activate）

4.退出虚拟环境

deactivate</code></pre> 
<p>我们采用python2.0创建虚拟环境</p> 
<pre><code>[root@zabbix zabbix]# virtualenv py2

[root@zabbix zabbix]# ls
py2  zbx_tool.py
[root@zabbix zabbix]# source py2/
bin/        .gitignore  include/    lib/        lib64/      pyvenv.cfg  
             python            wheel2            
[root@zabbix zabbix]# source py2/bin/activate
(py2) [root@zabbix zabbix]# ls
py2  zbx_tool.py
(py2) [root@zabbix zabbix]# pip install argparse
.........
(py2) [root@zabbix zabbix]# ls
py2  zbx_tool.py
(py2) [root@zabbix zabbix]# python


打包 上传虚拟环境
tar -zcvf zabbix.tar.gz zabbix</code></pre> 
<p>上传内网环境进行解压，然后加载就可以使用虚拟环境</p> 
<pre><code class="language-bash"> source py2/bin/activate</code></pre> 
<h2>生产环境实战</h2> 
<h3>删除单台主机</h3> 
<p><img alt="" height="296" src="https://img-blog.csdnimg.cn/be61ea52b49f4ccc989186cb4f9bcf81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="865"></p> 
<h3>&nbsp;批量删除</h3> 
<p><img alt="" height="155" src="https://img-blog.csdnimg.cn/d96b8a218ab3462e99bc4746cbd9cac1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="865"></p> 
<h3>for循环删除</h3> 
<p>首先新建有一个文本，然后通过for 循环批量删除</p> 
<pre><code class="language-bash">for ip in `cat zabbixip`;do python zbx_tool.py --delete $ip ;done</code></pre> 
<p><img alt="" height="423" src="https://img-blog.csdnimg.cn/2fef6a30074e49108b088690a6253452.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="865"></p> 
<p><strong>&nbsp;开始</strong><img alt="" height="363" src="https://img-blog.csdnimg.cn/3a628a3e420746d286ab394da496eeaa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="850"></p> 
<p><strong>批量操作</strong></p> 
<p>&nbsp;<img alt="" height="445" src="https://img-blog.csdnimg.cn/7b2da7afbbf04244a011902ccc332c23.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="856"></p> 
<p>&nbsp;</p> 
<p></p> 
<h2><strong>代码</strong></h2> 
<p>集合脚本，包含查询主机，主机组，模板，添加开启禁用删除主机等功能</p> 
<pre><code class="language-python">#!/usr/bin/env python
#-*- coding: utf-8 -*-
 
import json
import sys
import urllib2
import argparse
 
from urllib2 import URLError
 
reload(sys)
sys.setdefaultencoding('utf-8')
 
class zabbix_api:
    def __init__(self):
        self.url = 'http://zabbix.xxx.com/api_jsonrpc.php'
        self.header = {"Content-Type":"application/json"}
 
 
    def user_login(self):
        data = json.dumps({
                           "jsonrpc": "2.0",
                           "method": "user.login",
                           "params": {
                                      "user": "admin",
                                      "password": "zabbix"
                                      },
                           "id": 0
                           })
 
        request = urllib2.Request(self.url, data)
 
        for key in self.header:
            request.add_header(key, self.header[key])
 
        try:
            result = urllib2.urlopen(request)
        except URLError as e:
            print "\033[041m 认证失败，请检查URL !\033[0m",e.code
        except KeyError as e:
            print "\033[041m 认证失败，请检查用户名密码 !\033[0m",e
        else:
            response = json.loads(result.read())
            result.close()
            #print response['result']
            self.authID = response['result']
            return self.authID
 
    def hostid_get_hostname(self, hostId=''):
        data = json.dumps({
            "jsonrpc": "2.0",
            "method": "host.get",
            "params": {
                "output": "extend",
                "filter": {"hostid": hostId}
            },
            "auth": self.user_login(),
            "id": 1
        })
        request = urllib2.Request(self.url, data)
        for key in self.header:
            request.add_header(key, self.header[key])
        try:
            result = urllib2.urlopen(request)
        except URLError as e:
            if hasattr(e, 'reason'):
                print 'We failed to reach a server.'
                print 'Reason: ', e.reason
            elif hasattr(e, 'code'):
                print 'The server could not fulfill the request.'
                print 'Error code: ', e.code
        else:
            response = json.loads(result.read())
            #print response
            result.close()
 
            if not len(response['result']):
                print "hostId is not exist"
                return False
 
            #print "主机数量: \33[31m%s\33[0m" % (len(response['result']))
            host_dict=dict()
            for host in response['result']:
                status = {"0": "OK", "1": "Disabled"}
                available = {"0": "Unknown", "1": "available", "2": "Unavailable"}
                #if len(hostId) == 0:
                #    print "HostID : %s\t HostName : %s\t Status :\33[32m%s\33[0m \t Available :\33[31m%s\33[0m" % (
                #        host['hostid'], host['name'], status[host['status']], available[host['available']])
                #else:
                #    print "HostID : %s\t HostName : %s\t Status :\33[32m%s\33[0m \t Available :\33[31m%s\33[0m" % (
                #        host['hostid'], host['name'], status[host['status']], available[host['available']])
                host_dict['name']=host['name']
                host_dict['status']=status[host['status']]
                host_dict['available']=available[host['available']]
                return host_dict
 
    def hostid_get_hostip(self, hostId=''):
        data = json.dumps({
            "jsonrpc": "2.0",
            "method": "hostinterface.get",
            "params": {
                "output": "extend",
                "filter": {"hostid": hostId}
            },
            "auth": self.user_login(),
            "id": 1
        })
        request = urllib2.Request(self.url, data)
        for key in self.header:
            request.add_header(key, self.header[key])
        try:
            result = urllib2.urlopen(request)
        except URLError as e:
            if hasattr(e, 'reason'):
                print 'We failed to reach a server.'
                print 'Reason: ', e.reason
            elif hasattr(e, 'code'):
                print 'The server could not fulfill the request.'
                print 'Error code: ', e.code
        else:
            response = json.loads(result.read())
            # print response
            result.close()
 
            if not len(response['result']):
                print "\033[041m hostid \033[0m is not exist"
                return False
 
            #print "主机数量: \33[31m%s\33[0m" % (len(response['result']))
            for hostip in response['result']:
                #print hostip
                #if len(hostip) == 0:
                #    print "HostID : %s\t HostIp : %s \t Port : %s " % (hostip['hostid'], hostip['ip'], hostip['port'])
                #else:
                #    print "HostID : %s\t HostIp :\33[32m%s\33[0m \t Port :\33[31m%s\33[0m" % (
                #        hostip['hostid'], hostip['ip'], hostip['port'])
                return hostip['ip']
 
    def host_get(self,hostName=''):
        data=json.dumps({
                "jsonrpc": "2.0",
                "method": "host.get",
                "params": {
                          "output": "extend",
                          #"filter":{"host":""}
                          "filter":{"host":hostName}
                          },
                "auth": self.user_login(),
                "id": 1
                })
        request = urllib2.Request(self.url,data)
        for key in self.header:
            request.add_header(key, self.header[key])
 
        try:
            result = urllib2.urlopen(request)
        except URLError as e:
            if hasattr(e, 'reason'):
                print 'We failed to reach a server.'
                print 'Reason: ', e.reason
            elif hasattr(e, 'code'):
                print 'The server could not fulfill the request.'
                print 'Error code: ', e.code
        else:
            response = json.loads(result.read())
            #print reqponse
            result.close()
 
            if not len(response['result']):
                print "\033[041m %s \033[0m is not exist" % hostName
                return False
 
            print "主机数量: \033[31m%s\033[0m"%(len(response['result']))
            for host in response['result']:
                status={"0":"OK","1":"Disabled"}
                available={"0":"Unknown","1":"available","2":"Unavailable"}
                #print host
                if len(hostName)==0:
                    print "HostID : %s\t HostName : %s\t HostIp : %s\t Status :%s \t Available :%s"%(host['hostid'],host['name'],self.hostid_get_hostip(hostId=host['hostid']),status[host['status']],available[host['available']])
                else:
                    print "HostID : %s\t HostName : %s\t HostIp : %s\t Status :\033[32m%s\033[0m \t Available :\033[31m%s\033[0m"%(host['hostid'],host['name'],self.hostid_get_hostip(hostId=host['hostid']),status[host['status']],available[host['available']])
                    return host['hostid']
 
    def hostip_get(self, hostIp=''):
        data = json.dumps({
            "jsonrpc": "2.0",
            "method": "hostinterface.get",
            "params": {
                "output": "extend",
                "filter": {"ip": hostIp}
            },
            "auth": self.user_login(),
            "id": 1
        })
        request = urllib2.Request(self.url, data)
        for key in self.header:
            request.add_header(key, self.header[key])
 
        try:
            result = urllib2.urlopen(request)
        except URLError as e:
            if hasattr(e, 'reason'):
                print 'We failed to reach a server.'
                print 'Reason: ', e.reason
            elif hasattr(e, 'code'):
                print 'The server could not fulfill the request.'
                print 'Error code: ', e.code
        else:
            response = json.loads(result.read())
            # print response
            result.close()
 
            if not len(response['result']):
                print "\033[041m hostip \033[0m is not exist"
                return False
 
            print "主机数量: \33[31m%s\33[0m" % (len(response['result']))
            for hostip in response['result']:
                host = self.hostid_get_hostname(hostip['hostid'])
                if len(hostip) == 0:
                    print "HostID : %s\t HostName : %s\t HostIp : %s\t Status :\33[32m%s\33[0m \t Available :\33[31m%s\33[0m"%(hostip['hostid'],host['name'],hostip['ip'],host['status'],host['available'])
                else:
                    print "HostID : %s\t HostName : %s\t HostIp : %s\t Status :\33[32m%s\33[0m \t Available :\33[31m%s\33[0m"%(hostip['hostid'],host['name'],hostip['ip'],host['status'],host['available'])
                    return hostip['hostid']
 
    def hostgroup_get(self, hostgroupName=''):
        data = json.dumps({
                           "jsonrpc":"2.0",
                           "method":"hostgroup.get",
                           "params":{
                                     "output": "extend",
                                     "filter": {
                                                "name": hostgroupName
                                                }
                                     },
                           "auth":self.user_login(),
                           "id":1,
                           })
 
        request = urllib2.Request(self.url,data)
        for key in self.header:
            request.add_header(key, self.header[key])
 
        try:
            result = urllib2.urlopen(request)
        except URLError as e:
            print "Error as ", e
        else:
            # result.read()
            response = json.loads(result.read())
            result.close()
            #print response()
            if not len(response['result']):
                print "\033[041m %s \033[0m is not exist" % hostgroupName
                return False
 
            for group in response['result']:
                if  len(hostgroupName)==0:
                    print "hostgroup:  \033[31m%s\033[0m \tgroupid : %s" %(group['name'],group['groupid'])
                else:
                    print "hostgroup:  \033[31m%s\033[0m\tgroupid : %s" %(group['name'],group['groupid'])
                    self.hostgroupID = group['groupid']
            return group['groupid']
 
    def template_get(self,templateName=''):
        data = json.dumps({
                           "jsonrpc":"2.0",
                           "method": "template.get",
                           "params": {
                                      "output": "extend",
                                      "filter": {
                                                 "name":templateName
                                                 }
                                      },
                           "auth":self.user_login(),
                           "id":1,
                           })
 
        request = urllib2.Request(self.url, data)
        for key in self.header:
            request.add_header(key, self.header[key])
 
        try:
            result = urllib2.urlopen(request)
        except URLError as e:
            print "Error as ", e
        else:
            response = json.loads(result.read())
            result.close()
            #print response
            if not len(response['result']):
                print "\033[041m %s \033[0m is not exist" % templateName
                return False
 
            for template in response['result']:
                if len(templateName)==0:
                    print "template : %s \t id : %s" % (template['name'], template['templateid'])
                else:
                    self.templateID = response['result'][0]['templateid']
                    print "Template Name :%s"%templateName
                    return response['result'][0]['templateid']
 
    def hostgroup_create(self,hostgroupName):
        if self.hostgroup_get(hostgroupName):
            print "hostgroup  \033[42m%s\033[0m is exist !" % hostgroupName
            sys.exit(1)
 
        data = json.dumps({
                          "jsonrpc": "2.0",
                          "method": "hostgroup.create",
                          "params": {
                          "name": hostgroupName
                          },
                          "auth": self.user_login(),
                          "id": 1
                          })
        request=urllib2.Request(self.url,data)
 
        for key in self.header:
            request.add_header(key, self.header[key])
 
        try:
            result = urllib2.urlopen(request)
        except URLError as e:
            print "Error as ", e
        else:
            response = json.loads(result.read())
            result.close()
            print "添加主机组:%s  hostgroupID : %s"%(hostgroupName,self.hostgroup_get(hostgroupName))
 
    def host_create(self, hostIp, hostgroupName, templateName, hostName):
        if self.host_get(hostName) or self.hostip_get(hostIp):
            print "该主机已经添加!"
            sys.exit(1)
 
        group_list=[]
        template_list=[]
        for i in hostgroupName.split(','):
            var = {}
            var['groupid'] = self.hostgroup_get(i)
            group_list.append(var)
        for i in templateName.split(','):
            var={}
            var['templateid']=self.template_get(i)
            template_list.append(var)
 
        data = json.dumps({
                           "jsonrpc":"2.0",
                           "method":"host.create",
                           "params":{
                                     "host": hostName,
                                     "interfaces": [
                                     {
                                     "type": 1,
                                     "main": 1,
                                     "useip": 1,
                                     "ip": hostIp,
                                     "dns": "",
                                     "port": "10050"
                                      }
                                     ],
                                   "groups": group_list,
                                   "templates": template_list,
                                     },
                           "auth": self.user_login(),
                           "id":1
        })
        request = urllib2.Request(self.url, data)
        for key in self.header:
            request.add_header(key, self.header[key])
 
        try:
            result = urllib2.urlopen(request)
            response = json.loads(result.read())
            result.close()
            print "add host : %s id :%s" % (hostIp, hostName)
        except URLError as e:
            print "Error as ", e
        except KeyError as e:
            print "\033[041m 主机添加有误，请检查模板正确性或主机是否添加重复 !\033[0m",e
            print response
 
    def host_disable(self,hostip):
        data=json.dumps({
                "jsonrpc": "2.0",
                "method": "host.update",
                "params": {
                "hostid": self.host_get(hostip),
                "status": 1
                },
                "auth": self.user_login(),
                "id": 1
                })
        request = urllib2.Request(self.url,data)
        #opener = urllib2.build_opener(urllib2.HTTPBasicAuthHandler(TerminalPassword()))
        for key in self.header:
                request.add_header(key, self.header[key])
        try:
            result = urllib2.urlopen(request)
            #result = opener.open(request)
        except URLError as e:
            print "Error as ", e
        else:
            response = json.loads(result.read())
            result.close()
            print '------------主机现在状态------------'
            print self.host_get(hostip)
 
    def host_enable(self,hostip):
        data=json.dumps({
            "jsonrpc": "2.0",
            "method": "host.update",
            "params": {
            "hostid": self.host_get(hostip),
            "status": 0
            },
            "auth": self.user_login(),
            "id": 1
            })
        request = urllib2.Request(self.url,data)
        for key in self.header:
            request.add_header(key, self.header[key])
        try:
            result = urllib2.urlopen(request)
            #result = opener.open(request)
        except URLError as e:
            print "Error as ", e
        else:
            response = json.loads(result.read())
            result.close()
            print '------------主机现在状态------------'
            print self.host_get(hostip)
 
    def host_delete(self,hostNames):
        hostid_list=[]
        for hostName in hostNames.split(','):
            hostid = self.host_get(hostName=hostName)
            if not hostid:
                print "主机 \033[041m %s\033[0m  删除失败 !" % hostName
                sys.exit()
            hostid_list.append(hostid)
 
        data=json.dumps({
                "jsonrpc": "2.0",
                "method": "host.delete",
                "params": hostid_list,
                "auth": self.user_login(),
                "id": 1
                })
 
        request = urllib2.Request(self.url,data)
        for key in self.header:
            request.add_header(key, self.header[key])
 
        try:
            result = urllib2.urlopen(request)
            result.close()
            print "主机 \033[041m %s\033[0m  已经删除 !" % hostName
        except Exception,e:
            print  e
 
if __name__ == "__main__":
    zabbix=zabbix_api()
    parser=argparse.ArgumentParser(description='zabbix api ',usage='%(prog)s [options]')
    parser.add_argument('-H','--host',nargs='?',dest='listhost',default='host',help='查询主机')
    parser.add_argument('-G','--group',nargs='?',dest='listgroup',default='group',help='查询主机组')
    parser.add_argument('-T','--template',nargs='?',dest='listtemp',default='template',help='查询模板信息')
    parser.add_argument('-A','--add-group',nargs=1,dest='addgroup',help='添加主机组')
    parser.add_argument('-C','--add-host',dest='addhost',nargs=4,metavar=('192.168.2.1', 'groupname', 'Template01,Template02', 'hostName'),help='添加主机,多个主机组或模板使用逗号')
    parser.add_argument('-d','--disable',dest='disablehost',nargs='+',metavar=('sh-aa-01'),help='禁用主机,填写主机名，多个主机名之间用逗号')
    parser.add_argument('-e','--enable',dest='enablehost',nargs=1,metavar=('sh-aa-01'),help='开启主机')
    parser.add_argument('-D','--delete',dest='deletehost',nargs='+',metavar=('sh-aa-01'),help='删除主机,多个主机之间用逗号')
    parser.add_argument('-v','--version', action='version', version='%(prog)s 1.0')
 
    if len(sys.argv) == 1:
        #print parser.print_help()
        #print zabbix.host_get(hostName='bbb')
        #print zabbix.hostip_get(hostIp='127.0.0.1')
        #print zabbix.hostid_get_hostname(hostId='10108')
        #print zabbix.hostid_get_hostid(hostId='10105')
        #print zabbix.hostgroup_get(hostgroupName='Linux servers')
        #print zabbix.hostgroup_get(hostgroupName='aaa')
        # ...
        print zabbix.host_delete('hz-aaa-02')
    else:
        args = parser.parse_args()
        if args.listhost != 'host':
            if args.listhost:
                zabbix.host_get(args.listhost)
            else:
                zabbix.host_get()
        if args.listgroup != 'group':
            if args.listgroup:
                zabbix.hostgroup_get(args.listgroup)
            else:
                zabbix.hostgroup_get()
        if args.listtemp != 'template':
            if args.listtemp:
                zabbix.template_get(args.listtemp)
            else:
                zabbix.template_get()
        if args.addgroup:
            zabbix.hostgroup_create(args.addgroup[0])
        if args.addhost:
            zabbix.host_create(args.addhost[0], args.addhost[1], args.addhost[2], args.addhost[3])
        if args.disablehost:
            zabbix.host_disable(args.disablehost)
        if args.deletehost:
            zabbix.host_delete(args.deletehost[0])</code></pre> 
<h2><strong>用法</strong></h2> 
<pre><code class="language-bash">&gt; python zbx_tool.py -h
usage: zbx_tool.py [options]
 
zabbix api
 
optional arguments:
  -h, --help            show this help message and exit
  -H [LISTHOST], --host [LISTHOST]
                        查询主机
  -G [LISTGROUP], --group [LISTGROUP]
                        查询主机组
  -T [LISTTEMP], --template [LISTTEMP]
                        查询模板信息
  -A ADDGROUP, --add-group ADDGROUP
                        添加主机组
  -C 192.168.2.1 groupname Template01,Template02 hostName, --add-host 192.168.2.1 groupname Template01,Template02 hostName
                        添加主机,多个主机组或模板使用逗号
  -d sh-aa-01 [sh-aa-01 ...], --disable sh-aa-01 [sh-aa-01 ...]
                        禁用主机,填写主机名，多个主机名之间
                        ¨逗号
  -e sh-aa-01, --enable sh-aa-01
                        开启主机
  -D sh-aa-01 [sh-aa-01 ...], --delete sh-aa-01 [sh-aa-01 ...]
                        删除主机,多个主机之间用逗号
  -v, --version         show program's version number and exit</code></pre> 
<p style="text-align:center;">&nbsp;<img alt="" src="https://img-blog.csdnimg.cn/be5d546dac534f03a36ebf5ac083f565.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>&nbsp;</p> 
<p>相关博客</p> 
<p><a href="https://www.codeleading.com/article/3026664232/" title="利用zabbix API批量查询主机、模板、添加删除主机 - 代码先锋网">利用zabbix API批量查询主机、模板、添加删除主机 - 代码先锋网</a></p>
                ]]></description></item><item><title>Kubernetes高效收集生产日志</title><link>http://www.cnblogs.com/heian99/archive/2022/03/12/15998574.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 12 Mar 2022 13:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/03/12/15998574.html</guid><description><![CDATA[
                    <ul id="ul-bys-gkb-wdb"><li>容器本身特性： 
  <ul id="ul-cys-gkb-wdb"><li>采集目标多：容器本身的特性导致采集目标多，需要采集容器内日志、容器 stdout。对于容器内部的文件日志采集，现在并没有一个很好的工具能够去动态发现采集。针对每种数据源都有对应的采集软件，但缺乏一站式的工具。</li><li>弹性伸缩难：kubernetes 是分布式的集群，服务、环境的弹性伸缩对于日志采集带来了很大的困难，无法像传统虚拟机环境下那样，事先配置好日志的采集路径等信息，采集的动态性以及数据完整性是非常大的挑战。</li></ul></li><li>现有日志工具的一些缺陷： 
  <ul id="ul-dys-gkb-wdb"><li>缺乏动态配置的能力。目前的采集工具都需要事先手动配置好日志采集方式和路径等信息，因为它无法能够自动感知到容器的生命周期变化或者动态漂移，所以它无法动态地去配置。</li><li>日志采集重复或丢失的问题。因为现在的一些采集工具基本上是通过 tail 的方式来进行日志采集的，那么这里就可能存在两个方面的问题：一个是可能导致日志丢失，比如采集工具在重启的过程中，而应用依然在写日志，那么就有可能导致这个窗口期的日志丢失；而对于这种情况一般保守的做法就是，默认往前多采集 1M 日志或 2M 的日志，那么这就又会可能引起日志采集重复的问题。</li><li>未明确标记日志源。因为一个应用可能有很多个容器，输出的应用日志也是一样的，那么当我们将所有应用日志收集到统一日志存储后端时，在搜索日志的时候，我们就无法明确这条日志具体是哪一个节点上的哪一个应用容器产生的。</li></ul></li></ul>
<p>本文档将介绍一种 Docker 日志收集工具 log-pilot，结合 Elasticsearch 和 kibana 等工具，形成一套适用于 kubernetes 环境下的一站式日志解决方案。</p> 
<p><a class="has-card" href="https://github.com/AliyunContainerService/log-pilot" title="GitHub - AliyunContainerService/log-pilot: Collect logs for docker containers"><span class="link-card-box"><span class="link-title">GitHub - AliyunContainerService/log-pilot: Collect logs for docker containers</span><span class="link-desc">Collect logs for docker containers. Contribute to AliyunContainerService/log-pilot development by creating an account on GitHub.</span><span class="link-link"><img alt="" class="link-link-icon" src="https://github.com/fluidicon.png">https://github.com/AliyunContainerService/log-pilot</span></span></a><a class="has-card" href="https://developer.aliyun.com/article/674327" title="容器日志采集利器Log-Pilot-阿里云开发者社区"><span class="link-card-box"><span class="link-title">容器日志采集利器Log-Pilot-阿里云开发者社区</span><span class="link-desc">容器时代越来越多的传统应用将会逐渐容器化，而日志又是应用的一个关键环节，那么在应用容器化过程中，如何方便快捷高效地来自动发现和采集应用的日志，如何与日志存储系统协同来高效存储和搜索应用日志，本文将主要跟大家分享下如何通过Log-Pilot来采集容器的标准输出日志和容器内文件日志。</span><span class="link-link"><img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" alt="icon-default.png?t=M276">https://developer.aliyun.com/article/674327</span></span></a></p> 
<p>Log-Pilot 支持容器事件管理，它能够动态地监听容器的事件变化，然后依据容器的标签来进行解析，生成日志采集配置文件，然后交由采集插件来进行日志采集。</p> 
<p>相关特点和优势，可以点击上方的链接学习。</p> 
<h1 id="%E6%96%B9%E6%A1%88">方案</h1> 
<p>从日志的采集方式上，在我看来方案大致主要分为两种：</p> 
<p>**（1）POD 里面安装logging agent**</p> 
<p>每个pod里面都要安装一个agent，无论是以放在本container还是以sidecar的方式部署，很明显会占用很多资源，基本不推荐</p> 
<p>**（2）在节点上安装logging agent（推荐）**</p> 
<p>其实容器stdout,stderr的日志最终也是落在<a href="https://cloud.tencent.com/product/cdh?from=10680" title="宿主机">宿主机</a>上，而容器内的路径可以通过配置volumeMount 在宿主机上配置映射即可，所以这种方式还是最可行的</p> 
<blockquote> 
 <p>当然应用还可以自己通过代码直接上报给日志服务，但是这种方式不够通用，还增加了业务代码的复杂性</p> 
</blockquote> 
<p><strong>log-Pilot</strong>是一个智能容器日志采集工具，它不仅能够高效便捷地将容器日志采集输出到多种存储日志后端，同时还能够动态地发现和采集容器内部的日志文件，更多咨询可以移步<a href="https://yq.aliyun.com/articles/674327" title="这里">这里</a>。</p> 
<p>log-Pilot目前支持两种工具对日志进行收集，<a href="https://github.com/AliyunContainerService/log-pilot/blob/master/docs/fluentd/docs.md" title="Fluentd Plugin">Fluentd Plugin</a>&nbsp;和&nbsp;<a href="https://github.com/AliyunContainerService/log-pilot/blob/master/docs/filebeat/docs.md" title="Filebeat Plugin">Filebeat Plugin</a>。<br><br><br> Log-Pilot支持容器事件管理，它能够动态地监听容器的事件变化，然后依据容器的标签来进行解析，生成日志采集配置文件，然后交由采集插件来进行日志采集</p> 
<p></p> 
<p>以下的的安装配置，是基于上一篇的EFK的配置，只是修改收集端（有必要，可以了解上一篇的文章）</p> 
<p><a href="https://blog.csdn.net/heian_99/article/details/123405383?spm=1001.2014.3001.5501" title="Kubernetes安装EFK日志收集_南宫乘风-Linux运维-虚拟化容器-Python编程     ownit.top-CSDN博客">Kubernetes安装EFK日志收集_南宫乘风-Linux运维-虚拟化容器-Python编程 ownit.top-CSDN博客</a></p> 
<p></p> 
<h1>准备</h1> 
<p>参考官方<a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/fluentd-elasticsearch" title="部署文档">部署文档</a>的基础上使用本项目<code>manifests/efk/</code>部署，以下为几点主要的修改：</p> 
<ul><li><strong>增加</strong>&nbsp;<strong>log-Pilot 部署代码（解决 不支持 es7.0 版本以上的痛点）</strong></li><li>修改官方docker镜像，方便国内下载加速</li><li>修改 es-statefulset.yaml 支持日志存储持久化等</li><li>增加自动清理日志</li></ul>
<p></p> 
<h1 id="创建-elasticsearch-集群">创建 Elasticsearch 集群</h1> 
<pre><code class="language-bash">apiVersion: v1
kind: Namespace
metadata:
  name: logging</code></pre> 
<h2><a name="t2"></a>1、&nbsp;es-service.yaml</h2> 
<pre><code class="language-bash">kind: Service
apiVersion: v1
metadata:
  name: elasticsearch
  namespace: logging
  labels:
    app: elasticsearch
spec:
  selector:
    app: elasticsearch
  clusterIP: None
  ports:
    - port: 9200
      name: rest
    - port: 9300
      name: inter-node</code></pre> 
<p>定义了一个名为 elasticsearch 的 Service，指定标签&nbsp;<code>app=elasticsearch</code>，当我们将 Elasticsearch StatefulSet 与此服务关联时，服务将返回带有标签&nbsp;<code>app=elasticsearch</code>的 Elasticsearch Pods 的 DNS A 记录，然后设置&nbsp;<code>clusterIP=None</code>，将该服务设置成无头服务。最后，我们分别定义端口9200、9300，分别用于与 REST API 交互，以及用于节点间通信。&nbsp;</p> 
<pre><code class="language-bash">[root@master01 efk]# kubectl apply -f es-service.yaml
service/elasticsearch-logging created
[root@master01 efk]# kubectl get svc -n kube-system 
NAME                    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
elasticsearch-logging   ClusterIP   None            &lt;none&gt;        9200/TCP                     15s</code></pre> 
<h2><a name="t3"></a>es-statefulset.yaml</h2> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: es
  namespace: logging
spec:
  serviceName: elasticsearch
  replicas: 3
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels: 
        app: elasticsearch
    spec:
      nodeSelector:  #记得给节点把标签，不然会找到不符合的节点
        es: log
      initContainers:
      - name: increase-vm-max-map
        image: busybox
        command: ["sysctl", "-w", "vm.max_map_count=262144"]
        securityContext:
          privileged: true
      - name: increase-fd-ulimit
        image: busybox
        command: ["sh", "-c", "ulimit -n 65536"]
        securityContext:
          privileged: true
      containers:
      - name: elasticsearch
        image: docker.elastic.co/elasticsearch/elasticsearch:7.6.2
        ports:
        - name: rest
          containerPort: 9200
        - name: inter
          containerPort: 9300
        resources:
          limits:
            cpu: 1000m
          requests:
            cpu: 1000m
        volumeMounts:
        - name: data
          mountPath: /usr/share/elasticsearch/data
        env:
        - name: cluster.name
          value: k8s-logs
        - name: node.name
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: cluster.initial_master_nodes
          value: "es-0,es-1,es-2"
        - name: discovery.zen.minimum_master_nodes
          value: "2"
        - name: discovery.seed_hosts
          value: "elasticsearch"
        - name: ES_JAVA_OPTS
          value: "-Xms512m -Xmx512m"
        - name: network.host
          value: "0.0.0.0"
  volumeClaimTemplates:
  - metadata:
      name: data
      labels:
        app: elasticsearch
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: nfsdata
      resources:
        requests:
          storage: 5Gi </code></pre> 
<p><img alt="" height="252" src="https://img-blog.csdnimg.cn/ea6bebb226ff4569a5b5793743149eaa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1125"></p> 
<p>&nbsp;Pods 部署完成后，我们可以通过请求一个 REST API 来检查 Elasticsearch 集群是否正常运行。使用下面的命令将本地端口9200 转发到 Elasticsearch 节点（如es-0）对应的端口：</p> 
<pre><code class="language-bash">[root@master01 new]# kubectl port-forward es-0 9200:9200 --namespace=logging
Forwarding from 127.0.0.1:9200 -&gt; 9200
Forwarding from [::1]:9200 -&gt; 9200</code></pre> 
<pre><code>curl http://localhost:9200/_cluster/state?pretty</code></pre> 
<p></p> 
<p><img alt="" height="746" src="https://img-blog.csdnimg.cn/be8ab8d757834cdda7cd3dc3ed0e3a38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="926"></p> 
<p>&nbsp;看到上面的信息就表明我们名为 k8s-logs 的 Elasticsearch 集群成功创建了3个节点：es-0，es-1，和es-2，当前主节点是 es-0</p> 
<h1 id="创建-kibana-服务"><a name="t4"></a>创建 Kibana 服务</h1> 
<p>Elasticsearch 集群启动成功了，接下来我们可以来部署 Kibana 服务，新建一个名为 kibana.yaml 的文件，对应的文件内容如下：</p> 
<h2><a name="t5"></a>kibana.yaml&nbsp;</h2> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: kibana
  namespace: logging
  labels:
    app: kibana
spec:
  ports:
  - port: 5601
  type: NodePort
  selector:
    app: kibana
 
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kibana
  namespace: logging
  labels:
    app: kibana
spec:
  selector:
    matchLabels:
      app: kibana
  template:
    metadata:
      labels:
        app: kibana
    spec:
      nodeSelector:
        es: log
      containers:
      - name: kibana
        image: docker.elastic.co/kibana/kibana:7.6.2
        resources:
          limits:
            cpu: 1000m
          requests:
            cpu: 1000m
        env:
        - name: ELASTICSEARCH_HOSTS
          value: http://elasticsearch:9200
        ports:
        - containerPort: 5601</code></pre> 
<p>上面我们定义了两个资源对象，一个 Service 和 Deployment，为了测试方便，我们将 Service 设置为了 NodePort 类型，Kibana Pod 中配置都比较简单，唯一需要注意的是我们使用&nbsp;<code>ELASTICSEARCH_HOSTS</code>&nbsp;这个环境变量来设置Elasticsearch 集群的端点和端口，直接使用 Kubernetes DNS 即可，此端点对应服务名称为 elasticsearch，由于是一个 headless service，所以该域将解析为3个 Elasticsearch Pod 的 IP 地址列表。&nbsp;配置完成后，直接使用 kubectl 工具创建：</p> 
<pre><code class="language-bash">kubectl create -f kibana.yaml
service/kibana created
deployment.apps/kibana created</code></pre> 
<p>创建完成后，可以查看 Kibana Pod 的运行状态</p> 
<pre><code class="language-bash">[root@master01 new]#  kubectl get pods --namespace=logging
NAME                      READY   STATUS    RESTARTS   AGE
es-0                      1/1     Running   0          13m
es-1                      1/1     Running   0          9m48s
es-2                      1/1     Running   0          7m46s
kibana-8476dc9bbf-6mm6k   1/1     Running   0          3m2s</code></pre> 
<p>如果 Pod 已经是 Running 状态了，证明应用已经部署成功了，然后可以通过 NodePort 来访问 Kibana 这个服务，在浏览器中打开<code>http://&lt;任意节点IP&gt;:31838</code>即可，</p> 
<p>出现 这个代表成功</p> 
<p><img alt="" height="773" src="https://img-blog.csdnimg.cn/9631236c38634351822510057c521ba3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<h1 id="部署-fluentd"><a name="t6"></a>部署 <strong>log-Pilot</strong></h1> 
<p>Log-pilot是一个智能容器日志采集工具，它不仅能够高效便捷地将容器日志采集输出到多种存储日志后端，同时还能够动态地发现和采集容器内部的日志文件。</p> 
<p>针对前面提出的日志采集难题，Log-pilot通过声明式配置实现强大的容器事件管理，可同时获取容器标准输出和内部文件日志，解决了动态伸缩问题，此外，Log-pilot具有自动发现机制、CheckPoint及句柄保持的机制、自动日志数据打标、有效应对动态配置、日志重复和丢失以及日志源标记等问题。</p> 
<p>本质</p> 
<p>通过变量和模版文件生产日志收集配置文件，对日志进行采集。<br> 容器内文件日志路径需要配置emptyDir</p> 
<h2>log-pilot.yaml</h2> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: log-pilot
  labels:
    app: log-pilot
  # 设置期望部署的namespace。
  namespace: logging
spec:
  selector:
    matchLabels:
      app: log-pilot
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: log-pilot
      annotations:
        scheduler.alpha.kubernetes.io/critical-pod: ''
    spec:
      # 是否允许部署到Master节点上tolerations。
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
      containers:
      - name: log-pilot
        # 版本请参考https://github.com/AliyunContainerService/log-pilot/releases。
        image: heleicool/log-pilot:7.x-filebeat
        resources:
          limits:
            memory: 500Mi
          requests:
            cpu: 200m
            memory: 200Mi
        env:
          - name: "NODE_NAME"
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
          - name: "LOGGING_OUTPUT"
            value: "elasticsearch"
          # 请确保集群到ES网络可达。
          - name: "ELASTICSEARCH_HOSTS"
            value: "elasticsearch:9200"
          # 配置ES访问权限。
         # - name: "ELASTICSEARCH_USER"
        #    value: "{es_username}"
         # - name: "ELASTICSEARCH_PASSWORD"
         #   value: "{es_password}"
        volumeMounts:
        - name: sock
          mountPath: /var/run/docker.sock
        - name: root
          mountPath: /host
          readOnly: true
        - name: varlib
          mountPath: /var/lib/filebeat
        - name: varlog
          mountPath: /var/log/filebeat
        - name: localtime
          mountPath: /etc/localtime
          readOnly: true
        livenessProbe:
          failureThreshold: 3
          exec:
            command:
            - /pilot/healthz
          initialDelaySeconds: 10
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 2
        securityContext:
          capabilities:
            add:
            - SYS_ADMIN
      terminationGracePeriodSeconds: 30
      volumes:
      - name: sock
        hostPath:
          path: /var/run/docker.sock
      - name: root
        hostPath:
          path: /
      - name: varlib
        hostPath:
          path: /var/lib/filebeat
          type: DirectoryOrCreate
      - name: varlog
        hostPath:
          path: /var/log/filebeat
          type: DirectoryOrCreate
      - name: localtime
        hostPath:
          path: /etc/localtime
</code></pre> 
<p>默认阿里云仓库只支持7.x以下版本es的数据写入，使用如下插件可以实现。<br> git地址：https://<a href="https://so.csdn.net/so/search?q=github&amp;spm=1001.2101.3001.7020" title="github">github</a>.com/40kuai/log-pilot/tree/filebeat7.x<br> dockerhub：heleicool/log-pilot:7.x-filebeat</p> 
<p><img alt="" height="276" src="https://img-blog.csdnimg.cn/edbed7a4e717446f90285410123ca994.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_18,color_FFFFFF,t_70,g_se,x_16" width="536"></p> 
<h1>服务日志采集</h1> 
<p>创建一个标准的 Nginx 服务, 主要是 env 添加了两种,上面我们介绍过</p> 
<p>一 是 基于 docker stdout 输出日志 (aliyun_logs_catalina)</p> 
<p>二 是 基于 程序指定输出到指定的目录中 (aliyun_logs_access)</p> 
<p>( elasticsearch )环境变量中的 name表示Index，这里name 表示 Index，这里 name表示Index，这里name 即是 catalina 和 access, 这里用于 Kibana 查询日志</p> 
<h2>&nbsp;nginx.yaml</h2> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment 
metadata: 
  name: nginx-dm
spec: 
  replicas: 3
  selector:
    matchLabels:
      name: nginx
  template: 
    metadata: 
      labels: 
        name: nginx 
    spec: 
      tolerations:
        - key: "node-role.kubernetes.io/master"
          effect: "NoSchedule"
      containers: 
        - name: nginx 
          image: nginx:alpine 
          imagePullPolicy: IfNotPresent
          env:
           - name: aliyun_logs_nginx-log
             value: "stdout"
           - name: aliyun_logs_access
             value: "/var/log/nginx/*.log"
          ports:
            - containerPort: 80
              name: http
---
apiVersion: v1 
kind: Service
metadata: 
  name: nginx-svc 
spec: 
  ports: 
    - port: 80
      name: http
      targetPort: 80
      protocol: TCP 
  selector: 
    name: nginx
</code></pre> 
<p>&nbsp;</p> 
<p><img alt="" height="344" src="https://img-blog.csdnimg.cn/5938c75a67e6431a80d2011f1a285334.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="653"></p> 
<p><img alt="" height="158" src="https://img-blog.csdnimg.cn/b844431d60b440909f12fb4c68000c4f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1012"></p> 
<p>&nbsp;<img alt="" height="810" src="https://img-blog.csdnimg.cn/c72e1f67ca834b2890d9b0225dfe2494.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p> 
<p></p> 
<h3>pod.yaml</h3> 
<pre><code class="language-bash">[root@master01 new]# cat pod2.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: counter
  namespace: logging  #可以添加空间名称，也会收集到的
spec:
  containers:
  - name: count
    image: busybox
    args: [/bin/sh, -c,
            'i=0; while true; do echo "$i: $(date)"; i=$((i+1)); sleep 1; done']
    env:
    # 1、stdout为约定关键字，表示采集标准输出日志。
    # 2、配置标准输出日志采集到ES的catalina索引下。
    - name: aliyun_logs_catalina
      value: "stdout"
    # 1、配置采集容器内文件日志，支持通配符。
    # 2、配置该日志采集到ES的access索引下。
</code></pre> 
<h3>tomcat.yaml</h3> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: tomcat
spec:
  containers:
  - name: tomcat
    image: "tomcat:7.0"
    env:
    # 1、stdout为约定关键字，表示采集标准输出日志。
    # 2、配置标准输出日志采集到ES的catalina索引下。
    - name: aliyun_logs_catalina
      value: "stdout"
    # 1、配置采集容器内文件日志，支持通配符。
    # 2、配置该日志采集到ES的access索引下。
    - name: aliyun_logs_access
      value: "/usr/local/tomcat/logs/catalina.*.log"
    # 容器内文件日志路径需要配置emptyDir。
    volumeMounts:
      - name: tomcat-log
        mountPath: /usr/local/tomcat/logs
  volumes:
    - name: tomcat-log
      emptyDir: {}
</code></pre> 
<p>&nbsp;<a href="https://www.cnblogs.com/lixinliang/p/14519118.html" title="k8s 部署 log-pilot 收集容器标准输出日志和指定路径应用日志 - lixinliang - 博客园">k8s 部署 log-pilot 收集容器标准输出日志和指定路径应用日志 - lixinliang - 博客园</a></p>
                ]]></description></item><item><title>Kubernetes安装EFK日志收集</title><link>http://www.cnblogs.com/heian99/archive/2022/03/12/15998575.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 12 Mar 2022 13:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/03/12/15998575.html</guid><description><![CDATA[
                    <p>Kubernetes 中比较流行的日志收集解决方案是&nbsp;<code>Elasticsearch</code>、<code>Fluentd</code>&nbsp;和&nbsp;<code>Kibana</code>（EFK）技术栈，也是官方现在比较推荐的一种方案。</p> 
<p>后续我会更新使用<a href="https://github.com/easzlab/kubeasz/blob/master/docs/guide/log-pilot.md" title="Log-Pilot + ES + Kibana 日志方案">Log-Pilot + ES + Kibana 日志方案</a></p> 
<p><code>Elasticsearch</code>&nbsp;是一个实时的、分布式的可扩展的搜索引擎，允许进行全文、结构化搜索，它通常用于索引和搜索大量日志数据，也可用于搜索许多不同类型的文档。</p> 
<p>Elasticsearch 通常与&nbsp;<code>Kibana</code>&nbsp;一起部署，Kibana 是 Elasticsearch 的一个功能强大的数据可视化 Dashboard，Kibana 允许你通过 web 界面来浏览 Elasticsearch 日志数据。</p> 
<p><code>Fluentd</code>是一个流行的开源数据收集器，我们将在 Kubernetes 集群节点上安装 Fluentd，通过获取容器日志文件、过滤和转换日志数据，然后将数据传递到 Elasticsearch 集群，在该集群中对其进行索引和存储。</p> 
<p>我们先来配置启动一个可扩展的 Elasticsearch 集群，然后在 Kubernetes 集群中创建一个 Kibana 应用，最后通过 DaemonSet 来运行 Fluentd，以便它在每个 Kubernetes 工作节点上都可以运行一个 Pod。</p> 
<p></p> 
<p>官方文档：<br><br><a href="https://github.com/kubernetes/kubernetes/tree/release-1.22/cluster/addons/fluentd-elasticsearch" title="https://github.com/kubernetes/kubernetes/tree/release-1.22/cluster/addons/fluentd-elasticsearch">https://github.com/kubernetes/kubernetes/tree/release-1.22/cluster/addons/fluentd-elasticsearch</a></p> 
<h1>准备</h1> 
<p>参考官方<a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/fluentd-elasticsearch" title="部署文档">部署文档</a>的基础上使用本项目<code>manifests/efk/</code>部署，以下为几点主要的修改：</p> 
<ul><li>修改 fluentd-es-configmap.yaml 中的部分 journald 日志源（增加集群组件服务日志搜集）</li><li>修改官方docker镜像，方便国内下载加速</li><li>修改 es-statefulset.yaml 支持日志存储持久化等</li><li>增加自动清理日志</li></ul>
<p></p> 
<h1 id="创建-elasticsearch-集群">创建 Elasticsearch 集群</h1> 
<pre><code class="language-bash">apiVersion: v1
kind: Namespace
metadata:
  name: logging</code></pre> 
<h2>1、&nbsp;es-service.yaml</h2> 
<pre><code class="language-bash">kind: Service
apiVersion: v1
metadata:
  name: elasticsearch
  namespace: logging
  labels:
    app: elasticsearch
spec:
  selector:
    app: elasticsearch
  clusterIP: None
  ports:
    - port: 9200
      name: rest
    - port: 9300
      name: inter-node
</code></pre> 
<p>定义了一个名为 elasticsearch 的 Service，指定标签&nbsp;<code>app=elasticsearch</code>，当我们将 Elasticsearch StatefulSet 与此服务关联时，服务将返回带有标签&nbsp;<code>app=elasticsearch</code>的 Elasticsearch Pods 的 DNS A 记录，然后设置&nbsp;<code>clusterIP=None</code>，将该服务设置成无头服务。最后，我们分别定义端口9200、9300，分别用于与 REST API 交互，以及用于节点间通信。&nbsp;</p> 
<pre><code class="language-bash">[root@master01 efk]# kubectl apply -f es-service.yaml
service/elasticsearch-logging created
[root@master01 efk]# kubectl get svc -n kube-system 
NAME                    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
elasticsearch-logging   ClusterIP   None            &lt;none&gt;        9200/TCP                     15s
</code></pre> 
<h2>es-statefulset.yaml</h2> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: es
  namespace: logging
spec:
  serviceName: elasticsearch
  replicas: 3
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels: 
        app: elasticsearch
    spec:
      nodeSelector:  #记得给节点把标签，不然会找到不符合的节点
        es: log
      initContainers:
      - name: increase-vm-max-map
        image: busybox
        command: ["sysctl", "-w", "vm.max_map_count=262144"]
        securityContext:
          privileged: true
      - name: increase-fd-ulimit
        image: busybox
        command: ["sh", "-c", "ulimit -n 65536"]
        securityContext:
          privileged: true
      containers:
      - name: elasticsearch
        image: docker.elastic.co/elasticsearch/elasticsearch:7.6.2
        ports:
        - name: rest
          containerPort: 9200
        - name: inter
          containerPort: 9300
        resources:
          limits:
            cpu: 1000m
          requests:
            cpu: 1000m
        volumeMounts:
        - name: data
          mountPath: /usr/share/elasticsearch/data
        env:
        - name: cluster.name
          value: k8s-logs
        - name: node.name
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: cluster.initial_master_nodes
          value: "es-0,es-1,es-2"
        - name: discovery.zen.minimum_master_nodes
          value: "2"
        - name: discovery.seed_hosts
          value: "elasticsearch"
        - name: ES_JAVA_OPTS
          value: "-Xms512m -Xmx512m"
        - name: network.host
          value: "0.0.0.0"
  volumeClaimTemplates:
  - metadata:
      name: data
      labels:
        app: elasticsearch
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: nfsdata
      resources:
        requests:
          storage: 5Gi </code></pre> 
<p><img alt="" height="252" src="https://img-blog.csdnimg.cn/ea6bebb226ff4569a5b5793743149eaa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1125"></p> 
<p>&nbsp;Pods 部署完成后，我们可以通过请求一个 REST API 来检查 Elasticsearch 集群是否正常运行。使用下面的命令将本地端口9200 转发到 Elasticsearch 节点（如es-0）对应的端口：</p> 
<pre><code class="language-bash">[root@master01 new]# kubectl port-forward es-0 9200:9200 --namespace=logging
Forwarding from 127.0.0.1:9200 -&gt; 9200
Forwarding from [::1]:9200 -&gt; 9200
</code></pre> 
<pre><code class="language-bash">curl http://localhost:9200/_cluster/state?pretty</code></pre> 
<p></p> 
<p><img alt="" height="746" src="https://img-blog.csdnimg.cn/be8ab8d757834cdda7cd3dc3ed0e3a38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="926"></p> 
<p>&nbsp;看到上面的信息就表明我们名为 k8s-logs 的 Elasticsearch 集群成功创建了3个节点：es-0，es-1，和es-2，当前主节点是 es-0</p> 
<h1 id="创建-kibana-服务">创建 Kibana 服务</h1> 
<p>Elasticsearch 集群启动成功了，接下来我们可以来部署 Kibana 服务，新建一个名为 kibana.yaml 的文件，对应的文件内容如下：</p> 
<h2>kibana.yaml&nbsp;</h2> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: kibana
  namespace: logging
  labels:
    app: kibana
spec:
  ports:
  - port: 5601
  type: NodePort
  selector:
    app: kibana

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kibana
  namespace: logging
  labels:
    app: kibana
spec:
  selector:
    matchLabels:
      app: kibana
  template:
    metadata:
      labels:
        app: kibana
    spec:
      nodeSelector:
        es: log
      containers:
      - name: kibana
        image: docker.elastic.co/kibana/kibana:7.6.2
        resources:
          limits:
            cpu: 1000m
          requests:
            cpu: 1000m
        env:
        - name: ELASTICSEARCH_HOSTS
          value: http://elasticsearch:9200
        ports:
        - containerPort: 5601</code></pre> 
<p>上面我们定义了两个资源对象，一个 Service 和 Deployment，为了测试方便，我们将 Service 设置为了 NodePort 类型，Kibana Pod 中配置都比较简单，唯一需要注意的是我们使用&nbsp;<code>ELASTICSEARCH_HOSTS</code>&nbsp;这个环境变量来设置Elasticsearch 集群的端点和端口，直接使用 Kubernetes DNS 即可，此端点对应服务名称为 elasticsearch，由于是一个 headless service，所以该域将解析为3个 Elasticsearch Pod 的 IP 地址列表。&nbsp;配置完成后，直接使用 kubectl 工具创建：</p> 
<pre><code>kubectl create -f kibana.yaml
service/kibana created
deployment.apps/kibana created</code></pre> 
<p>创建完成后，可以查看 Kibana Pod 的运行状态</p> 
<pre><code class="language-bash">[root@master01 new]#  kubectl get pods --namespace=logging
NAME                      READY   STATUS    RESTARTS   AGE
es-0                      1/1     Running   0          13m
es-1                      1/1     Running   0          9m48s
es-2                      1/1     Running   0          7m46s
kibana-8476dc9bbf-6mm6k   1/1     Running   0          3m2s
</code></pre> 
<p>如果 Pod 已经是 Running 状态了，证明应用已经部署成功了，然后可以通过 NodePort 来访问 Kibana 这个服务，在浏览器中打开<code>http://&lt;任意节点IP&gt;:31838</code>即可，</p> 
<p>出现 这个代表成功</p> 
<p><img alt="" height="773" src="https://img-blog.csdnimg.cn/9631236c38634351822510057c521ba3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<h1 id="部署-fluentd">部署 Fluentd</h1> 
<p><code>Fluentd</code>&nbsp;是一个高效的日志聚合器，是用 Ruby 编写的，并且可以很好地扩展。对于大部分企业来说，Fluentd 足够高效并且消耗的资源相对较少，另外一个工具<code>Fluent-bit</code>更轻量级，占用资源更少，但是插件相对 Fluentd 来说不够丰富，所以整体来说，Fluentd 更加成熟，使用更加广泛，所以我们这里也同样使用 Fluentd 来作为日志收集工具。</p> 
<h2 id="工作原理">工作原理</h2> 
<p>Fluentd 通过一组给定的数据源抓取日志数据，处理后（转换成结构化的数据格式）将它们转发给其他服务，比如 Elasticsearch、对象存储等等。Fluentd 支持超过300个日志存储和分析服务，所以在这方面是非常灵活的。主要运行步骤如下：</p> 
<ul><li>首先 Fluentd 从多个日志源获取数据</li><li>结构化并且标记这些数据</li><li>然后根据匹配的标签将数据发送到多个目标服务去</li></ul>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/d0898fbe32ac393295ce90408fc77298.png"></p> 
<h2 id="配置">配置</h2> 
<p>一般来说我们是通过一个配置文件来告诉 Fluentd 如何采集、处理数据的</p> 
<p>日志源配置</p> 
<p>比如我们这里为了收集 Kubernetes 节点上的所有容器日志，就需要做如下的日志源配置：</p> 
<pre><code class="language-bash">&lt;source&gt;
  @id fluentd-containers.log
  @type tail                             # Fluentd 内置的输入方式，其原理是不停地从源文件中获取新的日志。
  path /var/log/containers/*.log         # 挂载的服务器Docker容器日志地址
  pos_file /var/log/es-containers.log.pos
  tag raw.kubernetes.*                   # 设置日志标签
  read_from_head true
  &lt;parse&gt;                                # 多行格式化成JSON
    @type multi_format                   # 使用 multi-format-parser 解析器插件
    &lt;pattern&gt;
      format json                        # JSON 解析器
      time_key time                      # 指定事件时间的时间字段
      time_format %Y-%m-%dT%H:%M:%S.%NZ  # 时间格式
    &lt;/pattern&gt;
    &lt;pattern&gt;
      format /^(?&lt;time&gt;.+) (?&lt;stream&gt;stdout|stderr) [^ ]* (?&lt;log&gt;.*)$/
      time_format %Y-%m-%dT%H:%M:%S.%N%:z
    &lt;/pattern&gt;
  &lt;/parse&gt;
&lt;/source&gt;</code></pre> 
<p>上面配置部分参数说明如下：</p> 
<ul><li>id：表示引用该日志源的唯一标识符，该标识可用于进一步过滤和路由结构化日志数据</li><li>type：Fluentd 内置的指令，<code>tail</code>&nbsp;表示 Fluentd 从上次读取的位置通过 tail 不断获取数据，另外一个是&nbsp;<code>http</code>&nbsp;表示通过一个 GET 请求来收集数据。</li><li>path：<code>tail</code>&nbsp;类型下的特定参数，告诉 Fluentd 采集&nbsp;<code>/var/log/containers</code>&nbsp;目录下的所有日志，这是 docker 在 Kubernetes 节点上用来存储运行容器 stdout 输出日志数据的目录。</li><li>pos_file：检查点，如果 Fluentd 程序重新启动了，它将使用此文件中的位置来恢复日志数据收集。</li><li>tag：用来将日志源与目标或者过滤器匹配的自定义字符串，Fluentd 匹配源/目标标签来路由日志数据。</li></ul>
<p>路由配置</p> 
<p>上面是日志源的配置，接下来看看如何将日志数据发送到 Elasticsearch：</p> 
<pre><code class="language-bash">&lt;match **&gt;

@id elasticsearch

@type elasticsearch

@log_level info

include_tag_key true

type_name fluentd

host "#{ENV['OUTPUT_HOST']}"

port "#{ENV['OUTPUT_PORT']}"

logstash_format true

&lt;buffer&gt;

@type file

path /var/log/fluentd-buffers/kubernetes.system.buffer

flush_mode interval

retry_type exponential_backoff

flush_thread_count 2

flush_interval 5s

retry_forever

retry_max_interval 30

chunk_limit_size "#{ENV['OUTPUT_BUFFER_CHUNK_LIMIT']}"

queue_limit_length "#{ENV['OUTPUT_BUFFER_QUEUE_LIMIT']}"

overflow_action block

&lt;/buffer&gt;
</code></pre> 
<p></p> 
<ul><li>match：标识一个目标标签，后面是一个匹配日志源的正则表达式，我们这里想要捕获所有的日志并将它们发送给 Elasticsearch，所以需要配置成<code>**</code>。</li><li>id：目标的一个唯一标识符。</li><li>type：支持的输出插件标识符，我们这里要输出到 Elasticsearch，所以配置成 elasticsearch，这是 Fluentd 的一个内置插件。</li><li>log_level：指定要捕获的日志级别，我们这里配置成&nbsp;<code>info</code>，表示任何该级别或者该级别以上（INFO、WARNING、ERROR）的日志都将被路由到 Elsasticsearch。</li><li>host/port：定义 Elasticsearch 的地址，也可以配置认证信息，我们的 Elasticsearch 不需要认证，所以这里直接指定 host 和 port 即可。</li><li>logstash_format：Elasticsearch 服务对日志数据构建反向索引进行搜索，将 logstash_format 设置为&nbsp;<code>true</code>，Fluentd 将会以 logstash 格式来转发结构化的日志数据。</li><li>Buffer： Fluentd 允许在目标不可用时进行缓存，比如，如果网络出现故障或者 Elasticsearch 不可用的时候。缓冲区配置也有助于降低磁盘的 IO。</li></ul>
<p>过滤</p> 
<p>由于 Kubernetes 集群中应用太多，也还有很多历史数据，所以我们可以只将某些应用的日志进行收集，比如我们只采集具有&nbsp;<code>logging=true</code>&nbsp;这个 Label 标签的 Pod 日志，这个时候就需要使用 filter，如下所示：</p> 
<pre><code class="language-bash"># 删除无用的属性
&lt;filter kubernetes.**&gt;
  @type record_transformer
  remove_keys $.docker.container_id,$.kubernetes.container_image_id,$.kubernetes.pod_id,$.kubernetes.namespace_id,$.kubernetes.master_url,$.kubernetes.labels.pod-template-hash
&lt;/filter&gt;
# 只保留具有logging=true标签的Pod日志
&lt;filter kubernetes.**&gt;
  @id filter_log
  @type grep
  &lt;regexp&gt;
    key $.kubernetes.labels.logging
    pattern ^true$
  &lt;/regexp&gt;
&lt;/filter&gt;</code></pre> 
<h2 id="安装">安装</h2> 
<p>要收集 Kubernetes 集群的日志，直接用 DasemonSet 控制器来部署 Fluentd 应用，这样，它就可以从 Kubernetes 节点上采集日志，确保在集群中的每个节点上始终运行一个 Fluentd 容器。当然可以直接使用 Helm 来进行一键安装，为了能够了解更多实现细节，我们这里还是采用手动方法来进行安装。</p> 
<p>首先，我们通过 ConfigMap 对象来指定 Fluentd 配置文件，新建 fluentd-configmap.yaml 文件，文件内容如下：</p> 
<pre><code class="language-bash">kind: ConfigMap
apiVersion: v1
metadata:
  name: fluentd-config
  namespace: logging
data:
  system.conf: |-
    &lt;system&gt;
      root_dir /tmp/fluentd-buffers/
    &lt;/system&gt;
  containers.input.conf: |-
    &lt;source&gt;
      @id fluentd-containers.log
      @type tail                              # Fluentd 内置的输入方式，其原理是不停地从源文件中获取新的日志。
      path /var/log/containers/*.log          # 挂载的服务器Docker容器日志地址
      pos_file /var/log/es-containers.log.pos
      tag raw.kubernetes.*                    # 设置日志标签
      read_from_head true
      &lt;parse&gt;                                 # 多行格式化成JSON
        @type multi_format                    # 使用 multi-format-parser 解析器插件
        &lt;pattern&gt;
          format json                         # JSON解析器
          time_key time                       # 指定事件时间的时间字段
          time_format %Y-%m-%dT%H:%M:%S.%NZ   # 时间格式
        &lt;/pattern&gt;
        &lt;pattern&gt;
          format /^(?&lt;time&gt;.+) (?&lt;stream&gt;stdout|stderr) [^ ]* (?&lt;log&gt;.*)$/
          time_format %Y-%m-%dT%H:%M:%S.%N%:z
        &lt;/pattern&gt;
      &lt;/parse&gt;
    &lt;/source&gt;
    # 在日志输出中检测异常，并将其作为一条日志转发 
    # https://github.com/GoogleCloudPlatform/fluent-plugin-detect-exceptions
    &lt;match raw.kubernetes.**&gt;           # 匹配tag为raw.kubernetes.**日志信息
      @id raw.kubernetes
      @type detect_exceptions           # 使用detect-exceptions插件处理异常栈信息
      remove_tag_prefix raw             # 移除 raw 前缀
      message log                       
      stream stream                     
      multiline_flush_interval 5
      max_bytes 500000
      max_lines 1000
    &lt;/match&gt;

    &lt;filter **&gt;  # 拼接日志
      @id filter_concat
      @type concat                # Fluentd Filter 插件，用于连接多个事件中分隔的多行日志。
      key message
      multiline_end_regexp /\n$/  # 以换行符“\n”拼接
      separator ""
    &lt;/filter&gt; 

    # 添加 Kubernetes metadata 数据
    &lt;filter kubernetes.**&gt;
      @id filter_kubernetes_metadata
      @type kubernetes_metadata
    &lt;/filter&gt;

    # 修复 ES 中的 JSON 字段
    # 插件地址：https://github.com/repeatedly/fluent-plugin-multi-format-parser
    &lt;filter kubernetes.**&gt;
      @id filter_parser
      @type parser                # multi-format-parser多格式解析器插件
      key_name log                # 在要解析的记录中指定字段名称。
      reserve_data true           # 在解析结果中保留原始键值对。
      remove_key_name_field true  # key_name 解析成功后删除字段。
      &lt;parse&gt;
        @type multi_format
        &lt;pattern&gt;
          format json
        &lt;/pattern&gt;
        &lt;pattern&gt;
          format none
        &lt;/pattern&gt;
      &lt;/parse&gt;
    &lt;/filter&gt;

    # 删除一些多余的属性
    &lt;filter kubernetes.**&gt;
      @type record_transformer
      remove_keys $.docker.container_id,$.kubernetes.container_image_id,$.kubernetes.pod_id,$.kubernetes.namespace_id,$.kubernetes.master_url,$.kubernetes.labels.pod-template-hash
    &lt;/filter&gt;

    # 只保留具有logging=true标签的Pod日志
    &lt;filter kubernetes.**&gt;
      @id filter_log
      @type grep
      &lt;regexp&gt;
        key $.kubernetes.labels.logging
        pattern ^true$
      &lt;/regexp&gt;
    &lt;/filter&gt;
  
  ###### 监听配置，一般用于日志聚合用 ######
  forward.input.conf: |-
    # 监听通过TCP发送的消息
    &lt;source&gt;
      @id forward
      @type forward
    &lt;/source&gt;

  output.conf: |-
    &lt;match **&gt;
      @id elasticsearch
      @type elasticsearch
      @log_level info
      include_tag_key true
      host elasticsearch
      port 9200
      logstash_format true
      logstash_prefix k8s  # 设置 index 前缀为 k8s
      request_timeout    30s
      &lt;buffer&gt;
        @type file
        path /var/log/fluentd-buffers/kubernetes.system.buffer
        flush_mode interval
        retry_type exponential_backoff
        flush_thread_count 2
        flush_interval 5s
        retry_forever
        retry_max_interval 30
        chunk_limit_size 2M
        queue_limit_length 8
        overflow_action block
      &lt;/buffer&gt;
    &lt;/match&gt;</code></pre> 
<p>上面配置文件中我们只配置了 docker 容器日志目录，收集到数据经过处理后发送到&nbsp;<code>elasticsearch:9200</code>&nbsp;服务。</p> 
<p>然后新建一个 fluentd-daemonset.yaml 的文件，文件内容如下：</p> 
<pre><code class="language-bash">apiVersion: v1
kind: ServiceAccount
metadata:
  name: fluentd-es
  namespace: logging
  labels:
    k8s-app: fluentd-es
    kubernetes.io/cluster-service: "true"
    addonmanager.kubernetes.io/mode: Reconcile
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: fluentd-es
  labels:
    k8s-app: fluentd-es
    kubernetes.io/cluster-service: "true"
    addonmanager.kubernetes.io/mode: Reconcile
rules:
- apiGroups:
  - ""
  resources:
  - "namespaces"
  - "pods"
  verbs:
  - "get"
  - "watch"
  - "list"
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: fluentd-es
  labels:
    k8s-app: fluentd-es
    kubernetes.io/cluster-service: "true"
    addonmanager.kubernetes.io/mode: Reconcile
subjects:
- kind: ServiceAccount
  name: fluentd-es
  namespace: logging
  apiGroup: ""
roleRef:
  kind: ClusterRole
  name: fluentd-es
  apiGroup: ""
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd-es
  namespace: logging
  labels:
    k8s-app: fluentd-es
    kubernetes.io/cluster-service: "true"
    addonmanager.kubernetes.io/mode: Reconcile
spec:
  selector:
    matchLabels:
      k8s-app: fluentd-es
  template:
    metadata:
      labels:
        k8s-app: fluentd-es
        kubernetes.io/cluster-service: "true"
      # 此注释确保如果节点被驱逐，fluentd不会被驱逐，支持关键的基于 pod 注释的优先级方案。
      annotations:
        scheduler.alpha.kubernetes.io/critical-pod: ''
    spec:
      serviceAccountName: fluentd-es
      containers:
      - name: fluentd-es
        image: quay.io/fluentd_elasticsearch/fluentd:v3.0.1
        env:
        - name: FLUENTD_ARGS
          value: --no-supervisor -q
        resources:
          limits:
            memory: 500Mi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: config-volume
          mountPath: /etc/fluent/config.d
      nodeSelector:
        beta.kubernetes.io/fluentd-ds-ready: "true"
      tolerations:
      - operator: Exists
      terminationGracePeriodSeconds: 30
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: config-volume
        configMap:
          name: fluentd-config</code></pre> 
<p>我们将上面创建的 fluentd-config 这个 ConfigMap 对象通过 volumes 挂载到了 Fluentd 容器中，另外为了能够灵活控制哪些节点的日志可以被收集，所以这里还添加了一个 nodSelector 属性：</p> 
<pre><code class="language-bash">nodeSelector:
  beta.kubernetes.io/fluentd-ds-ready: "true"</code></pre> 
<p>意思就是要想采集节点的日志，那么我们就需要给节点打上上面的标签</p> 
<p>如果你需要在其他节点上采集日志，则需要给对应节点打上标签，使用如下命令：</p> 
<p><code>kubectl label nodes node名 beta.kubernetes.io/fluentd-ds-ready=true</code></p> 
<pre><code class="language-bash">[root@master01 ~]# kubectl label nodes 172.17.1.32 beta.kubernetes.io/fluentd-ds-ready=true
node/172.17.1.32 labeled
[root@master01 ~]# kubectl label nodes 172.17.1.30 beta.kubernetes.io/fluentd-ds-ready=true
node/172.17.1.30 labeled
[root@master01 ~]# kubectl label nodes 172.17.1.31 beta.kubernetes.io/fluentd-ds-ready=true
node/172.17.1.31 labeled
</code></pre> 
<p>默认情况下 master 节点有污点，所以如果要想也收集 master 节点的日志，则需要添加上容忍：</p> 
<pre><code>tolerations:
- operator: Exists</code></pre> 
<p>创建完成后，查看对应的 Pods 列表，检查是否部署成功</p> 
<p><img alt="" height="351" src="https://img-blog.csdnimg.cn/9b2adebe282e4a2299203a7c327fcac7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="706"></p> 
<p></p> 
<p>Fluentd 启动成功后，这个时候就可以发送日志到 ES 了，但是我们这里是过滤了只采集具有&nbsp;<code>logging=true</code>&nbsp;标签的 Pod 日志，所以现在还没有任何数据会被采集。</p> 
<p>下面我们部署一个简单的测试应用， 新建 counter.yaml 文件，文件内容如下：</p> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: counter
  labels:
    logging: "true"  # 一定要具有该标签才会被采集
spec:
  containers:
  - name: count
    image: busybox
    args: [/bin/sh, -c,
            'i=0; while true; do echo "$i: $(date)"; i=$((i+1)); sleep 1; done']</code></pre> 
<p>该 Pod 只是简单将日志信息打印到&nbsp;<code>stdout</code>，所以正常来说 Fluentd 会收集到这个日志数据，在 Kibana 中也就可以找到对应的日志数据了，使用 kubectl 工具创建该 Pod：</p> 
<p>&nbsp;<img alt="" height="140" src="https://img-blog.csdnimg.cn/f7ad95121d6442268422571053b5576b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="566"></p> 
<p>Pod 创建并运行后，回到 Kibana Dashboard 页面，点击左侧最下面的&nbsp;<code>management</code>&nbsp;图标，然后点击 Kibana 下面的&nbsp;<code>Index Patterns</code>&nbsp;开始导入索引数据：</p> 
<p><img alt="" height="736" src="https://img-blog.csdnimg.cn/fdaf22ae9a954dffbdd6bd2d58974599.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="718" src="https://img-blog.csdnimg.cn/599f15ec0e4d4e7588111f072736f4db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p></p> 
<p>更详细细节请看阴阳博客</p> 
<p><a href="https://www.qikqiak.com/post/install-efk-stack-on-k8s/" title="在 Kubernetes 上搭建 EFK 日志收集系统[更新]-阳明的博客|Kubernetes|Istio|Prometheus|Python|Golang|云原生">在 Kubernetes 上搭建 EFK 日志收集系统[更新]-阳明的博客|Kubernetes|Istio|Prometheus|Python|Golang|云原生</a></p>
                ]]></description></item><item><title>Kubernetes的ETCD集群备份、恢复</title><link>http://www.cnblogs.com/heian99/archive/2022/03/12/15998576.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 12 Mar 2022 13:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/03/12/15998576.html</guid><description><![CDATA[
                    <p>首先，我们使用Kubernetes的都知道，etcd是k8s的核心所在，会记录各个pod的状态信息。所以重要性极为重要。</p> 
<p>etcd是kubernetes集群极为重要的一块服务，存储了kubernetes集群所有的数据信息，如Namespace、Pod、Service、路由等状态信息。如果etcd集群发生灾难或者 etcd 集群数据丢失，都会影响k8s集群数据的恢复。因此，通过备份etcd数据来实现kubernetes集群的灾备环境十分重要。</p> 
<p>我们一点要养成，重要的东西<strong>备份、备份、在备份</strong>的习惯。</p> 
<pre><code class="language-bash"> ETCDCTL_API=3 /opt/kube/bin/etcdctl  --endpoints="https://172.17.1.20:2379,https://172.17.1.21:2379,https://172.17.1.22:2379" \
--cacert=/etc/kubernetes/ssl/ca.pem \
--cert=/etc/kubernetes/ssl/etcd.pem \
--key=/etc/kubernetes/ssl/etcd-key.pem \
endpoint status --write-out=table  #状态
（配合替换最后一行使用）
member list --write-out=table   #列表

endpoint health --write-out=table #健康检查</code></pre> 
<pre><code class="language-bash">[root@master01 ~]#  ETCDCTL_API=3 /opt/kube/bin/etcdctl  --endpoints="https://172.17.1.20:2379,https://172.17.1.21:2379,https://172.17.1.22:2379" --cacert=/etc/kubernetes/ssl/ca.pem --cert=/etc/kubernetes/ssl/etcd.pem --key=/etc/kubernetes/ssl/etcd-key.pem endpoint status --write-out=table
+--------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|         ENDPOINT         |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |
+--------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
| https://172.17.1.20:2379 | 20eec45319ea02e1 |  3.4.13 |  4.3 MB |     false |      false |         5 |      14715 |              14715 |        |
| https://172.17.1.21:2379 |  395af18f6bbef1a |  3.4.13 |  4.3 MB |     false |      false |         5 |      14715 |              14715 |        |
| https://172.17.1.22:2379 | fc24d224af6a71d9 |  3.4.13 |  4.3 MB |      true |      false |         5 |      14715 |              14715 |        |
+--------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
</code></pre> 
<h2><img alt="" height="190" src="https://img-blog.csdnimg.cn/c0849547240c4eae84d11a414839acaf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></h2> 
<p>&nbsp;</p> 
<h2 id="autoid-0-0-0"><strong>一、etcd集群备份</strong></h2> 
<p>etcd不同版本的 etcdctl 命令不一样，但大致差不多，这里备份使用 napshot save进行快照备份。</p> 
<p>需要注意几点：</p> 
<ul><li>备份操作在etcd集群的其中一个节点执行就可以。</li><li>这里使用的是etcd v3的api，因为从 k8s 1.13 开始，k8s不再支持 v2 版本的 etcd，即k8s的集群数据都存在了v3版本的etcd中。故备份的数据也只备份了使用v3添加的etcd数据，v2添加的etcd数据是没有做备份的。</li><li>本案例使用的是二进制部署的k8s v1.20.2 + Calico 容器环境（下面命令中的"ETCDCTL_API=3 etcdctl" 等同于 "etcdctl"）</li></ul>
<p><img alt="" height="250" src="https://img-blog.csdnimg.cn/9f51bc5bfd39451b809a2dd2fee08ebc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="753"></p> 
<p>&nbsp;</p> 
<p><strong>1）开始备份之前，先来查看下etcd数据</strong></p> 
<pre><code>[root@master01 ~]# cat /etc/systemd/system/etcd.service
[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/coreos

[Service]
Type=notify
WorkingDirectory=/var/lib/etcd/
ExecStart=/opt/kube/bin/etcd \
  --name=etcd-172.17.1.20 \
  --cert-file=/etc/kubernetes/ssl/etcd.pem \
  --key-file=/etc/kubernetes/ssl/etcd-key.pem \
  --peer-cert-file=/etc/kubernetes/ssl/etcd.pem \
  --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem \
  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \
  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \
  --initial-advertise-peer-urls=https://172.17.1.20:2380 \
  --listen-peer-urls=https://172.17.1.20:2380 \
  --listen-client-urls=https://172.17.1.20:2379,http://127.0.0.1:2379 \
  --advertise-client-urls=https://172.17.1.20:2379 \
  --initial-cluster-token=etcd-cluster-0 \
  --initial-cluster=etcd-172.17.1.20=https://172.17.1.20:2380,etcd-172.17.1.21=https://172.17.1.21:2380,etcd-172.17.1.22=https://172.17.1.22:2380 \
  --initial-cluster-state=new \
  --data-dir=/var/lib/etcd \
  --snapshot-count=50000 \
  --auto-compaction-retention=1 \
  --max-request-bytes=10485760 \
  --auto-compaction-mode=periodic \
  --quota-backend-bytes=8589934592
Restart=always
RestartSec=15
LimitNOFILE=65536
OOMScoreAdjust=-999



[root@master01 ~]# tree /var/lib/etcd
/var/lib/etcd
└── member
    ├── snap
    │&nbsp;&nbsp; └── db
    └── wal
        ├── 0000000000000000-0000000000000000.wal
        └── 0.tmp

3 directories, 3 files
</code></pre> 
<p><strong>2）执行etcd集群数据备份</strong></p> 
<p>在etcd集群的其中一个节点执行备份操作，然后将备份文件拷贝到其他节点上。</p> 
<p></p> 
<p>先在etcd集群的每个节点上创建备份目录</p> 
<pre><code>mkdir -p /data/etcd_backup_dir</code></pre> 
<p>在etcd集群其中个一个节点（这里在k8s-master01）上执行备份：</p> 
<pre><code>ETCDCTL_API=3 /opt/kube/bin/etcdctl  \
snapshot  save /data/etcd_backup_dir/etcd-snapshot-`date +%Y%m%d`.db \
--endpoints=https://172.17.1.20:2379 \
--cacert=/etc/kubernetes/ssl/ca.pem \
--cert=/etc/kubernetes/ssl/etcd.pem \
--key=/etc/kubernetes/ssl/etcd-key.pem</code></pre> 
<p><img alt="" height="476" src="https://img-blog.csdnimg.cn/0aef38721c5f464a84693ba5720cdd82.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1195"></p> 
<p>&nbsp;将备份文件拷贝到其他的etcd节点</p> 
<pre><code class="language-bash">[root@master01 ~]# scp /data/etcd_backup_dir/etcd-snapshot-20220310.db 172.17.1.21:/data/etcd_backup_dir/
etcd-snapshot-20220310.db                                                                     100% 4208KB 158.6MB/s   00:00    
您在 /var/spool/mail/root 中有新邮件
[root@master01 ~]# scp /data/etcd_backup_dir/etcd-snapshot-20220310.db 172.17.1.22:/data/etcd_backup_dir/
etcd-snapshot-20220310.db                                                                     100% 4208KB 158.3MB/s   00:00    
[root@master01 ~]# 
</code></pre> 
<p>可以将上面k8s-master01节点的etcd备份命令放在脚本里，结合crontab进行定时备份：</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# cat /data/etcd_backup_dir/etcd_backup.sh
#!/usr/bin/bash
 
date;
ETCDCTL_API=3 /opt/kube/bin/etcdctl  \
snapshot  save /data/etcd_backup_dir/etcd-snapshot-`date +%Y%m%d`.db \
--endpoints=https://172.17.1.20:2379 \
--cacert=/etc/kubernetes/ssl/ca.pem \
--cert=/etc/kubernetes/ssl/etcd.pem \
--key=/etc/kubernetes/ssl/etcd-key.pem
 
# 备份保留30天
find /data/etcd_backup_dir/ -name "*.db" -mtime +30 -exec rm -f {} \;
 
# 同步到其他两个etcd节点
scp /data/etcd_backup_dir/etcd-snapshot-`date +%Y%m%d`.db 172.17.1.21:/data/etcd_backup_dir/
 scp /data/etcd_backup_dir/etcd-snapshot-`date +%Y%m%d`.db 172.17.1.22:/data/etcd_backup_dir/</code></pre> 
<p>设置crontab定时备份任务，每天凌晨5点执行备份：</p> 
<pre><code class="language-bash">[root@master01 ~]# chmod 755 /data/etcd_backup_dir/etcd_backup.sh
[root@master01 ~]# crontab -e
crontab: installing new crontab
[root@master01 ~]# crontab -l
*/10 * * * * ntpdate time.windows.com
0 5 * * * /bin/bash -x /data/etcd_backup_dir/etcd_backup.sh &gt; /dev/null 2&gt;&amp;1
</code></pre> 
<h2 id="autoid-1-0-0">二、etcd集群恢复</h2> 
<p>etcd集群备份操作只需要在其中的一个etcd节点上完成，然后将备份文件拷贝到其他节点。<br> 但etcd集群恢复操作必须要所有的etcd节点上完成！</p> 
<p><strong>1）模拟etcd集群数据丢失</strong><br> 删除三个etcd集群节点的data数据 (或者直接删除data目录)</p> 
<pre><code class="language-bash">[root@master01 ~]# ls /var/lib/etcd/
member
[root@master01 ~]# ansible master -m shell -a "mv /var/lib/etcd/member /var/lib/etcd/member_bak"
172.17.1.21 | CHANGED | rc=0 &gt;&gt;

172.17.1.22 | CHANGED | rc=0 &gt;&gt;

172.17.1.20 | CHANGED | rc=0 &gt;&gt;

[root@master01 ~]# ls /var/lib/etcd/
member_bak
</code></pre> 
<p>查看k8s集群状态：</p> 
<p>由于此时etcd集群的三个节点服务还在，过一会儿查看集群状态恢复正常：</p> 
<pre><code class="language-bash">[root@master01 ~]# kubectl get cs


Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE             ERROR
controller-manager   Healthy   ok                  
scheduler            Healthy   ok                  
etcd-1               Healthy   {"health":"true"}   
etcd-0               Healthy   {"health":"true"}   
etcd-2               Healthy   {"health":"true"}   
您在 /var/spool/mail/root 中有新邮件
[root@master01 ~]# 
[root@master01 ~]# 
[root@master01 ~]#  ETCDCTL_API=3 /opt/kube/bin/etcdctl  --endpoints="https://172.17.1.20:2379,https://172.17.1.21:2379,https://172.17.1.22:2379" \
&gt; --cacert=/etc/kubernetes/ssl/ca.pem \
&gt; --cert=/etc/kubernetes/ssl/etcd.pem \
&gt; --key=/etc/kubernetes/ssl/etcd-key.pem \
&gt; endpoint status --write-out=table  #状态
+--------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|         ENDPOINT         |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |
+--------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
| https://172.17.1.20:2379 | 20eec45319ea02e1 |  3.4.13 |  143 kB |     false |      false |         7 |        191 |                191 |        |
| https://172.17.1.21:2379 |  395af18f6bbef1a |  3.4.13 |  143 kB |      true |      false |         7 |        191 |                191 |        |
| https://172.17.1.22:2379 | fc24d224af6a71d9 |  3.4.13 |  152 kB |     false |      false |         7 |        191 |                191 |        |
+--------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
[root@master01 ~]# kubectl get svc,pod -A
NAMESPACE   NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
default     service/kubernetes   ClusterIP   10.68.0.1    &lt;none&gt;        443/TCP   18s
</code></pre> 
<p>但是，k8s集群数据其实已经丢失了。namespace命名空间下的pod等资源都没有了。此时就需要通过etcd集群备份文件来恢复，即通过上面的etcd集群快照文件恢复。</p> 
<pre><code class="language-bash">[root@master01 ~]# kubectl get ns
NAME              STATUS   AGE
default           Active   2m20s
kube-node-lease   Active   2m20s
kube-public       Active   2m20s
kube-system       Active   2m20s
[root@master01 ~]# kubectl get pod -n kube-system
No resources found in kube-system namespace.
</code></pre> 
<p><strong>2）etcd集群数据恢复，即kubernetes集群数据恢复</strong></p> 
<p>在etcd数据恢复之前，先依次关闭所有master节点的kube-aposerver服务，所有etcd节点的etcd服务：</p> 
<pre><code class="language-bash">[root@master01 ~]# ansible master -m shell -a "systemctl stop kube-apiserver &amp;&amp; systemctl stop etcd"
172.17.1.21 | CHANGED | rc=0 &gt;&gt;

172.17.1.22 | CHANGED | rc=0 &gt;&gt;

172.17.1.20 | CHANGED | rc=0 &gt;&gt;
</code></pre> 
<p><strong>特别注意：</strong>在进行etcd集群数据恢复之前，一定要先将所有etcd节点的data和wal旧工作目录删掉，否则，可能会导致恢复失败（恢复命令执行时报错数据目录已存在）。</p> 
<p>在每个etcd节点执行恢复操作：</p> 
<p>master01</p> 
<pre><code class="language-bash">[root@master01 ~]# 
[root@master01 ~]# ETCDCTL_API=3 /opt/kube/bin/etcdctl \
&gt; --name=etcd-172.17.1.20  \
&gt; --endpoints="https://172.17.1.20:2379" \
&gt; --cacert=/etc/kubernetes/ssl/ca.pem \
&gt; --cert=/etc/kubernetes/ssl/etcd.pem \
&gt; --key=/etc/kubernetes/ssl/etcd-key.pem \
&gt; --initial-cluster-token=etcd-cluster-0  \
&gt; --initial-advertise-peer-urls=https://172.17.1.20:2380  \
&gt; --initial-cluster=etcd-172.17.1.20=https://172.17.1.20:2380,etcd-172.17.1.21=https://172.17.1.21:2380,etcd-172.17.1.22=https://172.17.1.22:2380  \
&gt;  --data-dir=/var/lib/etcd \
&gt; snapshot restore /data/etcd_backup_dir/etcd-snapshot-20220310.db
</code></pre> 
<p><img alt="" height="571" src="https://img-blog.csdnimg.cn/e1a52c9e0d974d0a805539840cbffa9b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>master02</p> 
<pre><code class="language-bash">ETCDCTL_API=3 /opt/kube/bin/etcdctl \
--name=etcd-172.17.1.21  \
--endpoints="https://172.17.1.21:2379" \
--cacert=/etc/kubernetes/ssl/ca.pem \
--cert=/etc/kubernetes/ssl/etcd.pem \
--key=/etc/kubernetes/ssl/etcd-key.pem \
--initial-cluster-token=etcd-cluster-0  \
--initial-advertise-peer-urls=https://172.17.1.21:2380  \
--initial-cluster=etcd-172.17.1.20=https://172.17.1.20:2380,etcd-172.17.1.21=https://172.17.1.21:2380,etcd-172.17.1.22=https://172.17.1.22:2380  \
 --data-dir=/var/lib/etcd \
snapshot restore /data/etcd_backup_dir/etcd-snapshot-20220310.db</code></pre> 
<p>&nbsp;master03</p> 
<pre><code class="language-bash">ETCDCTL_API=3 /opt/kube/bin/etcdctl \
--name=etcd-172.17.1.22  \
--endpoints="https://172.17.1.22:2379" \
--cacert=/etc/kubernetes/ssl/ca.pem \
--cert=/etc/kubernetes/ssl/etcd.pem \
--key=/etc/kubernetes/ssl/etcd-key.pem \
--initial-cluster-token=etcd-cluster-0  \
--initial-advertise-peer-urls=https://172.17.1.22:2380  \
--initial-cluster=etcd-172.17.1.20=https://172.17.1.20:2380,etcd-172.17.1.21=https://172.17.1.21:2380,etcd-172.17.1.22=https://172.17.1.22:2380  \
 --data-dir=/var/lib/etcd \
snapshot restore /data/etcd_backup_dir/etcd-snapshot-20220310.db</code></pre> 
<p>依次启动所有etcd节点的etcd服务：</p> 
<pre><code class="language-bash"># systemctl start etcd
# systemctl status etcd</code></pre> 
<pre><code class="language-bash">[root@master01 ~]# ansible master -m shell -a "systemctl start etcd"
172.17.1.22 | CHANGED | rc=0 &gt;&gt;

172.17.1.21 | CHANGED | rc=0 &gt;&gt;

172.17.1.20 | CHANGED | rc=0 &gt;&gt;

您在 /var/spool/mail/root 中有新邮件
[root@master01 ~]# ansible master -m shell -a "systemctl status etcd"
172.17.1.21 | CHANGED | rc=0 &gt;&gt;
● etcd.service - Etcd Server
   Loaded: loaded (/etc/systemd/system/etcd.service; enabled; vendor preset: disabled)
   Active: active (running) since 四 2022-03-10 14:43:41 CST; 8s ago
     Docs: https://github.com/coreos
 Main PID: 81855 (etcd)
    Tasks: 13
   Memory: 23.4M
   CGroup: /system.slice/etcd.service
           └─81855 /opt/kube/bin/etcd --name=etcd-172.17.1.21 --cert-file=/etc/kubernetes/ssl/etcd.pem --key-file=/etc/kubernetes/ssl/etcd-key.pem --peer-cert-file=/etc/kubernetes/ssl/etcd.pem --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem --trusted-ca-file=/etc/kubernetes/ssl/ca.pem --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem --initial-advertise-peer-urls=https://172.17.1.21:2380 --listen-peer-urls=https://172.17.1.21:2380 --listen-client-urls=https://172.17.1.21:2379,http://127.0.0.1:2379 --advertise-client-urls=https://172.17.1.21:2379 --initial-cluster-token=etcd-cluster-0 --initial-cluster=etcd-172.17.1.20=https://172.17.1.20:2380,etcd-172.17.1.21=https://172.17.1.21:2380,etcd-172.17.1.22=https://172.17.1.22:2380 --initial-cluster-state=new --data-dir=/var/lib/etcd --snapshot-count=50000 --auto-compaction-retention=1 --max-request-bytes=10485760 --auto-compaction-mode=periodic --quota-backend-bytes=8589934592

3月 10 14:43:41 master02 etcd[81855]: published {Name:etcd-172.17.1.21 ClientURLs:[https://172.17.1.21:2379]} to cluster 948e35f16fc80e25
3月 10 14:43:41 master02 etcd[81855]: ready to serve client requests
3月 10 14:43:41 master02 etcd[81855]: ready to serve client requests
3月 10 14:43:41 master02 systemd[1]: Started Etcd Server.
3月 10 14:43:41 master02 etcd[81855]: serving insecure client requests on 127.0.0.1:2379, this is strongly discouraged!
3月 10 14:43:41 master02 etcd[81855]: serving client requests on 172.17.1.21:2379
3月 10 14:43:41 master02 etcd[81855]: set the initial cluster version to 3.4
3月 10 14:43:41 master02 etcd[81855]: enabled capabilities for version 3.4
3月 10 14:43:41 master02 etcd[81855]: established a TCP streaming connection with peer 20eec45319ea02e1 (stream Message reader)
3月 10 14:43:41 master02 etcd[81855]: established a TCP streaming connection with peer 20eec45319ea02e1 (stream MsgApp v2 reader)
172.17.1.22 | CHANGED | rc=0 &gt;&gt;
● etcd.service - Etcd Server
   Loaded: loaded (/etc/systemd/system/etcd.service; enabled; vendor preset: disabled)
   Active: active (running) since 四 2022-03-10 14:43:41 CST; 8s ago
     Docs: https://github.com/coreos
 Main PID: 81803 (etcd)
    Tasks: 13
   Memory: 20.7M
   CGroup: /system.slice/etcd.service
           └─81803 /opt/kube/bin/etcd --name=etcd-172.17.1.22 --cert-file=/etc/kubernetes/ssl/etcd.pem --key-file=/etc/kubernetes/ssl/etcd-key.pem --peer-cert-file=/etc/kubernetes/ssl/etcd.pem --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem --trusted-ca-file=/etc/kubernetes/ssl/ca.pem --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem --initial-advertise-peer-urls=https://172.17.1.22:2380 --listen-peer-urls=https://172.17.1.22:2380 --listen-client-urls=https://172.17.1.22:2379,http://127.0.0.1:2379 --advertise-client-urls=https://172.17.1.22:2379 --initial-cluster-token=etcd-cluster-0 --initial-cluster=etcd-172.17.1.20=https://172.17.1.20:2380,etcd-172.17.1.21=https://172.17.1.21:2380,etcd-172.17.1.22=https://172.17.1.22:2380 --initial-cluster-state=new --data-dir=/var/lib/etcd --snapshot-count=50000 --auto-compaction-retention=1 --max-request-bytes=10485760 --auto-compaction-mode=periodic --quota-backend-bytes=8589934592

3月 10 14:43:41 master03 etcd[81803]: ready to serve client requests
3月 10 14:43:41 master03 etcd[81803]: ready to serve client requests
3月 10 14:43:41 master03 systemd[1]: Started Etcd Server.
3月 10 14:43:41 master03 etcd[81803]: serving insecure client requests on 127.0.0.1:2379, this is strongly discouraged!
3月 10 14:43:41 master03 etcd[81803]: serving client requests on 172.17.1.22:2379
3月 10 14:43:41 master03 etcd[81803]: setting up the initial cluster version to 3.4
3月 10 14:43:41 master03 etcd[81803]: set the initial cluster version to 3.4
3月 10 14:43:41 master03 etcd[81803]: enabled capabilities for version 3.4
3月 10 14:43:41 master03 etcd[81803]: established a TCP streaming connection with peer 20eec45319ea02e1 (stream Message reader)
3月 10 14:43:41 master03 etcd[81803]: established a TCP streaming connection with peer 20eec45319ea02e1 (stream MsgApp v2 reader)
172.17.1.20 | CHANGED | rc=0 &gt;&gt;
● etcd.service - Etcd Server
   Loaded: loaded (/etc/systemd/system/etcd.service; enabled; vendor preset: disabled)
   Active: active (running) since 四 2022-03-10 14:43:41 CST; 9s ago
     Docs: https://github.com/coreos
 Main PID: 103123 (etcd)
    Tasks: 13
   Memory: 10.7M
   CGroup: /system.slice/etcd.service
           └─103123 /opt/kube/bin/etcd --name=etcd-172.17.1.20 --cert-file=/etc/kubernetes/ssl/etcd.pem --key-file=/etc/kubernetes/ssl/etcd-key.pem --peer-cert-file=/etc/kubernetes/ssl/etcd.pem --peer-key-file=/etc/kubernetes/ssl/etcd-key.pem --trusted-ca-file=/etc/kubernetes/ssl/ca.pem --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem --initial-advertise-peer-urls=https://172.17.1.20:2380 --listen-peer-urls=https://172.17.1.20:2380 --listen-client-urls=https://172.17.1.20:2379,http://127.0.0.1:2379 --advertise-client-urls=https://172.17.1.20:2379 --initial-cluster-token=etcd-cluster-0 --initial-cluster=etcd-172.17.1.20=https://172.17.1.20:2380,etcd-172.17.1.21=https://172.17.1.21:2380,etcd-172.17.1.22=https://172.17.1.22:2380 --initial-cluster-state=new --data-dir=/var/lib/etcd --snapshot-count=50000 --auto-compaction-retention=1 --max-request-bytes=10485760 --auto-compaction-mode=periodic --quota-backend-bytes=8589934592

3月 10 14:43:41 master01 etcd[103123]: serving insecure client requests on 127.0.0.1:2379, this is strongly discouraged!
3月 10 14:43:41 master01 etcd[103123]: serving client requests on 172.17.1.20:2379
3月 10 14:43:41 master01 systemd[1]: Started Etcd Server.
3月 10 14:43:41 master01 etcd[103123]: 20eec45319ea02e1 initialized peer connection; fast-forwarding 8 ticks (election ticks 10) with 2 active peer(s)
3月 10 14:43:41 master01 etcd[103123]: set the initial cluster version to 3.4
3月 10 14:43:41 master01 etcd[103123]: enabled capabilities for version 3.4
3月 10 14:43:41 master01 etcd[103123]: established a TCP streaming connection with peer fc24d224af6a71d9 (stream Message writer)
3月 10 14:43:41 master01 etcd[103123]: established a TCP streaming connection with peer fc24d224af6a71d9 (stream MsgApp v2 writer)
3月 10 14:43:41 master01 etcd[103123]: established a TCP streaming connection with peer 395af18f6bbef1a (stream Message writer)
3月 10 14:43:41 master01 etcd[103123]: established a TCP streaming connection with peer 395af18f6bbef1a (stream MsgApp v2 writer)
</code></pre> 
<p>检查 ETCD 集群状态（如下，发现etcd集群里已经成功选主了）</p> 
<p><img alt="" height="380" src="https://img-blog.csdnimg.cn/803fea704a0c43c7ac0e7b9d8eb93a8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;再依次启动所有master节点的kube-apiserver服务：</p> 
<pre><code class="language-bash"># systemctl start kube-apiserver
# systemctl status kube-apiserver</code></pre> 
<pre><code class="language-bash">[root@master01 ~]# ansible master -m shell -a "systemctl start kube-apiserver"
172.17.1.22 | CHANGED | rc=0 &gt;&gt;

172.17.1.21 | CHANGED | rc=0 &gt;&gt;

172.17.1.20 | CHANGED | rc=0 &gt;&gt;
</code></pre> 
<p>查看kubernetes集群状态：</p> 
<pre><code class="language-bash">[root@master01 ~]# kubectl get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE             ERROR
scheduler            Healthy   ok                  
controller-manager   Healthy   ok                  
etcd-1               Healthy   {"health":"true"}   
etcd-2               Healthy   {"health":"true"}   
etcd-0               Healthy   {"health":"true"}   
</code></pre> 
<p>查看kubernetes的资源情况：</p> 
<pre><code class="language-bash">[root@master01 ~]# kubectl get pod -A
NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE
kube-system   calico-kube-controllers-5677ffd49-t7dbx   1/1     Running   0          3h27m
kube-system   calico-node-2hrhv                         1/1     Running   0          3h27m
kube-system   calico-node-5kc79                         1/1     Running   0          3h27m
kube-system   calico-node-6v294                         1/1     Running   0          3h27m
kube-system   calico-node-hkm8l                         1/1     Running   0          3h27m
kube-system   calico-node-kkpmd                         1/1     Running   0          3h27m
kube-system   calico-node-tsmwx                         1/1     Running   0          3h27m
kube-system   coredns-5787695b7f-8ql8q                  1/1     Running   0          3h27m
kube-system   metrics-server-8568cf894b-ztcgf           1/1     Running   1          3h27m
kube-system   node-local-dns-5mbzg                      1/1     Running   0          3h27m
kube-system   node-local-dns-c5d9j                      1/1     Running   0          3h27m
kube-system   node-local-dns-nqnjw                      1/1     Running   0          3h27m
kube-system   node-local-dns-rz565                      1/1     Running   0          3h27m
kube-system   node-local-dns-skmzk                      1/1     Running   0          3h27m
kube-system   node-local-dns-zcncq                      1/1     Running   0          3h27m
kube-system   traefik-79f5f7879c-nwhlq                  1/1     Running   0          3h27m
</code></pre> 
<p>在etcd集群数据恢复后，pod容器也会慢慢恢复到running状态。至此，kubernetes整个集群已经通过etcd备份数据恢复了</p> 
<h2 id="autoid-2-0-0"><strong>三、最后总结</strong></h2> 
<p>Kubernetes 集群备份主要是备份 ETCD 集群。而恢复时，主要考虑恢复整个顺序：</p> 
<p><strong>停止kube-apiserver --&gt; 停止ETCD --&gt; 恢复数据 --&gt; 启动ETCD --&gt; 启动kube-apiserve</strong></p> 
<p></p> 
<p><strong>特别注意：</strong></p> 
<ul><li>备份ETCD集群时，只需要备份一个ETCD数据，然后同步到其他节点上。</li><li>恢复ETCD数据时，拿其中一个节点的备份数据恢复即可</li></ul>
<p>参考</p> 
<p>K8S集群灾备环境部署 - 散尽浮华 - 博客园<br> https://www.cnblogs.com/kevingrace/p/14616824.html</p>
                ]]></description></item><item><title>Linux虚拟机（lvm）报Unmount and run xfs_repair</title><link>http://www.cnblogs.com/heian99/archive/2022/03/12/15998577.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 12 Mar 2022 13:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/03/12/15998577.html</guid><description><![CDATA[
                    <p><img alt="" height="615" src="https://img-blog.csdnimg.cn/26026e6e4ee44b2f90bb96bf2941de1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="810"></p> 
<p>原因：因为突然断电，导致机器关闭</p> 
<p>结果：发现有一台虚拟机无法启动，一直报错&nbsp;<strong><span style="color:#fe2c24;">Unmount and run xfs_repair</span></strong></p> 
<p>分析：主机异常掉电后里面的虚拟机无法启动，主要是损坏的分区</p> 
<p><strong>解决办法：</strong></p> 
<p>原因：看出来应该是dm-0分区损坏，修复就可以了</p> 
<p>1：启动虚拟机E进入单用户模式</p> 
<p><img alt="" height="520" src="https://img-blog.csdnimg.cn/f9c0e1a5f93d4cf3bfb7a794d32ff8bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="995"></p> 
<p></p> 
<p>2：在linux16开头的哪一行后面添加rd.break，ctrl+x进入救援模式</p> 
<p><img alt="" height="534" src="https://img-blog.csdnimg.cn/67f7e52f60bd4486b52ed8438e12c274.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1071"></p> 
<p>&nbsp;</p> 
<p>3：分析dm-0</p> 
<pre><code class="language-bash">ls -l /dev/mapper</code></pre> 
<p>&nbsp;</p> 
<p><img alt="" height="411" src="https://img-blog.csdnimg.cn/fc4e19ae5524481884e6ea5a2f76236a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="721"></p> 
<p>4:卸载目录</p> 
<pre><code>umount /dev/mapper/centos-root</code></pre> 
<p><img alt="" height="446" src="https://img-blog.csdnimg.cn/c02824361f7e4efa91da5ce61776a3ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="727"></p> 
<p>&nbsp;5:修复目录</p> 
<pre><code class="language-bash">xfs_repair -L /dev/mapper/centos-root</code></pre> 
<p><img alt="" height="515" src="https://img-blog.csdnimg.cn/aa06491d5580417bb8788c77006c4568.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="728"></p> 
<p>&nbsp;6：重启机器</p> 
<pre><code class="language-bash">init 6</code></pre> 
<p>修复完成</p> 
<p><img alt="" height="308" src="https://img-blog.csdnimg.cn/ff745f35825943b68cc4d91ce9459013.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="796"></p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">xfs_repair -h
xfs_repair: invalid option -- 'h'
Usage: xfs_repair [options] device

Options:
-f The device is a file
-L Force log zeroing. Do this as a last resort.
-l logdev Specifies the device where the external log resides.
-m maxmem Maximum amount of memory to be used in megabytes.
-n No modify mode, just checks the filesystem for damage.
-P Disables prefetching.
-r rtdev Specifies the device where the realtime section resides.
-v Verbose output.
-c subopts Change filesystem parameters - use xfs_admin.
-o subopts Override default behaviour, refer to man page.
-t interval Reporting interval in minutes.
-d Repair dangerously.
-V Reports version and exits.</code></pre> 
<p></p> 
<p></p>
                ]]></description></item><item><title>内网DNS重要使用作用</title><link>http://www.cnblogs.com/heian99/archive/2022/03/12/15998578.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 12 Mar 2022 13:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/03/12/15998578.html</guid><description><![CDATA[
                    <h2 id="DNS服务简介：">DNS服务简介：</h2> 
<p>DNS(Domain Name System–域名系统),是因特网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。是一个应用层的协议DNS使用TCP和UDP端口53。</p> 
<p>DNS是一个分布式数据库,命名系统采用层次的逻辑结构,如同一颗倒置的树,这个逻辑的树形结构称为域名空间,由于DNS划分了域名空间,所以各机构可以使用自己的域名空间创建DNS信息.</p> 
<blockquote> 
 <p>注:DNS域名空间中,树的最大深度不得超过127层,树中每个节点最长可以存储63个字符.</p> 
</blockquote> 
<p>以上是在公网中的使用</p> 
<p>更详细介绍：<a href="https://cshihong.github.io/2018/10/15/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/" title="DNS服务器搭建与配置 | 曹世宏的博客">DNS服务器搭建与配置 | 曹世宏的博客</a></p> 
<p></p> 
<h2>DNS内网使用</h2> 
<p>首先，我们纯内网中，是不能过连接外网的环境的。</p> 
<p>但是纯内网也会有许多的IP和服务，我们该怎么来区分，总不能记录所有IP，所以我们需要自建内网的DNS，达到内网域名解析的效果。</p> 
<p></p> 
<p></p> 
<h2>DNS使用作用</h2> 
<p><strong>WHAT</strong>：DNS（域名系统）说白了，就是把一个域和IP地址做了一下绑定，如你在里机器里面输入 nslookup <a href="www.qq.com">www.qq.com</a>，出来的Address是一堆IP，IP是不容易记的，所以DNS让IP和域名做一下绑定，这样你输入域名就可以了</p> 
<p><strong>WHY</strong>：我们要用ingress，在K8S里要做7层调度，而且无论如何都要用域名（如之前的那个百度页面的域名，那个是host的方式），但是问题是我们怎么给K8S里的容器绑host，所以我们必须做一个DNS，然后容器服从我们的DNS解析调度</p> 
<p></p> 
<p>我们会在10.4.7.11 安装dns主服务，10.4.7.12作为备用dns服务</p> 
<p>也可以走一层keepalive虚拟IP。</p> 
<p><img alt="" height="534" src="https://img-blog.csdnimg.cn/5cc0cd46983c450a8dd5b52fd96b095d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1036"></p> 
<p>可以简单理解成：</p> 
<p>11机器：反向代理</p> 
<p>12机器：反向代理</p> 
<p>21机器：主控+运算节点（即服务群都是跑在21和22上）</p> 
<p>22机器：主控+运算节点（生产上我们会把主控和运算分开）</p> 
<p>200机器：运维主机（放各种文件资源）</p> 
<p>这样控节点有两个，运算节点有两个，就是小型的分布式，现在你可能没办法理解这些内容，我们接着做下去，慢慢的，你就理解了</p> 
<p><img alt="" height="484" src="https://img-blog.csdnimg.cn/9d341b2245e44548b910418e45e37d27.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1006">&nbsp;<img alt="" height="519" src="https://img-blog.csdnimg.cn/f95bc2b3fd604742ad3f46a9e0a990d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="997"></p> 
<p></p> 
<p></p> 
<h2>初始化</h2> 
<pre><code class="language-bash"># 查看enforce是否关闭，确保disabled状态，当然可能没有这个命令
~]# getforce
# 查看内核版本，确保在3.8以上版本
~]# uname -a
# 关闭firewalld
~]# systemctl stop firewalld
# 安装epel源及相关工具
~]# yum install epel-release -y
~]# yum install wget net-tools telnet tree nmap sysstat lrzsz dos2unix bind-utils -y</code></pre> 
<h2>&nbsp;</h2> 
<blockquote> 
 <p><strong>uname</strong>:显示系统信息</p> 
 <ul><li> <p><strong>-a/-all</strong>：显示全部</p> </li></ul>
 <p><strong>yum</strong>：提供了查找、安装、删除某一个、一组甚至全部软件包的命令</p> 
 <ul><li> <p><strong>install</strong>：安装</p> </li><li> <p><strong>-y</strong>：当安装过程提示选择全部为"yes"</p> </li></ul>
</blockquote> 
<h2>安装步骤&nbsp;</h2> 
<pre><code class="language-bash"># 在11机器：
~]# yum install bind -y
~]# rpm -qa bind
# out: bind-9.11.4-9.P2.el7.x86_64
# 配置主配置文件，11机器
~]# vi /etc/named.conf
listen-on port 53 { 10.4.7.11; };  # 原本是127.0.0.1
# listen-on-v6 port 53 { ::1; };  # 需要删掉
allow-query     { any; };  # 原本是locall
forwarders      { 10.4.7.254; };  #另外添加的
dnssec-enable no;  # 原本是yes
dnssec-validation no;  # 原本是yes

# 检查修改情况，没有报错即可（即没有信息）
~]# named-checkconf</code></pre> 
<p><img alt="" height="603" src="https://img-blog.csdnimg.cn/fa3f75b9297c4bda9446a5eea96eb746.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="980"></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<blockquote> 
 <p><strong>rpm</strong>：软件包管理器</p> 
 <ul><li> <p><strong>-qa</strong>：查看已安装的所有软件包</p> </li></ul>
 <p><strong>rpm和yum安装的区别</strong>：前者不检查相依性问题，后者检查（即相关依赖包）</p> 
 <p><strong>named.conf文件内容解析：</strong></p> 
 <ul><li> <p><strong>listen-on</strong>：监听端口，改为监听在内网，这样其它机器也可以用</p> </li><li> <p><strong>allow-query</strong>：哪些客户端能通过自建的DNS查</p> </li><li> <p><strong>forwarders</strong>：上级DNS是什么</p> </li></ul>
 <p></p> 
</blockquote> 
<pre><code class="language-bash"># 11机器，经验：主机域一定得跟业务是一点关系都没有，如host.com，而业务用的是od.com，因为业务随时可能变
# 区域配置文件，加在最下面
~]# vi /etc/named.rfc1912.zones
zone "host.com" IN {
        type  master;
        file  "host.com.zone";
        allow-update { 10.4.7.11; };
};

zone "od.com" IN {
        type  master;
        file  "od.com.zone";
        allow-update { 10.4.7.11; };
};</code></pre> 
<p><img alt="" height="626" src="https://img-blog.csdnimg.cn/3c2e103f1907498f9301f785637e95b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="992"></p> 
<p>&nbsp;</p> 
<pre><code class="language-bash"># 11机器：
# 注意serial行的时间，代表今天的时间+第一条记录：20200112+01
7-11 ~]# vi /var/named/host.com.zone
$ORIGIN host.com.
$TTL 600	; 10 minutes
@       IN SOA	dns.host.com. dnsadmin.host.com. (
				2020011201 ; serial
				10800      ; refresh (3 hours)
				900        ; retry (15 minutes)
				604800     ; expire (1 week)
				86400      ; minimum (1 day)
				)
			NS   dns.host.com.
$TTL 60	; 1 minute
dns                A    10.4.7.11
HDSS7-11           A    10.4.7.11
HDSS7-12           A    10.4.7.12
HDSS7-21           A    10.4.7.21
HDSS7-22           A    10.4.7.22
HDSS7-200          A    10.4.7.200

7-11 ~]# vi /var/named/od.com.zone
$ORIGIN od.com.
$TTL 600	; 10 minutes
@   		IN SOA	dns.od.com. dnsadmin.od.com. (
				2020011201 ; serial
				10800      ; refresh (3 hours)
				900        ; retry (15 minutes)
				604800     ; expire (1 week)
				86400      ; minimum (1 day)
				)
				NS   dns.od.com.
$TTL 60	; 1 minute
dns                A    10.4.7.11

# 看一下有没有报错
7-11 ~]# named-checkconf
7-11 ~]# systemctl start named
7-11 ~]# netstat -luntp|grep 53</code></pre> 
<blockquote> 
 <p><strong>TTL 600</strong>：指定IP包被路由器丢弃之前允许通过的最大网段数量</p> 
 <ul><li> <p><strong>10 minutes</strong>：过期时间10分钟</p> </li></ul>
 <p><strong>SOA</strong>：一个域权威记录的相关信息，后面有5组参数分别设定了该域相关部分</p> 
 <ul><li> <p><strong>dnsadmin.od.com.</strong> 一个假的邮箱</p> </li><li> <p><strong>serial</strong>：记录的时间</p> </li></ul>
 <p><strong>$ORIGIN</strong>：即下列的域名自动补充od.com，如dns，外面看来是dns.od.com</p> 
 <p><strong>netstat -luntp</strong>：显示 tcp,udp 的端口和进程等相关情况</p> 
</blockquote> 
<p><img alt="" height="396" src="https://img-blog.csdnimg.cn/e5d8352ea8014b0b84d145575825706d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="987">&nbsp;</p> 
<pre><code class="language-bash"># 11机器，检查主机域是否解析
7-11 ~]# dig -t A hdss7-21.host.com @10.4.7.11 +short
# 配置linux客户端和win客户端都能使用这个服务，修改
7-11 ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0
DNS1=10.4.7.11
7-11 ~]# systemctl restart network
7-11 ~]# ping www.baidu.com
7-11 ~]# ping hdss7-21.host.com</code></pre> 
<p>&nbsp;</p> 
<blockquote> 
 <p><strong>dig -t A</strong>：指的是找DNS里标记为A的相关记录，而后面会带上相关的域，如上面的hdss7-21.host.com，为什么外面配了HDSS7-21后面还会自动接上.host.com就是因为$ORIGIN，后面则是对应的IP</p> 
 <ul><li> <p><strong>+short</strong>：表示只返回IP</p> </li></ul>
</blockquote> 
<p>&nbsp;<img alt="" height="423" src="https://img-blog.csdnimg.cn/0b53fb98062c468c880f505207de3f2b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="980"></p> 
<pre><code class="language-bash"># 在所有机器添加search... ，即可使用短域名（我的是自带的）
~]# vi /etc/resolv.conf
~]# ping hdss7-200</code></pre> 
<p>&nbsp;<img alt="" height="157" src="https://img-blog.csdnimg.cn/52aa54db0528485583b7f66995f97f15.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_14,color_FFFFFF,t_70,g_se,x_16" width="430"></p> 
<p>&nbsp;</p> 
<pre><code class="language-bash"># 在非11机器上，全部改成11
~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0
DNS1=10.4.7.11

~]# systemctl restart network
# 试下网络是否正常
~]# ping baidu.com
# 其它机器尝试ping7-11机器
7-12 ~]# ping hdss7-11.host.com</code></pre> 
<p>让其它机器的DNS全部改成11机器的好处是，全部的机器访问外网就只有通过11端口，更好控制</p> 
<p><img alt="" height="408" src="https://img-blog.csdnimg.cn/7208f6e3d88e4f079787fa0e8f65b45f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="879">&nbsp;# 修改window网络，并ping</p> 
<p>&nbsp;<img alt="" height="776" src="https://img-blog.csdnimg.cn/2bb3f7059f2a46998441b414dbae5b89.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1056"></p> 
<p>&nbsp;<img alt="" height="434" src="https://img-blog.csdnimg.cn/421efbcdb8414ce390d8a738af3505f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="753"></p> 
<p>&nbsp;</p> 
<h2>后续域名解析</h2> 
<pre><code>[root@hdss7-11 ~]# cat /var/named/od.com.zone 
$ORIGIN od.com.
$TTL 600	; 10 minutes
@   		IN SOA	dns.od.com. dnsadmin.od.com. (
				2020011523 ; serial  #这个需要每次增加1
				10800      ; refresh (3 hours)
				900        ; retry (15 minutes)
				604800     ; expire (1 week)
				86400      ; minimum (1 day)
				)
				NS   dns.od.com.
$TTL 60	; 1 minute
dns                A    10.4.7.11
harbor             A    10.4.7.200
k8s-yaml           A    10.4.7.200
traefik            A    10.4.7.10
dashboard          A    10.4.7.10
zk1                A   10.4.7.11
zk2                A   10.4.7.12
zk3                A   10.4.7.21
jenkins            A   10.4.7.10
gitlab             A    10.4.7.200
dubbo-monitor      A    10.4.7.10
demo               A    10.4.7.10
config             A    10.4.7.10
mysql              A    10.4.7.11
portal             A    10.4.7.10
zk-test            A    10.4.7.11
zk-prod            A    10.4.7.12
config-test        A    10.4.7.10
config-prod        A    10.4.7.10
demo-test          A    10.4.7.10
demo-prod          A    10.4.7.10
blackbox           A    10.4.7.10
prometheus         A    10.4.7.10
grafana            A    10.4.7.10
km                 A    10.4.7.10
kibana             A    10.4.7.10
</code></pre> 
<p><img alt="" height="123" src="https://img-blog.csdnimg.cn/d513383889f24a618bd3dd6eb59f0504.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="722"></p> 
<p></p>
                ]]></description></item><item><title>Gin编写图床后端-上传图片代码实现</title><link>http://www.cnblogs.com/heian99/archive/2022/01/12/15806664.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 12 Jan 2022 02:43:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2022/01/12/15806664.html</guid><description><![CDATA[
                    <p>日常我们会使用到到图床来存放图片，但是大致流程是什么样子的来？？</p> 
<p><img alt="" height="901" src="https://img-blog.csdnimg.cn/aff15eb735a74259bfa1bd9ca3385e3f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="1000" src="https://img-blog.csdnimg.cn/fa0baa835e34495bb28f4ac30bba72cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="848" src="https://img-blog.csdnimg.cn/c2ccb53d36dc41bfab2a57da071d0111.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p> 
<h2>图床原理</h2> 
<p>实现一个HTTP服务器,用这个服务器存储图片,针对每个图片提供一个唯一的url,借助这个url就可以将图片展示到其他网页上</p> 
<p><img alt="" height="497" src="https://img-blog.csdnimg.cn/326f45711ced4e9a98f69f1a73c82d45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="864"></p> 
<p></p> 
<h2>后端代码实现</h2> 
<h2></h2> 
<p><img alt="" height="507" src="https://img-blog.csdnimg.cn/c3eb722b525840ba96312ecf7df883a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="927"></p> 
<h3>&nbsp;项目接口</h3> 
<p><img alt="" height="944" src="https://img-blog.csdnimg.cn/7696758e0e67412db0a967eb3bbbd498.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_17,color_FFFFFF,t_70,g_se,x_16" width="503"></p> 
<p>首先，我们需要建立Gin框架 post请求访问，上传图片，判断图片是否符合，在上传图片，返回Url地址，浏览器就可以正常访问</p> 
<h3>&nbsp;app.ini</h3> 
<pre><code class="language-Go">[app]
HttpPort = 8000

RuntimeRootPath = runtime/

ImagePrefixUrl = http://127.0.0.1:8000
ImageSavePath = upload/images/
# MB
ImageMaxSize = 5
ImageAllowExts = .jpg,.jpeg,.png,.gif

LogSavePath = logs/
LogSaveName = log
LogFileExt = log
TimeFormat = 20060102


</code></pre> 
<h3>app/upload.go</h3> 
<pre><code class="language-Go">package app

import (
	"ImagesUpload/pkg/e"
	"ImagesUpload/pkg/logging"
	"ImagesUpload/pkg/upload"
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
	"strconv"
	"time"
)
//获取ip
func GetRequestIP(c *gin.Context) string {
	reqIP := c.ClientIP()
	if reqIP == "::1" {
		reqIP = "127.0.0.1"
	}
	return reqIP
}

func UploadImage(c *gin.Context) {
	code := e.SUCCESS
	data := make(map[string]string)
	t := time.Now()
	year := t.Year()   // type int
	month := t.Month() // type time.Month
	file, image, err := c.Request.FormFile("image")
	if err != nil {
		logging.Warn(err)
		code = e.ERROR
		c.JSON(http.StatusOK, gin.H{
			"code": code,
			"msg":  e.GetMsg(code),
			"data": data,
		})
	}

	if image == nil {
		code = e.INVALID_PARAMS
	} else {
		imageName := upload.GetImageName(image.Filename)
		fullPath := upload.GetImageFullPath() + strconv.Itoa(year) + strconv.Itoa(int(month))
		savePath := upload.GetImagePath() + strconv.Itoa(year) + strconv.Itoa(int(month))
		src := fullPath + "/" + imageName
		fmt.Println(imageName, fullPath, savePath, src)
		if !upload.CheckImageExt(imageName) || !upload.CheckImageSize(file) {
			code = e.ERROR_UPLOAD_CHECK_IMAGE_FORMAT
			fmt.Println(e.GetMsg(code))
		} else {
			err := upload.CheckImage(fullPath)
			if err != nil {
				logging.Warn(err)
				code = e.ERROR_UPLOAD_CHECK_IMAGE_FAIL
			} else if err := c.SaveUploadedFile(image, src); err != nil {
				logging.Warn(err)
				code = e.ERROR_UPLOAD_SAVE_IMAGE_FAIL
			} else {
				logging.Info("访问者IP:",GetRequestIP(c),"上传地址连接:",upload.GetImageFullUrl(imageName))
				data["image_url"] = upload.GetImageFullUrl(imageName)
				data["image_save_url"] = savePath + "/" + imageName
			}
		}
	}
	c.JSON(http.StatusOK, gin.H{
		"code": code,
		"msg":  e.GetMsg(code),
		"data": data,
	})
}

</code></pre> 
<h3>pkg</h3> 
<p><img alt="" height="361" src="https://img-blog.csdnimg.cn/9bd502a205f0453ba404526c8d4bde0b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_10,color_FFFFFF,t_70,g_se,x_16" width="325"></p> 
<h3>&nbsp;pkg/e/code.go</h3> 
<pre><code class="language-Go">package e

const  (
	SUCCESS        = 200
	ERROR          = 500
	INVALID_PARAMS = 400
	// 保存图片失败
	ERROR_UPLOAD_SAVE_IMAGE_FAIL = 30001
	// 检查图片失败
	ERROR_UPLOAD_CHECK_IMAGE_FAIL = 30002
	// 校验图片错误，图片格式或大小有问题
	ERROR_UPLOAD_CHECK_IMAGE_FORMAT = 30003
)</code></pre> 
<h3>pkg/e/msg.go</h3> 
<pre><code class="language-Go">package e

var MsgFlags = map[int]string {
	SUCCESS:                        "ok",
	ERROR:                          "fail",
	INVALID_PARAMS:                 "请求参数错误",
	// 保存图片失败
	ERROR_UPLOAD_SAVE_IMAGE_FAIL: "保存图片失败",
	// 检查图片失败
	ERROR_UPLOAD_CHECK_IMAGE_FAIL: "检查图片失败",
	// 校验图片错误，图片格式或大小有问题
	ERROR_UPLOAD_CHECK_IMAGE_FORMAT: "校验图片错误，图片格式或大小有问题",
}

func GetMsg(code int) string {
	msg ,ok := MsgFlags[code]
	if ok{
		return msg
	}
	return MsgFlags[ERROR]
}</code></pre> 
<h3>pkg/file/file.go</h3> 
<pre><code class="language-Go">package file

import (
	"io/ioutil"
	"mime/multipart"
	"os"
	"path"
)

/*
GetSize：获取文件大小
GetExt：获取文件后缀
CheckNotExist：检查文件是否存在
CheckPermission：检查文件权限
IsNotExistMkDir：如果不存在则新建文件夹
MkDir：新建文件夹
Open：打开文件
*/
//GetSize：获取文件大小
func GetSize(f multipart.File) (int, error) {
	content, err := ioutil.ReadAll(f)

	return len(content), err
}

//GetExt：获取文件后缀
func GetExt(fileName string) string {
	return path.Ext(fileName)
}

//CheckNotExist：检查文件是否存在
func CheckNotExist(src string) bool {
	_, err := os.Stat(src)

	return os.IsNotExist(err)
}

//CheckPermission：检查文件权限
func CheckPermission(src string) bool {
	_, err := os.Stat(src)

	return os.IsPermission(err)
}

//IsNotExistMkDir：如果不存在则新建文件夹
func IsNotExistMkDir(src string) error {
	if notExist := CheckNotExist(src); notExist == true {
		if err := MkDir(src); err != nil {
			return err
		}
	}

	return nil
}

//MkDir：新建文件夹
func MkDir(src string) error {
	err := os.MkdirAll(src, os.ModePerm)
	if err != nil {
		return err
	}

	return nil
}

//Open：打开文件
func Open(name string, flag int, perm os.FileMode) (*os.File, error) {
	f, err := os.OpenFile(name, flag, perm)
	if err != nil {
		return nil, err
	}

	return f, nil
}
</code></pre> 
<h3>pkg/logging/file.go</h3> 
<pre><code class="language-Go">package logging

import (
	"ImagesUpload/pkg/file"
	"ImagesUpload/setting"
	"fmt"
	"os"
	"time"
)

func getLogFilePath() string {
	return fmt.Sprintf("%s%s", setting.AppSetting.RuntimeRootPath, setting.AppSetting.LogSavePath)
}

func getLogFileName() string {
	return fmt.Sprintf("%s%s.%s",
		setting.AppSetting.LogSaveName,
		time.Now().Format(setting.AppSetting.TimeFormat),
		setting.AppSetting.LogFileExt,
	)
}

func openLogFile(fileName, filePath string) (*os.File, error) {
	dir, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("os.Getwd err: %v", err)
	}

	src := dir + "/" + filePath
	perm := file.CheckPermission(src)
	if perm == true {
		return nil, fmt.Errorf("file.CheckPermission Permission denied src: %s", src)
	}

	err = file.IsNotExistMkDir(src)
	if err != nil {
		return nil, fmt.Errorf("file.IsNotExistMkDir src: %s, err: %v", src, err)
	}

	f, err := file.Open(src+fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return nil, fmt.Errorf("Fail to OpenFile :%v", err)
	}

	return f, nil
}
</code></pre> 
<h3>pkg/logging/log.go</h3> 
<pre><code class="language-Go">package logging

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
)


type Level int

var (
	F *os.File

	DefaultPrefix      = ""
	DefaultCallerDepth = 2

	logger     *log.Logger
	logPrefix  = ""
	levelFlags = []string{"DEBUG", "INFO", "WARN", "ERROR", "FATAL"}
)

const (
	DEBUG Level = iota
	INFO
	WARNING
	ERROR
	FATAL
)

func Setup() {
	var err error
	filePath := getLogFilePath()
	fileName := getLogFileName()
	F, err = openLogFile(fileName, filePath)
	if err != nil {
		log.Fatalln(err)
	}

	logger = log.New(F, DefaultPrefix, log.LstdFlags)
}

func Debug(v ...interface{}) {
	setPrefix(DEBUG)
	logger.Println(v)
}

func Info(v ...interface{}) {
	setPrefix(INFO)
	logger.Println(v)
}

func Warn(v ...interface{}) {
	setPrefix(WARNING)
	logger.Println(v)
}

func Error(v ...interface{}) {
	setPrefix(ERROR)
	logger.Println(v)
}

func Fatal(v ...interface{}) {
	setPrefix(FATAL)
	logger.Fatalln(v)
}

func setPrefix(level Level) {
	_, file, line, ok := runtime.Caller(DefaultCallerDepth)
	if ok {
		logPrefix = fmt.Sprintf("[%s][%s:%d]", levelFlags[level], filepath.Base(file), line)
	} else {
		logPrefix = fmt.Sprintf("[%s]", levelFlags[level])
	}

	logger.SetPrefix(logPrefix)
}
</code></pre> 
<h3>pkg/logging/logrus.go</h3> 
<pre><code class="language-Go">package logging

import (
	"fmt"
	"github.com/sirupsen/logrus"
)

func Logger() *logrus.Logger {
	//now := time.Now()
	//logFilePath := getLogFilePath()
	//logFileName :=  getLogFileFullPath()
	//日志文件
	//fileName := path.Join(logFilePath, logFileName)
	//if _, err := os.Stat(fileName); err != nil {
	//	if _, err := os.Create(fileName); err != nil {
	//		fmt.Println(err.Error())
	//	}
	//}
	//写入文件
	filePath := getLogFilePath()
	fileName := getLogFileName()
	F, err := openLogFile(fileName, filePath)
	if err != nil {
		fmt.Println("日志写入失败，请检查")
	}
	//实例化
	logger := logrus.New()

	//设置输出
	logger.Out = F

	//设置日志级别
	logger.SetLevel(logrus.DebugLevel)

	//设置日志格式
	logger.SetFormatter(&amp;logrus.TextFormatter{
		TimestampFormat: "2006-01-02 15:04:05",
	})
	return logger
}
</code></pre> 
<h3>pkg/upload/image.go</h3> 
<pre><code class="language-Go">package upload

import (
	"ImagesUpload/pkg/file"
	"ImagesUpload/pkg/logging"
	"ImagesUpload/pkg/util"
	"ImagesUpload/setting"
	"fmt"
	"log"
	"mime/multipart"
	"os"
	"path"
	"strconv"
	"strings"
	"time"
)

/*
GetImageFullUrl：获取图片完整访问 URL
GetImageName：获取图片名称
GetImagePath：获取图片路径
GetImageFullPath：获取图片完整路径
CheckImageExt：检查图片后缀
CheckImageSize：检查图片大小
CheckImage：检查图片
*/

//GetImageFullUrl：获取图片完整访问 URL
func GetImageFullUrl(name string) string {
	t := time.Now()
	year := t.Year()   // type int
	month := t.Month() // type time.Month
	return setting.AppSetting.ImagePrefixUrl + "/" + GetImagePath() + strconv.Itoa(year) + strconv.Itoa(int(month)) + "/" + name
}

//GetImageName：获取图片名称
func GetImageName(name string) string {
	ext := path.Ext(name)
	fileName := strings.TrimSuffix(name, ext)
	fileName = util.EncodeMD5(fileName)

	return fileName + ext
}

//GetImagePath：获取图片路径
func GetImagePath() string {
	return setting.AppSetting.ImageSavePath
}

//GetImageFullPath：获取图片完整路径
func GetImageFullPath() string {
	return setting.AppSetting.RuntimeRootPath + GetImagePath()
}

//CheckImageExt：检查图片后缀
func CheckImageExt(fileName string) bool {
	ext := file.GetExt(fileName)
	for _, allowExt := range setting.AppSetting.ImageAllowExts {
		if strings.ToUpper(allowExt) == strings.ToUpper(ext) {
			return true
		}
	}

	return false
}

//CheckImageSize：检查图片大小
func CheckImageSize(f multipart.File) bool {
	size, err := file.GetSize(f)
	if err != nil {
		log.Println(err)
		logging.Warn(err)
		return false
	}

	return size &lt;= setting.AppSetting.ImageMaxSize
}

//CheckImage：检查图片
func CheckImage(src string) error {
	dir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("os.Getwd err: %v", err)
	}

	err = file.IsNotExistMkDir(dir + "/" + src)
	if err != nil {
		return fmt.Errorf("file.IsNotExistMkDir err: %v", err)
	}

	perm := file.CheckPermission(src)
	if perm == true {
		return fmt.Errorf("file.CheckPermission Permission denied src: %s", src)
	}

	return nil
}
</code></pre> 
<h3>pkg/util/md5.go</h3> 
<pre><code class="language-Go">package util

import (
	"crypto/md5"
	"encoding/hex"
)

func EncodeMD5(value string) string {
	m := md5.New()
	m.Write([]byte(value))
	return hex.EncodeToString(m.Sum(nil))
}
</code></pre> 
<h3>routers/router.go</h3> 
<pre><code class="language-Go">package routers

import (
	"ImagesUpload/app"
	"ImagesUpload/pkg/upload"
	"github.com/gin-gonic/gin"
	"net/http"
)

func InitRouter() *gin.Engine {
	r := gin.New()

	r.Use(gin.Logger())

	r.Use(gin.Recovery())
	r.StaticFS("/upload/images", http.Dir(upload.GetImageFullPath()))
	r.POST("upload", app.UploadImage)
	return r
}
</code></pre> 
<h3>setting/setting.go</h3> 
<pre><code class="language-Go">package setting

import (
	"github.com/go-ini/ini"
	"log"
)

type App struct {
	HttpPort int
	RuntimeRootPath string

	ImagePrefixUrl string
	ImageSavePath  string
	ImageMaxSize   int
	ImageAllowExts []string

	LogSavePath string
	LogSaveName string
	LogFileExt  string
	TimeFormat  string
}

var AppSetting = &amp;App{}

func Setup() {
	Cfg, err := ini.Load("conf/app.ini")
	if err != nil {
		log.Fatalf("Fail to parse 'conf/app.ini': %v", err)
	}

	err = Cfg.Section("app").MapTo(AppSetting)
	if err != nil {
		log.Fatalf("Cfg.MapTo AppSetting err: %v", err)
	}
	AppSetting.ImageMaxSize = AppSetting.ImageMaxSize * 1024 * 1024
}</code></pre> 
<h3>main.go</h3> 
<pre><code class="language-Go">package main

import (
	"ImagesUpload/pkg/logging"
	"ImagesUpload/routers"
	"ImagesUpload/setting"
	"fmt"
	"log"
	"net/http"
)

func main() {
	setting.Setup()
	logging.Setup()
	router := routers.InitRouter()
	fmt.Println("启动端口：", setting.AppSetting.HttpPort)
	s := &amp;http.Server{
		Addr:           fmt.Sprintf(":%d", setting.AppSetting.HttpPort),
		Handler:        router,
	}
	if err := s.ListenAndServe(); err != nil {
		log.Printf("Listen: %s\n", err)
	}
}
</code></pre> 
<p></p>
                ]]></description></item><item><title>Gin框架组合（Zap、lumberjack、ini）使用手册</title><link>http://www.cnblogs.com/heian99/archive/2021/12/30/15778062.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 30 Dec 2021 08:43:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/12/30/15778062.html</guid><description><![CDATA[
                    <h2>Gin</h2> 
<p>Gin是一个golang的微框架，封装比较优雅，API友好，源码注释比较明确，已经发布了1.0版本。具有快速灵活，容错方便等特点。其实对于golang而言，web框架的依赖要远比Python，Java之类的要小。自身的net/http足够简单，性能也非常不错。框架更像是一些常用函数或者工具的集合。借助框架开发，不仅可以省去很多常用的封装带来的时间，也有助于团队的编码风格和形成规范。</p> 
<p>下面就Gin的用法做一个简单的介绍。</p> 
<p>首先需要安装，安装比较简单，使用go get即可：</p> 
<pre><code class="language-Go">go get gopkg.in/gin-gonic/gin.v1</code></pre> 
<pre><code class="language-Go">import (
    "gopkg.in/gin-gonic/gin.v1"
    "net/http"
)

func main(){
    
    router := gin.Default()

    router.GET("/", func(c *gin.Context) {
        c.String(http.StatusOK, "Hello World")
    })
    router.Run(":8000")
}</code></pre> 
<p>日常我们是使用Gin框架编写接口等等，可能会使用到一下几种组件。</p> 
<p><strong>Zap 日志记录</strong></p> 
<p><strong>lumberjack 日志切割</strong></p> 
<p><strong>ini 配置文件读取</strong></p> 
<h2>ini配置读取</h2> 
<p>下载</p> 
<pre><code class="language-Go">go get github.com/go-ini/ini</code></pre> 
<p>因为项目中要是到配置文件，我们可以采用ini模块来实现</p> 
<p>首先，创建一个<code>config.ini</code>配置文件：</p> 
<p><img alt="" height="616" src="https://img-blog.csdnimg.cn/e7a104fe1c93453b82ba53147f721889.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_16,color_FFFFFF,t_70,g_se,x_16" width="487"></p> 
<p></p> 
<pre><code class="language-Go">port = 9000
release = false

[mysql]
user = db1
password = db1
host = 10.10.10.6
port = 3306
db = db1

[log]
level = debug
filename = ./logs/info.log
maxsize = 1
max_age = 30
max_backups = 5</code></pre> 
<p></p> 
<pre><code class="language-Go">package setting

import (
	"gopkg.in/ini.v1"
)

var Conf = new(AppConfig)

// AppConfig 应用程序配置
type AppConfig struct {
	Release      bool `ini:"release"`
	Port         int  `ini:"port"`
	*MySQLConfig `ini:"mysql"`
	*LogConfig   `ini:"log"`
}

// MySQLConfig 数据库配置
type MySQLConfig struct {
	User     string `ini:"user"`
	Password string `ini:"password"`
	DB       string `ini:"db"`
	Host     string `ini:"host"`
	Port     int    `ini:"port"`
}

type LogConfig struct {
	Level      string `ini:"level"`
	Filename   string `ini:"filename"`
	MaxSize    int    `ini:"maxsize"`
	MaxAge     int    `ini:"max_age"`
	MaxBackups int    `ini:"max_backups"`
}

//把先关初始的参数加载到全局变量，然后方便调用
func Init(file string) error {
	return ini.MapTo(Conf, file)
}
</code></pre> 
<p>看一下调用方式</p> 
<pre><code class="language-Go">	// 传入配置文件路径，加载配置文件,
	if err := setting.Init("conf/config.ini"); err != nil {
		fmt.Printf("load config from file failed, err:%v\n", err)
		return
	}
	fmt.Println("config.ini配置加载成功", setting.Conf.Port)

	// 创建数据库
	// sql: CREATE DATABASE bubble;
	// 连接数据库
	err := dao.InitMySQL(setting.Conf.MySQLConfig)
	if err != nil {
		fmt.Printf("init mysql failed, err:%v\n", err)
		return
	}
	fmt.Println("数据库配置初始化加载成功", setting.Conf.MySQLConfig)
	if err := log.InitLogger(setting.Conf.LogConfig); err != nil {
		fmt.Printf("init logger failed, err:%v\n", err)
		return
	}</code></pre> 
<p>已经加载全局变量，可以正常使用</p> 
<p><img alt="" height="187" src="https://img-blog.csdnimg.cn/0e5409fb0f9741dab93d294b99bfb862.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p></p> 
<p>mysql调用参数，</p> 
<pre><code class="language-Go">func InitMySQL(cfg *setting.MySQLConfig) (err error) {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local",
		cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.DB)

	DB, err = gorm.Open("mysql", dsn)
	if err != nil {
		return
	}
	DB.Debug()
	DB.LogMode(true)
	DB.SetLogger(&amp;GormLogger{})
	return DB.DB().Ping()
}</code></pre> 
<h2>Zap和<strong>lumberjack </strong></h2> 
<p><strong>Zap 日志记录</strong></p> 
<p><strong>lumberjack 日志切割</strong></p> 
<pre><code class="language-Go">go get -u go.uber.org/zap
go get -u github.com/natefinch/lumberjack</code></pre> 
<p><strong>大家可以参考</strong></p> 
<p><a href="https://www.cnblogs.com/feixiangmanon/p/11109174.html" title="golang开发:类库篇(一) Zap高性能日志类库的使用 - 飞翔码农 - 博客园">golang开发:类库篇(一) Zap高性能日志类库的使用 - 飞翔码农 - 博客园</a><a href="https://www.fdevops.com/2020/08/24/go-gin-zap" title="使用zap接收gin框架默认的日志并配置日志归档 - 兰玉磊的个人博客">使用zap接收gin框架默认的日志并配置日志归档 - 兰玉磊的个人博客</a><a href="https://www.cnblogs.com/feixiangmanon/p/11109174.html" title="golang开发:类库篇(一) Zap高性能日志类库的使用 - 飞翔码农 - 博客园">golang开发:类库篇(一) Zap高性能日志类库的使用 - 飞翔码农 - 博客园</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/88856378?utm_source=wechat_session" title="在Go语言项目中使用Zap日志库 - 知乎">在Go语言项目中使用Zap日志库 - 知乎</a></p> 
<p>日志格式</p> 
<pre><code class="language-Go">{"level":"INFO","time":"2021-12-28T15:34:50.934+0800","caller":"log/logger.go:65","msg":"/","status":200,"method":"GET","path":"/","query":"","ip":"127.0.0.1","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36","errors":"","cost":0.0010676}
{"level":"DEBUG","time":"2021-12-28T15:34:51.194+0800","caller":"dao/mysql.go:23","msg":"sql","module":"gorm","type":"sql","src":"D:/桌面/bubble/models/todo.go:24","duration":0.0504676,"sql":"SELECT * FROM `todos`  ","values":null,"rows_returned":3}
</code></pre> 
<p>我们需要把它集成到Gin框架中。</p> 
<p></p> 
<p><img alt="" height="546" src="https://img-blog.csdnimg.cn/1dcf8443b73045f09e0c064a4ee34c5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_16,color_FFFFFF,t_70,g_se,x_16" width="493"></p> 
<p>我这边的配置，也会读取ini的文件（看上面的代码）</p> 
<pre><code class="language-Go">[log]
level = debug
filename = ./logs/info.log
maxsize = 1
max_age = 30
max_backups = 5







type LogConfig struct {
	Level      string `ini:"level"`
	Filename   string `ini:"filename"`
	MaxSize    int    `ini:"maxsize"`
	MaxAge     int    `ini:"max_age"`
	MaxBackups int    `ini:"max_backups"`
}
</code></pre> 
<pre><code class="language-Go">package log

import (
	"bubble/setting"
	"github.com/gin-gonic/gin"
	"github.com/natefinch/lumberjack"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"net"
	"net/http"
	"net/http/httputil"
	"os"
	"runtime/debug"
	"strings"
	"time"
)

var Logger *zap.Logger

// InitLogger 初始化Logger
func InitLogger(cfg *setting.LogConfig) (err error) {
	writeSyncer := getLogWriter(cfg.Filename, cfg.MaxSize, cfg.MaxBackups, cfg.MaxAge)
	//fmt.Println(cfg.Filename)
	encoder := getEncoder()
	var l = new(zapcore.Level)
	err = l.UnmarshalText([]byte(cfg.Level))
	if err != nil {
		return
	}
	core := zapcore.NewCore(encoder, writeSyncer, l)

	Logger = zap.New(core, zap.AddCaller())
	return
}

func getEncoder() zapcore.Encoder {
	encoderConfig := zap.NewProductionEncoderConfig()
	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	encoderConfig.TimeKey = "time"
	encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
	encoderConfig.EncodeDuration = zapcore.SecondsDurationEncoder
	encoderConfig.EncodeCaller = zapcore.ShortCallerEncoder

	return zapcore.NewJSONEncoder(encoderConfig)
}

func getLogWriter(filename string, maxSize, maxBackup, maxAge int) zapcore.WriteSyncer {
	lumberJackLogger := &amp;lumberjack.Logger{
		Filename:  filename,
		MaxSize:    maxSize,
		MaxBackups: maxBackup,
		MaxAge:     maxAge,
	}
	return zapcore.AddSync(lumberJackLogger)
}

// GinLogger 接收gin框架默认的日志
func GinLogger(logger *zap.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		query := c.Request.URL.RawQuery
		c.Next()

		cost := time.Since(start)
		logger.Info(path,
			zap.Int("status", c.Writer.Status()),
			zap.String("method", c.Request.Method),
			zap.String("path", path),
			zap.String("query", query),
			zap.String("ip", c.ClientIP()),
			zap.String("user-agent", c.Request.UserAgent()),
			zap.String("errors", c.Errors.ByType(gin.ErrorTypePrivate).String()),
			zap.Duration("cost", cost),
		)
	}
}

// GinRecovery recover掉项目可能出现的panic，并使用zap记录相关日志
func GinRecovery(logger *zap.Logger, stack bool) gin.HandlerFunc {
	return func(c *gin.Context) {
		defer func() {
			if err := recover(); err != nil {
				// Check for a broken connection, as it is not really a
				// condition that warrants a panic stack trace.
				var brokenPipe bool
				if ne, ok := err.(*net.OpError); ok {
					if se, ok := ne.Err.(*os.SyscallError); ok {
						if strings.Contains(strings.ToLower(se.Error()), "broken pipe") || strings.Contains(strings.ToLower(se.Error()), "connection reset by peer") {
							brokenPipe = true
						}
					}
				}

				httpRequest, _ := httputil.DumpRequest(c.Request, false)
				if brokenPipe {
					logger.Error(c.Request.URL.Path,
						zap.Any("error", err),
						zap.String("request", string(httpRequest)),
					)
					// If the connection is dead, we can't write a status to it.
					c.Error(err.(error)) // nolint: errcheck
					c.Abort()
					return
				}

				if stack {
					logger.Error("[Recovery from panic]",
						zap.Any("error", err),
						zap.String("request", string(httpRequest)),
						zap.String("stack", string(debug.Stack())),
					)
				} else {
					logger.Error("[Recovery from panic]",
						zap.Any("error", err),
						zap.String("request", string(httpRequest)),
					)
				}
				c.AbortWithStatus(http.StatusInternalServerError)
			}
		}()
		c.Next()
	}
}</code></pre> 
<p>注册中间件的操作在<code>routes.SetupRouter()</code>中：</p> 
<pre><code class="language-Go">func SetupRouter() *gin.Engine {
	if setting.Conf.Release {
		gin.SetMode(gin.ReleaseMode)
	}
    #开始调用，中间件使用
	r := gin.New()
	r.Use(log.GinLogger(log.Logger), log.GinRecovery(log.Logger, true))

}</code></pre> 
<p><img alt="" height="412" src="https://img-blog.csdnimg.cn/7a42676173a541ed96715b5dd128deca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1086"></p> 
<p>&nbsp;main中调用</p> 
<pre><code class="language-Go">	log.Logger.Debug("大家好，日志展示")
	defer log.Logger.Sync()</code></pre> 
<pre><code class="language-Go">{"level":"DEBUG","time":"2021-12-28T15:34:42.647+0800","caller":"bubble/main.go:39","msg":"大家好，日志展示"}</code></pre> 
<p>日志格式可以定义json格式，后期可以直接接入elk分析展示日志</p> 
<p></p> 
<h2>Gorm的sql日志记录到文本</h2> 
<p>Gorm 建立了对 Logger 的支持，默认模式只会在错误发生的时候打印日志。可以通过gorm SetLogger(log logger)方法 改变gorm 打日志的行为。</p> 
<p>gorm 中 logger的接口：</p> 
<pre><code class="language-Go">type logger interface {
	Print(ctx context.Context, v ...interface{})
}

v 的值为：

1个参数： level，表示这个是个什么请求，可以是“sql”
2个参数：打印sql的代码行号，如/Users/yejianfeng/Documents/gopath/src/gorm-log/main.go:50, 
3个参数: 执行时间戳
4个参数: sql语句
5参数：如果有预处理，请求参数，第六个参数是这个sql影响的行数。</code></pre> 
<p>zaplog集成示例</p> 
<pre><code class="language-Go">DB.Debug()
DB.LogMode(true)
DB.SetLogger(&amp;GormLogger{})

// GormLogger struct
type GormLogger struct{}

// Print - Log Formatter
func (*GormLogger) Print(v ...interface{}) {
	switch v[0] {
	case "sql":
		log.Debug(
			"sql",
			zap.String("module", "gorm"),
			zap.String("type", "sql"),
			zap.Any("src", v[1]),
			zap.Any("duration", v[2]),
			zap.Any("sql", v[3]),
			zap.Any("values", v[4]),
			zap.Any("rows_returned", v[5]),
		)
	case "log":
		log.Debug("log", zap.Any("gorm", v[2]))
	}
}</code></pre> 
<p><img alt="" height="838" src="https://img-blog.csdnimg.cn/fa1ab3c8fd31455aa284eb37f1844d8b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1093"></p> 
<p>&nbsp;日志格式，sql语句已经打印到日志中</p> 
<pre><code class="language-Go">{"level":"DEBUG","time":"2021-12-28T15:34:51.194+0800","caller":"dao/mysql.go:23","msg":"sql","module":"gorm","type":"sql","src":"D:/桌面/bubble/models/todo.go:24","duration":0.0504676,"sql":"SELECT * FROM `todos`  ","values":null,"rows_returned":3}
</code></pre> 
<p>参考文档&nbsp;<a href="https://www.cnblogs.com/tomtellyou/p/13230163.html" title="GORM自定义日志配置 - 苍山落暮 - 博客园">GORM自定义日志配置 - 苍山落暮 - 博客园</a></p> 
<p></p>
                ]]></description></item><item><title>Zabbix监控集群操作用户“登录失败次数“和“失败日志记录“</title><link>http://www.cnblogs.com/heian99/archive/2021/12/29/15778063.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 29 Dec 2021 07:28:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/12/29/15778063.html</guid><description><![CDATA[
                    <p>近期，快要邻近春节，安全方面更加重要。</p> 
<p>首先要对操作系统的用户做安全监控，防止操作系统账号被爆破泄露，我们也要监控起来。</p> 
<p>（1）Zabbix记录每分钟日志登录失败的次数</p> 
<p>（2）Zabbix记录登录失败用户的信息，方便查看</p> 
<p></p> 
<p>首先，我们<strong>整个集群日志，通过rsyslog服务，把上千台的日志同步到一台上</strong>，所以我们只需要<strong>监控</strong>这个<strong>rsyslog的服务端</strong>就可以了。&nbsp;</p> 
<p><strong>看效果图（这样一来，十分方便查看记录）</strong></p> 
<p><img alt="" height="198" src="https://img-blog.csdnimg.cn/6a7d4549874b4a959571845d3f2fa003.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p></p> 
<p><img alt="" height="325" src="https://img-blog.csdnimg.cn/564c1453257f493cb99fce1b459db4ca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p><img alt="" height="616" src="https://img-blog.csdnimg.cn/3e0e111a599747cda1a046503b0acace.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="668" src="https://img-blog.csdnimg.cn/24a757410f8d4203ba7bb6e240216519.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<h2>（1）&nbsp;登录失败次数</h2> 
<p>日志格式</p> 
<pre><code class="language-bash">2021-12-29T15:04:16.264895+08:00 127.0.0.1 [sshd] notice: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=172.17.9.200  user=deployer
</code></pre> 
<p>编写代码的脚本</p> 
<pre><code class="language-bash">#!/bin/bash
 
LOG_PATH="/var/log/secure"
mon=$(date +%B)
h=$(date +%d)
ms=$(date +%H:%M)
#表示字符开头为0就替换为空
h=${h/#0/""}
k="T"  #我这边有T，有的是空格，根据时间环境使用
count=`grep "$h$k$ms" /var/log/secure | grep -v sudo | grep -c "authentication failure" `
echo $count
</code></pre> 
<p>修改zabbix客户端配置</p> 
<pre><code class="language-bash">#====================检查 账号登录失败次数======================
UserParameter=check_failed,sh /usr/local/zabbix-v503/scripts/check_failed.sh</code></pre> 
<p>重启zabbix客户端</p> 
<p></p> 
<p></p> 
<p>zabbix界面配置</p> 
<p>检查配置</p> 
<p><img alt="" height="706" src="https://img-blog.csdnimg.cn/6e8be05c7a5a4c9eb61b4cd7aaa3c25d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1171"></p> 
<p>&nbsp;触发器</p> 
<p><img alt="" height="712" src="https://img-blog.csdnimg.cn/f7394203d3b941a7b844df9f1e528768.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1046"></p> 
<p></p> 
<h2>（2）失败日志记录</h2> 
<p>编写脚本</p> 
<pre><code class="language-bash">[root@logserver01 zabbix-v503]# cat scripts/check_failedlog.sh 
#!/bin/bash
 
LOG_PATH="/var/log/secure"
mon=$(date +%B)
h=$(date +%d)
#获取前一分钟的爆破日志记录的时间  时:分
ms=$(date -d "1 minute ago" +"%H:%M")
#表示字符开头为0就替换为空
h=${h/#0/""}
k="T"
grep "$h$k$ms" /var/log/secure | grep -v sudo | grep "authentication failure" &gt;&gt; /usr/local/zabbix-v503/scripts/fail.log
</code></pre> 
<p>开启定时任务（每分钟检查一次）</p> 
<pre><code class="language-bash">#-------check_fail_user_log-----------------
* * * * * sh /usr/local/zabbix-v503/scripts/check_failedlog.sh
</code></pre> 
<p></p> 
<p>如果有登录失败的，会单独过滤出来</p> 
<p><img alt="" height="199" src="https://img-blog.csdnimg.cn/93f99c7a00fb46168a72df8420e5ef25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>zabbix界面配置</p> 
<pre><code class="language-bash">log[/usr/local/zabbix-v503/scripts/fail.log,"sshd",skip,]</code></pre> 
<p><img alt="" height="719" src="https://img-blog.csdnimg.cn/4619ce4636234a6ab3bc0fda75c04595.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1003"></p> 
<p>已经完成相关的项目类容，很容易监控。</p> 
<p><img alt="" height="243" src="https://img-blog.csdnimg.cn/9494914d2d8d46b0a082618d7d20ab23.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_17,color_FFFFFF,t_70,g_se,x_16" width="521"></p> 
<p>&nbsp;根据触发器，可以设置值，如果每分钟爆破登录失败10次，就报警，有爆破的嫌疑</p>
                ]]></description></item><item><title>Gin编写邮件告警接口（添加配置，项目拆分）</title><link>http://www.cnblogs.com/heian99/archive/2021/12/25/15730500.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 25 Dec 2021 06:13:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/12/25/15730500.html</guid><description><![CDATA[
                    <p>相关代码已经放在github：<a href="https://github.com/nangongchengfeng/Go_gin/tree/main/Projects" title="https://github.com/nangongchengfeng/Go_gin/tree/main/Projects">https://github.com/nangongchengfeng/Go_gin/tree/main/Projects</a></p> 
<h1 id="articleContentId"><a href="https://blog.csdn.net/heian_99/article/details/121851358" title="GO的WEB编程（GIN实现邮件接口报警）">GO的WEB编程（GIN实现邮件接口报警）</a></h1> 
<h1><a name="t1" title=""></a><a href="https://blog.csdn.net/heian_99/article/details/121912558" title="Gin编写邮件接口（支持多人发送）">Gin编写邮件接口（支持多人发送）</a></h1> 
<h1><a class="link-info" href="https://blog.csdn.net/heian_99/article/details/122002534">Gin编写邮件告警接口（添加优化日志记录）</a></h1> 
<p>上面3个已经完成基本功能，但是所有的代码放在一个main，配置也是写死代码里面，不方便修改调整。现在在以上的基础上添加新的功能</p> 
<p>（1）加入配置文件读写管理</p> 
<p>（2）项目拆分</p> 
<p><img alt="" height="326" src="https://img-blog.csdnimg.cn/5382794c033f4210b84879dd4452691a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_10,color_FFFFFF,t_70,g_se,x_16" width="310"></p> 
<p><img alt="" height="280" src="https://img-blog.csdnimg.cn/db9992ac409e427793ece1be415d2daf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="634"></p> 
<p>&nbsp;</p> 
<p>因为日常范围，我们在操作系统上，需要报警时，只能采用mailx来使用。需要配置账号，密码，和邮箱认证。如果需要多台使用的话，岂不是很麻烦，要配置多台，这个导致密码很不安全，容易泄露。所以，为了安全，有效，更方便，我们可以采用接口发送邮件。</p> 
<p>（1）构建接口</p> 
<p>（2）传入post的json情况</p> 
<p>（3）把相应json转换字符</p> 
<p>（4）发送邮件</p> 
<p><strong>开始下面项目规划</strong></p> 
<p><img alt="" height="340" src="https://img-blog.csdnimg.cn/9cef939227f448cabc4de66fb4efc232.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="564"></p> 
<p>&nbsp;</p> 
<h2><strong>main.go</strong></h2> 
<pre><code class="language-Go">package main

import (
	"code/mail_qq/log"
	"code/mail_qq/routers"
	"code/mail_qq/setting"
	"fmt"
)

/*
支持多人发送
curl http://10.10.10.3:7070/send -H "Content-Type:application/json" -X POST -d '{"source":"heian","contacts":["账号@mail_qq.com","账号@mail_qq.com"],"subject":"多人测试","content":"现在进行多人测试"}'

*/

/*
zapcore.Core需要三个配置——Encoder，WriteSyncer，LogLevel
Encoder:编码器(如何写入日志)。我们将使用开箱即用的NewJSONEncoder()
WriterSyncer ：指定日志将写到哪里去。我们使用zapcore.AddSync()
Log Level：哪种级别的日志将被写入。
*/
//var sugarLogger *zap.SugaredLogger

func main() {
	log.InitLogger()
	defer log.SugarLogger.Sync()
	port := setting.GetPort()
	r := routers.SetupRouter()
	r.Run(":" + fmt.Sprint(port))
	log.SugarLogger.Infof("Success! Port is start")
	//r.Run(":8080")

}
</code></pre> 
<h2>conf/<strong>config.ini</strong></h2> 
<pre><code>port = 8080
[mail]
user = 账号@qq.com
password = 密码
host = smtp.qq.com:25
source = heian</code></pre> 
<h2><strong>util/&nbsp;GetIP.go</strong></h2> 
<p>工具类，获取客户端的IP</p> 
<pre><code class="language-Go">package util

import "github.com/gin-gonic/gin"

//获取ip
func GetRequestIP(c *gin.Context) string {
	reqIP := c.ClientIP()
	if reqIP == "::1" {
		reqIP = "127.0.0.1"
	}
	return reqIP
}
</code></pre> 
<h2><strong>&nbsp;setting/setting.go</strong></h2> 
<p>加入配置文件，给代码返回相应的参数</p> 
<pre><code class="language-Go">package setting

import (
	"fmt"
	"os"

	"github.com/go-ini/ini"
)



func GetMail() (user, password, host, source string) {
	//读取.ini里面的数据库配置
	config, err := ini.Load("conf/config.ini")
	if err != nil {
		//失败
		fmt.Printf("Fail to read file: %v", err)
		os.Exit(1)
	}
	host = config.Section("mail").Key("host").String()
	//port = config.Section("mail").Key("port").String()
	user = config.Section("mail").Key("user").String()
	password = config.Section("mail").Key("password").String()
	source = config.Section("mail").Key("source").String()
	//fmt.Println(user, password, host, source)
	return
}
func GetPort() (prot string) {
	config, err := ini.Load("conf/config.ini")
	if err != nil {
		//失败
		fmt.Printf("Fail to read file: %v", err)
		os.Exit(1)
	}
	prot = config.Section("").Key("port").String()
	return
}
</code></pre> 
<h2><strong>log/&nbsp;log.go</strong></h2> 
<p>日志切割和分割类，主要记录日志</p> 
<pre><code class="language-Go">package log

import (
	"github.com/natefinch/lumberjack"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var SugarLogger *zap.SugaredLogger

func InitLogger() {
	writeSyncer := getLogWriter()
	encoder := getEncoder()
	core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel)

	logger := zap.New(core, zap.AddCaller())
	SugarLogger = logger.Sugar()
}

func getEncoder() zapcore.Encoder {
	encoderConfig := zap.NewProductionEncoderConfig()
	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
	return zapcore.NewConsoleEncoder(encoderConfig)
}

func getLogWriter() zapcore.WriteSyncer {
	/*
		Lumberjack Logger采用以下属性作为输入:

		Filename: 日志文件的位置
		MaxSize：在进行切割之前，日志文件的最大大小（以MB为单位）
		MaxBackups：保留旧文件的最大个数
		MaxAges：保留旧文件的最大天数
		Compress：是否压缩/归档旧文件
	*/
	lumberJackLogger := &amp;lumberjack.Logger{
		Filename:   "./logs/info.log",
		MaxSize:    10,
		MaxBackups: 5,
		MaxAge:     30,
		Compress:   false,
	}
	return zapcore.AddSync(lumberJackLogger)

}
</code></pre> 
<h2>routers/router.go</h2> 
<pre><code class="language-Go">package routers

import (
	"code/mail_qq/app"

	"github.com/gin-gonic/gin"
)

func SetupRouter() *gin.Engine {
	r := gin.Default()

	//v1
	v1Group := r.Group("v1")
	{
		//待办事项
		//添加
		v1Group.POST("/send", app.PostMail)

	}

	return r
}
</code></pre> 
<h2>app/&nbsp;send.go</h2> 
<p>发送邮件的代码</p> 
<pre><code class="language-Go">package app

import (
	"code/mail_qq/log"
	"code/mail_qq/setting"
	"code/mail_qq/util"
	"fmt"
	"net/http"
	"net/smtp"
	"strings"

	"github.com/gin-gonic/gin"
)

//var sugarLogger *zap.SugaredLogger

// 定义接收数据的结构体
type User struct {
	// binding:"required"修饰的字段，若接收为空值，则报错，是必须字段
	Source   string   `form:"source" json:"source" uri:"source" xml:"source" binding:"required"`
	Contacts []string `form:"contacts" json:"contacts" uri:"contacts" xml:"contacts" binding:"required"`
	Subject  string   `form:"subject" json:"subject" uri:"subject" xml:"subject" binding:"required"`
	Content  string   `form:"content" json:"content" uri:"content" xml:"content" binding:"required"`
}

func SendToMail(user, sendUserName, password, host, to, subject, body, mailtype string) error {
	hp := strings.Split(host, ":")
	//fmt.Println(hp)
	auth := smtp.PlainAuth("", user, password, hp[0])
	var content_type string
	if mailtype == "html" {
		content_type = "Content-Type: text/" + mailtype + "; charset=UTF-8"
	} else {
		content_type = "Content-Type: text/plain" + "; charset=UTF-8"
	}

	msg := []byte("To: " + to + "\r\nFrom: " + sendUserName + "&lt;" + user + "&gt;" + "\r\nSubject: " + subject + "\r\n" + content_type + "\r\n\r\n" + body)
	send_to := strings.Split(to, ";")
	err := smtp.SendMail(host, auth, user, send_to, msg)
	//fmt.Println(err)
	return err
}
func PostMail(c *gin.Context) {

	c_ip := util.GetRequestIP(c)
	fmt.Println(c_ip)
	log.SugarLogger.Debugf("调用 PostMail 接口Api，调用者IP： %s ", c_ip)
	 声明接收的变量
	var json User
	 将request的body中的数据，自动按照json格式解析到结构体
	//
	if err := c.ShouldBindJSON(&amp;json); err != nil {
		//	// 返回错误信息
		//	// gin.H封装了生成json数据的工具
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		log.SugarLogger.Errorf("Error: %s", err.Error())
		return
	}
	//fmt.Println(json.Content, json.Contacts)
	//c.JSON(http.StatusOK, gin.H{"status": &amp;json})
	//sugarLogger.Infof("info: %s", json)

	sources := json.Source
	user, password, host, source := setting.GetMail()
	if sources != source {
		fmt.Println("Send mail error!,source 认证失败")
		log.SugarLogger.Errorf("Send mail error!,source 认证失败")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,source 认证失败",
		})
		return
	}
	//println(json.Contacts)
	to := json.Contacts
	if to[0] == "" {
		fmt.Println("Send mail error!,发送人为空")
		log.SugarLogger.Errorf("Send mail error!,发送人为空")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,发送人为空",
		})
		return
	}
	subject := json.Subject
	if strings.TrimSpace(subject) == "" {
		fmt.Println("Send mail error!标题为空")
		log.SugarLogger.Errorf("Send mail error!标题为空")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,标题为空",
		})
		return
	}
	body := `
		&lt;!DOCTYPE html&gt;
		&lt;html lang="en"&gt;
		&lt;head&gt;
			&lt;meta charset="iso-8859-15"&gt;
			&lt;title&gt;MMOGA POWER&lt;/title&gt;
		&lt;/head&gt;
		&lt;body&gt;
			` + fmt.Sprintf(json.Content) +
		`&lt;/body&gt;
		&lt;/html&gt;`

	sendUserName := "告警平台" //发送邮件的人名称
	fmt.Println("send email")

	for _, s := range to {
		//fmt.Println(i, s)
		err := SendToMail(user, sendUserName, password, host, s, subject, body, "html")
		//log.Printf("接收人：", s+"\n"+"标题:", json.Subject+"\n", "发送内容：", json.Content+"\n")
		fmt.Printf("接收人:%s \n 标题: %s \n 内容: %s \n", s, json.Subject, json.Content)
		log.SugarLogger.Infof("接收人: %s ,标题: %s, 内容: %s", s, json.Subject, json.Content)
		fmt.Println(err)
		if err != nil {
			fmt.Println("Send mail error!\n")
			log.SugarLogger.Errorf("Error 调用者IP: %s ,Send mail error! !", c_ip)
			c.JSON(http.StatusOK, gin.H{
				"error": "Send mail error! !\n",
			})
			//fmt.Println(err)
		} else {
			fmt.Println("Send mail success!\n")
			log.SugarLogger.Infof("success 调用者IP: %s ,Send mail success! !", c_ip)
			c.JSON(http.StatusOK, gin.H{
				"success": "Send mail success! !\n",
			})
		}

	}

}
</code></pre> 
<p>功能实现</p> 
<p><img alt="" height="629" src="https://img-blog.csdnimg.cn/6196e62803664f5fb073673af02e88a5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1126"></p> 
<p>&nbsp;</p> 
<p>日志记录</p> 
<p><img alt="" height="328" src="https://img-blog.csdnimg.cn/9d3d1980721a4aa39c4a649661ee0a83.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="198" src="https://img-blog.csdnimg.cn/840ec13484974b31a23989268503040b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="630"></p> 
<p>&nbsp;</p> 
<p></p> 
<p></p> 
<p></p>
                ]]></description></item><item><title>Linux操作系统账号密码失效检测</title><link>http://www.cnblogs.com/heian99/archive/2021/12/23/15730501.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 23 Dec 2021 07:40:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/12/23/15730501.html</guid><description><![CDATA[
                    <p>根据我开发的邮件接口上调用操作，触发告警</p> 
<h1 id="articleContentId"><a href="https://blog.csdn.net/heian_99/article/details/121851358" title="GO的WEB编程（GIN实现邮件接口报警）">GO的WEB编程（GIN实现邮件接口报警）</a></h1> 
<h1><a name="t1" title=""></a><a href="https://blog.csdn.net/heian_99/article/details/121912558" title="Gin编写邮件接口（支持多人发送）">Gin编写邮件接口（支持多人发送）</a></h1> 
<h1><a class="link-info" href="https://blog.csdn.net/heian_99/article/details/122002534">Gin编写邮件告警接口（添加优化日志记录）</a></h1> 
<p></p> 
<p>首先，我们Linux操作系统可以创建多个用户账号。</p> 
<p>但是为了系统安全考虑，我们会给账号密码设置有效期和复杂难度，防止非法操作爆破我们的机器。</p> 
<p>但是每次修改完，到规定时间需要修改账号密码，这个每次人工来看，比较麻烦，所以做个账号密码到期的警告。当密码快要过期时，我们可以发邮件告警。</p> 
<h2><strong>账号密码过期设置</strong></h2> 
<pre><code class="language-bash">function Check_Password_Policy(){
    #查看系统账户策略:密码失效时间90天、密码到期提醒时间14天
    echo "========正在检查账户密码失效时间========"
    Check_Pass_Poli=`grep  -E "^PASS_MAX_DAYS|^PASS_WARN_AGE"  /etc/login.defs | wc -l`
    cp  /etc/login.defs{,_bak$Date_Time}
    if  [ $Check_Pass_Poli -lt 2 ];then
        echo -e "\033[31;40m当前系统未对账户密码进行失效时间设置、密码到期提醒设置\033[0m"
        sed -i  '$iPASS_MAX_DAYS   90'  /etc/login.defs &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
        sed -i  '$iPASS_WARN_AGE   14'  /etc/login.defs &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
    else
        PAMAX=`grep  -E "^PASS_MAX_DAYS"  /etc/login.defs | awk -F" " '{ print $2 }'`
        PAWARN=`grep  -E "^PASS_WARN_AGE"  /etc/login.defs | awk -F" " '{ print $2 }'`
        if [ $PAMAX -le 90 ];then     
            echo -e "\033[32;40m密码失效时间为$PAMAX天，符合标准\033[0m"; 
        else     
            echo -e "\033[31;40m密码失效时间为$PAMAX天，不符合标准\033[0m"; 
            sed -i  's/^PASS_MAX_DAYS.*/PASS_MAX_DAYS   90/'  /etc/login.defs &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
        fi
        if [ $PAWARN -ge 14 ];then    
            echo -e "\033[32;40m密码到期提醒时间为$PAWARN天，符合标准\033[0m"; 
        else     
            echo -e "\033[31;40m密码到期提醒时间为$PAWARN天，不符合标准\033[0m"; 
            sed -i  's/^PASS_WARN_AGE.*/PASS_WARN_AGE   14/'  /etc/login.defs &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
        fi
    fi
    #chage --warndays  14 root &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
    #chage --maxdays 90 root &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
}</code></pre> 
<h2><strong>密码复杂度设置</strong></h2> 
<pre><code class="language-bash">function Check_User_Policy(){
    #查看系统账户策略:密码最小长度12位、密码复杂度为大小写英文字母、数字、特殊字符
    echo "========正在检查账户密码策略========"
    Check_User_Poli=`grep -E "^minlen|^minclass"  /etc/security/pwquality.conf |wc -l`
    cp  /etc/security/pwquality.conf{,_bak$Date_Time}
    if  [ $Check_User_Poli -lt 2 ];then
        echo -e "\033[31;40m当前系统未对账户密码复杂度及密码最小长度设置\033[0m"
        sed -i  '$iminlen = 12'  /etc/security/pwquality.conf &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
        sed -i  '$iminclass = 4'  /etc/security/pwquality.conf &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
    else
        PACLS=`grep  -E "^minclass"  /etc/security/pwquality.conf | awk -F"=| " '{ print $NF }'`
        PALEN=`grep  -E "^minlen"   /etc/security/pwquality.conf | awk -F"=| " '{ print $NF }'`
        if [ $PACLS -eq 4 ];then     
            echo -e "\033[32;40m密码负责度为$PACLS种类型，符合标准\033[0m"; 
        else     
            echo -e "\033[31;40m密码负责度为$PACLS种类型，不符合标准\033[0m"; 
            sed -i  's/^minclass.*/minclass = 4/'  /etc/login.defs &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
        fi
        if [ $PALEN -ge 12 ];then    
            echo -e "\033[32;40m密码长度为$PALEN位，符合标准\033[0m"; 
        else     
            echo -e "\033[31;40m密码长度为$PALEN位，不符合标准\033[0m"; 
            sed -i  's/^minlen.*/minlen = 12/'  /etc/login.defs &amp;&amp; echo -e "\033[32;40m 修改成功 \033[0m" || echo -e "\033[31;40m 修改失败 \033[0m"
        fi
    fi
}</code></pre> 
<h2>用户认证失败次数设置</h2> 
<pre><code class="language-bash">function Check_Auth_Failed(){
    echo "========正在检查用户登陆认证失败次数========"
    Check_Auth_Failsystem=`grep pam_faillock.so /etc/pam.d/system-auth | wc -l`
    Check_Auth_Failpasswd=`grep pam_faillock.so /etc/pam.d/password-auth | wc -l`
    cp  /etc/pam.d/system-auth{,_bak$Date_Time}
    cp  /etc/pam.d/password-auth{,_bak$Date_Time}
    if [ $Check_Auth_Failsystem -ge 3 ];then
        if [ $Check_Auth_Failpasswd -ge 3 ];then
            echo -e "\033[32;40m 用户登陆连续认证失败锁定策略设置成功，符合标准 \033[0m"
        else
            echo -e "\033[31;40m 用户登陆连续认证失败锁定策略设置不完全，不符合标准 \033[0m"
        fi
    else
        echo -e "\033[31;40m 用户登陆连续认证失败锁定策略设置不正确，不符合标准 \033[0m" 
        sed -i '/auth        required      pam_env.so/i auth required pam_faillock.so preauth audit silent deny=5 unlock_time=900'  /etc/pam.d/system-auth
        sed -i '/auth        required      pam_deny.so/a auth [default=die] pam_faillock.so authfail audit deny=5 unlock_time=900'  /etc/pam.d/system-auth
        sed -i '/account     required      pam_unix.so/i account required pam_faillock.so' /etc/pam.d/system-auth
        sed -i '/auth        required      pam_env.so/i auth required pam_faillock.so preauth audit silent deny=5 unlock_time=900'  /etc/pam.d/password-auth
        sed -i '/auth        required      pam_deny.so/a auth [default=die] pam_faillock.so authfail audit deny=5 unlock_time=900'  /etc/pam.d/password-auth
        sed -i '/account     required      pam_unix.so/i account required pam_faillock.so' /etc/pam.d/password-auth
    fi    
}</code></pre> 
<h2><strong>账号密码过期设置</strong></h2> 
<p><strong>设置定时任务，可以每天自己执行判断，如果快到期会发邮件告警，及时修改，防止过期导致crontab任务不可使用</strong></p> 
<pre><code class="language-bash">#!/bin/bash
#定义时间变量，用于告警发送
check_time=`date +"%Y-%m-%d %H:%M:%S"`
#日志位置
log=${HOME}/user-info.log
user_name=`whoami`

end_year=` chage -l ${user_name} | head -2| tail -1 | awk -F: '{print $2}'| awk -F',' '{print $2}'| awk '{print $1}'`
if [ "${end_year}" == "" ];then
    echo "99999"
    exit 0
fi
 
    end_mounth=`chage -l ${user_name} | head -2| tail -1 | awk -F: '{print $2}'| awk -F',' '{print $1}'| awk '{print $1}'`
 
    case ${end_mounth} in
        'Jan') end_mounth=1;;
        'Feb') end_mounth=2;;
        'Mar') end_mounth=3;;
        'Apr') end_mounth=4;;
        'May') end_mounth=5;;
        'Jun') end_mounth=6;;
        'Jul') end_mounth=7;;
        'Aug') end_mounth=8;;
        'Sep') end_mounth=9;;
        'Oct') end_mounth=10;;
        'Nov') end_mounth=11;;
        'Dec') end_mounth=12;;
    esac
 
    end_day=`chage -l ${user_name} | head -2| tail -1 | awk -F: '{print $2}'| awk -F',' '{print $1}'| awk '{print $2}'`
    end_date_s=`/bin/date -d "${end_year}"-"${end_mounth}"-"${end_day}" +%s`
    star_date_s=`/bin/date +%s`
    let diffday=(${end_date_s}-${star_date_s})/86400


    echo ${diffday}
#过期时间判断，如果小于15天，开始发邮件
if [  ${diffday} -gt 15 ]  
then  
	    curl http://mail.ownit.top/send -H "Content-Type:application/json" -X POST -d '{"source" : "game","contacts" : ["1794748404@qq.com"],"subject" : "'" ${user_name} 账号过期警告"'","content" : "'" ${user_name} 账号过期警告 &lt;br&gt;  ${user_name} 即将在 ${diffday} 后过期，请及时修改 &lt;br&gt; 注意: 账号密码过期后,用户的Crontab中的执行任务会失效  &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; "'"}'
    echo " time: $check_time   账号 ${user_name} 即将 在 ${diffday} 天后 密码过期 " &gt;&gt; ${log}
else

    echo " time: $check_time   账号 ${user_name} 还有 ${diffday} 天使用期 " &gt;&gt; ${log}
fi 
</code></pre> 
<p><img alt="" height="189" src="https://img-blog.csdnimg.cn/d033a1bbe8474b1790781dab2229b3d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="781"></p> 
<p>&nbsp;<img alt="" height="144" src="https://img-blog.csdnimg.cn/09b90c8dffa044ac84a038006ff5db29.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="736"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="100" src="https://img-blog.csdnimg.cn/185bd2a62462402ab3b8cb546d81ae45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="278" src="https://img-blog.csdnimg.cn/1ce69121181246b79b2c8ae4140b1a5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Gin编写邮件告警接口（添加优化日志记录）</title><link>http://www.cnblogs.com/heian99/archive/2021/12/17/15730502.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 17 Dec 2021 10:32:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/12/17/15730502.html</guid><description><![CDATA[
                    <h1 id="articleContentId"><a class="link-info" href="https://blog.csdn.net/heian_99/article/details/121851358">GO的WEB编程（GIN实现邮件接口报警）</a></h1> 
<h1><a class="link-info" href="https://blog.csdn.net/heian_99/article/details/121912558">Gin编写邮件接口（支持多人发送）</a></h1> 
<p>这个代码基于上面两个已经完成的功能上实现。</p> 
<p>实现下面功能</p> 
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日志分割</strong></p> 
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日志记录</strong></p> 
<p>效果图</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img alt="" height="673" src="https://img-blog.csdnimg.cn/416e3577dc7b400c9ac06ac783863c15.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="222" src="https://img-blog.csdnimg.cn/5239fc811ee94f5ea78a853eb232bb97.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1134"></p> 
<p>&nbsp;</p> 
<p>因为日常范围，我们在操作系统上，需要报警时，只能采用mailx来使用。需要配置账号，密码，和邮箱认证。如果需要多台使用的话，岂不是很麻烦，要配置多台，这个导致密码很不安全，容易泄露。所以，为了安全，有效，更方便，我们可以采用接口发送邮件。</p> 
<p>（1）构建接口</p> 
<p>（2）传入post的json情况</p> 
<p>（3）把相应json转换字符</p> 
<p>（4）发送邮件</p> 
<p></p> 
<p>代码放在一个main。</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"net/http"
	"net/smtp"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/natefinch/lumberjack"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

/*
支持多人发送
curl http://10.10.10.3:7070/send -H "Content-Type:application/json" -X POST -d '{"source":"heian","contacts":["账号@qq.com","账号@qq.com"],"subject":"多人测试","content":"现在进行多人测试"}'

*/

/*
zapcore.Core需要三个配置——Encoder，WriteSyncer，LogLevel
Encoder:编码器(如何写入日志)。我们将使用开箱即用的NewJSONEncoder()
WriterSyncer ：指定日志将写到哪里去。我们使用zapcore.AddSync()
Log Level：哪种级别的日志将被写入。
*/
var sugarLogger *zap.SugaredLogger

func InitLogger() {
	writeSyncer := getLogWriter()
	encoder := getEncoder()
	core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel)

	logger := zap.New(core, zap.AddCaller())
	sugarLogger = logger.Sugar()
}

func getEncoder() zapcore.Encoder {
	encoderConfig := zap.NewProductionEncoderConfig()
	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
	return zapcore.NewConsoleEncoder(encoderConfig)
}

func getLogWriter() zapcore.WriteSyncer {
	/*
		Lumberjack Logger采用以下属性作为输入:

		Filename: 日志文件的位置
		MaxSize：在进行切割之前，日志文件的最大大小（以MB为单位）
		MaxBackups：保留旧文件的最大个数
		MaxAges：保留旧文件的最大天数
		Compress：是否压缩/归档旧文件
	*/
	lumberJackLogger := &amp;lumberjack.Logger{
		Filename:   "./logs/info.log",
		MaxSize:    10,
		MaxBackups: 5,
		MaxAge:     30,
		Compress:   false,
	}
	return zapcore.AddSync(lumberJackLogger)

}

// 定义接收数据的结构体
type User struct {
	// binding:"required"修饰的字段，若接收为空值，则报错，是必须字段
	Source   string   `form:"source" json:"source" uri:"source" xml:"source" binding:"required"`
	Contacts []string `form:"contacts" json:"contacts" uri:"contacts" xml:"contacts" binding:"required"`
	Subject  string   `form:"subject" json:"subject" uri:"subject" xml:"subject" binding:"required"`
	Content  string   `form:"content" json:"content" uri:"content" xml:"content" binding:"required"`
}

func SendToMail(user, sendUserName, password, host, to, subject, body, mailtype string) error {
	hp := strings.Split(host, ":")
	//fmt.Println(hp)
	auth := smtp.PlainAuth("", user, password, hp[0])
	var content_type string
	if mailtype == "html" {
		content_type = "Content-Type: text/" + mailtype + "; charset=UTF-8"
	} else {
		content_type = "Content-Type: text/plain" + "; charset=UTF-8"
	}

	msg := []byte("To: " + to + "\r\nFrom: " + sendUserName + "&lt;" + user + "&gt;" + "\r\nSubject: " + subject + "\r\n" + content_type + "\r\n\r\n" + body)
	send_to := strings.Split(to, ";")
	err := smtp.SendMail(host, auth, user, send_to, msg)
	//fmt.Println(err)
	return err
}

//获取ip
func GetRequestIP(c *gin.Context) string {
	reqIP := c.ClientIP()
	if reqIP == "::1" {
		reqIP = "127.0.0.1"
	}
	return reqIP
}
func PostMail(c *gin.Context) {
	c_ip := GetRequestIP(c)
	//fmt.Println(c_ip)
	sugarLogger.Debugf("调用 PostMail 接口Api，调用者IP： %s ", c_ip)
	 声明接收的变量
	var json User
	 将request的body中的数据，自动按照json格式解析到结构体
	//
	if err := c.ShouldBindJSON(&amp;json); err != nil {
		//	// 返回错误信息
		//	// gin.H封装了生成json数据的工具
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		sugarLogger.Errorf("Error: %s", err.Error())
		return
	}
	//fmt.Println(json.Content, json.Contacts)
	//c.JSON(http.StatusOK, gin.H{"status": &amp;json})
	sugarLogger.Infof("info: %s", json)
	user := "账号@qq.com"
	password := "密码"
	host := "smtp.qq.com:25"
	source := json.Source
	if source != "heian" {
		fmt.Println("Send mail error!,source 认证失败")
		sugarLogger.Errorf("Send mail error!,source 认证失败")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,source 认证失败",
		})
		return
	}
	//println(json.Contacts)
	to := json.Contacts
	if to[0] == "" {
		fmt.Println("Send mail error!,发送人为空")
		sugarLogger.Errorf("Send mail error!,发送人为空")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,发送人为空",
		})
		return
	}
	subject := json.Subject
	if strings.TrimSpace(subject) == "" {
		fmt.Println("Send mail error!标题为空")
		sugarLogger.Errorf("Send mail error!标题为空")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,标题为空",
		})
		return
	}
	body := `
		&lt;!DOCTYPE html&gt;
		&lt;html lang="en"&gt;
		&lt;head&gt;
			&lt;meta charset="iso-8859-15"&gt;
			&lt;title&gt;MMOGA POWER&lt;/title&gt;
		&lt;/head&gt;
		&lt;body&gt;
			` + fmt.Sprintf(json.Content) +
		`&lt;/body&gt;
		&lt;/html&gt;`

	sendUserName := "告警平台" //发送邮件的人名称
	fmt.Println("send email")

	for _, s := range to {
		//fmt.Println(i, s)
		err := SendToMail(user, sendUserName, password, host, s, subject, body, "html")
		//log.Printf("接收人：", s+"\n"+"标题:", json.Subject+"\n", "发送内容：", json.Content+"\n")
		fmt.Printf("接收人:%s \n 标题: %s \n 内容: %s \n", s, json.Subject, json.Content)
		sugarLogger.Infof("接收人: %s ,标题: %s, 内容: %s", s, json.Subject, json.Content)
		if err != nil {
			fmt.Println("Send mail error!\n")
			sugarLogger.Errorf("Error 调用者IP: %s ,Send mail error! !", c_ip)
			c.JSON(http.StatusOK, gin.H{
				"error": "Send mail error! !\n",
			})
			//fmt.Println(err)
		} else {
			fmt.Println("Send mail success!\n")
			sugarLogger.Infof("success 调用者IP: %s ,Send mail success! !", c_ip)
			c.JSON(http.StatusOK, gin.H{
				"success": "Send mail success! !\n",
			})
		}

	}

}

func main() {
	// 1.创建路由
	// 默认使用了2个中间件Logger(), Recovery()
	InitLogger()
	defer sugarLogger.Sync()
	r := gin.Default()
	// JSON绑定
	r.POST("send", PostMail)
	sugarLogger.Infof("Success! Port is start")
	r.Run(":7070")

}
</code></pre> 
<p><img alt="" height="626" src="https://img-blog.csdnimg.cn/ebcbd6aae9db429ead007045fd309141.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Gin编写邮件接口（支持多人发送）</title><link>http://www.cnblogs.com/heian99/archive/2021/12/13/15684941.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 13 Dec 2021 11:36:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/12/13/15684941.html</guid><description><![CDATA[
                    <h1 id="articleContentId"><a class="link-info" href="https://blog.csdn.net/heian_99/article/details/121851358">GO的WEB编程（GIN实现邮件接口报警）</a></h1> 
<p>上面吧基本功能实现，但是不支持多人发送。</p> 
<p>下面做个小改动，支持多人发送</p> 
<p><img alt="" height="758" src="https://img-blog.csdnimg.cn/eed68b9a23d7468e8a8017b5d3438e6b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="235" src="https://img-blog.csdnimg.cn/8654a6ade2164d169049dd5df3245308.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="592"></p> 
<p>&nbsp;</p> 
<p></p> 
<p>因为日常范围，我们在操作系统上，需要报警时，只能采用mailx来使用。需要配置账号，密码，和邮箱认证。如果需要多台使用的话，岂不是很麻烦，要配置多台，这个导致密码很不安全，容易泄露。所以，为了安全，有效，更方便，我们可以采用接口发送邮件。</p> 
<p>（1）构建接口</p> 
<p>（2）传入post的json情况</p> 
<p>（3）把相应json转换字符</p> 
<p>（4）发送邮件</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"net/http"
	"net/smtp"
	"strings"

	"github.com/gin-gonic/gin"
)

/*
支持多人发送
curl http://10.10.10.3:7070/send -H "Content-Type:application/json" -X POST -d '{"source":"heian","contacts":["账号@qq.com","账号@qq.com"],"subject":"多人测试","content":"现在进行多人测试"}'

*/
// 定义接收数据的结构体
type User struct {
	// binding:"required"修饰的字段，若接收为空值，则报错，是必须字段
	Source   string   `form:"source" json:"source" uri:"source" xml:"source" binding:"required"`
	Contacts []string `form:"contacts" json:"contacts" uri:"contacts" xml:"contacts" binding:"required"`
	Subject  string   `form:"subject" json:"subject" uri:"subject" xml:"subject" binding:"required"`
	Content  string   `form:"content" json:"content" uri:"content" xml:"content" binding:"required"`
}

func SendToMail(user, sendUserName, password, host, to, subject, body, mailtype string) error {
	hp := strings.Split(host, ":")
	//fmt.Println(hp)
	auth := smtp.PlainAuth("", user, password, hp[0])
	var content_type string
	if mailtype == "html" {
		content_type = "Content-Type: text/" + mailtype + "; charset=UTF-8"
	} else {
		content_type = "Content-Type: text/plain" + "; charset=UTF-8"
	}

	msg := []byte("To: " + to + "\r\nFrom: " + sendUserName + "&lt;" + user + "&gt;" + "\r\nSubject: " + subject + "\r\n" + content_type + "\r\n\r\n" + body)
	send_to := strings.Split(to, ";")
	err := smtp.SendMail(host, auth, user, send_to, msg)
	//fmt.Println(err)
	return err
}

func PostMail(c *gin.Context) {
	 声明接收的变量
	var json User
	 将request的body中的数据，自动按照json格式解析到结构体
	//
	if err := c.ShouldBindJSON(&amp;json); err != nil {
		//	// 返回错误信息
		//	// gin.H封装了生成json数据的工具
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	//fmt.Println(json.Content, json.Contacts)
	//c.JSON(http.StatusOK, gin.H{"status": &amp;json})
	user := "账号@qq.com"
	password := "密码"
	host := "smtp.qq.com:25"
	source := json.Source
	if source != "heian" {
		fmt.Println("Send mail error!,source 认证失败")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,source 认证失败",
		})
		return
	}
	//println(json.Contacts)
	to := json.Contacts
	if to[0] == "" {
		fmt.Println("Send mail error!,发送人为空")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,发送人为空",
		})
		return
	}
	subject := json.Subject
	if strings.TrimSpace(subject) == "" {
		fmt.Println("Send mail error!标题为空")
		c.JSON(http.StatusOK, gin.H{
			"error": "Send mail error!,标题为空",
		})
		return
	}
	body := `
		&lt;!DOCTYPE html&gt;
		&lt;html lang="en"&gt;
		&lt;head&gt;
			&lt;meta charset="iso-8859-15"&gt;
			&lt;title&gt;MMOGA POWER&lt;/title&gt;
		&lt;/head&gt;
		&lt;body&gt;
			` + fmt.Sprintf(json.Content) +
		`&lt;/body&gt;
		&lt;/html&gt;`

	sendUserName := "告警平台" //发送邮件的人名称
	fmt.Println("send email")

	for _, s := range to {
		//fmt.Println(i, s)
		err := SendToMail(user, sendUserName, password, host, s, subject, body, "html")
		//log.Printf("接收人：", s+"\n"+"标题:", json.Subject+"\n", "发送内容：", json.Content+"\n")
		fmt.Printf("接收人:%s \n 标题: %s \n 内容: %s \n", s, json.Subject, json.Content)
		if err != nil {
			fmt.Println("Send mail error!\n")
			c.JSON(http.StatusOK, gin.H{
				"error": "Send mail error! !\n",
			})
			//fmt.Println(err)
		} else {
			fmt.Println("Send mail success!\n")
			c.JSON(http.StatusOK, gin.H{
				"success": "Send mail success! !\n",
			})
		}

	}

}

func main() {
	// 1.创建路由
	// 默认使用了2个中间件Logger(), Recovery()
	r := gin.Default()
	// JSON绑定
	r.POST("send", PostMail)
	r.Run(":7070")
}
</code></pre> 
<p><img alt="" height="708" src="https://img-blog.csdnimg.cn/662468fc30d049ed8448eae21f42e6c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="758" src="https://img-blog.csdnimg.cn/eed68b9a23d7468e8a8017b5d3438e6b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p>
                ]]></description></item><item><title>GO的WEB编程（GIN实现邮件接口报警）</title><link>http://www.cnblogs.com/heian99/archive/2021/12/10/15678583.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 10 Dec 2021 03:13:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/12/10/15678583.html</guid><description><![CDATA[
                    <p>为什么要写这个邮件告警接口？？？？？？</p> 
<p>因为日常范围，我们在操作系统上，需要报警时，只能采用mailx来使用。需要配置账号，密码，和邮箱认证。如果需要多台使用的话，岂不是很麻烦，要配置多台，这个导致密码很不安全，容易泄露。所以，为了安全，有效，更方便，我们可以采用接口发送邮件。</p> 
<p>（1）构建接口</p> 
<p>（2）传入post的json情况</p> 
<p>（3）把相应json转换字符</p> 
<p>（4）发送邮件</p> 
<p><img alt="" height="273" src="https://img-blog.csdnimg.cn/f82790457251415f8f747422b0c2549f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p><img alt="" height="185" src="https://img-blog.csdnimg.cn/a592ffe3fae24e92a4309fe0f1fca608.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="759"><strong>&nbsp;调用方式（已做脱敏）</strong></p> 
<pre><code class="language-bash">curl http://mawnit.top/send -H "Content-Type:application/json" -X POST -d '{"source":"heiassns","contacts":"17947@qq.com","subject":"geian","content":"精确吗,我很好"} '</code></pre> 
<p>&nbsp;</p> 
<p>代码很简单，实现基本功能</p> 
<p>自定义标题，内容，发送人（只支持单个）</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"net/http"
	"net/smtp"
	"strings"

	"github.com/gin-gonic/gin"
)

// 定义接收数据的结构体
type User struct {
	// binding:"required"修饰的字段，若接收为空值，则报错，是必须字段
	Source   string `form:"source" json:"source" uri:"source" xml:"source" binding:"required"`
	Contacts string `form:"contacts" json:"contacts" uri:"contacts" xml:"contacts" binding:"required"`
	Subject  string `form:"subject" json:"subject" uri:"subject" xml:"subject" binding:"required"`
	Content  string `form:"content" json:"content" uri:"content" xml:"content" binding:"required"`
}

func SendToMail(user, sendUserName, password, host, to, subject, body, mailtype string) error {
	hp := strings.Split(host, ":")
	fmt.Println(hp)
	auth := smtp.PlainAuth("", user, password, hp[0])
	var content_type string
	if mailtype == "html" {
		content_type = "Content-Type: text/" + mailtype + "; charset=UTF-8"
	} else {
		content_type = "Content-Type: text/plain" + "; charset=UTF-8"
	}

	msg := []byte("To: " + to + "\r\nFrom: " + sendUserName + "&lt;" + user + "&gt;" + "\r\nSubject: " + subject + "\r\n" + content_type + "\r\n\r\n" + body)
	send_to := strings.Split(to, ";")
	err := smtp.SendMail(host, auth, user, send_to, msg)
	fmt.Println(err)
	return err
}

func main() {
	// 1.创建路由
	// 默认使用了2个中间件Logger(), Recovery()
	r := gin.Default()
	// JSON绑定
	r.POST("send", func(c *gin.Context) {
		 声明接收的变量
		var json User
		 将request的body中的数据，自动按照json格式解析到结构体
		//
		if err := c.ShouldBindJSON(&amp;json); err != nil {
			//	// 返回错误信息
			//	// gin.H封装了生成json数据的工具
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}
		//fmt.Println(json.Content, json.Contacts)
		//c.JSON(http.StatusOK, gin.H{"status": &amp;json})
		user := "发件人邮箱"
		password := "密码"
		host := "smtp.qq.com:25"
		source := json.Source
		if source != "heian" {
			fmt.Println("Send mail error!,source 认证失败")
			c.JSON(http.StatusOK, gin.H{
				"error": "Send mail error!,source 认证失败",
			})
			return
		}
		to := json.Contacts
		if strings.TrimSpace(to) == "" {
			fmt.Println("Send mail error!,发送人为空")
			c.JSON(http.StatusOK, gin.H{
				"error": "Send mail error!,发送人为空",
			})
			return
		}
		subject := json.Subject
		if strings.TrimSpace(subject) == "" {
			fmt.Println("Send mail error!标题为空")
			c.JSON(http.StatusOK, gin.H{
				"error": "Send mail error!,标题为空",
			})
			return
		}
		body := `
		&lt;!DOCTYPE html&gt;
		&lt;html lang="en"&gt;
		&lt;head&gt;
			&lt;meta charset="iso-8859-15"&gt;
			&lt;title&gt;MMOGA POWER&lt;/title&gt;
		&lt;/head&gt;
		&lt;body&gt;
			` + fmt.Sprintf(json.Content) +
			`&lt;/body&gt;
		&lt;/html&gt;`
		//log.Printf("接收人：", json.Contacts+"\n"+"标题:", json.Subject+"\n", "发送内容：", json.Content+"\n")
		fmt.Printf("接收人:%s \n 标题: %s \n 内容: %s \n", json.Contacts, json.Subject, json.Content)
		sendUserName := "告警平台" //发送邮件的人名称
		fmt.Println("send email")
		err := SendToMail(user, sendUserName, password, host, to, subject, body, "html")
		if err != nil {
			fmt.Println("Send mail error!")
			c.JSON(http.StatusOK, gin.H{
				"error": "Send mail error! !",
			})
			//fmt.Println(err)
		} else {
			fmt.Println("Send mail success!")
			c.JSON(http.StatusOK, gin.H{
				"success": "Send mail success! !",
			})
		}

	})
	r.Run(":7070")
}

</code></pre> 
<p>后续慢慢改进，把相应的发送信息，保存到数据库中，支持多人发送，支持文件发送，等等</p>
                ]]></description></item><item><title>TCP扫描增强器实现65000端口，10S完成，快准狠（Go语言编程）</title><link>http://www.cnblogs.com/heian99/archive/2021/12/02/15678584.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 02 Dec 2021 09:25:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/12/02/15678584.html</guid><description><![CDATA[
                    <p><img alt="" height="423" src="https://img-blog.csdnimg.cn/d26f3b96b67f456586526b45a7e51baf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="949"></p> 
<p>&nbsp;</p> 
<h1 id="TCP%E6%89%AB%E6%8F%8F%E5%A2%9E%E5%BC%BA%E5%99%A8">TCP扫描增强器</h1> 
<p>TCP扫描增强器实现原理，主要是使用TCP三次握手原理</p> 
<p>TCP是比我们介绍的要复杂的多，但是我们只介绍一点基础知识。TCP的握手有三个过程。</p> 
<p>首先，客户端发送一个 syn 的包，表示建立回话的开始。如果客户端收到超时，说明端口可能在防火墙后面，或者没有启用服务器</p> 
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/ba16919769276de3f44bb04257ac8f08.png"></p> 
<p>第二，如果服务端应答 syn-ack 包，意味着这个端口是打开的，否则会返回 rst 包。最后，客户端需要另外发送一个 ack 包。从这时起，连接就已经建立。</p> 
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/a3ef55f9200aab9e8608092bb070b905.png"></p> 
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/2ec6eb21d371a22dd16150d93df230ad.png"></p> 
<p>我们TCP扫描器第一步先实现单个端口的测试。使用标准库中的 net.Dial 函数，该函数接收两个参数：协议和测试地址（带端口号）。</p> 
<h2 id="%E7%89%88%E6%9C%AC%E4%B8%80%EF%BC%88%E5%8D%95%E7%AB%AF%E5%8F%A3%EF%BC%89">版本一（单端口）</h2> 
<pre><code class="language-Go">package main

import (
    "fmt"
    "net"
)

func main() {
	_, err := net.Dial("tcp", "www.baidu.com:80")
    if err == nil {
        fmt.Println("Connection successful")
    } else {
        fmt.Println(err)
    }
}</code></pre> 
<p>&nbsp;</p> 
<p><img alt="" height="162" src="https://img-blog.csdnimg.cn/c9b6f9ab583f45afb59b24ca3a75e3c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="558"></p> 
<h2 id="%E7%89%88%E6%9C%AC%E4%BA%8C%EF%BC%88%E5%A4%9A%E7%AB%AF%E5%8F%A3%EF%BC%89">版本二（多端口）</h2> 
<p>为了不一个一个地测试每个端口，我们将添加一个简单的循环来简化整个测试过程。</p> 
<pre><code class="language-Go">package main

import (
    "fmt"
    "net"
)

func main() {
    for port := 80; port &lt; 100; port++ {
        conn, err := net.Dial("tcp", fmt.Sprintf("www.baidu.com:%d", port))
        if err == nil {
            conn.Close()
            fmt.Println("Connection successful")
        } else {
            fmt.Println(err)
        }
    }
}</code></pre> 
<p>这种处理方式有个很大的问题，极度的慢。我们可以通过两个操作来处理一下：并行的执行及为每个连接添加超时控制。</p> 
<p>我们来看下如何实现并行。第一步先把扫描功能拆分为一个独立函数。这样会使我们的代码看起来清晰。</p> 
<h2 id="%E7%89%88%E6%9C%AC%E4%B8%89%EF%BC%88%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%EF%BC%89">版本三（并发执行）</h2> 
<p>我们会引入一个新的方法 WaitGroup ，详细用法信息可以参考标准库文档。在主函数中，我们可以拆分为协程去执行，然后等待执行结束</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"net"
	"sync"
	"time"
)

func isOpen(host string, port int) bool {
	time.Sleep(time.Millisecond * 3)
	conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", host, port))
	if err == nil {
		_ = conn.Close()
		return true
	}

	return false
}

func main() {
	ports := []int{}
	wg := &amp;sync.WaitGroup{}
	for port := 1; port &lt; 50000; port++ {
		wg.Add(1)
		port := port
		go func() {
			opened := isOpen("www.baidu.com", port)
			if opened {
				ports = append(ports, port)
			}
			wg.Done()
		}()

	}
	wg.Wait()
	fmt.Printf("opened ports: %v\n", ports)
}
</code></pre> 
<h2 id="%E7%89%88%E6%9C%AC%E5%9B%9B%EF%BC%88%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%EF%BC%89">版本四（等待超时）</h2> 
<p>我们的代码已经执行的很快了，但是由于超时的原因，我们需要等待很久才能收到返回的错误信息。我们可以假设如果我们200毫秒内没有收到服务器的回应，就不再继续等待。</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"net"
	"sync"
	"time"
)
func isOpen(host string, port int, timeout time.Duration) bool {
    time.Sleep(time.Millisecond * 1)
    conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", host, port), timeout)
    if err == nil {
        _ = conn.Close()
        return true
    }

    return false
}

func main() {
    ports := []int{}

    wg := &amp;sync.WaitGroup{}
    timeout := time.Millisecond * 200
    for port := 1; port &lt; 100; port++ {
        wg.Add(1)
        go func(p int) {
            opened := isOpen("www.baidu.com", p, timeout)
            if opened {
                ports = append(ports, p)
            }
            wg.Done()
        }(port)
    }

    wg.Wait()
    fmt.Printf("opened ports: %v\n", ports)
}</code></pre> 
<h2 id="%E7%89%88%E6%9C%AC%E4%BA%94%EF%BC%88%E6%B7%BB%E5%8A%A0%E9%94%81%EF%BC%89">版本五（添加锁）</h2> 
<p>为什么要添加锁，因为并发执行的话，在往ports数组写的话，会有影响。</p> 
<p>现在这个程序会有竞争条件。在只扫描少数端口时，速度比较慢，可能不会出现，但确实存在这个问题。所以我们需要使用 mutex 来修复它。</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

var wg sync.WaitGroup
var mutex sync.Mutex

func isOpen(host string, port int, timeout time.Duration) bool {

	time.Sleep(time.Millisecond * 1)
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", host, port), timeout)
	if err == nil {
		_ = conn.Close()
		return true
	}

	return false
}

func main() {
	startTime := time.Now()
	ports := []int{}
	timeout := time.Millisecond * 500
	for port := 1; port &lt;= 65000; port++ {
		go func(p int) {
			opened := isOpen("www.baidu.com", p, timeout)
			if opened {
				mutex.Lock()
				ports = append(ports, p)
				log.Printf("端口: %d 已经开通", p)
				mutex.Unlock()
			}
		}(port)
	}
	time.Since(startTime)
	cost := int(time.Since(startTime) / time.Second)
	fmt.Printf("opened ports: %v\n", ports)

	fmt.Printf("代码运行时长: %d S", cost)
}
</code></pre> 
<h2>版本六（并发控制）</h2> 
<p id="main-toc">为什么并发控制，不控制的话，在运行时会卡，有时间会导致竞争条件。会影响接口，为了数值的准确性，有必要控制一下并发数量</p> 
<p>这里面并发控制，我采用channel，有兴趣可以谷歌一下。</p> 
<p><strong>golimit.go</strong></p> 
<pre><code class="language-Go">package golimit

type GoLimit struct {
	ch chan int
}

func NewGoLimit(max int) *GoLimit {
	return &amp;GoLimit{ch: make(chan int, max)}
}

func (g *GoLimit) Add() {
	g.ch &lt;- 1
}

func (g *GoLimit) Done() {
	&lt;-g.ch
}
</code></pre> 
<p><strong>tcp.go</strong></p> 
<pre><code class="language-Go">package main

import (
	"code/Projects/tcp_Scanning/golimit"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

var wg sync.WaitGroup
var mutex sync.Mutex

func isOpen(host string, port int, timeout time.Duration) bool {

	time.Sleep(time.Millisecond * 1)
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", host, port), timeout)
	if err == nil {
		_ = conn.Close()
		return true
	}

	return false
}

func main() {
	startTime := time.Now()
	ports := []int{}
	timeout := time.Millisecond * 500
	g := golimit.NewGoLimit(2000)
	for port := 1; port &lt;= 65000; port++ {
		g.Add()
		go func(g *golimit.GoLimit, p int) {
			opened := isOpen("10.10.10.1", p, timeout)
			if opened {
				mutex.Lock()
				ports = append(ports, p)
				log.Printf("端口: %d 已经开通", p)
				mutex.Unlock()
			}
			g.Done()
		}(g, port)
	}
	time.Since(startTime)
	cost := int(time.Since(startTime) / time.Second)
	fmt.Printf("opened ports: %v\n", ports)

	fmt.Printf("代码运行时长: %d S", cost)
}
</code></pre> 
<h2><strong>版本七（参数定制）</strong></h2> 
<p>我们就得到了一个简单的端口扫描器。但有些不好的是，不能很方便的修改域名地址以及端口号范围，我们必须要重新编译代码才可以。Go还有一个很不错的包叫做 flag 。</p> 
<p>flag 包可以帮助我们编写命令行程序。我们可以配置每个字符串或数字。我们为主机名及要测试的端口范围和连接超时添加参数。</p> 
<pre><code class="language-Go">package main

import (
	"code/Projects/tcp_Scanning/golimit"
	"flag"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

var wg sync.WaitGroup
var mutex sync.Mutex

func isOpen(host string, port int, timeout time.Duration) bool {

	time.Sleep(time.Millisecond * 1)
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", host, port), timeout)
	if err == nil {
		_ = conn.Close()
		return true
	}

	return false
}

func main() {
	startTime := time.Now()
	hostname := flag.String("hostname", "", "hostname to test")
	startPort := flag.Int("start-port", 80, "the port on which the scanning starts")
	endPort := flag.Int("end-port", 100, "the port from which the scanning ends")
	timeout := flag.Duration("timeout", time.Millisecond*200, "timeout")
	golimits := flag.Int("golimit", 1000, "the Program Concurrency")
	flag.Parse()
	ports := []int{}
	//timeout := time.Millisecond * 500
	g := golimit.NewGoLimit(*golimits)
	for port := *startPort; port &lt;= *endPort; port++ {
		g.Add()
		go func(g *golimit.GoLimit, p int) {
			opened := isOpen(*hostname, p, *timeout)
			if opened {
				mutex.Lock()
				ports = append(ports, p)
				log.Printf("端口: %d 已经开通", p)
				mutex.Unlock()
			}
			g.Done()
		}(g, port)
	}
	time.Since(startTime)
	cost := int(time.Since(startTime) / time.Second)
	fmt.Printf("opened ports: %v\n", ports)

	fmt.Printf("代码运行时长: %d S", cost)
}
</code></pre> 
<p></p> 
<p>如果我们想要显示如何使用，我们可以添加一个 -h 参数，来显示使用说明。整个项目不到50行的代码，我们使用到了并行、flag 及 net 包。</p> 
<p id="%E7%89%88%E6%9C%AC%E4%B8%80%EF%BC%88%E5%8D%95%E7%AB%AF%E5%8F%A3%EF%BC%89-toc" style="margin-left:40px;"></p> 
<p id="%E7%89%88%E6%9C%AC%E4%BA%8C%EF%BC%88%E5%A4%9A%E7%AB%AF%E5%8F%A3%EF%BC%89-toc" style="margin-left:40px;"></p> 
<p id="%E7%89%88%E6%9C%AC%E4%B8%89%EF%BC%88%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%EF%BC%89-toc" style="margin-left:40px;"></p> 
<p id="%E7%89%88%E6%9C%AC%E5%9B%9B%EF%BC%88%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%EF%BC%89-toc" style="margin-left:40px;"></p> 
<p id="%E7%89%88%E6%9C%AC%E4%BA%94%EF%BC%88%E6%B7%BB%E5%8A%A0%E9%94%81%EF%BC%89-toc" style="margin-left:40px;"></p> 
<p>速度测试还不错，</p> 
<p>并发 2000，扫描65000端口，只需要16s，而且很准确。</p> 
<p>如果设置4000的并发，扫描出来的结果可能缺少，只需要8S 。</p> 
<p><img alt="" height="449" src="https://img-blog.csdnimg.cn/ca35772563364382b002a741ed544f91.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="442" src="https://img-blog.csdnimg.cn/d0dc15b853014aebb529840c4fe4c594.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1092"></p> 
<p>&nbsp;大家可以多试试。</p>
                ]]></description></item><item><title>golang的ping检测主机存活</title><link>http://www.cnblogs.com/heian99/archive/2021/11/30/15678585.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 30 Nov 2021 03:18:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/11/30/15678585.html</guid><description><![CDATA[
                    <p>Go语言的协程会并发，执行，可以大大提高效率。</p> 
<p>列如，我们通过 ping 来检测网络的主机的话。</p> 
<p>如果使用shell的话，会检查一个IP，在检查下一个IP，速度很慢。</p> 
<p>如果我们使用Python 的话，可以使用多线程。</p> 
<p>我们这里使用Go的协程来操作，速度是刚刚的。</p> 
<p></p> 
<p>一个网段，10S中，相当于，一秒钟处理25个左右的IP，因为ping检查，有延时性&nbsp;</p> 
<p><img alt="" height="429" src="https://img-blog.csdnimg.cn/a37b9ebad853478a849ea442451c10f3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_17,color_FFFFFF,t_70,g_se,x_16" width="502"></p> 
<p>此脚本，只能在Linux上执行</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"os/exec"
	"strconv"
	"strings"
	"sync"
	"time"
)

var wg sync.WaitGroup

func main() {
	start := time.Now()
	ip := "10.10.10."
	wg.Add(254)
	for i := 1; i &lt;= 254; i++ {
		//fmt.Println(ip + strconv.Itoa(i))
		true_ip := ip + strconv.Itoa(i)
		go ping(true_ip)
	}
	wg.Wait()
	cost := time.Since(start)
	fmt.Println("执行时间:", cost)
}

func ping(ip string) {
	var beaf = "false"
	Command := fmt.Sprintf("ping -c 1 %s  &gt; /dev/null &amp;&amp; echo true || echo false", ip)
	output, err := exec.Command("/bin/sh", "-c", Command).Output()
	if err != nil {
		fmt.Println(err)
		return
	}
	real_ip := strings.TrimSpace(string(output))

	if real_ip == beaf {
		fmt.Printf("IP: %s  失败\n", ip)
	} else {

		fmt.Printf("IP: %s  成功 ping通\n", ip)
	}
	wg.Done()
}
</code></pre> 
<p>不得不说，GO语言的并发，是真的香啊，</p>
                ]]></description></item><item><title>集群服务器的网络连接状态接入ELK（可视化操作）</title><link>http://www.cnblogs.com/heian99/archive/2021/11/22/15678586.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 22 Nov 2021 07:36:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/11/22/15678586.html</guid><description><![CDATA[
                    <p><img alt="" height="717" src="https://img-blog.csdnimg.cn/f0d382ca74a74af2b711e7e8e8a4a5cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<h1 id="articleContentId"><a class="link-info" href="https://blog.csdn.net/heian_99/article/details/121432620">Rsyslog同步集群服务器的网络连接状态</a></h1> 
<p>上篇文件，主要是把集群服务器状态同步到一台机器上，然后通过grep，awk 什么的比较方便。但是考虑到更简单，方便的操作，那就是接入elk日志管理平台</p> 
<p>来来，大致思路很简单</p> 
<p>（1）有个完成的elk集群</p> 
<p>（2）使用filebeat收集汇总的tcp.log（只要一个filebeat就可以）</p> 
<p>（3）把filebeat数据发送到logstash中，进行日志切割转换（靠，正则很难受）</p> 
<p>（4）把logstash的数据存储到es</p> 
<p>（5）kibana展示es中的数据日志</p> 
<p></p> 
<h1>（1）filebeat收集tcp.log</h1> 
<p>来来，看配置，很简单</p> 
<h2>配置文件</h2> 
<pre><code class="language-bash">[root@logserver01 filebeat]# cat tcp_listen.yml 
#=========================== Filebeat inputs =============================
filebeat.inputs:
- type: log
  enabled: true
  tail_files: true
  paths:
    - /var/log/history/tcp.log
#=========================== Filebeat outppp_id: messuts =============================
output.logstash:
  hosts: ["127.0.0.1:5516"]

</code></pre> 
<h2>启动命令</h2> 
<pre><code class="language-bash">nohup /usr/local/filebeat/filebeat -e -c  /usr/local/filebeat/tcp_listen.yml -path.data=/usr/local/filebeat/tcp_listen &amp;</code></pre> 
<h1>（2）logstash收集清洗日志</h1> 
<p>清洗日志，比较麻烦，需要grok正则来实现</p> 
<p>grok正则</p> 
<p><a href="http://grokdebug.herokuapp.com/" title="http://grokdebug.herokuapp.com/">http://grokdebug.herokuapp.com/</a></p> 
<pre><code class="language-bash">2021-11-22T10:51:41+08:00 172.17.42.101 storm-42-101  [storm] info: 172.21.5.22 ESTABLISHED 1</code></pre> 
<h2>grok的正则</h2> 
<pre><code class="language-bash">^(?&lt;atime&gt;\d+-\d+-\d+)(?:[^\d]+)(?&lt;hhmmss&gt;\d+:\d+:\d+)(?:[^\d]+\d+:\d+)(?:\s+)(?&lt;hostip&gt;\d+\.\d+\.\d+\.\d+)(?:\s)(?&lt;hostname&gt;[^ ]+)(?:\s+)(?&lt;hostuser&gt;[^ ]+)(?:\s+)(?&lt;names&gt;[^ ]+)(?:\s)%{HOSTNAME:connect_IP}(?:\s)(?&lt;connect_state&gt;[^ ]+)(?:\s)%{HOSTNAME:connect_num}</code></pre> 
<p><img alt="" height="902" src="https://img-blog.csdnimg.cn/c088ea0d45314ae6a0ce377cd9e5e697.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<h2>&nbsp;配置文件</h2> 
<pre><code class="language-bash">[root@logserver01 config]# cat tcp_listen.conf 
input {
   beats {
    port =&gt; 5516
    type =&gt; syslog
  }
}

filter {
    grok {
        match =&gt; { 
		"message" =&gt; "^(?&lt;atime&gt;\d+-\d+-\d+)(?:[^\d]+)(?&lt;hhmmss&gt;\d+:\d+:\d+)(?:[^\d]+\d+:\d+)(?:\s+)(?&lt;hostip&gt;\d+\.\d+\.\d+\.\d+)(?:\s)(?&lt;hostname&gt;[^ ]+)(?:\s+)(?&lt;hostuser&gt;[^ ]+)(?:\s+)(?&lt;names&gt;[^ ]+)(?:\s)%{HOSTNAME:connect_IP}(?:\s)(?&lt;connect_state&gt;[^ ]+)(?:\s)%{HOSTNAME:connect_num}"
		}
		overwrite =&gt; ["message"]
		
    }
	mutate {  
	split =&gt; ["type",","]     
	}

    mutate{remove_field =&gt; [ "tags","agent","host","log","ecs","type" ]}
	
	ruby { 
    code =&gt; "event.set('index_date', event.get('@timestamp').time.localtime + 8*60*60)" 
} 
	mutate { 
    convert =&gt; ["index_date", "string"] 
    gsub =&gt; ["index_date", "-\d{2}T([\S\s]*?)Z", ""] 
    gsub =&gt; ["index_date", "-", "."] 
}  
	date {
        match =&gt; ["time", "yyyy-MM-dd HH:mm:ss,SSS", "UNIX"]
        target =&gt; "@timestamp"
        locale =&gt; "cn"
    }
}

output {
  stdout {
#    codec=&gt; rubydebug
  }
  elasticsearch {
    hosts =&gt; ["http://127.0.0.1:9200"]
    index =&gt; "tcp_listen_%{index_date}"
  }
}

</code></pre> 
<h2>启动命令</h2> 
<pre><code class="language-bash">nohup /usr/local/logstash/bin/logstash -f /usr/local/logstash/config/tcp_listen.conf --path.data=/usr/local/logstash/data/tcp_listen &amp;</code></pre> 
<p><img alt="" height="776" src="https://img-blog.csdnimg.cn/ea84829a4e714484a236960efe963572.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1134"></p> 
<h1>&nbsp;（3）kibana展示数据</h1> 
<h2>创建索引</h2> 
<p><img alt="" height="790" src="https://img-blog.csdnimg.cn/08e1fd28fc304fae98021a42818ac2e2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<h2>&nbsp;查看数据</h2> 
<p>脚本为15分钟拉去一次数据的。所有在kibana展示也是和脚本时间同步的&nbsp;</p> 
<p><img alt="" height="702" src="https://img-blog.csdnimg.cn/0df915317d564e6b9202788e3bd7d783.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p><img alt="" height="717" src="https://img-blog.csdnimg.cn/f0d382ca74a74af2b711e7e8e8a4a5cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/07d4b6c2a5684582a567930301edfb08.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<p></p>
                ]]></description></item><item><title>Rsyslog同步集群服务器的网络连接状态</title><link>http://www.cnblogs.com/heian99/archive/2021/11/19/15678587.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 19 Nov 2021 15:13:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/11/19/15678587.html</guid><description><![CDATA[
                    <p>目前集群机器比较多，因为下载业务比较多，网络状态不好监控，涉及的状态比较多。有几次出问题，对方的锅，还要扔给我们。有必要做一下监控。防止背锅</p> 
<p>目前业务方式是把日志写入本地，到时间那台有问题，再去分析那一台。</p> 
<p>我一看，这还的行吗。如果出问题业务量大，分析半天能累死人，太累了，不太建议。</p> 
<p>看来的拿出来看家本领，好歹也是管理过上K台机器的菜鸡，还是有点方法的。</p> 
<p>（1）使用脚本分析本地网络的问题</p> 
<p>（2）写入rsyslog</p> 
<p>（3）使用rsyslog的同步，把日志接入一台机器</p> 
<p>（4）然后把数据接入elk，使用可视化界面操作（逼格是否一下上来了）</p> 
<p></p> 
<h1>1、分析网络的脚本</h1> 
<pre><code class="language-bash">[heian@game ~]$ netstat -n | awk '/^tcp/ {print $0}'  | awk '{print $(NF-1),$NF}' |  awk -F ':| ' '{print $1,$NF}' |awk  '{a[$1" "$2]++}END{for(i in a)print i,a[i]}' |sort -nk 3
10.10.10.3 ESTABLISHED 1
127.0.0.1 ESTABLISHED 6
172.18.0.2 ESTABLISHED 1
192.168.1.100 ESTABLISHED 6
192.168.1.15 ESTABLISHED 6
192.168.1.210 ESTABLISHED 1
</code></pre> 
<p>脚本实现，把数据写入rsyslog</p> 
<pre><code class="language-bash">[root@game heian]# cat tcp_listen.sh 
#!/bin/bash
date_time=`date +"%Y%m%d%H%M"`
today=`date +"%Y-%m-%d"`
date_hour=`date +"%Y-%m-%d_%H"`
log_dir="/app/bighead/scripts/monitorNetstat_log"
log_path=$log_dir/$today/${date_hour}.log

#检查文件夹是否存在，不存在则创建
[ ! -d $log_dir/$today ] &amp;&amp; mkdir -p $log_dir/$today
#获取数据
netstat -n | awk '/^tcp/ {print $0}'  | awk '{print $(NF-1),$NF}' |  awk -F ':| ' '{print $1,$NF}' |awk -v date_time=$date_time '{a[$1" "$2]++}END{for(i in a)print date_time,i,a[i]}' |sort -nk 4 &gt;&gt; $log_path
tcp_listen2=$(netstat -n | awk '/^tcp/ {print $0}'  | awk '{print $(NF-1),$NF}' |  awk -F ':| ' '{print $1,$NF}' |awk  '{a[$1" "$2]++}END{for(i in a)print i,a[i]}' |sort -nk 3)
#写入本地文件 
while read tcp
do 
  echo "$tcp"
  logger -p local5.info  "$tcp"
done &lt;&lt;&lt; "$tcp_listen2"

#删除5天前的文件夹
[ -d $log_dir ] &amp;&amp; find $log_dir -type d -mtime +5 | xargs rm -rf
</code></pre> 
<p>此脚本会把数据在本地保存一份，也会把数据写入rsyslog</p> 
<p>为什么要这么做，防止rsyslog服务器宕机，数据丢失喽（别说，考虑全面点）</p> 
<p></p> 
<h1>2、分发脚本，执行定时任务</h1> 
<p>把这个脚本分发到集群机器上，设置定时任务，10分钟执行一次，会同步一次网络状态。</p> 
<p>至于分发，和执行命令创建，ansible喽，自己写了命令，一个copy 一个cron 两个命令搞定</p> 
<pre><code class="language-bash">
#大致这格式
ansible p3 -m copy -a "src=/root/node_monitor dest=/root"
ansible p3 -m shell -a "chmod a+x /root/node_monitor/*" -f 10
ansible p3 -m cron -a "minute=* hour=* day=* month=* weekday=* name='chia' job='/usr/bin/python3 /root/node_monitor/node_monitor.py' user='root' state='present'"</code></pre> 
<h1>3、同步集群网络状态到rsyslog</h1> 
<p></p> 
<h2><strong>rsyslog 服务器配置</strong></h2> 
<pre><code class="language-bash">[root@jenkins ~]# cat /etc/rsyslog.conf 
$ModLoad imuxsock # provides support for local system logging (e.g. via logger command)
$ModLoad imklog   # provides kernel logging support (previously done by rklogd)
$ModLoad imudp
$UDPServerRun 514
$ModLoad imtcp
$InputTCPServerRun 514
$template myFormat,"%timestamp:::date-rfc3339% %fromhost-ip% %HOSTNAME%  [%programname%] %syslogseverity-text%:%msg%\n"
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat
$IncludeConfig /etc/rsyslog.d/*.conf
*.info;mail.none;authpriv.none;cron.none                /var/log/messages;myFormat
authpriv.*                                              /var/log/secure;myFormat
mail.*                                                  -/var/log/maillog
cron.*                                                  /var/log/cron
*.emerg                                                 :omusrmsg:*
uucp,news.crit                                          /var/log/spooler
local7.*                                                /var/log/boot.log
local5.*                                                /var/log/history/tcp.log;myFormat
#将local类型5的日志存放到 /var/log/history/tcp.log下 使用myFormat模板</code></pre> 
<h2><strong>rsyslog 客户端配置</strong></h2> 
<pre><code class="language-bash">[heian@game ~]$ cat  /etc/rsyslog.conf  | grep -Ev "^$|^#"
$ModLoad imuxsock # provides support for local system logging (e.g. via logger command)
$ModLoad imjournal # provides access to the systemd journal
$WorkDirectory /var/lib/rsyslog
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat
$IncludeConfig /etc/rsyslog.d/*.conf
$OmitLocalLogging on
$IMJournalStateFile imjournal.state
*.info;mail.none;authpriv.none;cron.none                /var/log/messages
authpriv.*                                              /var/log/secure
mail.*                                                  -/var/log/maillog
cron.*                                                  /var/log/cron
*.emerg                                                 :omusrmsg:*
uucp,news.crit                                          /var/log/spooler
local7.*                                                /var/log/boot.log
*.* @@192.168.1.210
#主要是最后一行啊啊啊啊啊啊啊啊啊，注意</code></pre> 
<p>配置文件后，记得重启客户端啊</p> 
<h1>4、查看日志</h1> 
<pre><code class="language-bash">[root@jenkins history]# pwd
/var/log/history
[root@jenkins history]# ls
tcp.log
[root@jenkins history]# cat tcp.log |wc -l
28
[root@jenkins history]# tail -f tcp.log 
2021-11-19T16:32:21+08:00 192.168.1.100 game  [heian] info: 172.18.0.2 ESTABLISHED 1
2021-11-19T16:32:21+08:00 192.168.1.100 game  [heian] info: 192.168.1.100 ESTABLISHED 6
2021-11-19T16:32:21+08:00 192.168.1.100 game  [heian] info: 192.168.1.15 ESTABLISHED 6
2021-11-19T16:32:21+08:00 192.168.1.100 game  [heian] info: 192.168.1.210 ESTABLISHED 1
2021-11-19T16:32:40+08:00 192.168.1.100 game  [heian] info: 10.10.10.3 ESTABLISHED 1
2021-11-19T16:32:40+08:00 192.168.1.100 game  [heian] info: 127.0.0.1 ESTABLISHED 6
2021-11-19T16:32:40+08:00 192.168.1.100 game  [heian] info: 172.18.0.2 ESTABLISHED 1
2021-11-19T16:32:40+08:00 192.168.1.100 game  [heian] info: 192.168.1.100 ESTABLISHED 6
2021-11-19T16:32:40+08:00 192.168.1.100 game  [heian] info: 192.168.1.15 ESTABLISHED 6
2021-11-19T16:32:40+08:00 192.168.1.100 game  [heian] info: 192.168.1.210 ESTABLISHED 1
</code></pre> 
<p>集群的数据已经同步过来，后面直接接入elk就可以了。</p> 
<h1 id="articleContentId"><a class="link-info" href="https://blog.csdn.net/heian_99/article/details/121432620">Rsyslog同步集群服务器的网络连接状态</a></h1> 
<p><img alt="" height="593" src="https://img-blog.csdnimg.cn/07d4b6c2a5684582a567930301edfb08.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1157"></p> 
<h1><a class="link-info" href="https://blog.csdn.net/heian_99/article/details/121472415">集群服务器的网络连接状态接入ELK（可视化操作）</a></h1> 
<p><img alt="" src="https://img-blog.csdnimg.cn/f0d382ca74a74af2b711e7e8e8a4a5cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>&nbsp;</p> 
<p></p>
                ]]></description></item><item><title>截取日志范围（sed）</title><link>http://www.cnblogs.com/heian99/archive/2021/11/03/15546376.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 03 Nov 2021 08:53:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/11/03/15546376.html</guid><description><![CDATA[
                    <p>&nbsp;</p> 
<p>后续补充</p> 
<pre><code class="language-bash">sed &nbsp;-n &nbsp;'/2021-02-13 21:00:00/,/2021-02-13 22:00:00/p' &nbsp; /usr/local/apache-tomcat-6.0.45/logs/crm.log &nbsp; &gt; /opt/crm-`date +%Y-%m-%d-%H-%M`.log
截取某个时间段到某个时间段的日志 &nbsp; &nbsp;
sed &nbsp;-n &nbsp;'/2021-01-18 21:10:00/,$p' &nbsp; /usr/local/apache-tomcat-6.0.45/logs/crm.log &nbsp; &gt; /opt/crm-`date +%Y-%m-%d-%H-%M`.log&nbsp;
截取某个时间段到现在的</code></pre>
                ]]></description></item><item><title>Xtrabackup工具进行在线主从搭建</title><link>http://www.cnblogs.com/heian99/archive/2021/11/01/15546377.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 01 Nov 2021 04:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/11/01/15546377.html</guid><description><![CDATA[
                    <p>在工作中，我们经常会使用mysql的主从，来去报数据的安全性。</p> 
<p>首先目前主流的备份工作mysqldump和Xtrabackup，都可以实现数据库的备份。</p> 
<p>关于那个用来备份数据，来做mysql主从，毫无疑问就是&nbsp;Xtrabackup了。</p> 
<p>首先MySQL做主从时，需要使用到binlog日志 和 pos号，关键就是这个pos。</p> 
<p>如果是mysqldump来备份，需要进行锁表才行，如果是Xtrabackup 完全可以在任务运行中，进行备份，完全不需要锁表，更不会影响业务。所以我们首选就是Xtrabackup</p> 
<p>相关原理，可以进行谷歌。</p> 
<p>在这个只暂时先关步骤</p> 
<h2>Mysql日志选择</h2> 
<h3>（1）mysql的binlog日志格式</h3> 
<p>mysql的binlog有3种日志格式。</p> 
<p><a href="http://lib.csdn.net/base/mysql" title="mysql">mysql</a>&nbsp;binlog日志有三种格式，分别为Statement,MiXED,以及ROW！</p> 
<p>查看binlog的格式的脚本：</p> 
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/90d66f3df1f0a7fa84354614dfdad784.png"></p> 
<h3>（2）binlog 的不同模式有什么区别呢？&nbsp;</h3> 
<p>1.Statement：每一条会修改数据的sql都会记录在binlog中。</p> 
<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。)</p> 
<p>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).<br> &nbsp;</p> 
<p>2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p> 
<p>优点：&nbsp;binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题</p> 
<p>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。</p> 
<p>3.Mixedlevel:&nbsp;是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。</p> 
<p></p> 
<h3>（3）Binlog基本配制与格式设定</h3> 
<p>1.基本配制</p> 
<p>Mysql BInlog日志格式可以通过mysql的my.cnf文件的属性binlog_format指定。如以下：</p> 
<p>binlog_format &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = MIXED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //binlog日志格式</p> 
<p>log_bin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =目录/mysql-bin.log&nbsp;&nbsp;&nbsp; //binlog日志名</p> 
<p>expire_logs_days &nbsp; &nbsp; = 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //binlog过期清理时间</p> 
<p>max_binlog_size &nbsp; &nbsp; &nbsp;100m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //binlog每个日志文件大小</p> 
<p></p> 
<p>2.Binlog日志格式选择</p> 
<p>Mysql默认是使用Statement日志格式，推荐使用MIXED.</p> 
<p>由于一些特殊使用，可以考虑使用ROWED，如自己通过binlog日志来同步数据的修改，这样会节省很多相关操作。对于binlog数据处理会变得非常轻松,相对mixed，解析也会很轻松(当然前提是增加的日志量所带来的IO开销在容忍的范围内即可)。&nbsp;</p> 
<pre><code class="language-bash">1.先修改从库的binlog格式
set global binlog_format=MIXED;
2.再修改主库的binlog格式
set global binlog_format=MIXED;
3.修改主库的my.cnf(避免重启失效)
binlog_format=MIXED
4.重启stop slave，start slave</code></pre> 
<h2>2、主备库均安装Xtrabackup开源工具在线热备份搭建备库</h2> 
<p></p> 
<pre><code class="language-bash">#下载工具包percona-xtrabackup-2.4.14-Linux-x86_64.libgcrypt183.tar.gz

tar -xf percona-xtrabackup-2.4.14-Linux-x86_64.libgcrypt183.tar.gz
mv percona-xtrabackup-2.4.14-Linux-x86_64 xtrabackup
mv xtrabackup/ /usr/local/
echo "export PATH=$PATH:/usr/local/xtrabackup/bin" &gt;&gt; /etc/profile
source /etc/profile</code></pre> 
<h2>3、主库在线备份(不影响业务)</h2> 
<pre><code class="language-bash">innobackupex --user='root' --password='xxxxxx' --slave-info /data1/backup/20210927 --no-timestamp --socket=/tmp/mysql.sock

#以下是输出结果:
xtrabackup: recognized server arguments: --server-id=1 --log_bin=binlog --datadir=/data1/mysql/data/ --tmpdir=/tmp 
xtrabackup: recognized client arguments: --server-id=1 --log_bin=binlog --datadir=/data1/mysql/data/ --tmpdir=/tmp 
200615 16:26:27 innobackupex: Starting the backup operation

IMPORTANT: Please check that the backup run completes successfully.
           At the end of a successful backup run innobackupex
           prints "completed OK!".
         ..........
xtrabackup: Transaction log of lsn (5055292518) to (5055292527) was copied.
200615 16:26:30 completed OK!</code></pre> 
<h2>4、检查全备的POS</h2> 
<pre><code class="language-bash">cat /data/backup/20200615/xtrabackup_binlog_info
binlog.000002   184668420</code></pre> 
<h2>5、将备份文件压缩传输到备机上</h2> 
<pre><code class="language-bash">cd /data1/backup/
tar -zcf 20210927.tar.gz  20210927
scp 20210927.tar.gz  dam@dam02:/home/dam/</code></pre> 
<h2>6、停止备库,将原来的备库datadir的路径重命名并创建新的数据data目录</h2> 
<pre><code class="language-bash">/etc/init.d/mysqld stop
cd  /data1/mysql
mv data  data3
mkdir data</code></pre> 
<h2>7、解压缩备份文件并恢复数据到新的data目录</h2> 
<pre><code class="language-bash">tar -xf  20210927.tar.gz  -C /data1/mysql/

#数据一致性恢复
innobackupex --apply-log /data1/mysql/20210927
#数据copy到dir目录
innobackupex --copy-back /data1/mysql/20210927

chown -R mysql.mysql /data1/mysql/data
chmod -R 775 /data1/mysql/data</code></pre> 
<h2>8、重启备机228的mysql</h2> 
<pre><code class="language-bash">/etc/init.d/mysqld stop
/etc/init.d/mysqld start</code></pre> 
<h2>9、配置主从同步</h2> 
<pre><code class="language-bash">#227主机创建同步用户:
create  USER 'xxxx'@'172.17.8.%' IDENTIFIED WITH mysql_native_password BY 'xxxxxx';
grant replication slave on *.* to 'syncuser'@'172.17.8.%';
flush privileges;

#228配置备机：
reset slave all; 
stop slave;
change master to master_host='172.17.8.227',master_port=3306,master_user='syncuser',master_password='xxxxx',master_log_file='binlog.000002',master_log_pos=184668420;
start slave;
show slave status\G;
show master status\G;</code></pre> 
<h2>10、为解决msyql主从延迟问题进行的相关调优：</h2> 
<pre><code class="language-bash">#主从并行复制参数：
vim my.cnf
master_info_repository=TABLE                   #master信息放到表里      
relay_log_info_repository=TABLE                #relay日志信息放到表里      
slave_parallel_type = LOGICAL_CLOCK            #基于组提交的并行复制方式
slave_parallel_workers=8                       #sql并行量
slave_preserve_commit_order=ON                  #relay顺序与master并行顺序保持一致
relay_log_recovery=ON                          #宕机时重新从master获取日志，保证relay完整性
replicate-wild-ignore-table=scheduler.tb_qa%   #不同步scheduler.tb_qa开头的表
replicate-wild-ignore-table=scheduler.tb_qc%   #不同步scheduler.tb_qc开头的表										   
stop slave;

set global master_info_repository='table';
set global relay_log_info_repository='table';
set global slave_parallel_type='logical_clock';
set global slave_parallel_workers=8;
set global slave_preserve_commit_order='on';
set global relay_log_recovery='on';

start slave;</code></pre> 
<p><img alt="" height="441" src="https://img-blog.csdnimg.cn/50e66a7d6f4d45aea6a78b1f17d3e9a6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="774"></p>
                ]]></description></item><item><title>openssh-8.6p1批量编译安装升级</title><link>http://www.cnblogs.com/heian99/archive/2021/10/30/15546378.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 30 Oct 2021 06:55:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/10/30/15546378.html</guid><description><![CDATA[
                    <p>近期因为业务系统等保，发现ssh有好多的漏洞，需要更新升级。</p> 
<p>负责的服务器有点多，不能单个手动编译，所以采用 ansible + 脚本方式批量编译安装</p> 
<p>相关下载软件地址：<a href="https://download.csdn.net/download/heian_99/35589407" title="https://download.csdn.net/download/heian_99/35589407">https://download.csdn.net/download/heian_99/35589407</a></p> 
<p><img alt="" height="851" src="https://img-blog.csdnimg.cn/746d38181ced4e5980256ade89206e05.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="553"></p> 
<p>&nbsp;<img alt="" height="278" src="https://img-blog.csdnimg.cn/e8edeb1bb61648f8a0159b451ca2c432.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="553"></p> 
<p style="margin-left:0;text-align:left;"><strong>本次升级主要解决上次升级造成的隐患，并添加12222端口，</strong></p> 
<p style="margin-left:0;text-align:left;"><strong>隐患：</strong></p> 
<ul><li style="text-align:left;">（1）sshd无法开机自启 主机重启后，sshd无法起来，需要他们手动重启</li><li style="text-align:left;">（2）ssh的配置文件目录不对 ，没办法统一管理</li></ul>
<ul><li style="text-align:left;">（3）sshd无法开机自启，导致rc-local.service 无法自启,</li></ul>
<p style="margin-left:0;text-align:left;"><strong>再次升级基础上</strong></p> 
<p style="margin-left:0;text-align:left;">（1）添加ssh_banner_change 隐藏版本信息</p> 
<p style="margin-left:0;text-align:left;">（2）编译是修改版本号，禁止telnet显示版本号</p> 
<p style="margin-left:0;text-align:left;">（3）禁止root的密码登录</p> 
<p style="margin-left:0;text-align:left;">端口添加</p> 
<p style="margin-left:0;text-align:left;">（注：集群有些业务是需要22端口，暂时不能直接去掉22端口）</p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="88" src="https://img-blog.csdnimg.cn/446865ea023a4fbb99197bf531cb9550.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="553"></p> 
<p>&nbsp;隐藏效果</p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="181" src="https://img-blog.csdnimg.cn/7db72f16e34e4651ab0b358acac69eca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="553"></p> 
<p><img alt="" height="164" src="https://img-blog.csdnimg.cn/ac10c0495e464bfd97081ebc3f87be59.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="551"></p> 
<p><strong>sshup.sh</strong></p> 
<pre><code class="language-bash">#!/bin/bash
# 作者：南宫乘风
# 作用：升级ssh 到 OpenSSH_8.6p1 版本，并添加12222端口

#日期和升级过程中步骤
log="/opt/backup/update_log"
datetime=$(date '+%Y-%m-%d %H:%M:%S')
hostname=`hostname`
echo "==========主机名：${hostname} 开始升级==============" &gt;&gt;${log}
yum -y install openssl-devel zlib-devel gcc gcc-c++ pam-devel perl
#步骤 ：备份  解压 编译 重启

#备份，主要是/etc/ssh 目录 和 先关升级的包
backup=/opt/backup/update_2021_11_01
mkdir -p ${backup}
echo "${backup} 创建成功" &gt;&gt;${log}
#备份文件 主要是移除
echo "=======time: ${datetime}=======开始备份文件==============" &gt;&gt;${log}
mv /etc/ssh ${backup}
mv /usr/sbin/sshd ${backup}
mv /usr/bin/ssh ${backup}/ssh_bak
mv /usr/bin/ssh-keygen ${backup}
datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "${datetime}    /etc/ssh 备份成功" &gt;&gt;${log}
echo "${datetime}    /usr/sbin/sshd 备份成功" &gt;&gt;${log}
echo "${datetime}    /usr/bin/ssh 备份成功" &gt;&gt;${log}
echo "${datetime}    /usr/bin/ssh-keygen 备份成功" &gt;&gt;${log}
FILE=/lib/systemd/system/sshd.service
if [ -f "$FILE" ]; then
	rm -rf /lib/systemd/system/sshd.service
	echo "sshd.service  已清除" &gt;&gt;${log}
fi
datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======备份程序编译文件==============" &gt;&gt;${log}
mv /usr/local/src/openssh* ${backup}
mv /usr/local/src/openssl* ${backup}
mv /usr/local/src/zlib* ${backup}

datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======开始解压文件==============" &gt;&gt;${log}
#解压
cd /opt/backup/ssh_tar
tar xf openssh-8.6p1.tar.gz -C /usr/local/src/
tar xf openssl-1.1.1i.tar.gz -C /usr/local/src/
tar xf zlib-1.2.11.tar.gz -C /usr/local/src/

datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======开始编译zlib==============" &gt;&gt;${log}
#移除
mv /usr/local/zlib ${backup}
cd /usr/local/src/zlib-1.2.11/
./configure --prefix=/usr/local/zlib &amp;&amp; make -j 4 &amp;&amp; make install

datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======开始编译openssl==============" &gt;&gt;${log}
#openssl
mv /usr/local/ssl ${backup}
cd /usr/local/src/openssl-1.1.1i/
./config --prefix=/usr/local/ssl -d shared
make -j 4 &amp;&amp; make install
echo '/usr/local/ssl/lib' &gt;&gt;/etc/ld.so.conf
ldconfig -v
datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======开始编译openssh==============" &gt;&gt;${log}
#openssh
mv /usr/local/openssh ${backup}
cd /usr/local/src/openssh-8.6p1/
sed -i 's/OpenSSH_8.6/Prohibit_detection/g'  /usr/local/src/openssh-8.6p1/version.h
./configure --prefix=/usr/local/openssh --sysconfdir=/etc/ssh --with-pam --with-ssl-dir=/usr/local/ssl --with-zlib=/usr/local/zlib
make -j 4 &amp;&amp; make install
echo 'Version is empty'&gt;&gt; /etc/ssh_banner_change
echo 'Banner /etc/ssh_banner_change' &gt;&gt; /etc/ssh/sshd_config

echo 'Port 22' &gt;&gt;/etc/ssh/sshd_config
echo 'Port 12222' &gt;&gt;/etc/ssh/sshd_config

echo 'PermitRootLogin without-password' &gt;&gt;/etc/ssh/sshd_config
echo 'PubkeyAuthentication yes' &gt;&gt;/etc/ssh/sshd_config
echo 'PasswordAuthentication yes' &gt;&gt;/etc/ssh/sshd_config
echo 'UsePAM yes' &gt;&gt;/etc/ssh/sshd_config
echo 'KexAlgorithms curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group14-sha1' &gt;&gt;/etc/ssh/sshd_config

datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======开始写入pam_sshd==============" &gt;&gt;${log}
cp /etc/pam.d/sshd ${backup}/pam_sshd
if [ ! -e /etc/pam.d/sshd ]; then
	cat &gt;/etc/pam.d/sshd &lt;&lt;EOF
#%PAM-1.0
auth       required     pam_sepermit.so
auth       substack     password-auth
auth       include      postlogin
# Used with polkit to reauthorize users in remote sessions
-auth      optional     pam_reauthorize.so prepare
account    required     pam_nologin.so
account    include      password-auth
password   include      password-auth
# pam_selinux.so close should be the first session rule
session    required     pam_selinux.so close
session    required     pam_loginuid.so
# pam_selinux.so open should only be followed by sessions to be executed in the user context
session    required     pam_selinux.so open env_params
session    required     pam_namespace.so
session    optional     pam_keyinit.so force revoke
session    include      password-auth
session    include      postlogin
# Used with polkit to reauthorize users in remote sessions
-session   optional     pam_reauthorize.so prepare
EOF
	chmod 644 /etc/pam.d/sshd
else
	cp -pf /etc/pam.d/{login,sshd}
fi

datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======开始覆盖sshd，ssh，ssh-keygen==============" &gt;&gt;${log}
cp -rf /usr/local/openssh/sbin/sshd /usr/sbin/sshd
cp -rf /usr/local/openssh/bin/ssh /usr/bin/ssh
cp -rf /usr/local/openssh/bin/ssh-keygen /usr/bin/ssh-keygen
chmod 755 /usr/sbin/sshd
chmod 755 /usr/bin/ssh
chmod 755 /usr/bin/ssh-keygen
datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======设置开机自启sshd==============" &gt;&gt;${log}
\cp  /usr/local/src/openssh-8.6p1/contrib/redhat/sshd.init /etc/init.d/sshd
chmod u+x /etc/init.d/sshd
systemctl daemon-reload
/etc/init.d/sshd restart
chkconfig --add sshd
chkconfig sshd on
chkconfig --list sshd
datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======sshd升级成功==============" &gt;&gt;${log}
echo -e "本次升级使用: $SECONDS seconds"
datetime=$(date '+%Y-%m-%d %H:%M:%S')
echo "=======time: ${datetime}=======本次升级使用: ${SECONDS} seconds ==============" &gt;&gt;${log}
</code></pre> 
<p>&nbsp;配合ansible 批量升级</p> 
<pre><code class="language-bash">[heian@zabbix ssh]$ cat ssh-update.yml 
- hosts: test
  remote_user: heian
  gather_facts: false
  become: yes
  become_user: root
  become_method: sudo
  vars:
   - ssh_tar: /opt/backup/ssh_tar
  tasks:
  - name: 创建ssh_tar目录
    file:
      path: "{<!-- -->{ssh_tar}}"
      state: directory
      mode: '0755'
  - name: 分发编译包
    copy:
      src: "{<!-- -->{ item }}"
      dest: "{<!-- -->{ ssh_tar }}"
      mode: 0755
    with_items:
      - /home/heian/ssh/openssh-8.6p1.tar.gz
      - /home/heian/ssh/openssl-1.1.1i.tar.gz
      - /home/heian/ssh/zlib-1.2.11.tar.gz
      - /home/heian/ssh/sshup.sh
  - name: 执行sshd升级脚本
    shell: sh /opt/backup/ssh_tar/sshup.sh
  - name: 查看升级结果
    shell: cat /opt/backup/update_log
    register: ssh_log
  - name: Debug number
    debug:
      msg: " IP : {<!-- -->{ inventory_hostname }}  升级结果 : {<!-- -->{ ssh_log.stdout  }} "
</code></pre> 
<p style="margin-left:0;text-align:left;"><img alt="" height="296" src="https://img-blog.csdnimg.cn/d2c97494a4c94825b2e328e09ebce52f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_19,color_FFFFFF,t_70,g_se,x_16" width="553"></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p>&nbsp;参考文档：<a href="https://www.cnblogs.com/chillax1314/p/13858655.html" title="CentOS7.x升级openssh8.4p1详解 - chillax1314 - 博客园">CentOS7.x升级openssh8.4p1详解 - chillax1314 - 博客园</a></p>
                ]]></description></item><item><title>Kubernetes安装zookeeper集群</title><link>http://www.cnblogs.com/heian99/archive/2021/10/14/15546379.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 14 Oct 2021 10:08:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/10/14/15546379.html</guid><description><![CDATA[
                    <p>业务要求，近期集群要使用zookeeper集群，准备在Kubernetes实现。</p> 
<p></p> 
<h2>方法一：</h2> 
<p>使用pv和pvc 来挂载</p> 
<p>这个同时创建pv和pvc</p> 
<pre><code class="language-bash">[root@k8s-master k8s-yaml]# cat zookeeper-pv.yaml 
apiVersion: v1
kind: PersistentVolume
metadata: 
  name: zk-01
  labels:
    name: zk-cluster
    type: nfs
spec:
  nfs:
    path: /home/installapp/nfs/data/zk-01
    server: 192.168.1.210
  accessModes: 
  - "ReadWriteOnce"
  capacity:
    storage: 1Gi
  persistentVolumeReclaimPolicy: Recycle
---
apiVersion: v1
kind: PersistentVolume
metadata: 
  name: zk-02
  labels:
    name: zk-cluster
    type: nfs
spec:
  nfs:
    path: /home/installapp/nfs/data/zk-02
    server: 192.168.1.210
  accessModes: 
  - "ReadWriteOnce"
  capacity:
    storage: 1Gi
  persistentVolumeReclaimPolicy: Recycle
---
apiVersion: v1
kind: PersistentVolume
metadata: 
  name: zk-03
  labels:
    name: zk-cluster
    type: nfs
spec:
  nfs:
    path: /home/installapp/nfs/data/zk-03
    server: 192.168.1.210
  accessModes: 
  - "ReadWriteOnce"
  capacity:
    storage: 1Gi
  persistentVolumeReclaimPolicy: Recycle
</code></pre> 
<pre><code class="language-bash">[root@k8s-master k8s-yaml]# cat statefulset-zk.yaml 
apiVersion: v1
kind: Service
metadata:
  name: zk-hs
  labels:
    app: zk
spec:
  ports:
  - port: 2888
    name: server
  - port: 3888
    name: leader-election
  clusterIP: None
  selector:
    app: zk
---
apiVersion: v1
kind: Service
metadata:
  name: zk-cs
  labels:
    app: zk
spec:
  ports:
  - port: 2181
    name: client
  selector:
    app: zk
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: zk-pdb
spec:
  selector:
    matchLabels:
      app: zk
  maxUnavailable: 1
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: zk
spec:
  selector:
    matchLabels:
      app: zk
  serviceName: zk-hs
  replicas: 3
  updateStrategy:
    type: RollingUpdate
  podManagementPolicy: OrderedReady
  template:
    metadata:
      labels:
        app: zk
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: "app"
                    operator: In
                    values:
                    - zk
              topologyKey: "kubernetes.io/hostname"
      containers:
      - name: kubernetes-zookeeper
        imagePullPolicy: IfNotPresent
        image: k8s.gcr.io/kubernetes-zookeeper:1.0-3.4.10
        resources:
          requests:
            memory: "1Gi"
            cpu: "0.5"
        ports:
        - containerPort: 2181
          name: client
        - containerPort: 2888
          name: server
        - containerPort: 3888
          name: leader-election
        command:
        - sh
        - -c
        - "start-zookeeper \
          --servers=3 \
          --data_dir=/var/lib/zookeeper/data \
          --data_log_dir=/var/lib/zookeeper/data/log \
          --conf_dir=/opt/zookeeper/conf \
          --client_port=2181 \
          --election_port=3888 \
          --server_port=2888 \
          --tick_time=2000 \
          --init_limit=10 \
          --sync_limit=5 \
          --heap=512M \
          --max_client_cnxns=60 \
          --snap_retain_count=3 \
          --purge_interval=12 \
          --max_session_timeout=40000 \
          --min_session_timeout=4000 \
          --log_level=INFO"
        readinessProbe:
          exec:
            command:
            - sh
            - -c
            - "zookeeper-ready 2181"
          initialDelaySeconds: 10
          timeoutSeconds: 5
        livenessProbe:
          exec:
            command:
            - sh
            - -c
            - "zookeeper-ready 2181"
          initialDelaySeconds: 10
          timeoutSeconds: 5
        volumeMounts:
        - name: datadir
          mountPath: /var/lib/zookeeper
      securityContext:
        # runAsUser: 1000
        fsGroup: 1000
  volumeClaimTemplates:
  - metadata:
      name: datadir
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
</code></pre> 
<p></p> 
<h2>方法二</h2> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: zk-hs
  namespace: uat
  labels:
    app: zk
spec:
  ports:
  - port: 2888
    name: server
  - port: 3888
    name: leader-election
  clusterIP: None
  selector:
    app: zk
---
apiVersion: v1
kind: Service
metadata:
  name: zk-cs
  namespace: uat
  labels:
    app: zk
spec:
  ports:
  - port: 2181
    name: client
  selector:
    app: zk
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: zk-pdb
  namespace: uat
spec:
  selector:
    matchLabels:
      app: zk
  maxUnavailable: 1
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: zk
  namespace: uat
spec:
  selector:
    matchLabels:
      app: zk
  serviceName: zk-hs
  replicas: 3
  updateStrategy:
    type: RollingUpdate
  podManagementPolicy: OrderedReady
  template:
    metadata:
      labels:
        app: zk
    spec:
      nodeSelector:
        env: uat
      containers:
      - name: kubernetes-zookeeper
        imagePullPolicy: IfNotPresent
        image: k8s.gcr.io/kubernetes-zookeeper:1.0-3.4.10
        resources:
          requests:
            memory: "1Gi"
            cpu: "0.5"
        ports:
        - containerPort: 2181
          name: client
        - containerPort: 2888
          name: server
        - containerPort: 3888
          name: leader-election
        command:
        - sh
        - -c
        - "start-zookeeper \
          --servers=3 \
          --data_dir=/var/lib/zookeeper/data/${HOSTNAME} \
          --data_log_dir=/var/lib/zookeeper/data/${HOSTNAME}/log \
          --conf_dir=/opt/zookeeper/conf \
          --client_port=2181 \
          --election_port=3888 \
          --server_port=2888 \
          --tick_time=2000 \
          --init_limit=10 \
          --sync_limit=5 \
          --heap=512M \
          --max_client_cnxns=60 \
          --snap_retain_count=3 \
          --purge_interval=12 \
          --max_session_timeout=40000 \
          --min_session_timeout=4000 \
          --log_level=INFO"
        readinessProbe:
          exec:
            command:
            - sh
            - -c
            - "zookeeper-ready 2181"
          initialDelaySeconds: 10
          timeoutSeconds: 5
        livenessProbe:
          exec:
            command:
            - sh
            - -c
            - "zookeeper-ready 2181"
          initialDelaySeconds: 10
          timeoutSeconds: 5
        volumeMounts:
          - name: datadir
            mountPath: /var/lib/zookeeper
          - name: host-time
            mountPath: /etc/localtime
#      securityContext:
#        runAsUser: 0
#        fsGroup: 0
      volumes:
      - name: datadir
        hostPath:
          path: /store/logs/uat/zk
          type: DirectoryOrCreate
      - name: host-time
        hostPath:
          path: /etc/localtime
</code></pre> 
<p></p>
                ]]></description></item><item><title>Kubernetes收集pod的日志</title><link>http://www.cnblogs.com/heian99/archive/2021/10/12/15546381.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 12 Oct 2021 09:58:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/10/12/15546381.html</guid><description><![CDATA[
                    <p>背景环境：<br> 开发频繁查看日志，登录服务器导出日志比较耗费时间，搭建一款轻量又简单的日志查询工具供开<br> 发查询容器日志。<br> 方案选型：<br> （1）ELK（EFK）适用于日志体系比较大的场景，且比较消耗服务器资源。<br> （2）Loki----&gt;轻量级（特点：简洁明了，安装部署简单）-----&gt;适用于当前环境</p> 
<pre><code class="language-bash">#1.安装helm
首先安装helm管理工具（官网）：https://helm.sh/docs/intro/install/
[root@k8s-node01 ~]# wget https://get.helm.sh/helm-v3.3.3-linux-amd64.tar.gz
[root@k8s-node01 ~]# tar xf helm-v3.3.3-linux-amd64.tar.gz
[root@k8s-node01 ~]# mv linux-amd64/helm /usr/local/bin/helm
[root@k8s-node01 ~]# helm version
version.BuildInfo{Version:"v3.3.3",
GitCommit:"55e3ca022e40fe200fbc855938995f40b2a68ce0", GitTreeState:"clean",
GoVersion:"go1.14.9"}

[root@k8s-node01 ~]# mkdir loki
[root@k8s-node01 ~]# ls
anaconda-ks.cfg helm-v3.3.3-linux-amd64.tar.gz linux-amd64 loki thirdservice
[root@k8s-node01 ~]# cd loki/
[root@k8s-node01 loki]# helm repo add loki https://grafana.github.io/loki/charts
&amp;&amp; helm repo update
[root@k8s-node01 loki]# helm pull loki/loki-stack
[root@k8s-node01 loki]# tar xf loki-stack-2.1.2.tgz
[root@k8s-node01 loki]# helm install loki -n loki loki-stack/


#创建grafana文件
[root@k8s-node01 loki]# cat grangfan.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  labels:
    app: grafana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
      - name: grafana
        image: grafana/grafana:latest
        volumeMounts:
        - name: timezone
          mountPath: /etc/localtime
      volumes:
        - name: timezone
          hostPath:
            path: /usr/share/zoneinfo/Asia/Shanghai

---

apiVersion: v1
kind: Service
metadata:
  name: grafana-svc
  #namespace: test
spec:
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 3303
  type: NodePort
  selector:
    app: grafana</code></pre> 
<p>浏览器访问 IP:3003 账号密码：admin admin<br> 数据源配置</p> 
<p><img alt="" height="538" src="https://img-blog.csdnimg.cn/20211012175645983.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1110"></p> 
<p>loki:3100&nbsp;</p> 
<p><img alt="" height="555" src="https://img-blog.csdnimg.cn/20211012175700336.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1127"></p> 
<p>容器日志查询&nbsp;&nbsp;&nbsp;</p> 
<p><img alt="" height="559" src="https://img-blog.csdnimg.cn/20211012175715924.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1130"></p> 
<p>依次点击实时查看容器日志&nbsp;</p> 
<p><img alt="" height="539" src="https://img-blog.csdnimg.cn/20211012175728609.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1114"></p> 
<p>效果图</p> 
<p><img alt="" height="561" src="https://img-blog.csdnimg.cn/20211012175749979.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1133"></p> 
<p>&nbsp;</p> 
<p></p>
                ]]></description></item><item><title>Minio--Mysql存储桶通知配置</title><link>http://www.cnblogs.com/heian99/archive/2021/09/22/15335270.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 22 Sep 2021 08:00:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/09/22/15335270.html</guid><description><![CDATA[
                    <p><span style="color:#FF0000;">**！！！中文社区中说的config.json的方式已经打算被废弃了，所以现在最好通过minio客户端的方式进行处理了**</span></p> 
<p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">·&nbsp;<strong>在目标mysql创建数据库miniodb（<span style="color:#FF0000;">要用默认字符集</span>，不然会报错）</strong></span></span></p> 
<p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">·&nbsp;<strong>在minio client的可执行目录下执行如下命令，查看是否已经存在配置</strong></span></span></p> 
<pre><code class="language-bash">mc --insecure admin config get minio notify_mysql</code></pre> 
<p><strong>添加Mysql通知配置</strong></p> 
<pre><code class="language-bash"> mc admin config set minio notify_mysql:mysql table="minio_log" dsn_string="minio:minio@tcp(192.168.1.200:3306)/minio"</code></pre> 
<p>步骤：先创建minio的数据库，编码默认一下，在执行这条命令，但是会报错。</p> 
<p>发现报错，错误如下：</p> 
<pre><code>Error: Error 1071: Specified key was too long; max key length is 3072 bytes</code></pre> 
<p>解决办法：手动创建记录表就可以了</p> 
<pre><code class="language-bash">CREATE TABLE `minio_log` (
  `key_name` varchar(1000) DEFAULT NULL,
  `value` longtext
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</code></pre> 
<p>关联event事件</p> 
<pre><code> mc event add minio/k8s/ arn:minio:sqs::mysql:mysql

查看
mc event list minio/k8s/</code></pre> 
<p>&nbsp;重启server服务，直接命令重启</p> 
<pre><code class="language-bash"> mc admin service restart minio/k8s/</code></pre> 
<p><img alt="" height="540" src="https://img-blog.csdnimg.cn/20210922155940242.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>企业级-纯内网构建Harbor （HTTPS认证）</title><link>http://www.cnblogs.com/heian99/archive/2021/09/16/15335271.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 16 Sep 2021 06:19:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/09/16/15335271.html</guid><description><![CDATA[
                    <p>集群内部构建一套Kubernetes集群，纯内网没有公网环境，无法拉取镜像，不是很方便</p> 
<p>前期做法，本地拉去镜像，保存，上传内网，加载。这个是针对每台机器的步骤。</p> 
<p>步骤比较繁琐，和机械化。</p> 
<p>所以准备在内部构建harbor，走域名绑定。docker加载配置，后期可以正常使用。</p> 
<h1>1、环境</h1> 
<p>Docker version 20.10.7</p> 
<p>docker-compose version 1.29.2</p> 
<p>harbor-offline-installer-v2.3.1.tgz</p> 
<p>内网安装，我选择离线版本的</p> 
<p><a href="https://github.com/goharbor/harbor/releases/tag/v2.3.2" title="Release v2.3.2 · goharbor/harbor · GitHub">Release v2.3.2 · goharbor/harbor · GitHub</a></p> 
<h1>2、生成https证书</h1> 
<p>&nbsp;docker 和 docker-compose 已经安装好下进行</p> 
<pre><code class="language-bash">cd /opt/cert
#输入密码
openssl genrsa -des3 -out server.pass.key 2048
#去除密码
openssl rsa -in server.pass.key -out server.key
#生成域名证书
openssl req -new -key server.key -out server.csr -subj "/C=CN/ST=Jiangsu/L=Nanjing/O=Company/OU=group/CN=hub.docker.com"
#生成时间多久
openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt
#生成pem的（可以跳过）
openssl x509 -in server.crt -out server.pem -outform PEM
</code></pre> 
<p><img alt="" height="91" src="https://img-blog.csdnimg.cn/20210916140855868.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="601"></p> 
<h1>&nbsp;3、安装harbor</h1> 
<p>解压文件</p> 
<pre><code class="language-bash">#复制新的配置
[root@hdpv3test08 harbor]# cat harbor.yml
# Configuration file of Harbor

# The IP address or hostname to access admin UI and registry service.
# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.
hostname: hub.docker.com

# http related config
http:
  # port for http, default is 80. If https enabled, this port will redirect to https port
  port: 80

# https related config
https:
  # https port for harbor, default is 443
  port: 443
  # The path of cert and key files for nginx
  certificate: /opt/cert/server.crt
  private_key: /opt/cert/server.key

# # Uncomment following will enable tls communication between all harbor components
# internal_tls:
#   # set enabled to true means internal tls is enabled
#   enabled: true
#   # put your cert and key files on dir
#   dir: /etc/harbor/tls/internal

# Uncomment external_url if you want to enable external proxy
# And when it enabled the hostname will no longer used
# external_url: https://reg.mydomain.com:8433

# The initial password of Harbor admin
# It only works in first time to install harbor
# Remember Change the admin password from UI after launching Harbor.
harbor_admin_password: Harbor12345

# Harbor DB configuration
database:
  # The password for the root user of Harbor DB. Change this before any production use.
  password: root123
  # The maximum number of connections in the idle connection pool. If it &lt;=0, no idle connections are retained.
  max_idle_conns: 100
  # The maximum number of open connections to the database. If it &lt;= 0, then there is no limit on the number of open connections.
  # Note: the default number of connections is 1024 for postgres of harbor.
  max_open_conns: 900

# The default data volume
data_volume: /data/service/harbor

# Harbor Storage settings by default is using /data dir on local filesystem
# Uncomment storage_service setting If you want to using external storage
# storage_service:
#   # ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore
#   # of registry's and chart repository's containers.  This is usually needed when the user hosts a internal storage with self signed certificate.
#   ca_bundle:

#   # storage backend, default is filesystem, options include filesystem, azure, gcs, s3, swift and oss
#   # for more info about this configuration please refer https://docs.docker.com/registry/configuration/
#   filesystem:
#     maxthreads: 100
#   # set disable to true when you want to disable registry redirect
#   redirect:
#     disabled: false

# Trivy configuration
#
# Trivy DB contains vulnerability information from NVD, Red Hat, and many other upstream vulnerability databases.
# It is downloaded by Trivy from the GitHub release page https://github.com/aquasecurity/trivy-db/releases and cached
# in the local file system. In addition, the database contains the update timestamp so Trivy can detect whether it
# should download a newer version from the Internet or use the cached one. Currently, the database is updated every
# 12 hours and published as a new release to GitHub.
trivy:
  # ignoreUnfixed The flag to display only fixed vulnerabilities
  ignore_unfixed: false
  # skipUpdate The flag to enable or disable Trivy DB downloads from GitHub
  #
  # You might want to enable this flag in test or CI/CD environments to avoid GitHub rate limiting issues.
  # If the flag is enabled you have to download the `trivy-offline.tar.gz` archive manually, extract `trivy.db` and
  # `metadata.json` files and mount them in the `/home/scanner/.cache/trivy/db` path.
  skip_update: false
  #
  # insecure The flag to skip verifying registry certificate
  insecure: false
  # github_token The GitHub access token to download Trivy DB
  #
  # Anonymous downloads from GitHub are subject to the limit of 60 requests per hour. Normally such rate limit is enough
  # for production operations. If, for any reason, it's not enough, you could increase the rate limit to 5000
  # requests per hour by specifying the GitHub access token. For more details on GitHub rate limiting please consult
  # https://developer.github.com/v3/#rate-limiting
  #
  # You can create a GitHub token by following the instructions in
  # https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line
  #
  # github_token: xxx

jobservice:
  # Maximum number of job workers in job service
  max_job_workers: 10

notification:
  # Maximum retry count for webhook job
  webhook_job_max_retry: 10

chart:
  # Change the value of absolute_url to enabled can enable absolute url in chart
  absolute_url: disabled

# Log configurations
log:
  # options are debug, info, warning, error, fatal
  level: info
  # configs for logs in local storage
  local:
    # Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.
    rotate_count: 50
    # Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.
    # If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G
    # are all valid.
    rotate_size: 200M
    # The directory on your host that store log
    location: /var/log/harbor

  # Uncomment following lines to enable external syslog endpoint.
  # external_endpoint:
  #   # protocol used to transmit log to external endpoint, options is tcp or udp
  #   protocol: tcp
  #   # The host of external endpoint
  #   host: localhost
  #   # Port of external endpoint
  #   port: 5140

#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!
_version: 2.3.0

# Uncomment external_database if using external database.
# external_database:
#   harbor:
#     host: harbor_db_host
#     port: harbor_db_port
#     db_name: harbor_db_name
#     username: harbor_db_username
#     password: harbor_db_password
#     ssl_mode: disable
#     max_idle_conns: 2
#     max_open_conns: 0
#   notary_signer:
#     host: notary_signer_db_host
#     port: notary_signer_db_port
#     db_name: notary_signer_db_name
#     username: notary_signer_db_username
#     password: notary_signer_db_password
#     ssl_mode: disable
#   notary_server:
#     host: notary_server_db_host
#     port: notary_server_db_port
#     db_name: notary_server_db_name
#     username: notary_server_db_username
#     password: notary_server_db_password
#     ssl_mode: disable

# Uncomment external_redis if using external Redis server
# external_redis:
#   # support redis, redis+sentinel
#   # host for redis: &lt;host_redis&gt;:&lt;port_redis&gt;
#   # host for redis+sentinel:
#   #  &lt;host_sentinel1&gt;:&lt;port_sentinel1&gt;,&lt;host_sentinel2&gt;:&lt;port_sentinel2&gt;,&lt;host_sentinel3&gt;:&lt;port_sentinel3&gt;
#   host: redis:6379
#   password:
#   # sentinel_master_set must be set to support redis+sentinel
#   #sentinel_master_set:
#   # db_index 0 is for core, it's unchangeable
#   registry_db_index: 1
#   jobservice_db_index: 2
#   chartmuseum_db_index: 3
#   trivy_db_index: 5
#   idle_timeout_seconds: 30

# Uncomment uaa for trusting the certificate of uaa instance that is hosted via self-signed cert.
# uaa:
#   ca_file: /path/to/ca

# Global proxy
# Config http proxy for components, e.g. http://my.proxy.com:3128
# Components doesn't need to connect to each others via http proxy.
# Remove component from `components` array if want disable proxy
# for it. If you want use proxy for replication, MUST enable proxy
# for core and jobservice, and set `http_proxy` and `https_proxy`.
# Add domain to the `no_proxy` field, when you want disable proxy
# for some special registry.
proxy:
  http_proxy:
  https_proxy:
  no_proxy:
  components:
    - core
    - jobservice
    - trivy

# metric:
#   enabled: false
#   port: 9090
#   path: /metrics

</code></pre> 
<p>安装</p> 
<pre><code class="language-bash">./prepare
./install.sh --with-notary --with-trivy --with-chartmuseum
</code></pre> 
<p>安装完就成功</p> 
<p><img alt="" height="522" src="https://img-blog.csdnimg.cn/20210916141158676.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1158"></p> 
<p>&nbsp;<img alt="" height="1080" src="https://img-blog.csdnimg.cn/20210916141235817.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<h1>&nbsp;4、配置本地域名</h1> 
<p>由于是内网，我们需要写入hosts文件，配置本地域名</p> 
<pre><code class="language-bash">[root@hdpv3test08 harbor]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
172.17.9.47 hub.docker.com
</code></pre> 
<h1>5、配置docker</h1> 
<p>给dock添加仓库，我们自建的，需要添加到配置里面</p> 
<pre><code class="language-bash">[root@hdpv3test08 harbor]# cat /etc/docker/daemon.json 
{
    "insecure-registries":["hub.docker.com"]
}
[</code></pre> 
<p>填加完需要重启，但是由于已经容器，重启会照成影响，我们可以热加载</p> 
<p><strong>热加载</strong></p> 
<pre><code class="language-bash">[root@hdpv3test08 harbor]# ps -ef | grep docker
root      81995      1  0 9月15 ?       00:04:03 /usr/bin/dockerd
[root@hdpv3test08 harbor]# kill -HUP 81995      
这个就是热加载</code></pre> 
<p></p> 
<h1>6、测试</h1> 
<pre><code class="language-bash">docker login hub.docker.com -u admin -p Harbor12345</code></pre> 
<p><img alt="" height="186" src="https://img-blog.csdnimg.cn/20210916141613296.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="797"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>calico-node 报错calico/node is not ready: BIRD is not ready: BGP not established with</title><link>http://www.cnblogs.com/heian99/archive/2021/09/15/15335272.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 15 Sep 2021 02:57:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/09/15/15335272.html</guid><description><![CDATA[
                    <h3><strong>错误</strong></h3> 
<p>今天不知道怎么回事，一台机器的calico-node报错，也就是无法初始化正常</p> 
<p><img alt="" height="433" src="https://img-blog.csdnimg.cn/20210915105413198.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="828"></p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">Events:
  Type     Reason     Age   From               Message
  ----     ------     ----  ----               -------
  Normal   Scheduled  45s   default-scheduler  Successfully assigned kube-system/calico-node-pkbkv to k8s-node2
  Normal   Started    45s   kubelet            Started container install-cni
  Normal   Pulled     45s   kubelet            Container image "docker.io/calico/cni:v3.20.0" already present on machine
  Normal   Started    45s   kubelet            Started container upgrade-ipam
  Normal   Pulled     45s   kubelet            Container image "docker.io/calico/cni:v3.20.0" already present on machine
  Normal   Created    45s   kubelet            Created container install-cni
  Normal   Created    45s   kubelet            Created container upgrade-ipam
  Normal   Started    44s   kubelet            Started container flexvol-driver
  Normal   Pulled     44s   kubelet            Container image "docker.io/calico/pod2daemon-flexvol:v3.20.0" already present on machine
  Normal   Created    44s   kubelet            Created container flexvol-driver
  Normal   Pulled     43s   kubelet            Container image "docker.io/calico/node:v3.20.0" already present on machine
  Normal   Created    43s   kubelet            Created container calico-node
  Normal   Started    43s   kubelet            Started container calico-node
  Warning  Unhealthy  40s   kubelet            Readiness probe failed: calico/node is not ready: BIRD is not ready: Error querying BIRD: unable to connect to BIRDv4 socket: dial unix /var/run/calico/bird.ctl: connect: connection refused
  Warning  Unhealthy  30s   kubelet            Readiness probe failed: 2021-09-15 02:36:49.282 [INFO][417] confd/health.go 180: Number of node(s) with BGP peering established = 0
calico/node is not ready: BIRD is not ready: BGP not established with 172.17.6.120,172.17.6.121,172.17.6.122
  Warning  Unhealthy  20s  kubelet  Readiness probe failed: 2021-09-15 02:36:59.282 [INFO][497] confd/health.go 180: Number of node(s) with BGP peering established = 0
calico/node is not ready: BIRD is not ready: BGP not established with 172.17.6.120,172.17.6.121,172.17.6.122
  Warning  Unhealthy  10s  kubelet  Readiness probe failed: 2021-09-15 02:37:09.280 [INFO][567] confd/health.go 180: Number of node(s) with BGP peering established = 0
calico/node is not ready: BIRD is not ready: BGP not established with 172.17.6.120,172.17.6.121,172.17.6.122
</code></pre> 
<h3>解决办法</h3> 
<pre><code class="language-bash">Remove interfaces related to docker and flannel:
ip link
For each interface for docker or flannel, do the following
ifconfig &lt;name of interface from ip link&gt; down
ip link delete &lt;name of interface from ip link&gt;</code></pre> 
<p>移除这台主机多余的docker网卡和calico</p> 
<p>然后从重新删除这个错误pod的，就会恢复正常</p> 
<p><img alt="" height="581" src="https://img-blog.csdnimg.cn/20210915105625479.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1127"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Prometheus报警规则别名设置</title><link>http://www.cnblogs.com/heian99/archive/2021/09/12/15257896.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 12 Sep 2021 05:03:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/09/12/15257896.html</guid><description><![CDATA[
                    <p></p> 
<p>prometheus报警规则，是由promsql语句编写组合的，但是有时语句会很长，我们看还好，但是有时间业务组那边也会使用promsql来看主机偏高的指标，这边只能设置别名，方便他们使用。</p> 
<p><strong>别名设置：</strong></p> 
<p>很简单，也是和报警规则一样，但是语法可能不一样</p> 
<p><strong>示例</strong><br> &nbsp;</p> 
<pre><code class="language-bash">[root@hdpv3test08 rules]# cat prometheus_rules_name.yml 
groups:
- name: alive
  rules:
  - record: node:ping:total 
    expr: up 
- name: cpu
  rules:
  - record: node:cpu_usage:ratio #别的文件使用，直接使用这个
    expr: ((100 - (avg by(instance,ip,hostname) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100))) 
- name: mem
  rules:
  - record: node:memory_usage:ratio
    expr: (100 -(node_memory_MemTotal_bytes -node_memory_MemFree_bytes+node_memory_Buffers_bytes+node_memory_Cached_bytes ) / node_memory_MemTotal_bytes * 100 )</code></pre> 
<p>node:cpu_usage:ratio 就是查看cpu使用率的指标</p> 
<p>下面两张图就是区别</p> 
<p><img alt="" height="301" src="https://img-blog.csdnimg.cn/20210912125819832.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="300" src="https://img-blog.csdnimg.cn/20210912125903402.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;我们正常使用，就是直接采用这个别名指标了</p> 
<p><img alt="" height="174" src="https://img-blog.csdnimg.cn/20210912130017467.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="924"></p> 
<p>&nbsp;<strong>业务组使用</strong></p> 
<p style="margin-left:0;text-align:left;">prometheus支持promsql语法，我们可以通过相关语句，很快定位到集群，资源使用情况</p> 
<p style="margin-left:0;text-align:left;">如：高CPU 高内存，出入流量大， tcp连接数多等等一些列问题。</p> 
<p style="margin-left:0;text-align:left;"><strong>主机重启</strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">delta(node_boot_time_seconds[5m]) != 0</span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><img alt="" height="489" src="https://img-blog.csdnimg.cn/20210912130137384.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p style="margin-left:0;text-align:left;"><strong>文件只读异常</strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">node_filesystem_readonly == 1</span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><strong>CPU</strong><strong>使用率</strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">((100 - (avg by(instance,ip,hostname) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)))</span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><img alt="" height="653" src="https://img-blog.csdnimg.cn/20210912130137433.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><strong>内存使用率</strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">(100 -(node_memory_MemTotal_bytes -node_memory_MemFree_bytes+node_memory_Buffers_bytes+node_memory_Cached_bytes ) / node_memory_MemTotal_bytes * 100 ) </span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><strong>IO</strong><strong>性能</strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">&nbsp;100-(avg(irate(node_disk_io_time_seconds_total[5m])) by(instance,hostname)* 100) &lt; 40</span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><strong>磁盘使用率</strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">100-(node_filesystem_free_bytes{fstype=~"ext4|xfs"}/node_filesystem_size_bytes {fstype=~"ext4|xfs"}*100) &gt; 80</span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><strong>主机网络IO速率</strong></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#525252;">入速率(MiB/s)</span></strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">irate(node_network_receive_bytes_total{}[5m]) / 1024 / 1024 </span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#525252;">出速率(MiB/s)</span></strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">irate(node_network_transmit_bytes_total{}[5m]) / 1024 / 1024</span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><strong>主机磁盘IO</strong></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#525252;">写速率(MiB/s)</span></strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">irate(node_disk_written_bytes_total{}[5m]) / 1024 / 1024 </span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#525252;">读速率(MiB/s)</span></strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">irate(node_disk_read_bytes_total{}[5m]) / 1024 / 1024</span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:left;"><strong>TCP</strong><strong>连接数</strong></p> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#f9f9f9;"><span style="background-color:#f9f9f9;"><span style="color:#595959;">node_netstat_Tcp_CurrEstab</span></span></span></p> 
</div>
                ]]></description></item><item><title>Prometheus监控，生产可用告警规则（可获取主机名）</title><link>http://www.cnblogs.com/heian99/archive/2021/09/12/15257897.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 12 Sep 2021 04:52:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/09/12/15257897.html</guid><description><![CDATA[
                    <p>以下是生产环境中prometheus.rules.yml告警规则用例</p> 
<p>prometheus默认的instance是ip:port格式的，无法知道主机名。</p> 
<h1>方法一：node_uname_info获取</h1> 
<p>参考链接：<a href="https://blog.csdn.net/CHEndorid/article/details/106820612" title="https://blog.csdn.net/CHEndorid/article/details/106820612">https://blog.csdn.net/CHEndorid/article/details/106820612</a></p> 
<p>主机名（nodename）在指标node_uname_info中，且node_uname_info的值恰巧为1，所以我们可以在PromQL中通过node_uname_info提取，只需要在原有PromQL后添加</p> 
<pre><code class="language-bash">* on(instance) group_left(nodename) (node_uname_info)</code></pre> 
<p>这样，在prometheus告警的labels中，就可以通过nodename获取主机名了</p> 
<p>特别的，up==0的值是0，做乘法是不会得到结果的</p> 
<h2><br> 示例：</h2> 
<pre><code class="language-bash">    - alert: cpu使用率过高告警
      expr: (100 - (avg(irate(node_cpu_seconds_total{mode="idle"}[5m])) by(instance)* 100))* on(instance) group_left(nodename) (node_uname_info) &gt; 85
      for: 5m
      labels:
        region: 成都
      annotations:
        summary: "{<!-- -->{$labels.instance}}（{<!-- -->{$labels.nodename}}）CPU使用率过高！"
        description: '服务器{<!-- -->{$labels.instance}}（{<!-- -->{$labels.nodename}}）CPU使用率超过85%(目前使用:{<!-- -->{printf "%.2f" $value}}%)'
</code></pre> 
<h1>方法二：relabel_configs增加主机名标签</h1> 
<p>此方法，可以适应所有报警的规则</p> 
<p>在 prometheus增加主机配置是，添加配置即可</p> 
<pre><code class="language-bash">  - job_name: 'hadoop-test-exporter'
    consul_sd_configs:
    - server: 'localhost:8500'
      services: [hadoop-test-exporter]
    relabel_configs: #把__meta_consul_service_id 映射主机名
    - source_labels: [__meta_consul_service_id]
      separator: ;
      regex: (.*)
      target_label: hostname
      replacement: $1
      action: replace
    - source_labels: [__meta_consul_service_address] #映射主机IP
      separator: ;
      regex: (.*)
      target_label: ip
      replacement: $1
      action: replace
    - source_labels: ['__meta_consul_tags'] #根据tag来匹配分组
      regex: '^.*,hadoop-test,.*$'
      action: keep
</code></pre> 
<p><img alt="" height="456" src="https://img-blog.csdnimg.cn/20210912125024499.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p>&nbsp;<img alt="" height="295" src="https://img-blog.csdnimg.cn/20210912125048533.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2X5a6r5LmY6aOO,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p></p>
                ]]></description></item><item><title>Ansible批量部署客户端并注册consul自动发现</title><link>http://www.cnblogs.com/heian99/archive/2021/08/23/15177439.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 23 Aug 2021 11:26:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/08/23/15177439.html</guid><description><![CDATA[
                    <p>前文链接：<a href="https://blog.csdn.net/heian_99/article/details/119874180">https://blog.csdn.net/heian_99/article/details/119874180</a></p> 
<p>需求：prometheus监控多台主机时，基于自动发现consul模块，主机安装采集器注册到那台consul，consul识别到。promethues获取consul地址上的监控主机列表，实现多台主机自动发现。</p> 
<p>思路：</p> 
<ol><li>web机器安装node_exporter采集器<br> 2.注册node_exporter为系统服务<br> 3.使用curl -x PUT ... 注册到consul机器中<br> 4.consul监控到后，prometheus配置consul地址。<br> 1-3步都可用ansible批量完成。</li></ol>
<p>node_exoporter软件包 ，system服务配置文件，注册脚本，注册接口</p> 
<p>如果有密码验证还需要一个config.yml</p> 
<h3>consul-register.sh</h3> 
<p>注册脚本(传参方式注册)：</p> 
<pre><code class="language-bash">#!/bin/bash
service_name=$1
instance_id=$2
ip=$3
port=$4

curl -X PUT -d '{"id": "'"$instance_id"'","name": "'"$service_name"'","address": "'"$ip"'","port": '"$port"',"tags": ["'"$service_name"'"],"checks": [{"http": "http://'"$ip"':'"$port"'","interval": "5s"}]}' http://10.10.10.27:8500/v1/agent/service/register
</code></pre> 
<h3>node_exporter.service</h3> 
<p>node_exporter系统服务配置文件</p> 
<pre><code class="language-bash">[heian@zabbix ~]$ cat node_exporter.service 


[Unit]
Description=node_exporter
After=network.target 

[Service]
ExecStart=/usr/local/node_exporter/node_exporter\
          --web.listen-address=:9100\
          --collector.systemd\
          --collector.systemd.unit-whitelist=(sshd|nginx).service\
          --collector.processes\
          --collector.tcpstat\
          --collector.supervisord
[Install]
WantedBy=multi-user.target



--collector.systemd --collector.systemd.unit-include=(docker|portal|sshd).service 配置的意思是只收集docker,portal,sshd服务的数据
--web.config=/usr/local/jiankong/node_exporter/config.yml 如果有密码验证接口需要指定这个config.yml，里面保存的用户名和密码。需要把这条配在启动execstart行的node_proter后。</code></pre> 
<h3>ansible-playbook</h3> 
<pre><code>cat hosts

[blog]
10.10.10.15  name=nginx

</code></pre> 
<pre><code class="language-bash">cat playbook.yml

- hosts: blog
  remote_user: heian
  become: yes
  become_user: root
  become_method: sudo
  gather_facts: no
  tasks:
    - name: 推送采集器安装包
      unarchive: src=node_exporter-1.2.2.linux-amd64.tar.gz dest=/usr/local/
    - name: 重命名
      shell: |
        cd /usr/local/ 
        if [ ! -d node_exporter ];then 
           mv node_exporter-1.2.2.linux-amd64  node_exporter 
        fi
    - name: 推送system文件
      copy: src=node_exporter.service dest=/usr/lib/systemd/system
    - name: 启动服务
      systemd: name=node_exporter state=started enabled=yes
    - name: 推送注册脚本
      copy: src=consul-register.sh dest=/usr/local/node_exporter
    - name: 注册当前节点
      shell: /bin/sh /usr/local/node_exporter/consul-register.sh {<!-- -->{ group_names[0] }} {<!-- -->{ name }} {<!-- -->{ inventory_hostname }} 9100
</code></pre> 
<p>{<!-- -->{ group_names[0] }} --ansible内置变量 代表hosts中自定义组名，数组形式，[0]取第一个<br> {<!-- -->{ name }} -- hosts文件中定义主机的名字，如name=web1<br> {<!-- -->{ inventory_hostname }} 当前执行主机的ip<br> 执行：</p> 
<p><img alt="" height="657" src="https://img-blog.csdnimg.cn/20210823192310944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>看一下consul中，服务已经注册进来了&nbsp;</p> 
<p><img alt="" height="706" src="https://img-blog.csdnimg.cn/20210823192329533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h3>prometheus自动发现</h3> 
<p><img alt="" height="812" src="https://img-blog.csdnimg.cn/20210823192429609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1094"></p> 
<p>&nbsp;<img alt="" height="601" src="https://img-blog.csdnimg.cn/20210823192453713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="652"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="798" src="https://img-blog.csdnimg.cn/20210823192508451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<p>参考文档地址：<a href="https://www.jianshu.com/p/f243a3aec18e">https://www.jianshu.com/p/f243a3aec18e</a></p> 
<p></p>
                ]]></description></item><item><title>Prometheus基于consul中心自动发现注册监控</title><link>http://www.cnblogs.com/heian99/archive/2021/08/23/15177440.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 23 Aug 2021 09:50:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/08/23/15177440.html</guid><description><![CDATA[
                    <h3><img alt="" src="https://img-blog.csdnimg.cn/20210108095552681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjk0OTQxNzE0MA==,size_16,color_FFFFFF,t_70"></h3> 
<p>&nbsp;</p> 
<h3>一、 简介</h3> 
<p>prometheus配置文件 prometheus.yml 里配置需要监听的服务时，是按服务名写死的，如果后面增加了节点或者组件信息，就得手动修改此配置，并重启 promethues；那么能否动态的监听微服务呢？Prometheus 提供了多种动态服务发现的功能，这里以 consul 为例。</p> 
<h3><a name="t2"></a><a id="_consul__4"></a>二、引入 consul 的好处</h3> 
<p>在没有使用 consul 服务自动发现的时候，我们需要频繁对 Prometheus 配置文件进行修改，无疑给运维人员带来很大的负担。引入consul之后，只需要在consul中维护监控组件配置，prometheus就能够动态发现配置了。</p> 
<h3><a name="t3"></a><a id="Prometheus__7"></a>三、Prometheus 支持的多种服务发现机制</h3> 
<pre><code class="language-bash">#Prometheus数据源的配置主要分为静态配置和动态发现, 常用的为以下几类:
1）static_configs: #静态服务发现
2）file_sd_configs: #文件服务发现
3）dns_sd_configs: DNS #服务发现
4）kubernetes_sd_configs: #Kubernetes 服务发现
5）consul_sd_configs: Consul #服务发现
...

#在监控kubernetes的应用场景中，频繁更新的pod，svc，等等资源配置应该是最能体现Prometheus监控目标自动发现服务的好处</code></pre> 
<h3>四、安装单节点consul</h3> 
<p><strong>下载consul文件</strong></p> 
<p><a href="https://www.consul.io/downloads">https://www.consul.io/downloads</a></p> 
<pre><code class="language-bash">解压

移动

给权限

查看版
consul --version
Consul v1.10.1
Revision db839f18b
Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when speaking to compatible agents)</code></pre> 
<p><strong>数据持久化</strong></p> 
<pre><code>mkdir -p /app/consul/data</code></pre> 
<p><strong>启动命令</strong></p> 
<pre><code class="language-bash">启动命令
nohup consul  agent -server -data-dir=/app/consul/data  -node=agent-one -bind=172.17.9.47 -bootstrap-expect=1 -client=0.0.0.0 -ui &gt; /app/consul/consul.log 2&gt;&amp;1 &amp;
</code></pre> 
<p>简单单机版已经完成。</p> 
<p>复杂点的有集群版，账号口令认证等等，相关参考文档</p> 
<p><a href="https://www.k8stech.net/post/prom-discovery-consul/">https://www.k8stech.net/post/prom-discovery-consul/</a></p> 
<p>大佬版本讲解真的是好</p> 
<p><img alt="" height="659" src="https://img-blog.csdnimg.cn/20210823173951282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;<img alt="" height="675" src="https://img-blog.csdnimg.cn/20210823174025226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h3>五、注册主机到<strong>consul</strong></h3> 
<p>&nbsp;由于机器比较多，需要批量添加</p> 
<p>consul主要是添加和删除命令，都是使用接口调用</p> 
<pre><code>删除
curl -X PUT http://172.17.9.47:8500/v1/agent/service/deregister/dam02


添加
 curl -X PUT -d '{"id": "'${host_name}'","name": "node-exporter","address": "'${host_addr}'","port":9100,"tags": ["dam"],"checks": [{"http": "http://'${host_addr}':9100/","interval": "5s"}]}' http://172.17.9.47:8500/v1/agent/service/register</code></pre> 
<p>批量添加可以使用下面脚本</p> 
<p></p> 
<pre><code class="language-bash">hosts文件格式

dam01  172.17.8.227
dam02  172.17.8.228</code></pre> 
<pre><code class="language-bash">$ cat registry.sh    # 脚本内容如下
#!/bin/bash
while read host_name host_addr
do
    curl -X PUT -d '{"id": "'${host_name}'","name": "node-exporter","address": "'${host_addr}'","port":9100,"tags": ["dam"],"checks": [{"http": "http://'${host_addr}':9100/","interval": "15s"}]}' http://172.17.9.47:8500/v1/agent/service/register
done &lt; hosts
</code></pre> 
<p>执行这个脚本，就可以批量添加主机到consul里面去。</p> 
<h3>六、配置prometheus自动发现</h3> 
<pre><code>cat  /usr/local/prometheus/prometheus.yml

#类似下面格式  这个server为consul的地址，根据标签匹配组
  - job_name: 'dam-exporter'
    consul_sd_configs:
    - server: 'localhost:8500'
      services: [dam-exporter] 



#复杂一点，需要正则表达式
  - job_name: dam-exporter
    honor_labels: true
    metrics_path: /metrics
    scheme: http
    consul_sd_configs:
      - server: 172.17.9.47:8500
        services: [dam-exporter]
    relabel_configs:
    - source_labels: ['__meta_consul_tags']
      target_label: 'product'
    - source_labels: ['__meta_consul_dc']
      target_label: 'idc'
    - source_labels: ['product']
      regex: ",dam-exporter,"
      action: keep
</code></pre> 
<p><img alt="" height="283" src="https://img-blog.csdnimg.cn/20210823174829513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="579"></p> 
<p>&nbsp;重启prometheus就自动发现成功，并且可以采集数据。</p> 
<p></p>
                ]]></description></item><item><title>Zabbix监控流量异常（偶尔超出交换机限制）</title><link>http://www.cnblogs.com/heian99/archive/2021/08/20/15173007.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 20 Aug 2021 08:02:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/08/20/15173007.html</guid><description><![CDATA[
                    <h3><strong>前提：</strong></h3> 
<p>近期业务做了集群的流量汇总，整体没有问题。后面慢慢优化一些参数项。但是这两天发现，集群流量数据增大，业务正常。</p> 
<h3><strong>问题：</strong></h3> 
<p>zabbix和prometheus 监控网卡，流量异常增大，超出限制，每次2分钟，偶尔性触发</p> 
<p>看图，这个和7月对比，简介翻了几倍，但是业务没有增长，这就很奇怪了</p> 
<p><img alt="" height="279" src="https://img-blog.csdnimg.cn/20210820154341424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="603"></p> 
<p>&nbsp;<img alt="" height="399" src="https://img-blog.csdnimg.cn/20210820154446171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;<img alt="" height="39" src="https://img-blog.csdnimg.cn/20210820154520134.png" width="707"></p> 
<p></p> 
<p>上面介绍相关截图。</p> 
<h3>解决：</h3> 
<p>首先以为业务导致网卡过大加载，导致流量增大，我们使用&nbsp;<strong> ifstat-1.1.tar.gz</strong>&nbsp; 工具记录每一秒的网卡速度，记录一晚上再看。</p> 
<p><img alt="" height="799" src="https://img-blog.csdnimg.cn/20210820154806631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="854"></p> 
<p>分析上图，虽然流量有超过100M的，但是网卡是能够支撑的。没有zabbix和prometheus显示的那么恐怖。</p> 
<h3>思考</h3> 
<p>我和大佬分交流一下。说是zabbix的单位转换，要加8倍，我也是添加了的</p> 
<p></p> 
<p><img alt="" height="248" src="https://img-blog.csdnimg.cn/20210820155043875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1114"></p> 
<p>&nbsp;<img alt="" height="625" src="https://img-blog.csdnimg.cn/20210820155108496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="893"></p> 
<p>&nbsp;</p> 
<p>嗯。。。。。。。。。。。。。。。。。。。。。正常</p> 
<p>大佬建议让我使用snmp监控对比一下，思路不错，可以搞。直接部署上去对比了</p> 
<p></p> 
<h3>分析</h3> 
<p>snmp对比一下</p> 
<p><img alt="" height="141" src="https://img-blog.csdnimg.cn/20210820155324221.png" width="1120"></p> 
<p>&nbsp;zabbix的（还是这么高）</p> 
<p><img alt="" height="410" src="https://img-blog.csdnimg.cn/20210820155427739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1149"></p> 
<p></p> 
<p>snmp的（这个是正常的）</p> 
<p><img alt="" height="435" src="https://img-blog.csdnimg.cn/20210820155518591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;很明显，这是snmp是准确的。但是为什么会这样</p> 
<p></p> 
<h3>结果：</h3> 
<p>首先，业务正常，服务器正常，现在就是zabbix不正常，怀疑是zabbix的问题</p> 
<p>回想一下，在数据量增加前做了什么操作。</p> 
<p>之前，我当时增加一批监控指标，因为监控点比较重要，所有设置抓取时间为10s。谁知道这个10s就是罪魁祸首。集群内部机器较多，可能会产生数据积压。</p> 
<p></p> 
<h3>后续</h3> 
<p>取消关联模板，监控整体流量，确定无虚假流量</p> 
<p>调整监控项的抓取指标为：1m&nbsp; 再次关联模板正常</p>
                ]]></description></item><item><title>vsftp禁止下载，允许上传文件</title><link>http://www.cnblogs.com/heian99/archive/2021/08/10/15144893.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 10 Aug 2021 13:58:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/08/10/15144893.html</guid><description><![CDATA[
                    <h2>问题需求</h2> 
<p>公司有台业务服务器，上面有多个用户，但是这台机器无法使用scp ，sftp ，和ftp等传输工具（因为安全问题，不能对外公开传输数据渠道）</p> 
<p>但是，这些功能禁用后，怎么往上面传输文件，偶尔有些用户需要往上面传程序，这个就是很头疼的问题。</p> 
<h2>解决方案：</h2> 
<p>采用vsftp工具，构建本机用户登录，使用白名单，对特定用户使用，运行上传，不能下载</p> 
<h2>实现方法：</h2> 
<p>环境是纯内网：首先找vsftp安装包</p> 
<pre><code>yum install yum-utils -y
#下载rpm包的工具
yumdownloader vsftpd --resolve --destdir=/root/rpm
#使用这个下载vsftp包和依赖</code></pre> 
<p>下载完成，上传服务器直接安装</p> 
<pre><code class="language-bash">rpm -ivh vsftpd-3.0.2-29.el7_9.x86_64.rpm</code></pre> 
<pre><code class="language-bash">主配置文件：/etc/vsftpd/vsftpd.conf
配置文件目录：/etc/vsftpd/*.conf
服务启动脚本：/etc/rc.d/init.d/vsftpd
用户认证配置文件：/etc/pam.d/vsftpd</code></pre> 
<p><strong>配置参数</strong></p> 
<p>常用配置参数都为主配置文件，/etc/vsftpd/vsftpd.conf 的常用配置。</p> 
<p><strong>通用基础配置</strong></p> 
<pre><code>listen=[YES|NO]         #是否以独立运行的方式监听服务
listen_address=IP地址   #设置要监听的 IP 地址
listen_port=21        #设置 FTP 服务的监听端口
download_enable＝[YES|NO] #是否允许下载文件
max_clients=0   #最大客户端连接数，0 为不限制
max_per_ip=0   #同一 IP 地址的最大连接数，0 为不限制
chown_uploads=[YES|NO] #是否允许改变上传文件的属主
chown_username=whoever #改变上传文件的属主为 whoever
pam_service_name=vsftpd #让 vsftpd 使用 pam 完成用户认证，使用的文件为/etc/pam.d/vsftpd</code></pre> 
<p><strong>系统用户的配置</strong></p> 
<pre><code>anonymous_enable=NO    #禁止匿名访问模式
local_enable=[YES|NO]  #是否允许本地用户登录 FTP
write_enable=[YES|NO]  #是否开放本地用户的其他写入权限
local_umask=022        #本地用户上传文件的 umask 值
local_root=/var/ftp    #本地用户的 FTP 根目录
local_max_rate=0      #本地用户最大传输速率（字节/秒），0 为不限制
userlist_enable=[YES|NO] #开启用户作用名单文件功能
userlist_deny=[YES|NO]   #启用禁止用户名单，名单文件为 ftpusers 和/etc/vsftpd/user_list
chroot_local_user=[YES|NO] #是否将用户权限禁锢在 FTP 家目录中，以确保安全
chroot_list_enable=[YES|NO] #禁锢文件中指定的 FTP 本地用户于其家目录中
chroot_list_file=/etc/vsftpd/chroot_list #指定禁锢文件位置，需要和 chroot_list_enable 一同</code></pre> 
<h2>vsftp配置</h2> 
<p>我这边为了实现对应功能，配置如下</p> 
<pre><code class="language-bash">anonymous_enable=NO #禁止匿名用户登录
local_enable=YES #本地用户
write_enable=YES
download_enable=NO
local_umask=022
chroot_list_enable=YES
chroot_local_user=yes #固定传输文件在家目录
allow_writeable_chroot=YES
userlist_enable=YES
userlist_deny=NO
userlist_file=/etc/vsftpd/user_list #登录白名单
dirmessage_enable=YES
connect_from_port_20=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd
userlist_enable=YES
tcp_wrappers=YES
xferlog_enable=YES
xferlog_std_format=YES</code></pre> 
<p>&nbsp;/etc/vsftpd/user_list 这个文件里面写入允许登录的用户即可</p> 
<p>（1）允许特定用户登录</p> 
<p>（2）允许上传，禁止下载</p> 
<p>（3）禁止跳转目录，只允许自己家目录</p> 
<p><img alt="" height="686" src="https://img-blog.csdnimg.cn/20210810215742972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="656"></p> 
<p>&nbsp;参考地址：</p> 
<p><a href="https://zhuanlan.zhihu.com/p/354583347">https://zhuanlan.zhihu.com/p/354583347</a></p> 
<p><a href="https://blog.csdn.net/weixin_30514745/article/details/98155033">https://blog.csdn.net/weixin_30514745/article/details/98155033</a></p> 
<p><a href="https://www.huaweicloud.com/articles/2cc1b07fa2841e3874e7b4f430b038af.html">https://www.huaweicloud.com/articles/2cc1b07fa2841e3874e7b4f430b038af.html</a></p>
                ]]></description></item><item><title>企业纯内网二进制完美部署Docker（20.10.7版本）</title><link>http://www.cnblogs.com/heian99/archive/2021/08/03/15144894.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 03 Aug 2021 13:43:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/08/03/15144894.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BC%81%E4%B8%9A%E7%BA%AF%E5%86%85%E7%BD%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%8C%E7%BE%8E%E9%83%A8%E7%BD%B2Docker%EF%BC%8820.10.7%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%BC%81%E4%B8%9A%E7%BA%AF%E5%86%85%E7%BD%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%8C%E7%BE%8E%E9%83%A8%E7%BD%B2Docker%EF%BC%8820.10.7%E7%89%88%E6%9C%AC%EF%BC%89">企业纯内网二进制完美部署Docker（20.10.7版本）</a></p> 
<p id="Docker%E4%B8%8B%E8%BD%BD-toc" style="margin-left:40px;"><a href="#Docker%E4%B8%8B%E8%BD%BD">Docker下载</a></p> 
<p id="%E4%B8%8A%E4%BC%A0%E8%A7%A3%E5%8E%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%8A%E4%BC%A0%E8%A7%A3%E5%8E%8B">上传解压</a></p> 
<p id="systemd%E7%AE%A1%E7%90%86docker-toc" style="margin-left:40px;"><a href="#systemd%E7%AE%A1%E7%90%86docker">systemd管理docker</a></p> 
<p id="%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86Docker-toc" style="margin-left:40px;"><a href="#%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86Docker">普通用户管理Docker</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%AE%B5-toc" style="margin-left:40px;"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%AE%B5">自定义网段</a></p> 
<p id="%E6%9B%B4%E6%94%B9%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84-toc" style="margin-left:40px;"><a href="#%E6%9B%B4%E6%94%B9%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84">更改存储路径</a></p> 
<p id="%E5%A6%82%E6%9E%9C%E6%9C%89%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E6%95%B0%E6%8D%AE">如果有数据</a></p> 
<p id="%E6%97%A0%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%E6%97%A0%E6%95%B0%E6%8D%AE">无数据</a></p> 
<p id="%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8-toc" style="margin-left:40px;"><a href="#%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8">启动并设置开机启动</a></p> 
<p id="articleContentId-toc" style="margin-left:40px;"><a href="#articleContentId">docker命令补全方法</a></p> 
<p id="1.%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#1.%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6">1.复制文件</a></p> 
<p id="2.%E5%AE%89%E8%A3%85bash-completion%C2%A0-toc" style="margin-left:80px;"><a href="#2.%E5%AE%89%E8%A3%85bash-completion%C2%A0">2.安装bash-completion&nbsp;</a></p> 
<p id="%C2%A03.%E5%88%B7%E6%96%B0%E7%94%9F%E6%95%88-toc" style="margin-left:80px;"><a href="#%C2%A03.%E5%88%B7%E6%96%B0%E7%94%9F%E6%95%88">&nbsp;3.刷新生效</a></p> 
<p id="4%E3%80%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E6%B5%8B%E8%AF%95">4、测试</a></p> 
<hr id="hr-toc">
<h1 id="%E4%BC%81%E4%B8%9A%E7%BA%AF%E5%86%85%E7%BD%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%8C%E7%BE%8E%E9%83%A8%E7%BD%B2Docker%EF%BC%8820.10.7%E7%89%88%E6%9C%AC%EF%BC%89">企业纯内网二进制完美部署Docker（20.10.7版本）</h1> 
<hr>
<p></p> 
<p>近期由于公司业务需求，需要使用到Docker。</p> 
<p>平常有网环境，直接yum可以安装完成。但是由于服务器在纯内网环境，无法访问公网，所有无法在线直接安装Docker，需要另想方法完成部署安装。</p> 
<p>（1）找一台有网机器，使用yum（yumdownloader）把docker包和依赖下载下来，上传在安装&nbsp;</p> 
<p>（2）二进制安装Docker（比较复杂，但是能更好理解和管理Docker，我选择后者）</p> 
<h2 id="Docker%E4%B8%8B%E8%BD%BD">Docker下载</h2> 
<p>Docker版本：20.10.7</p> 
<p>Docker版本下载地址：<a href="https://download.docker.com/linux/static/stable/x86_64/">https://download.docker.com/linux/static/stable/x86_64/</a></p> 
<p><img alt="" height="267" src="https://img-blog.csdnimg.cn/20210803213054267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="951"></p> 
<p></p> 
<h2 id="%E4%B8%8A%E4%BC%A0%E8%A7%A3%E5%8E%8B">上传解压</h2> 
<pre><code class="language-bash">tar zxvf docker-20.10.7.tgz
mv docker/* /usr/bin
</code></pre> 
<h2 id="systemd%E7%AE%A1%E7%90%86docker"><strong><span style="color:#24292e;">systemd</span><span style="color:#24292e;">管理docker</span></strong></h2> 
<pre><code class="language-bash">cat &gt; /usr/lib/systemd/system/docker.service &lt;&lt; EOF
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target
Requires=docker.socket 
[Service]
Type=notify
ExecStart=/usr/bin/dockerd
ExecReload=/bin/kill -s HUP $MAINPID
TimeoutSec=0
RestartSec=2
Restart=always
StartLimitBurst=3
StartLimitInterval=60s
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
Delegate=yes
KillMode=process
OOMScoreAdjust=-500
[Install]
WantedBy=multi-user.target
EOF
</code></pre> 
<pre><code class="language-bash">cat &gt; /usr/lib/systemd/system/docker.socket &lt;&lt; EOF
[Unit]
Description=Docker Socket for the API

[Socket]
ListenStream=/var/run/docker.sock
SocketMode=0660
SocketUser=root
SocketGroup=docker

[Install]
WantedBy=sockets.target


EOF
</code></pre> 
<h2 id="%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86Docker">普通用户管理Docker</h2> 
<pre><code class="language-bash">groupadd  docker 
#添加docker组，二进制不会自动添加的，yum会
usermod -a -G docker user1
#把要管理的用户添加到组里面就行</code></pre> 
<p>这样在docker组的用户，也有权限管理docker，这边是因为在docker.sock定义了以docker组启动</p> 
<h2 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%AE%B5">自定义网段</h2> 
<pre><code>mkdir /etc/docker
cat &gt; /etc/docker/daemon.json &lt;&lt; EOF
{
    "bip":"10.10.10.1/24"

}
EOF
</code></pre> 
<p>纯内网Docker-hub无法使用，这里就定义网段，启用初始就会直接定义网段</p> 
<h2 id="%E6%9B%B4%E6%94%B9%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84">更改存储路径</h2> 
<p>docker的默认路径是/var/lib/docker</p> 
<p>但是有时间这个空间很小，我们需要把目录迁移到足够大的磁盘下</p> 
<h3 id="%E5%A6%82%E6%9E%9C%E6%9C%89%E6%95%B0%E6%8D%AE">如果有数据</h3> 
<pre><code class="language-bash">systemctl stop docker
mkdir /data/service/docker -p
mv /var/lib/docker/* /data/service/docker/
#迁移数据
vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd  --graph /data/service/docker
</code></pre> 
<h3 id="%E6%97%A0%E6%95%B0%E6%8D%AE">无数据</h3> 
<pre><code class="language-bash">mkdir /data/service/docker -p

vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd  --graph /data/service/docker</code></pre> 
<h2 id="%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8"><strong><span style="color:#24292e;">启动并设置开机启动</span></strong></h2> 
<pre><code class="language-bash">systemctl daemon-reload
systemctl start docker
systemctl enable docker
</code></pre> 
<h2 id="articleContentId">docker命令补全方法</h2> 
<h3 id="1.%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6">1.复制文件</h3> 
<p><br> 通过yum安装相同版本的docker。将 /usr/share/bash-completion/completions/docker 文件拷贝到二进制安装的docker服务器上的 /usr/share/bash-completion/completions/ 目录下</p> 
<h3 id="2.%E5%AE%89%E8%A3%85bash-completion%C2%A0">2.安装bash-completion&nbsp;</h3> 
<p></p> 
<pre><code class="language-bash">yum install -y bash-completion</code></pre> 
<h3 id="%C2%A03.%E5%88%B7%E6%96%B0%E7%94%9F%E6%95%88">&nbsp;3.刷新生效</h3> 
<pre><code class="language-bash">source /usr/share/bash-completion/completions/docker
source /usr/share/bash-completion/bash_completion</code></pre> 
<p></p> 
<h3 id="4%E3%80%81%E6%B5%8B%E8%AF%95">4、测试</h3> 
<pre><code class="language-bash">[root@localhost ~]# docker 
attach     context    exec       import     logout     port       rm         service    system     version    
build      cp         export     info       logs       ps         rmi        stack      tag        volume     
builder    create     help       inspect    network    pull       run        start      top        wait       
commit     diff       history    kill       node       push       save       stats      trust      
config     engine     image      load       pause      rename     search     stop       unpause    
container  events     images     login      plugin     restart    secret     swarm      update
</code></pre> 
<p></p>
                ]]></description></item><item><title>解决二进制K8S布署的metrics-server查看集群资源报错权限问题</title><link>http://www.cnblogs.com/heian99/archive/2021/08/01/15144895.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 01 Aug 2021 15:24:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/08/01/15144895.html</guid><description><![CDATA[
                    <p>布署完metircs-server后，但是访问会报错，此处有两个坑</p> 
<h2>1、API聚合功能</h2> 
<p>通过二进制方式部署完成&nbsp;<code>kubernetes</code>&nbsp;后，部署&nbsp;<code>Metrics Server</code>&nbsp;后，查看日志出现下面错误信息：</p> 
<pre><code class="language-bash">E1231 10:33:31.978715 1 configmap_cafile_content.go:243] key failed with:
missing content for CA bundle "client-ca::kube-system::extension-apiserver-authentication::requestheader-client-ca-file"
E1231 10:34:22.710836 1 configmap_cafile_content.go:243] kube-system/extension-apiserver-authentication failed with:
missing content for CA bundle "client-ca::kube-system::extension-apiserver-authentication::requestheader-client-ca-file"
E1231 10:34:31.978769 1 configmap_cafile_content.go:243] key failed with:
missing content for CA bundle "client-ca::kube-system::extension-apiserver-authentication::requestheader-client-ca-file"</code></pre> 
<p>根据错误日志信息，可以知道是缺少认证的证书文件，导致不能访问&nbsp;<code>kube-apiserver</code>&nbsp;而出现的问题。</p> 
<p>出现这个错误是因为 kube-apiserver 没有开启&nbsp;<code>API</code>&nbsp;聚合功能。所以需要配置&nbsp;<code>kube-apiserver</code>&nbsp;参数，开启聚合功能即可。</p> 
<p>为了能够将用户自定义的 API 注册到&nbsp;<code>Master</code>&nbsp;的&nbsp;<code>API Server</code>&nbsp;中，首先需要在 Master 节点所在服务器，配置&nbsp;<code>kube-apiserver</code>&nbsp;应用的启动参数来启用&nbsp;<code>API 聚合</code>&nbsp;功能，参数如下：</p> 
<pre><code class="language-bash">--runtime-config=api/all=true
--requestheader-allowed-names=aggregator
--requestheader-group-headers=X-Remote-Group
--requestheader-username-headers=X-Remote-User
--requestheader-extra-headers-prefix=X-Remote-Extra-
--requestheader-client-ca-file=/etc/kubernetes/pki/ca.pem
--proxy-client-cert-file=/etc/kubernetes/pki/proxy-client.pem
--proxy-client-key-file=/etc/kubernetes/pki/proxy-client-key.pem</code></pre> 
<p>如果&nbsp;<code>kube-apiserver</code>&nbsp;所在的主机上没有运行&nbsp;<code>kube-proxy</code>，即无法通过服务的&nbsp;<code>ClusterIP</code>&nbsp;进行访问，那么还需要设置以下启动参数：</p> 
<pre><code class="language-bash">--enable-aggregator-routing=true</code></pre> 
<p>在设置完成重启&nbsp;<code>kube-apiserver</code>&nbsp;服务，就启用&nbsp;<code>API 聚合</code>&nbsp;功能了。</p> 
<pre><code class="language-bash">systemctl daemon-reload &amp;&amp; systemctl restart kube-apiserver</code></pre> 
<h3>开启API聚合功能</h3> 
<p>按照上面的解决问题思路，我们可以开启 API 聚合功能，然后重启 Metrics Server 服务，步骤如下：</p> 
<p>安装 cfssl 工具</p> 
<pre><code class="language-bash">## 下载三个组件
$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O cfssl
$ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64  -O cfssljson
$ wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64  -O cfssl-certinfo

## 复制到 bin 目录下
$ chmod +x ./cfssl*
$ mv ./cfssl* /usr/local/bin/</code></pre> 
<h3>创建 cfssl 配置文件</h3> 
<p>创建 proxy-client-csr.json 文件：</p> 
<pre><code class="language-bash">{
  "CN": "aggregator",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "BeiJing",
      "L": "BeiJing",
      "O": "system:masters",
      "OU": "System"
    }
  ]
}</code></pre> 
<p>生成证书和秘钥：</p> 
<pre><code class="language-bash">cfssl gencert   -profile=kubernetes   -ca=/etc/kubernetes/pki/ca.pem   -ca-key=/etc/kubernetes/pki/ca-key.pem   proxy-client-csr.json | cfssljson -bare kube-proxy
</code></pre> 
<pre><code class="language-bash">ls -l

-rw-r--r-- 1 root root 1017 12月 31 11:20 proxy-client.csr
-rw-r--r-- 1 root root  236 12月 31 11:07 proxy-client-csr.json
-rw------- 1 root root 1675 12月 31 11:20 proxy-client-key.pem
-rw-r--r-- 1 root root 1411 12月 31 11:20 proxy-client.pem</code></pre> 
<p>将证书访问指定的目录下，这里我将其放到 /etc/kubernetes/pki 下：</p> 
<pre><code class="language-bash"> cp * /etc/kubernetes/pki/</code></pre> 
<p>修改 kube-apiserver 参数</p> 
<pre><code class="language-bash">--runtime-config=api/all=true \
--requestheader-allowed-names=aggregator \
--requestheader-group-headers=X-Remote-Group \
--requestheader-username-headers=X-Remote-User \
--requestheader-extra-headers-prefix=X-Remote-Extra- \
--requestheader-client-ca-file=/etc/kubernetes/pki/ca.pem \
--proxy-client-cert-file=/etc/kubernetes/pki/proxy-client.pem \
--proxy-client-key-file=/etc/kubernetes/pki/proxy-client-key.pem \</code></pre> 
<pre><code>参数说明：

–requestheader-client-ca-file： 客户端 CA 证书。
–requestheader-allowed-names： 允许访问的客户端 common names 列表，通过 header 中 –requestheader-username-headers 参数指定的字段获取。客户端 common names 的名称需要在 client-ca-file 中进行设置，将其设置为空值时，表示任意客户端都可访问。
–requestheader-username-headers： 参数指定的字段获取。
–requestheader-extra-headers-prefix： 请求头中需要检查的前缀名。
–requestheader-group-headers 请求头中需要检查的组名。
–requestheader-username-headers 请求头中需要检查的用户名。
–proxy-client-cert-file： 在请求期间验证 Aggregator 的客户端 CA 证书。
–proxy-client-key-file： 在请求期间验证 Aggregator 的客户端私钥。
–requestheader-allowed-names： 允许访问的客户端 common names 列表，通过 header 中 –requestheader-username-headers 参数指定的字段获取。客户端 common names 的名称需要在 client-ca-file 中进行设置，将其设置为空值时，表示任意客户端都可访问。</code></pre> 
<p>重启 kube-apiserver 组件</p> 
<pre><code class="language-bash"> systemctl daemon-reload &amp;&amp; systemctl restart kube-apiserver</code></pre> 
<h2>2、用户无权限访问资源pod</h2> 
<p>报错</p> 
<pre><code class="language-bash">^C[root@k8s-master cfg]# kubectl top pod -A
Error from server (Forbidden): pods.metrics.k8s.io is forbidden: User "system:kube-proxy" cannot list resource "pods" in API group "metrics.k8s.io" at the cluster scope
[root@k8s-master cfg]# kubectl top pod 
Error from server (Forbidden): pods.metrics.k8s.io is forbidden: User "system:kube-proxy" cannot list resource "pods" in API group "metrics.k8s.io" in the namespace "default"
</code></pre> 
<p>报错提示为RBAC权限问题，给kubernetes用户授权如下：</p> 
<pre><code>kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: metrics-reader
rules:
- apiGroups: ["metrics.k8s.io"]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
- apiGroups: ["metrics.k8s.io"]
  resources: ["nodes"]
  verbs: ["get", "watch", "list"]
 
---
 
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-pods
  namespace: default
subjects:
- kind: User
  name: system:kube-proxy  #用户名称
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: metrics-reader
  apiGroup: rbac.authorization.k8s.io
 
 
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: metrics-reader
rules:
- apiGroups: ["metrics.k8s.io"]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
- apiGroups: ["metrics.k8s.io"]
  resources: ["nodes"]
  verbs: ["get", "watch", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: metrics
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: metrics-reader
subjects:
- kind: User
  name: system:kube-proxy #用户名称
  apiGroup: rbac.authorization.k8s.io
</code></pre> 
<p>问题就解决</p> 
<p><img alt="" height="325" src="https://img-blog.csdnimg.cn/20210801232304517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="722"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>zabbix企业应用之监控磁盘读写状态</title><link>http://www.cnblogs.com/heian99/archive/2021/08/01/15086450.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 01 Aug 2021 04:34:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/08/01/15086450.html</guid><description><![CDATA[
                    <p>最近公司服务器的一个磁盘出现Read Only，导致数据不可写，但此服务器安装的zabbix监控并未报警，所以针对此情况，新增了监控系统磁盘读写状态的监控。<br> 下面是效果图</p> 
<p><img alt="" height="271" src="https://img-blog.csdnimg.cn/20210801122955191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1178"></p> 
<p><img alt="" height="75" src="https://img-blog.csdnimg.cn/2021080112311067.png" width="496"></p> 
<p></p> 
<p>如果返回值0代表磁盘都是rw状态可以正常读写，返回值1的话，代表磁盘是ro状态，会报警。<br> 如何实现：</p> 
<h2>目标</h2> 
<p>使用zabbix监控磁盘ro指标，如果发现ro模式，及时报警</p> 
<pre><code class="language-bash">mount | grep -v '/sys/fs/cgroup' |awk '{print $NF}' |cut -c 2-3 |awk '{if($1~/ro/) {print 1}}'|wc -l|awk '{if($1&lt;=0) {print 0 } else {print 1}}'</code></pre> 
<p>使用这个监控所有磁盘，判断是否只读模式</p> 
<h2>修改zabbix_agentd.conf文件</h2> 
<p>添加</p> 
<pre><code class="language-bash">UserParameter=check_disk_status,/bin/mount | grep -v '/sys/fs/cgroup' |awk '{print $NF}' |cut -c 2-3 |awk '{if($1~/ro/) {print 1}}'|wc -l|awk '{if($1&lt;=0) {print 0 } else {print 1}}'</code></pre> 
<h2>重启zabbix客户端</h2> 
<pre><code class="language-bash">sh startup_zabbix_agentd.sh restart</code></pre> 
<h2>zabbix服务端添加监控项</h2> 
<p><img alt="" height="637" src="https://img-blog.csdnimg.cn/20210801123228748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="943"></p> 
<p></p> 
<h2>zabbix服务端添加触发器</h2> 
<p>这个触发器是最近3次检测都出现ro状态，就会报警。</p> 
<p><img alt="" height="630" src="https://img-blog.csdnimg.cn/20210801123240203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="921"></p> 
<p></p> 
<h2>测试</h2> 
<p><img alt="" height="278" src="https://img-blog.csdnimg.cn/20210801123259362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p></p> 
<p><img alt="" height="238" src="https://img-blog.csdnimg.cn/20210801123254588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p></p> 
<h2></h2>
                ]]></description></item><item><title>Centos7 自启没有起作用？？（rc.local）</title><link>http://www.cnblogs.com/heian99/archive/2021/07/26/15083368.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 26 Jul 2021 08:40:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/07/26/15083368.html</guid><description><![CDATA[
                    <p>今天机器重启，但是以前加的自启任务的脚本没有执行</p> 
<p><strong>原因：</strong></p> 
<p>在centos7中,/etc/rc.d/rc.local文件的权限被降低了,没有执行权限,需要给它添加可执行权限。</p> 
<pre><code class="language-bash">chmod +x /etc/rc.d/rc.local</code></pre> 
<p><br> 然后就可以在里面添加你要开机自启的命令了</p> 
<pre><code class="language-bash">vi /etc/rc.d/rc.local</code></pre> 
<p><img alt="" height="127" src="https://img-blog.csdnimg.cn/20210726163905909.png" width="804"></p>
                ]]></description></item><item><title>Docker集群可视化管理平台（Portainer）</title><link>http://www.cnblogs.com/heian99/archive/2021/07/25/15083369.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 25 Jul 2021 15:24:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/07/25/15083369.html</guid><description><![CDATA[
                    <h2>什么是Portainer</h2> 
<p><code>Portainer</code>是<code>Docker</code>的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。</p> 
<h2>汉化界面</h2> 
<p><img alt="" height="890" src="https://img-blog.csdnimg.cn/20210725231911721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<h2>安装Docker</h2> 
<p>如果已经安装了Docker环境直接跳过本步骤即可</p> 
<pre><code>#CentOS 6
rpm -iUvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
yum update -y
yum -y install docker-io
service docker start
chkconfig docker on

#CentOS 7、Debian、Ubuntu
curl -sSL https://get.docker.com/ | sh
systemctl start docker
systemctl enable docker.service</code></pre> 
<p>安装Portainer版本：&nbsp;portainer-ce:2.0.1</p> 
<p>汉化地址：<a href="https://github.com/eysp/public/releases">https://github.com/eysp/public/releases</a></p> 
<p>此版本已经测试，暂无bug，可以正常汉化显示，推荐</p> 
<h2>Portainer中文汉化</h2> 
<pre><code class="language-bash">docker volume create portainer_data
docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.0.1</code></pre> 
<p><img alt="" height="310" src="https://img-blog.csdnimg.cn/20210725232147729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1188"></p> 
<p>进入这个目录把汉化的文件全部解压覆盖到：&nbsp;<code>public</code>&nbsp;目录下</p> 
<p><img alt="" height="330" src="https://img-blog.csdnimg.cn/20210725232244219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1114"></p> 
<p>&nbsp;<img alt="" height="934" src="https://img-blog.csdnimg.cn/20210725232323132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Python文件处理</title><link>http://www.cnblogs.com/heian99/archive/2021/07/21/15083370.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 21 Jul 2021 07:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/07/21/15083370.html</guid><description><![CDATA[
                    <p>在Python中实现文件的读写操作其实非常简单，通过Python内置的<code>open</code>函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。</p> 
<table><thead><tr><th>操作模式</th><th>具体含义</th></tr></thead><tbody><tr><td><code>'r'</code></td><td>读取 （默认）</td></tr><tr><td><code>'w'</code></td><td>写入（会先截断之前的内容）</td></tr><tr><td><code>'x'</code></td><td>写入，如果文件已经存在会产生异常</td></tr><tr><td><code>'a'</code></td><td>追加，将内容写入到已有文件的末尾</td></tr><tr><td><code>'b'</code></td><td>二进制模式</td></tr><tr><td><code>'t'</code></td><td>文本模式（默认）</td></tr><tr><td><code>'+'</code></td><td>更新（既可以读又可以写）</td></tr></tbody></table>
<p>Python文件处理，正确格式，防止有异常，我们需要加上try&nbsp;except</p> 
<p>标准格式</p> 
<pre><code class="language-python">def main():
    f = None
    try:
        f = open('文件.txt', 'r', encoding='utf-8')
        print(f.read())
    except FileNotFoundError:
        print('无法打开指定的文件!')
    except LookupError:
        print('指定了未知的编码!')
    except UnicodeDecodeError:
        print('读取文件时解码错误!')
    finally:
        if f:
            f.close()
if __name__ == '__main__':
    main()</code></pre> 
<p>在Python中，我们可以将那些在运行时可能会出现状况的代码放在<code>try</code>代码块中，在<code>try</code>代码块的后面可以跟上一个或多个<code>except</code>来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发<code>FileNotFoundError</code>，指定了未知的编码会引发<code>LookupError</code>，而如果读取文件时无法按指定方式解码会引发<code>UnicodeDecodeError</code>，我们在<code>try</code>后面跟上了三个<code>except</code>分别处理这三种不同的异常状况。最后我们使用<code>finally</code>代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于<code>finally</code>块的代码不论程序正常还是异常都会执行到（甚至是调用了<code>sys</code>模块的<code>exit</code>函数退出Python环境，<code>finally</code>块都会被执行，因为<code>exit</code>函数实质上是引发了<code>SystemExit</code>异常），因此我们通常把<code>finally</code>块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在<code>finally</code>代码块中关闭文件对象释放资源，也可以使用上下文语法，通过<code>with</code>关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。</p> 
<p>除了使用文件对象的<code>read</code>方法读取文件之外，还可以使用<code>for-in</code>循环逐行读取或者用<code>readlines</code>方法将文件按行读取到一个列表容器中，代码如下所示。</p> 
<pre><code class="language-python">import time
def main():
    # 一次性读取整个文件内容
    with open('文件.txt', 'r', encoding='utf-8') as f:
        print(f.read())
    # 通过for-in循环逐行读取
    with open('文件.txt', mode='r') as f:
        for line in f:
            print(line, end='')
            time.sleep(0.5)
    print()
    # 读取文件按行读取到列表中
    with open('文件.txt') as f:
        lines = f.readlines()
    print(lines)
if __name__ == '__main__':
    main()</code></pre> 
<p></p> 
<p>通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考<a href="http://json.org">JSON的官方网站</a>，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。</p> 
<p>上面的JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的，如下面两张表所示。</p> 
<table><thead><tr><th>JSON</th><th>Python</th></tr></thead><tbody><tr><td>object</td><td>dict</td></tr><tr><td>array</td><td>list</td></tr><tr><td>string</td><td>str</td></tr><tr><td>number (int / real)</td><td>int / float</td></tr><tr><td>true / false</td><td>True / False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table>
<p></p> 
<pre><code class="language-python">import json
def main():
    mydict = {
        'name': '小风',
        'age': 20,
        'qq': 95849158,
        'friends': ['张三', '李四'],
        'cars': [
            {'brand': 'BYD', 'max_speed': 180},
            {'brand': 'Audi', 'max_speed': 280},
            {'brand': 'Benz', 'max_speed': 320}
        ]
    }
    try:
        with open('data.json', 'w', encoding='utf-8') as fs:
            json.dump(mydict, fs)
    except IOError as e:
        print(e)
    print('保存数据完成!')
if __name__ == '__main__':
    main()</code></pre> 
<p>&nbsp;</p> 
<p>json模块主要有四个比较重要的函数，分别是：</p> 
<ul><li><code>dump</code>&nbsp;- 将Python对象按照JSON格式序列化到文件中</li><li><code>dumps</code>&nbsp;- 将Python对象处理成JSON格式的字符串</li><li><code>load</code>&nbsp;- 将文件中的JSON数据反序列化成对象</li><li><code>loads</code>&nbsp;- 将字符串的内容反序列化成Python对象</li></ul>
                ]]></description></item><item><title>zabbix-api查询机器资源利用率，导出execl表格</title><link>http://www.cnblogs.com/heian99/archive/2021/07/19/15083371.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 19 Jul 2021 13:19:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/07/19/15083371.html</guid><description><![CDATA[
                    <p>zabbix调用api查询机器资源利用率，导出execl表格</p> 
<p>背景：平常我们工作中，需要知道机器的资源利用率多少，我们可以手动查看，但是有1000多台改怎么办？</p> 
<p>方案：我们机器如果是zabbix监控的，我们可以直接调用zabbix的api，来获取所有主机的相关信息，生成execl表格并且导出</p> 
<p>我们可以设置定时任务，每周定时导出，查看集群服务器的利用率。&nbsp;</p> 
<p>github地址：<a href="https://github.com/nangongchengfeng/zabbix-api.git">https://github.com/nangongchengfeng/zabbix-api.git</a></p> 
<p><img alt="" height="224" src="https://img-blog.csdnimg.cn/20210719210917960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<pre><code class="language-python">if host['Number of CPUs'] == "0":
	HostItemValues.append("已停用")
if  float(host['Load average (15m avg)']) &gt;= 10 or  float(round(float(host['CPU utilization']), 2)) &gt;= 20 :
	HostItemValues.append("否")
else:
	HostItemValues.append("是")</code></pre> 
<p>最后面添加是否低负载机器</p> 
<p>判断条件：CPU平均负载/15min &gt;= 10 or CPU使用率 &gt;=20</p> 
<h2>Zabbix-api_v1</h2> 
<p>Zabbix-api_v1版本是初级版本，需要Python环境下操作</p> 
<h2>Zabbix-api_v2</h2> 
<p>Zabbix-api_v2版本可以打包成exe程序，可以方便执行，不需要依赖</p> 
<p></p> 
<p>这里我贴版本2的代码，可以生成exe</p> 
<h2>main.py</h2> 
<pre><code class="language-python">#! /usr/bin/env python

import configparser
import os,sys
import time
from GetItems import Zabbix
from SaveToExcel  import WriteExcel
import datetime

path = os.path.dirname(os.path.abspath(__file__))
sys.intern(path)


if __name__ == "__main__":
    print("start".center(60,"*"))
    print("zabbix统计机器资源使用情况".center(60))
    config = configparser.ConfigParser()
    config.read(os.path.join(os.getcwd(), 'config.ini'), encoding='utf-8')
    # 实例化一个zabbix对象
    #api调用地址
    zabbix_api='http://10.190.5.237/api_jsonrpc.php'
    zabbix_user=input("请输入您zabbix的账号：")
    zabbix_passwd=input('请输入您zabbix的密码：')
    file_name='服务器资源使用情况分析'
    zabbix =  Zabbix(
        zabbix_api,
        zabbix_user,
        zabbix_passwd
    )
    starttime = datetime.datetime.now()
    # 调用GetItemValue方法获取每台监控主机的监控数据
    zabbix_data = zabbix.GetItemValue()
    if len(zabbix_data) == 2:
        print(zabbix_data['errmsg'])
        print("end".center(60, "*"))
    else:
        date_time = time.strftime('%Y-%m-%d_%H-%M')
        #print(zabbix_data)
        file_name = os.path.join(os.getcwd(), file_name + date_time + '.xlsx')
        WriteExcel(file_name, zabbix_data)
        endtime = datetime.datetime.now()
        run_time=endtime - starttime
        print(f"程序运行：{run_time.seconds} s  生成文件：{file_name}")
        print("end".center(60, "*"))</code></pre> 
<h2>GetItems.py</h2> 
<p>在这里可以定制值。切记，这里代码只适合我的环境，有些值为特定值，如有需要，需要更改值</p> 
<p>列如：</p> 
<blockquote> 
 <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "io.usedgen[*]", &nbsp; &nbsp; &nbsp; &nbsp;# 根目录使用率监控<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "disk_capacity.[disk_all_Usage]",#服务器总使用率</p> 
</blockquote> 
<pre><code class="language-python">#! /usr/bin/env python
# _*_ coding: utf-8 _*_

# @Desc   :调用zabbix api接口，获取监控数据，zabbix-版本为5.0以上


import requests
import json
import re

class Zabbix(object):
    def __init__(self, ApiUrl, User, Pwd):
        self.ApiUrl = ApiUrl
        self.User = User
        self.Pwd = Pwd
        self.__Headers = {
            'Content-Type': 'application/json-rpc',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36'
        }
        self.Message = {
            1001: {"errcode": "1001", "errmsg": "请求路径错误，请检查API接口路径是否正确."},
            1002: {"errcode": "1002", "errmsg": "Login name or password is incorrect."},
            1003: {"errcode": "1003", "errmsg": "未获取到监控主机，请检查server端是否监控有主机."},
            1004: {"errcode": "1004", "errmsg": "未知错误."},
        }


    def __Login(self):
        '''
        登陆zabbix，获取认证的秘钥
        Returns: 返回认证秘钥

        '''
        # 登陆zabbix,接口的请求数据
        LoginApiData = {
            "jsonrpc": "2.0",
            "method": "user.login",
            "params": {
                "user": self.User,
                "password": self.Pwd
            },
            "id": 1
        }
        # 向登陆接口发送post请求，获取result
        LoginRet = requests.post(url=self.ApiUrl, data=json.dumps(LoginApiData), headers=self.__Headers)
        # 判断请求是否为200
        if LoginRet.status_code is not 200:
            return 1001
        else:
            # 如果是200状态，则进行数据格式化
            try:
                LoginRet = LoginRet.json()
            except:
                return 1001
            # 如果result在返回数据中，那么表示请求成功，则获取认证key
            if 'result' in LoginRet:
                Result = LoginRet['result']
                return Result
            # 否则返回用户或密码错误
            else:
                return 1002


    def __GetMonitorHost(self):
        # 调用登陆函数，获取auth，并判断是否登陆成功
        Auth = self.__Login()
        if Auth == 1001:
            return 1001
        elif Auth == 1002:
            return 1002
        else:
            HostApiData = {
                "jsonrpc": "2.0",
                "method": "host.get",
                "params": {
                    "output": ["hostid", "host", "name"],
                    "selectInterfaces": ["interfaces", "ip"],
                },
                "auth": Auth,
                "id": 1
            }
            # 向host.get接口发起请求，获取所有监控主机
            HostRet = requests.post(url=self.ApiUrl, data=json.dumps(HostApiData), headers=self.__Headers).json()

            if 'result' in HostRet:
                if len(HostRet['result']) != 0:
                    # 循环处理每一条记录，进行结构化,最终将所有主机加入到all_host字典中
                    Allhost = {}
                    for host in HostRet['result']:
                        # host = {'hostid': '10331', 'host': '172.24.125.24', 'name': 'TBDS测试版172.24.125.24', 'interfaces': [{'ip': '172.24.125.24'}]}
                        # 进行结构化，提取需要的信息
                        HostInfo = {'host': host['host'], 'hostid': host['hostid'], 'ip': host['interfaces'][0]['ip'],
                                     'name': host['name']}
                        # host_info = {'host': '172.24.125.24', 'hostid': '10331', 'ip': '172.24.125.24', 'name': 'TBDS测试版172.24.125.24'}
                        # 加入到all_host中
                        Allhost[host['hostid']] = HostInfo
                    #print(Allhost)主机结构化列表
                    return {"Auth":Auth, "Allhost":Allhost}
                else:
                    return 1003
            else:
                return 1001


    def GetItemValue(self):
        '''
        # 调用item.get接口，获取监控项（监控项中带有每个监控项的最新监控数据） 接口说明文档：https://www.zabbix.com/documentation/4.0/zh/manual/api/reference/item/get
        Returns: 返回所有监控主机监控信息，
        '''
        # 获取所有的主机
        HostRet = self.__GetMonitorHost()
        # 判断HostRet是否有主机和认证key存在，这里如果是类型如果是字段，那边表示一定获取到的有主机信息，如果不是，则表示没有获取到值

        if type(HostRet) is dict:
            # 首先拿到认证文件和所有主机信息
            Auth, AllHost = HostRet['Auth'], HostRet['Allhost']
            # 定义一个新的allhost，存放所有主机新的信息
            NewAllHost = {}
            # 循环向每个主机发起请求，获取监控项的值
            for k in AllHost:
                ItemData = {
                    "jsonrpc": "2.0",
                    "method": "item.get",
                    "params": {
                        "output": ["extend", "name", "key_", "lastvalue"],
                        "hostids": str(k),
                        "search": {
                            "key_":
                                [
                                    "system.hostname",    # 主机名
                                    "system.uptime",      # 系统开机时长
                                    "io.usedgen[*]",        # 根目录使用率监控
                                    "disk_capacity.[disk_all_Usage]",#服务器总使用率
                                    "system.cpu.util",    # cpu使用率
                                    "system.cpu.num",     # cpu核数
                                    "system.cpu.load",    # cpu平均负载
                                    "system.cpu.util[,idle]",     # cpu空闲时间
                                    "vm.memory.utilization",      # 内存使用率
                                    "vm.memory.size[total]",      # 内存总大小
                                    "vm.memory.size[available]",  # 可用内存
                                    "net.if.in",  # 网卡每秒流入的比特(bit)数
                                    "net.if.out"  # 网卡每秒流出的比特(bit)数
                                ]
                        },
                        "searchByAny": "true",
                        "sortfield": "name"
                    },
                    "auth": Auth,
                    "id": 1
                }
                # 向每一台主机发起请求，获取监控项
                Ret = requests.post(url=self.ApiUrl, data=json.dumps(ItemData), headers=self.__Headers).json()
                #print(Ret)
                if 'result' in Ret:
                    # 判断每台主机是否有获取到监控项，如果不等于0表示获取到有监控项
                    if len(Ret['result']) != 0:
                        # 从所有主机信息中取出目前获取信息的这台主机信息存在host_info中
                        HostInfo = AllHost[k]
                        #{'host': 'Zabbix server', 'hostid': '10084', 'ip': '127.0.0.1', 'name': 'Zabbix server'}
                        # 循环处理每一台主机的所有监控项
                        #print(HostInfo)
                        for host in Ret['result']:
                            #print(str(host.values()))
                            # 匹配所有分区挂载目录使用率的正则表达式
                            DiskUtilization = re.findall(r'根目录使用率监控', str(host.values()))
                            #print(DiskUtilization)
                            if len(DiskUtilization) == 1:   #如果匹配到了分区目录，进行保存
                                HostInfo[host['name']] = host['lastvalue']

                            # 匹配网卡进出流量的正则表达式
                            NetworkBits = re.findall(r'Interface.*: Bits [a-z]{4,8}', str(host.values()))
                            #print(host.values())
                            if  len(NetworkBits) == 1:
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'System name' in host.values():      # 匹配主机名，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'System uptime' in host.values():  # 匹配系统开机运行时长，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'Number of CPUs' in host.values(): # 匹配CPU核数，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'Total memory' in host.values():   # 匹配内存总大小，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif '/: Total space' in host.values(): # 匹配根目录总量，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif '/: Used space' in host.values():  # 匹配根目录使用量，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif '/: Space utilization' in host.values():  # 匹配根目录使用量，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'Load average (1m avg)' in host.values():  # 匹配CPU平均1分钟负载，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'Load average (5m avg)' in host.values():  # 匹配CPU平均5分钟负载，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'Load average (15m avg)' in host.values():  # 匹配CPU平均15分钟负载，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'idle time' in host.values():  # 匹配CPU空闲时间，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'CPU utilization' in host.values(): # 匹配CPU使用率，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'Memory utilization' in host.values(): # 匹配内存使用率，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif 'Available memory' in host.values():   # 匹配可用内存大小，进行保存
                                HostInfo[host['name']] = host['lastvalue']
                            elif '服务器硬盘总使用率' in host.values():
                                HostInfo[host['name']] = host['lastvalue']
                        #print(HostInfo)
                        NewAllHost[HostInfo['hostid']] = HostInfo
                        #print(NewAllHost)
                else:
                    return {"errcode": "1001", "errmess": "Login name or password is incorrect."}
            return NewAllHost
            #print(NewAllHost)

        elif HostRet == 1001:
            return self.Message[1001]
        elif HostRet == 1002:
            return self.Message[1002]
        elif HostRet == 1003:
            return self.Message[1003]
        else:
            return self.Message[1004]
</code></pre> 
<h2>SaveToExcel.py</h2> 
<pre><code class="language-bash">#! /usr/bin/env python
# _*_ coding: utf-8 _*_



import re
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, Side, Border, PatternFill


def WriteExcel(FilaPath, ZabbixData):
    WorkBook = Workbook()
    Sheet = WorkBook.active
    Sheet.title = '服务器资源使用情况'
    #  除去 :  '根目录总量/G','根目录使用量/G',
    TableTitle = ['IP','主机名','运行时长/天','CPU/核','内存/GB','根目录使用率/%','CPU平均负载/1min','CPU平均负载/5min','CPU平均负载/15min','CPU空闲时间','CPU使用率/%','内存使用率/%','可用内存/G','磁盘使用率/%','低负载（是/否）']
    TitleColumn = {} #存放每个title值所对应的列{'IP': 'A', '主机名': 'B', '运行时长': 'C', 'CPU/核': 'D', '内存/GB': 'E', '根目录总量': 'F',...}
    AllHostItemValues = [] #存放所有主机的监控项值 列表信息。

    # 维护表头，写入表头数据
    for row in range(len(TableTitle)):
        Col = row + 1
        Column = Sheet.cell(row=1, column=Col)    #获取单元格的位置
        Column.value = TableTitle[row]  #写入数据
        TitleCol = Column.coordinate.strip('1') #获取Title所在的列
        TitleColumn[TableTitle[row]] = TitleCol #加入到TitleColumn

    # 整理Zabbix 监控数据逐行写入到表格中
    #print(ZabbixData)
    for host in ZabbixData.values():
        # 1.首先要对分区目录使用率进行一个整合，将除/目录外的分区目录使用率整合为一个值
        DiskItems = ''   #定义一个空值，用于存放除根目录空间使用率外所有的分区目录使用率
        DelItems = []    #定义一个空列表，用于存放除根目录空间使用率外所有的分区目录使用率的键值
        for item in host:
            DiskItem = re.findall(r'^/[a-z0-9]{1,50}: Space utilization', item)
            if len(DiskItem) == 1:
                DiskItem = DiskItem[0]  #获取监控项的名字 /boot: Space utilization
                NewDiskItem = DiskItem.strip('Space utilization')  # 将名字格式化，/boot: Space utilization 格式化为：/boot:
                DiskItemValue = str(round(float(host[item]), 2)) + '%'  # 取出对应监控项的值，并格式化保留两位小数
                # 将所有分区目录使用率组合为一个整的磁盘使用率
                if DiskItems == '':
                    DiskItemData = str(NewDiskItem) + ' ' + str(DiskItemValue)
                else:
                    DiskItemData = '\n' + str(NewDiskItem) + ' ' + str(DiskItemValue)
                DiskItems += DiskItemData
                # 将处理完的磁盘使用率加入到DelItems列表中，供后续删除使用
                DelItems.append(DiskItem)
        #print(host)
        # 2.将已经整合过的分区目录使用率监控项在原来的主机监控项中删除
        for delitem in DelItems:
            host.pop(delitem)

        # 3.将整合好的分区目录使用率，重新加入到主机监控项的字典中
        host['Disk utilization'] = DiskItems
        #print(host)
        # 4.将每台主机监控项的值取出来组成一个列表
        # 最终得到一条一条这样的数据：
        #'IP','主机名','运行时长/天','CPU/核','内存/GB','根目录使用率/%','CPU平均负载/1min','CPU平均负载/5min','CPU平均负载/15min','CPU空闲时间','CPU使用率/%','内存使用率/%','可用内存/G','磁盘使用率/%'
        # ['172.24.125.12', 'tbds-172-24-125-12', '245.87d', '16', 64, '50G', 7.43, '14.87%', '0.1', '0.18', '0.32', 97.79, '2.21%', '35.52%', 40.45, '/boot: 14.23%\n/data: 6.24%\n/home: 0.03%']
        #print(host['System uptime'])
        if 'System uptime' in host:
            HostItemValues = [] #定义一个空列表，用于存放主机的监控项的值
            HostItemValues.append(host['ip'])
            HostItemValues.append(host['name'])
            try:
                HostItemValues.append(str(round(int(host['System uptime']) / 24 / 60 / 60, 2)) + 'd')
                # 首先将运行时长换算为天数，然后再加入到列表中
            except  IndexError as e:
                print("IndexError Details : " + str(e))
                pass

            HostItemValues.append(host['Number of CPUs'])
            TotalMemory = int(int(host['Total memory']) / 1024 / 1024 / 1024)
            if TotalMemory == 7:
                TotalMemory = 8
            elif TotalMemory == 15:
                TotalMemory = 16
            elif TotalMemory == 31:
                TotalMemory = 32
            elif TotalMemory == 62:
                TotalMemory = 64
            elif TotalMemory == 251:
                TotalMemory = 256
            elif TotalMemory == 503:
                TotalMemory = 512
            HostItemValues.append(TotalMemory)  # 内存总大小
            #HostItemValues.append(str(round(int(host['/: Total space']) / 1024 / 1024 / 1024)) + 'G')  # 根目录总共大小
            #HostItemValues.append(str(round(int(host['/: Used space']) / 1024 / 1024 / 1024, 2)) + 'G')  # 根目录使用量
            HostItemValues.append(str(round(float(host['根目录使用率监控']), 2)) + '%')  # 根目录使用率
            HostItemValues.append(host['Load average (1m avg)'])
            HostItemValues.append(host['Load average (5m avg)'])
            HostItemValues.append(host['Load average (15m avg)'])
            HostItemValues.append(round(float(host['idle time']), 2))  # CPU空闲时间
            HostItemValues.append(str(round(float(host['CPU utilization']), 2)) + '%')  # CPU使用率
            HostItemValues.append(str(round(float(host['Memory utilization']), 2)) + '%')  # 内存使用率
            HostItemValues.append(str(round(int(host['Available memory']) / 1024 / 1024 / 1024, 2)) + 'G')  # 可用内存
            HostItemValues.append(host['服务器硬盘总使用率'])  # 磁盘使用率
            if host['Number of CPUs'] == "0":
                HostItemValues.append("已停用")
            #print(type(float(host['Load average (15m avg)'])),type(float(round(float(host['CPU utilization']), 2))))
            if  float(host['Load average (15m avg)']) &gt;= 10 or  float(round(float(host['CPU utilization']), 2)) &gt;= 20 :
                #print("负载: 是" + host['Load average (15m avg)'])
                #print("cpu: 是" + str(round(float(host['CPU utilization']), 2)))
                HostItemValues.append("否")
            else:
                #print("负载: 否" + host['Load average (15m avg)'])
               # print("cpu: 否" + str(round(float(host['CPU utilization']), 2)))
                HostItemValues.append("是")
            # 将每一台主机的所有监控项信息添加到AllHostItems列表中
            AllHostItemValues.append(HostItemValues)
        #print(AllHostItemValues)
    # 将所有信息写入到表格中
    for HostValue in range(len(AllHostItemValues)):
        Sheet.append(AllHostItemValues[HostValue])
        #print(HostValue)
    ############ 设置单元格样式 ############
    # 字体样式
    TitleFont = Font(name="宋体", size=12, bold=True, italic=False, color="000000")
    TableFont = Font(name="宋体", size=11, bold=False, italic=False, color="000000")
    # 对齐样式
    alignment = Alignment(horizontal="center", vertical="center", text_rotation=0, wrap_text=True)
    # 边框样式
    side1 = Side(style='thin', color='000000')
    border = Border(left=side1, right=side1, top=side1, bottom=side1)
    # 填充样式
    pattern_fill = PatternFill(fill_type='solid', fgColor='99ccff')
    # 设置列宽
    column_width = {'A': 15, 'B': 30, 'C': 14, 'D': 10, 'E': 10, 'F': 16, 'G': 18, 'H': 18, 'I': 22, 'J': 22, 'K': 23,
                    'L': 15, 'M': 16, 'N': 16, 'O': 14, 'P': 16}
    for i in column_width:
        Sheet.column_dimensions[i].width = column_width[i]
    # 设置首行的高度
    Sheet.row_dimensions[1].height = 38
    # 冻结窗口
    Sheet.freeze_panes = 'A2'
    # 添加筛选器
    Sheet.auto_filter.ref = Sheet.dimensions

    # 设置单元格字体及样式
    for row in Sheet.rows:
        for cell in row:
            if cell.coordinate.endswith('1') and len(cell.coordinate) == 2:
                cell.alignment = alignment  #设置对齐样式
                cell.font = TitleFont   #设置字体
                cell.border = border    #设置边框样式
                cell.fill = pattern_fill    #设置填充样式
            else:
                cell.font = TableFont
                cell.alignment = alignment
                cell.border = border
    WorkBook.save(filename=FilaPath)</code></pre> 
<p></p> 
<p>多文件打包。这边百度一下，很简单的</p> 
<p><img alt="" height="184" src="https://img-blog.csdnimg.cn/2021071921171411.png" width="616"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Python实现查询剪贴板自动匹配信息</title><link>http://www.cnblogs.com/heian99/archive/2021/07/08/14999354.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 08 Jul 2021 10:21:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/07/08/14999354.html</guid><description><![CDATA[
                    <h2>Python实现查询剪贴板自动匹配信息</h2> 
<p>前提：业务IP太多，每个有不同的主机名和不同的功能。</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不想每次都要去查execl，想更方便点，更快一点。</p> 
<p><img alt="" height="127" src="https://img-blog.csdnimg.cn/20210708181301587.png" width="1200"></p> 
<p>通俗点思路：点击exe，Python 自动监控剪贴板的内容，然后正则取出IP，接着根据IP对比业务文档，获取相应的信息，然后把查询出来的内容，弹出提示，把查询出的内容写入剪贴板。</p> 
<pre><code class="language-python">'''
功能作用：对比剪贴板类容
'''

import win32clipboard as w
import win32con
import xlrd
from tkinter import messagebox
import win32api, win32con
import pyperclip
import re
import sys
import os

# print(__file__)

path = os.path.dirname(os.path.abspath(__file__))
sys.intern(path)


# print(path)
# 获取剪贴板中的内容
def getText():
    w.OpenClipboard()
    d = w.GetClipboardData(win32con.CF_TEXT)
    w.CloseClipboard()
    return (d).decode('GBK')


# 设置剪贴板的类容
def set_text(aString):
    w.OpenClipboard()
    w.EmptyClipboard()
    w.SetClipboardData(win32con.CF_TEXT, aString)
    w.CloseClipboard()


# 生成资源文件目录访问路径
def resource_path(relative_path):
    if getattr(sys, 'frozen', False):  # 是否Bundle Resource
        base_path = sys._MEIPASS
    else:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)


# 获取剪贴板中的ip,并判断是否正常
def get_ip(ss_ip):
    ipList = re.findall(r'[0-9]+(?:\.[0-9]+){3}', ss_ip)
    # print(ipList)
    if ipList:
        return ipList
    else:
        win32api.MessageBox(0, "请您检查复制是否带有IP，请重新测试", "提醒", win32con.MB_OK)
        sys.exit(0)


# 获取xls中的数据，和之前剪贴板的数据对比
def host(ss_ip):
    # 获取execl的内容，这边是根据业务来分析
    filename = resource_path(os.path.join("res", "hosts.xls"))
    # print(filename)
    # execl_hosts = './hosts.xls'
    data1 = xlrd.open_workbook(filename)
    page = data1.sheet_by_index(2)
    nrows1 = page.nrows
    ncols1 = page.ncols
    # 获取ip
    host_ip = page.col_values(10)
    app = page.col_values(1)  # 功能集群
    purpose = page.col_values(2)  # 用途
    hostname = page.col_values(11)  # 主机名称
    # print(host_ip)

    # 开始对比数据
    start = 0
    count = 1
    # print(ss_ip)
    if str(ss_ip[0]) not in host_ip:
        win32api.MessageBox(0, f"暂无设备{ss_ip[0]}的信息", "未知设备", win32con.MB_OK)
        sys.exit(0)
    for k, item in enumerate(host_ip, start):
        # print(k,item,ss_ip[0])
        if str(ss_ip[0]) == str(item):
            # print("正常:" + item, k)
            win32api.MessageBox(0, f"\t\t注意\n 主机ip：{item}  主机名称：{hostname[k]} \n 功能集群：{app[k]}  主机用途：{purpose[k]}",
                                "发现设备", win32con.MB_OK)
            pyperclip.copy(f"主机ip：{item}  主机名称：{hostname[k]} \n 功能集群：{app[k]}  主机用途：{purpose[k]}")
            sys.exit(0)

        count = count + 1


def main():
    ss_ip = getText()
    one_ip = get_ip(ss_ip)
    host(one_ip)


if __name__ == '__main__':
    main()
</code></pre> 
<p>测试效果：</p> 
<p><img alt="" height="228" src="https://img-blog.csdnimg.cn/20210708181412458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="375"></p> 
<p><img alt="" height="188" src="https://img-blog.csdnimg.cn/20210708181431902.png" width="297"></p> 
<p></p> 
<h2>打包资源生成exe</h2> 
<p>Python打包.exe的方法大致有四种：py2exe, pyinstaller,cx_Freeze和nuitka。其中最常用的是pyinstaller。Pyinstaller本身不是python库，但依旧可以安装python库安装方式安装，生成的.exe可以跨多平台使用，也能指定图标。<br> &nbsp;</p> 
<p>我们需要把使用到的资源文件都放在一个文件夹里。本文在当前目录下新建了一个名为res的子文件夹来存放资源文件，本文假设res内的资源文件为hosts.xls</p> 
<p>修改完.py文件后可以先运行一下，保证无误。然后通过cmd指令：</p> 
<pre><code class="language-python">pyi-makespec -F beloved.py</code></pre> 
<p><br> 生成.spec文件。如果要添加Icon等可以在这里就使用pyi-makespec --icon abc.jpg -F beloved.py语句生成spec文件。<br> 接下来，修改.spec文件：<br><img alt="" src="https://img-blog.csdnimg.cn/2020032516311779.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Njg1MDMw,size_16,color_FFFFFF,t_70"></p> 
<p>修改前datas=[]，本文这里把它改成上图所示，意思是</p> 
<blockquote> 
 <p>将beloved.py当前目录下的res目录（及其目录中的文件）加入目标exe中，在运行时放在零时文件的根目录下，名称为res。</p> 
</blockquote> 
<h2>生成.exe文件以及其他相关文件</h2> 
<p>接下来，我们便可以放心的生成.exe文件了。执行cmd指令</p> 
<pre><code class="language-bash">pyinstaller -F beloved.spec</code></pre> 
<p>.exe文件生成在子文件dict中。到此便可以把.exe发给其他电脑端运行了。.exe运行比较慢，建议多等待，只要没出现错误提示就OK。</p> 
<p>参考地址：<a href="https://blog.csdn.net/qq_44685030/article/details/105096338">https://blog.csdn.net/qq_44685030/article/details/105096338</a></p> 
<p></p>
                ]]></description></item><item><title>再也不用担心Shell脚本出错-ShellCheck</title><link>http://www.cnblogs.com/heian99/archive/2021/06/12/14999355.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 12 Jun 2021 13:33:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/06/12/14999355.html</guid><description><![CDATA[
                    <h2>简介</h2> 
<p>写过shell脚本的人都知道，即便出现一些简单的语法错误，运行的时候也可能没有办法发现。有些看似运行正确的脚本，实际上<strong>可能在某些分支，某些场景下仍然出现错误</strong>，而有的写法可能运行正常，但是却不符合POSIX标准，<strong>不具备可移植性</strong>。</p> 
<p>诚然，shell脚本是解释运行，没有办法向C/C++那样严格检查，但是我们仍然可以借助一些工具帮助我们<strong>提前发现一些错误</strong>。</p> 
<h2><a href="https://github.com/koalaman/shellcheck">shellcheck</a></h2> 
<p>github地址：<a href="https://github.com/koalaman/shellcheck">https://github.com/koalaman/shellcheck</a></p> 
<p>shellcheck 是一款实用的 shell脚本静态检查工具。</p> 
<p>首先，可以帮助你提前发现并修复简单的语法错误，节约时间。每次都需要运行才发现写错了一个小地方，确实非常浪费时间。<br> 其次，可以针对你当前不够完善不够健壮的写法，提供建议，帮助你提前绕开一些坑，避免等问题真的发生了才去调试处理。</p> 
<p>在其介绍中，目标是针对所有用户的，从初学者到高手，都用得上</p> 
<ul><li>指出并澄清典型的初学者的语法问题，那通常会shell提供神秘的错误消息。</li><li>指出并澄清典型的中级的语义问题，这些问题会导致shell出现奇怪且反直觉的行为。</li><li>指出可能导致高级用户的脚本中，可能在未来某种情况下失败的陷阱。</li></ul>
<h3 id="在网页上使用">在线使用</h3> 
<p>非常简单，在网页&nbsp;<a href="https://www.shellcheck.net/">https://www.shellcheck.net</a>&nbsp;上，贴入你的脚本，运行检查即可</p> 
<pre><code class="language-bash">#!/bin/sh
for n in {1..$RANDOM}
do
  str=""
  if (( n % 3 == 0 ))
  then
    str="fizz"
  fi
  if [ $[n%5] == 0 ]
  then
    str="$strbuzz"
  fi
  if [[ ! $str ]]
  then
    str="$n"
  fi
  echo "$str"
done</code></pre> 
<p>shell<br> 它会给出错误提示或者建议：</p> 
<pre><code class="language-bash">$ shellcheck myscript
 
Line 2:
for n in {1..$RANDOM}
         ^-- SC3009: In POSIX sh, brace expansion is undefined.
             ^-- SC3028: In POSIX sh, RANDOM is undefined.
 
Line 5:
  if (( n % 3 == 0 ))
     ^-- SC3006: In POSIX sh, standalone ((..)) is undefined.
 
Line 9:
  if [ $[n%5] == 0 ]
       ^-- SC3007: In POSIX sh, $[..] in place of $((..)) is undefined.
       ^-- SC2007: Use $((..)) instead of deprecated $[..]
              ^-- SC3014: In POSIX sh, == in place of = is undefined.
 
Line 11:
    str="$strbuzz"
         ^-- SC2154: strbuzz is referenced but not assigned.
 
Line 13:
  if [[ ! $str ]]
     ^-- SC3010: In POSIX sh, [[ ]] is undefined.

$</code></pre> 
<p><img alt="" height="678" src="https://img-blog.csdnimg.cn/20210612212405188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>每个可能的错误都提示了。新手写shell出现莫名的报错时，可以尝试使用奥。当然例子中很多并不是真的错误，而是某种写法不符合POSIX标准，这种情况也应该避免。</p> 
<h3 id="安装方式">安装方式</h3> 
<p>在大多数发行版的包管理中，已经有shellcheck了，如在基于debian的机器上</p> 
<pre><code>apt-get install shellcheck
</code></pre> 
<p>其他系统的具体安装方式，可以查阅 shellcheck 的github首页介绍</p> 
<p>当然，也可以选择自行从源码安装。</p> 
<p>我选择的就是二进制安装，直接放在/usr/bin/目录下，给权限就可以了</p> 
<p>下载：<a href="https://download.csdn.net/download/heian_99/19597695">https://download.csdn.net/download/heian_99/19597695</a></p> 
<p>github：<a href="https://github.com/koalaman/shellcheck/releases/download/stable/shellcheck-stable.linux.x86_64.tar.xz">https://github.com/koalaman/shellcheck/releases/download/stable/shellcheck-stable.linux.x86_64.tar.xz</a></p> 
<p>测试</p> 
<pre><code class="language-bash">#!/bin/bash
if[ $# -eq 0 ]
then
    echo "no para"
else
    echo "$# para"
fi
exit 0</code></pre> 
<p>结果：</p> 
<pre><code class="language-bash">[root@redhat heian]# sh test.sh 
test.sh:行2: if[ 0 -eq 0 ]: 未找到命令
test.sh:行3: 未预期的符号 `then' 附近有语法错误
test.sh:行3: `then'
[root@redhat heian]# shellcheck test.sh 

In test.sh line 2:
if[ $# -eq 0 ]
  ^-- SC1069: You need a space before the [.

For more information:
  https://www.shellcheck.net/wiki/SC1069 -- You need a space before the [.
</code></pre> 
<p>相关的报错已经给了解决的办法，也可以根据连接去查询更详细的原因。</p> 
<h3 id="问题列表">问题列表</h3> 
<p>那么shellcheck具体会检查一些什么问题呢，以下给出一个不完整的问题检查列表。<br> 可以看下，你是否都能意识到这样的写法时有错误或隐患的。<br> 如果发现有自己不知道的或自己容易错漏的，那么也许你也应该花点时间，装上shellcheck。</p> 
<p><a name="_caption3"></a></p> 
<h3 id="引号问题"><a name="t6"></a>引号问题</h3> 
<pre><code class="language-bash">echo $1                           # Unquoted variables  #变量未加引号
find . -name *.ogg                # Unquoted find/grep patterns #find/grep 的匹配模式未加引号
rm "~/my file.txt"                # Quoted tilde expansion #引号中的波浪符扩展
v='--verbose="true"'; cmd $v      # Literal quotes in variables # 变量中的字面引号
for f in "*.ogg"                  # Incorrectly quoted 'for' loops # 错误的for循环
touch $@                          # Unquoted $@  # $@未加引号
echo 'Don't forget to restart!'   # Singlequote closed by apostrophe  # 单引号被撇号意外关闭了
echo 'Don\'t try this at home'    # Attempting to escape ' in ''  #试图在单引号括起来的部分中加上一个单引号
echo 'Path is $PATH'              # Variables in single quotes # 将变量用单引号括起来
trap "echo Took ${SECONDS}s" 0    # Prematurely expanded trap #过早扩展陷阱</code></pre> 
<h3 id="条件判断">条件判断</h3> 
<p>ShellCheck 可以识别大多数不正确的条件判断语句</p> 
<pre><code class="language-bash">[[ n != 0 ]]                      # Constant test expressions  # 常量测试表达式
[[ -e *.mpg ]]                    # Existence checks of globs # 对文件是否存在进行检查时，使用通配符
[[ $foo==0 ]]                     # Always true due to missing spaces #由于缺乏空格，结果总是为真
[[ -n "$foo " ]]                  # Always true due to literals #由于字面值存在，结果总是为真
[[ $foo =~ "fo+" ]]               # Quoted regex in =~   # 在 =~ 中使用正则表达式
[ foo =~ re ]                     # Unsupported [ ] operators # 不支持的[]运算符
[ $1 -eq "shellcheck" ]           # Numerical comparison of strings # 比较数字和字符串
[ $n &amp;&amp; $m ]                      # &amp;&amp; in [ .. ]  # 在[]中使用&amp;&amp;运算符
[ grep -q foo file ]              # Command without $(..)  #命令缺少了$(..)
[[ "$$file" == *.jpg ]]           # Comparisons that can't succeed #无法成功的比较
(( 1 -lt 2 ))                     # Using test operators in ((..)) #在((..))中使用比较</code></pre> 
<h3 id="常见的对命令的错误使用">常见的对命令的错误使用</h3> 
<p>ShellCheck 可以识别对一些命令的错误使用</p> 
<pre><code class="language-bash">grep '*foo*' file                 # Globs in regex contexts  #在grep的正则表达式中前后使用通配符
find . -exec foo {} &amp;&amp; bar {} \;  # Prematurely terminated find -exec  # 使find -exec 过早结束
sudo echo 'Var=42' &gt; /etc/profile # Redirecting sudo # 重定向sudo
time --format=%s sleep 10         # Passing time(1) flags to time builtin # 将time(1)的标志传递给内建的time
while read h; do ssh "$h" uptime  # Commands eating while loop input  # 一个获取输入的while循环中，使用同样会获取输入的命令
alias archive='mv $1 /backup'     # Defining aliases with arguments # 定义使用参数的alias
tr -cd '[a-zA-Z0-9]'              # [] around ranges in tr # 在tr的参数范围外使用[]
exec foo; echo "Done!"            # Misused 'exec'  # 错误地使用exec
find -name \*.bak -o -name \*~ -delete  # Implicit precedence in find  # 在find中的隐式优先级
# find . -exec foo &gt; bar \;       # Redirections in find  #find中的重定向
f() { whoami; }; sudo f           # External use of internal functions #在外部使用内部函数</code></pre> 
<h3 id="初学者的常见错误">初学者的常见错误</h3> 
<p>ShellCheck 识别很多初学者的语法错误</p> 
<pre><code class="language-bash">var = 42                          # Spaces around = in assignments #等号两边的空格
$foo=42                           # $ in assignments # 对变量赋值时使用了$
for $var in *; do ...             # $ in for loop variables  # 在循环变量处使用$
var$n="Hello"                     # Wrong indirect assignment #错误的变量
echo ${var$n}                     # Wrong indirect reference #错误的引用
var=(1, 2, 3)                     # Comma separated arrays #逗号分割数组
array=( [index] = value )         # Incorrect index initialization #错误的索引初始化
echo $var[14]                     # Missing {} in array references #引用数组缺少{}
echo "Argument 10 is $10"         # Positional parameter misreference #错误的位置参数引用
if $(myfunction); then ..; fi     # Wrapping commands in $() #在命令外加上$()
else if othercondition; then ..   # Using 'else if'  #使用else if
f; f() { echo "hello world; }     # Using function before definition 在函数定义之前使用函数
[ false ]                         # 'false' being true # 此处false为true
if ( -f file )                    # Using (..) instead of test #使用()取代测试条件</code></pre> 
<h3 id="数据和拼写错误">数据和拼写错误</h3> 
<p>ShellCheck 可以识别一些数据和拼写错误</p> 
<pre><code class="language-bash">args="$@"                         # Assigning arrays to strings # 将数组赋值给字符串
files=(foo bar); echo "$files"    # Referencing arrays as strings # 把数字当成字符串引用
declare -A arr=(foo bar)          # Associative arrays without index # 不带索引组合数组
printf "%s\n" "Arguments: $@."    # Concatenating strings and arrays # 连接字符串和数组
[[ $# &gt; 2 ]]                      # Comparing numbers as strings # 把数字当成字符串比较
var=World; echo "Hello " var      # Unused lowercase variables # 未使用的小写变量
echo "Hello $name"                # Unassigned lowercase variables # 未赋值的小写变量
cmd | read bar; echo $bar         # Assignments in subshells # 在subshells中进行赋值
cat foo | cp bar                  # Piping to commands that don't read # 通过管道传递数据给一个不会做读取的程序
printf '%s: %s\n' foo             # Mismatches in printf argument count # pirintf参数数量不匹配</code></pre> 
<p>&nbsp;</p> 
<h3 id="其他杂七杂八的问题">其他杂七杂八的问题</h3> 
<p>ShellCheck 可以识别到一些其他问题</p> 
<pre><code class="language-bash">PS1='\e[0;32m\$\e[0m '            # PS1 colors not in \[..\]  # PS1 的颜色不在\[..\] 中
PATH="$PATH:~/bin"                # Literal tilde in $PATH # $PATH中的波浪号
rm “file”                         # Unicode quotes #Unicode 引号
echo "Hello world"                # Carriage return / DOS line endings # 传输返回DOS行结束符/
echo hello \                      # Trailing spaces after \   # \后面的行尾空格
var=42 echo $var                  # Expansion of inlined environment # 展开内联环境变量
#!/bin/bash -x -e                 # Common shebang errors # shebang  命令错误
echo $((n/180*100))               # Unnecessary loss of precision # 不必要的精度丢失
ls *[:digit:].txt                 # Bad character class globs # 不好的通配符
sed 's/foo/bar/' file &gt; file      # Redirecting to input # 重定向到输入
while getopts "a" f; do case $f in "b") # Unhandled getopts flags # 未处理的getopts标志</code></pre> 
<h3 id="总结">总结</h3> 
<p>以上就是shellcheck的介绍了，主要来自其github 的readme ，源码在&nbsp;<a href="https://www.cnblogs.com/zqb-all/p/!https://github.comf/koalaman/shellcheck">github</a>&nbsp;<a href="https://github.comf/koalaman/shellcheck">https://github.com/koalaman/shellcheck</a></p> 
<p>简单实用，只要配置好了，就可以持续为你提供帮助。而且这个是建议性的，可以自己根据实际情况决定是否采纳。即用即弃的临时脚本，那兼容性等就不用太care。长期使用的，就还是完善一下比较稳妥。</p> 
<p>&nbsp;</p> 
<p>参考博客：<a href="https://blog.csdn.net/whatday/article/details/105070638">https://blog.csdn.net/whatday/article/details/105070638</a></p> 
<p>微信：<a href="https://mp.weixin.qq.com/s/jPZocFgl5OiDochx7rvI6w">https://mp.weixin.qq.com/s/jPZocFgl5OiDochx7rvI6w</a></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Shell帮你掌管上千台服务（多线程）</title><link>http://www.cnblogs.com/heian99/archive/2021/06/09/14999356.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 09 Jun 2021 12:42:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/06/09/14999356.html</guid><description><![CDATA[
                    <h2>Shell帮你掌管上千台服务（多线程）</h2> 
<p>日常服务器运维时，我们都会批量管理多台服务器。</p> 
<p>脚本，批量化，使我们工作中必不可少的。</p> 
<p>首先我们需要一台堡垒机，负责免秘钥的登录和分发任务等等</p> 
<p><strong>堡垒机到主机</strong></p> 
<p style="margin-left:0;text-align:justify;">需要一套ssh-keygen来管理</p> 
<p><img alt="" height="316" src="https://img-blog.csdnimg.cn/20210609203330757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p> 
<hr>
<div style="margin-left:18pt;"> 
 <ol><li style="text-align:left;"><span style="background-color:#FFFFFF;"><span style="background-color:#FFFFFF;"><span style="color:#000000;">authorized_keys</span><span style="color:#000000;">：</span>&nbsp;<span style="color:#000000;">授权密钥</span>&nbsp;&nbsp;</span></span></li><li style="text-align:left;"><span style="background-color:#FFFFFF;"><span style="background-color:#f8f8f8;"><span style="color:#000000;">id_rsa&nbsp;&nbsp;</span><span style="color:#000000;">：私钥</span>&nbsp;&nbsp;</span></span></li><li style="text-align:left;"><span style="background-color:#FFFFFF;"><span style="background-color:#FFFFFF;"><span style="color:#000000;">id_rsa.pub&nbsp;&nbsp;</span><span style="color:#000000;">：公钥</span>&nbsp;&nbsp;</span></span></li><li style="text-align:left;"><span style="background-color:#FFFFFF;"><span style="background-color:#f8f8f8;"><span style="color:#000000;">known_hosts</span><span style="color:#000000;">：连接过机器记录信息，不需要属于</span><span style="color:#000000;">“yes”&nbsp;&nbsp;</span></span></span></li></ol>
</div> 
<p>这些都是前面基础环境和工作。</p> 
<h2>默认脚本</h2> 
<p>这个脚本是最初始化的，可以远程过去执行任务，并打印结果</p> 
<pre><code class="language-bash">#/bin/bash  
START_TIME=`date +%s`  
for i in `cat /opt/wei/pam_ip.txt`  #ip存放的文件
do  
    cc="ssh deployer@$i \"sudo cat /etc/ssh/sshd_config | grep -Ev '^#' | grep UsePAM\" " 
        kk=`echo $cc|bash`  
        if [ ! -n "$kk" ]; then  
          echo "IP: $i UsePAM no seting"  
          sudo echo "IP: $i UsePAM no seting" &gt;&gt; /opt/wei/pam_no.txt  
        else  
          echo "IP: $i  $kk"   
          sudo echo "IP: $i  $kk" &gt;&gt; /opt/wei/pam_yes.txt  
        fi  
done  
END_TIME=`date +%s`  
EXECUTING_TIME=`expr $END_TIME - $START_TIME`  
echo "================end====================="  
echo "程序运行时长：$EXECUTING_TIME S" 
</code></pre> 
<h2><img alt="" height="83" src="https://img-blog.csdnimg.cn/20210609203846700.png" width="452"></h2> 
<h2>脚本优化（加入线程概念）</h2> 
<pre><code class="language-bash">#/bin/bash  
START_TIME=`date +%s`  
for i in `cat /opt/wei/pam_ip.txt`  
do  
{    cc="ssh deployer@$i \"sudo cat /etc/ssh/sshd_config | grep -Ev '^#' | grep UsePAM\" "  
        kk=`echo $cc|bash`  
        if [ ! -n "$kk" ]; then  
          echo "IP: $i UsePAM no seting"  
          sudo echo "IP: $i UsePAM no seting" &gt;&gt; /opt/wei/pam_no.txt  
        else  
          echo "IP: $i  $kk"   
          sudo echo "IP: $i  $kk" &gt;&gt; /opt/we/pam_yes.txt  
        fi  
}&amp;  
done  
wait  
END_TIME=`date +%s`  
EXECUTING_TIME=`expr $END_TIME - $START_TIME`  
echo "================end====================="  
echo "程序运行：$EXECUTING_TIME S"  
</code></pre> 
<p style="margin-left:0;text-align:justify;"><strong><span style="background-color:#FFFFFF;"><span style="color:#333333;">使用</span></span></strong><strong><span style="background-color:#FFFFFF;"><span style="color:#333333;">'&amp;'+wait </span></span></strong><strong><span style="background-color:#FFFFFF;"><span style="color:#333333;">实现</span></span></strong><strong><span style="background-color:#FFFFFF;"><span style="color:#333333;">“</span></span></strong><strong><span style="background-color:#FFFFFF;"><span style="color:#333333;">多进程</span></span></strong><strong><span style="background-color:#FFFFFF;"><span style="color:#333333;">”</span></span></strong><strong><span style="background-color:#FFFFFF;"><span style="color:#333333;">实现</span></span></strong></p> 
<blockquote> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#333333;">运行很快，而且很不老实（顺序都乱了,大概是因为expr运算所花时间不同）</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#333333;">解析：这一个脚本的变化是在命令后面增加了&amp;标记，意思是将进程扔到后台。在shell中，后台命令之间是不区分先来后到关系的。所以各后台子进程会抢夺资源进行运算。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#333333;">wait</span><span style="color:#333333;">命令：</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#333333;">wait </span>&nbsp;<span style="color:#333333;">[n]</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#333333;">n </span><span style="color:#333333;">表示当前shell中某个执行的后台命令的pid，wait命令会等待该后台进程执行完毕才允许下一个shell语句执行；如果没指定则代表当前shell后台执行的语句，wait会等待到所有的后台程序执行完毕为止。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#17233f;">如果没有wait，后面的shell语句是不会等待后台进程的，一些对前面后台进程有依赖关系的命令执行就不正确了</span></span></p> 
</blockquote> 
<p style="margin-left:0;text-align:left;"><img alt="" height="98" src="https://img-blog.csdnimg.cn/20210609203837964.png" width="554"></p> 
<h2 style="margin-left:0px;text-align:left;">自定义线程数</h2> 
<pre><code class="language-bash">#!/bin/bash  
Nproc=20 #最大并发进程数  
function PushQue { #将PID值追加到队列中  
    Que="$Que $1"  
    Nrun=$(($Nrun+1))  
}  
function GenQue { #更新队列信息，先清空队列信息，然后检索生成新的队列信息  
    OldQue=$Que  
    Que=""; Nrun=0  
    for PID in $OldQue; do  
    if [[ -d /proc/$PID ]]; then  
    PushQue $PID  
    fi  
    done  
}  
function ChkQue { #检查队列信息，如果有已经结束了的进程的PID，那么更新队列信息  
    OldQue=$Que  
    for PID in $OldQue; do  
    if [[ ! -d /proc/$PID ]]; then  
    GenQue; break  
    fi  
    done  
}  
for i in `cat /opt/wei/pam_ip.txt`  
do  
{  
    cc="ssh deployer@$i \"sudo cat /etc/ssh/sshd_config | grep -Ev '^#' | grep UsePAM\" "  
    kk=`echo $cc|bash`  
    if [ ! -n "$kk" ]; then  
      echo "IP: $i UsePAM no seting"  
      sudo echo "IP: $i UsePAM no seting" &gt;&gt; /opt/wei/pam_no.txt  
    else  
      echo "IP: $i  $kk"   
      sudo echo "IP: $i  $kk" &gt;&gt; /opt/wei/pam_yes.txt  
    fi  
}&amp;  
    sleep 0.1  #考虑有序，开启这个参数，速度优先，则注释掉
    PID=$!  
    PushQue $PID  
    while [[ $Nrun -ge $Nproc ]]; do # 如果Nrun大于Nproc，就一直ChkQue  
        ChkQue  
        sleep 0.1  
        done  
done  
wait  
echo -e "time-consuming: $SECONDS seconds" #显示脚本执行耗时#!/bin/bash  
</code></pre> 
<p style="margin-left:0;text-align:justify;"><strong>使用模拟队列来控制进程数量</strong></p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">要控制后台同一时刻的进程数量，需要在原有循环的基础上增加管理机制。</p> 
 <p style="margin-left:0;text-align:justify;">一个方法是以for循环的子进程PID做为队列元素，模拟一个限定最大进程数的队列（只是一个长度固定的数组，并不是真实的队列）。队列的初始长度为0，循环每创建一个进程，就让队列长度+1。当队列长度到达设置的并发进程限制数之后，每隔一段时间检查队列，如果队列长度还是等于限制值，那么不做操作，继续轮询；如果检测到有并发进程执行结束了，那么队列长度-1，轮询检测到队列长度小于限制值后，会启动下一个待执行的进程，直至所有等待执行的并发进程全部执行完。</p> 
</blockquote> 
<p style="margin-left:0;text-align:left;">定义20线程，速度从原来的311S，降到40S，大大提高效率</p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="136" src="https://img-blog.csdnimg.cn/20210609204036133.png" width="516"></p>
                ]]></description></item><item><title>自动安装Zabbix-agent 自动注册</title><link>http://www.cnblogs.com/heian99/archive/2021/05/22/14799767.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 22 May 2021 12:46:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/05/22/14799767.html</guid><description><![CDATA[<h2>Centos7脚本自动安装并注册zabbix服务端</h2>
<p>此脚本可以自动安装zabbix客户端并且配置（注意修改）</p>
<div class="cnblogs_code">
<pre>#zabbix-agent4.<span style="color: #800080;">0.4</span><span style="color: #000000;">
#centos7系列安装zabbix监控
#获取影院IP
#</span><span style="color: #0000ff;">ifconfig</span> -a|<span style="color: #0000ff;">grep</span> inet|<span style="color: #0000ff;">grep</span> -v <span style="color: #800080;">127.0</span>.<span style="color: #800080;">0.1</span>|<span style="color: #0000ff;">grep</span> -v inet6|<span style="color: #0000ff;">awk</span> <span style="color: #800000;">'</span><span style="color: #800000;">{print $2}</span><span style="color: #800000;">'</span>|<span style="color: #0000ff;">tr</span> -d <span style="color: #800000;">"</span><span style="color: #800000;">addr:</span><span style="color: #800000;">"</span><span style="color: #000000;">
#首先ip获取要测试一下，双ip，多ip都会有影响
localname</span>=`<span style="color: #0000ff;">hostname</span><span style="color: #000000;">`
conf</span>=<span style="color: #800000;">"</span><span style="color: #800000;">/etc/init.d/zabbix-agent</span><span style="color: #800000;">"</span><span style="color: #000000;">
 
 
installzabbix(){
 
</span><span style="color: #0000ff;">if</span> [[ -f $conf ]]; <span style="color: #0000ff;">then</span>
        <span style="color: #0000ff;">echo</span> <span style="color: #800000;">"</span><span style="color: #800000;">zabbix_agentd already install</span><span style="color: #800000;">"</span>
    <span style="color: #0000ff;">else</span>
        /etc/init.d/<span style="color: #000000;">zabbix_agentd stop
        </span><span style="color: #0000ff;">rm</span>   -rf     /etc/init.d/<span style="color: #000000;">zabbix_agentd
        </span><span style="color: #0000ff;">rm</span>   -rf    /usr/local/<span style="color: #000000;">zabbix  
        </span><span style="color: #0000ff;">yum</span> -y <span style="color: #0000ff;">install</span>  https:<span style="color: #008000;">//</span><span style="color: #008000;">mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix/4.2/rhel/7/x86_64/zabbix-agent-4.2.8-1.el7.x86_64.rpm</span>
<span style="color: #000000;">        #delconf
        </span><span style="color: #0000ff;">sed</span>   -i  <span style="color: #800000;">'</span><span style="color: #800000;">/^Server/d</span><span style="color: #800000;">'</span>      /etc/zabbix/<span style="color: #000000;">zabbix_agentd.conf 
        </span><span style="color: #0000ff;">sed</span>   -i  <span style="color: #800000;">'</span><span style="color: #800000;">/^Hostname/d</span><span style="color: #800000;">'</span>      /etc/zabbix/<span style="color: #000000;">zabbix_agentd.conf 
        </span><span style="color: #0000ff;">sed</span>   -i  <span style="color: #800000;">'</span><span style="color: #800000;">/^HostMetadata/d</span><span style="color: #800000;">'</span>      /etc/zabbix/<span style="color: #000000;">zabbix_agentd.conf  
        #addconf
        </span><span style="color: #0000ff;">echo</span> <span style="color: #800000;">"</span><span style="color: #800000;">Server=10.10.10.1</span><span style="color: #800000;">"</span>  &gt;&gt; /etc/zabbix/<span style="color: #000000;">zabbix_agentd.conf 
        </span><span style="color: #0000ff;">echo</span> <span style="color: #800000;">"</span><span style="color: #800000;">ServerActive=10.10.10.1</span><span style="color: #800000;">"</span>  &gt;&gt; /etc/zabbix/<span style="color: #000000;">zabbix_agentd.conf 
        </span><span style="color: #0000ff;">echo</span> <span style="color: #800000;">"</span><span style="color: #800000;">HostMetadata=ownit</span><span style="color: #800000;">"</span>   &gt;&gt; /etc/zabbix/<span style="color: #000000;">zabbix_agentd.conf 
        </span><span style="color: #0000ff;">echo</span>  Hostname=$localname   &gt;&gt; /etc/zabbix/<span style="color: #000000;">zabbix_agentd.conf 
 
</span><span style="color: #0000ff;">fi</span><span style="color: #000000;">
}
installzabbix
 
average(){
#负载监控average
</span><span style="color: #0000ff;">echo</span>   <span style="color: #800000;">"</span><span style="color: #800000;">UserParameter=average[*],uptime|awk '{print \$NF}'</span><span style="color: #800000;">"</span>   &gt; /etc/zabbix/zabbix_agentd.d/<span style="color: #000000;">average.conf 
}
average
 
restzabbix(){
chkconfig zabbix</span>-<span style="color: #000000;">agent on
systemctl restart zabbix</span>-<span style="color: #000000;">agent.service
}
restzabbix</span></pre>
</div>
<p>&nbsp;</p>
<h2><a name="t1"></a><a name="t1"></a>zabbix的基本配置文件</h2>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">#zabbix-agent运行的pid
PidFile=/var/run/zabbix/zabbix_agentd.pid
#zabbix-aget运行的日志
LogFile=/var/log/zabbix/zabbix_agentd.log
#zabbix-agent运行的日志大小，当设置为0时，表示不进行日志轮询
LogFileSize=0
#zabbix-agent的目录路径或扩展配置文件路径
Include=/etc/zabbix/zabbix_agentd.d/*.conf
#zabbix server的ip地址，多个ip使用逗号分隔
Server=10.150.11.205,10.50.11.205
#zabbix 主动监控server的ip地址，使用逗号分隔多IP，如果注释这个选项，那么当前服务器的主动监控就被禁用了
ServerActive=10.150.11.205,10.50.11.205
#zabbix-agent的数据源，仅用于主机自动注册功能
HostMetadata=ownit
#zabbix-agent的主机名，必须唯一，区分大小写。Hostname必须和zabbix web上配置的一直，否则zabbix主动监控无法正常工作
Hostname=10.10.3.240
#zabbix-agent是否启用用户自定义监控脚本，1启用，0不启用
UnsafeUserParameters=1
</pre>
</div>
<p>　　</p>
<h2><a name="t2"></a><a name="t2"></a>Zabbix服务端配置</h2>
<p>&nbsp;</p>
<p><img src="https://img-blog.csdnimg.cn/20210522155033431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="1200" height="850" /></p>
<p><img src="https://img-blog.csdnimg.cn/20210522155102362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="1161" height="555" /></p>
<p><img src="https://img-blog.csdnimg.cn/20210522155050260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="1138" height="630" /></p>
<p><img src="https://img-blog.csdnimg.cn/20210522155121670.png" alt="" width="415" height="194" /></p>]]></description></item><item><title>自动安装Zabbix-agent 自动注册</title><link>http://www.cnblogs.com/heian99/archive/2021/05/22/15257898.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 22 May 2021 07:52:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/05/22/15257898.html</guid><description><![CDATA[
                    <h2><a href="https://ownit.top/">博客</a>：<a href="https://www.ownit.top/">https://ownit.top/</a></h2> 
<h2>Centos7脚本自动安装并注册zabbix服务端</h2> 
<p>此脚本可以自动安装zabbix客户端并且配置（注意修改）</p> 
<pre><code class="language-bash">#zabbix-agent4.0.4
#centos7系列安装zabbix监控
#获取影院IP
#ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d "addr:"
#首先ip获取要测试一下，双ip，多ip都会有影响
localname=`hostname`
conf="/etc/init.d/zabbix-agent"


installzabbix(){

if [[ -f $conf ]]; then
		echo "zabbix_agentd already install"
	else
		/etc/init.d/zabbix_agentd stop
		rm   -rf     /etc/init.d/zabbix_agentd
		rm   -rf    /usr/local/zabbix  
		yum -y install  https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix/4.2/rhel/7/x86_64/zabbix-agent-4.2.8-1.el7.x86_64.rpm
		#delconf
		sed   -i  '/^Server/d'      /etc/zabbix/zabbix_agentd.conf 
		sed   -i  '/^Hostname/d'      /etc/zabbix/zabbix_agentd.conf 
		sed   -i  '/^HostMetadata/d'      /etc/zabbix/zabbix_agentd.conf  
		#addconf
		echo "Server=10.10.10.1"  &gt;&gt; /etc/zabbix/zabbix_agentd.conf 
		echo "ServerActive=10.10.10.1"  &gt;&gt; /etc/zabbix/zabbix_agentd.conf 
		echo "HostMetadata=ownit"   &gt;&gt; /etc/zabbix/zabbix_agentd.conf 
		echo  Hostname=$localname   &gt;&gt; /etc/zabbix/zabbix_agentd.conf 

fi
}
installzabbix

average(){
#负载监控average
echo   "UserParameter=average[*],uptime|awk '{print \$NF}'"   &gt; /etc/zabbix/zabbix_agentd.d/average.conf 
}
average

restzabbix(){
chkconfig zabbix-agent on
systemctl restart zabbix-agent.service
}
restzabbix</code></pre> 
<h2>zabbix的基本配置文件</h2> 
<pre><code class="language-bash">#zabbix-agent运行的pid
PidFile=/var/run/zabbix/zabbix_agentd.pid
#zabbix-aget运行的日志
LogFile=/var/log/zabbix/zabbix_agentd.log
#zabbix-agent运行的日志大小，当设置为0时，表示不进行日志轮询
LogFileSize=0
#zabbix-agent的目录路径或扩展配置文件路径
Include=/etc/zabbix/zabbix_agentd.d/*.conf
#zabbix server的ip地址，多个ip使用逗号分隔
Server=10.150.11.205,10.50.11.205
#zabbix 主动监控server的ip地址，使用逗号分隔多IP，如果注释这个选项，那么当前服务器的主动监控就被禁用了
ServerActive=10.150.11.205,10.50.11.205
#zabbix-agent的数据源，仅用于主机自动注册功能
HostMetadata=ownit
#zabbix-agent的主机名，必须唯一，区分大小写。Hostname必须和zabbix web上配置的一直，否则zabbix主动监控无法正常工作
Hostname=10.10.3.240
#zabbix-agent是否启用用户自定义监控脚本，1启用，0不启用
UnsafeUserParameters=1
</code></pre> 
<h2>Zabbix服务端配置</h2> 
<p>&nbsp;</p> 
<p><img alt="" height="850" src="https://img-blog.csdnimg.cn/20210522155033431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="555" src="https://img-blog.csdnimg.cn/20210522155102362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1161"></p> 
<p><img alt="" height="630" src="https://img-blog.csdnimg.cn/20210522155050260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1138"></p> 
<p><img alt="" height="194" src="https://img-blog.csdnimg.cn/20210522155121670.png" width="415"></p>
                ]]></description></item><item><title>Ansible小实例</title><link>http://www.cnblogs.com/heian99/archive/2021/05/05/14999358.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 04 May 2021 16:07:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/05/05/14999358.html</guid><description><![CDATA[
                    <h2>1、向各主机分发秘钥</h2> 
<p>方法一</p> 
<pre><code class="language-bash">---
- name: 配置ssh免秘钥连接
  hosts: new
  gather_facts: false
  connection: local #本地连接
  tasks:
    - name: configure ssh connection
      shell: |
        ssh-keyscan {<!-- -->{inventory_hostname}} &gt;&gt;~/.ssh/known_hosts
        sshpass -p'密码' ssh-copy-id root@{<!-- -->{inventory_hostname}}
</code></pre> 
<p>方法二&nbsp;</p> 
<pre><code class="language-bash">---
- name: configure ssh connection
  hosts: new
  gather_facts: false
  tasks:
    - authorized_key:
        key: "{<!-- -->{lookup('file','~/.ssh/id_rsa.pub')}}"
        state: present
        user: root</code></pre> 
<p>执行该playbook，主机加上了<code>-k</code>选项，它会提示用户输入ssh连接密码。如果所有目标主机的密码都相同，则只需输入一次即可：</p> 
<pre><code class="language-bash">$ ansible-playbook -k anth_key.yml
SSH password: 

PLAY [configure ssh connection] ***********

TASK [authorized_key] *********************
changed: [192.168.200.34]
changed: [192.168.200.35]
......</code></pre> 
<h2>2、循环创建文件</h2> 
<p>方法一</p> 
<pre><code class="language-cpp">---
- name: play1
  hosts: localhost
  gather_facts: false
  tasks: 
    - name: create /tmp/test1
      file: 
        path: /tmp/test1
        state: directory

    - name: create /tmp/test2
      file: 
        path: /tmp/test2
        state: directory</code></pre> 
<p>方法二</p> 
<pre><code class="language-bash">---
- name: play1
  hosts: localhost
  gather_facts: false
  tasks: 
    - name: create directories
      file: 
        path: "{<!-- -->{item}}"
        state: directory
      loop:
        - /tmp/test1
        - /tmp/test2</code></pre> 
<h2>3、设置多个主机名</h2> 
<pre><code class="language-bash">---
- name: set hostname
  hosts: new
  gather_facts: false
  vars:
    hostnames:
      - host: 192.168.200.34
        name: new1
      - host: 192.168.200.35
        name: new2
  tasks: 
    - name: set hostname
      hostname: 
        name: "{<!-- -->{item.name}}"
      when: item.host == inventory_hostname
      loop: "{<!-- -->{hostnames}}"</code></pre> 
<p>&nbsp;</p> 
<h2>4、主机之间相互添加DNS</h2> 
<pre><code class="language-bash">---
- name: add DNS for each
  hosts: new
  gather_facts: true
  tasks: 
    - name: add DNS
      lineinfile: 
        path: "/etc/hosts"
        line: "{<!-- -->{item}} {<!-- -->{hostvars[item].ansible_hostname}}"
      when: item != inventory_hostname
      loop: "{<!-- -->{ play_hosts }}"</code></pre> 
<p>&nbsp;</p> 
<h2>5、添加yum源</h2> 
<pre><code class="language-bash">---
- name: config yum repo and install software
  hosts: new
  gather_facts: false
  tasks: 
    - name: backup origin yum repos
      shell: 
        cmd: "mkdir bak; mv *.repo bak"
        chdir: /etc/yum.repos.d
        creates: /etc/yum.repos.d/bak

    - name: add os repo and epel repo
      yum_repository: 
        name: "{<!-- -->{item.name}}"
        description: "{<!-- -->{item.name}} repo"
        baseurl: "{<!-- -->{item.baseurl}}"
        file: "{<!-- -->{item.name}}"
        enabled: 1
        gpgcheck: 0
        reposdir: /etc/yum.repos.d
      loop:
        - name: os
          baseurl: "https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch"
        - name: epel
          baseurl: "https://mirrors.tuna.tsinghua.edu.cn/epel/$releasever/$basearch"

    - name: install pkgs
      yum: 
        name: lrzsz,vim,dos2unix,wget,curl
        state: present</code></pre> 
<h2>6、时间同步</h2> 
<pre><code class="language-bash">---
- name: sync time
  hosts: new
  gather_facts: false
  tasks: 
    - name: install and sync time
      block: 
        - name: install ntpdate
          yum: 
            name: ntpdate
            state: present

        - name: ntpdate to sync time
          shell: |
            ntpdate ntp1.aliyun.com
            hwclock -w
    - name: date_show
      shell: |
        date +%F-%T
</code></pre> 
<h2>7、关闭selinux</h2> 
<pre><code class="language-bash">---
- name: disable selinux
  hosts: new
  gather_facts: false
  tasks: 
    - block: 
        - name: disable on the fly
          shell: setenforce 0

        - name: disable forever in config
          lineinfile: 
            path: /etc/selinux/config
            line: "SELINUX=disabled"
            regexp: '^SELINUX='
      ignore_errors: true</code></pre> 
<h2>8、配置防火墙</h2> 
<p>方法一</p> 
<pre><code class="language-bash">---
- name: set firewall
  hosts: new
  gather_facts: false
  tasks: 
    - name: set iptables rule
      shell: |
        # 备份已有规则
        iptables-save &gt; /tmp/iptables.bak$(date +"%F-%T")
        # 给它三板斧
        iptables -X
        iptables -F
        iptables -Z

        # 放行lo网卡和允许ping
        iptables -A INPUT -i lo -j ACCEPT
        iptables -A INPUT -p icmp -j ACCEPT

        # 放行关联和已建立连接的包，放行22、443、80端口
        iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
        iptables -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
        iptables -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
        iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT

        # 配置filter表的三链默认规则，INPUT链丢弃所有包
        iptables -P INPUT DROP
        iptables -P FORWARD DROP
        iptables -P OUTPUT ACCEPT</code></pre> 
<p>方法二</p> 
<pre><code class="language-bash">---
- name: set firewall
  hosts: new
  gather_facts: false
  vars: 
    allowed_tcp_ports: [22,80,443]
    default_policies:
      INPUT: DROP
      FORWARD: DROP
      OUTPUT: ACCEPT
    user_iptables_rule: 
      - iptables -A INPUT -p tcp -m tcp --dport 8000 -j ACCEPT
      - iptables -A INPUT -p tcp -m tcp --dport 8080 -j ACCEPT

  tasks: 
    - block: 
      - name: backup and empty rules
        shell: |
          # 备份已有规则，并清空规则等
          iptables-save &gt; /tmp/iptables.bak$(date +"%F-%T")
          iptables -X
          iptables -F
          iptables -Z

      - name: green light for lo interface and icmp protocol
        shell: |
          # 放行lo接口、ping和已建立连接的包
          iptables -A INPUT -i lo -j ACCEPT
          iptables -A INPUT -p icmp -j ACCEPT
          iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

      # 放行用户指定的tcp端口列表
      - name: allow for given tcp port
        shell: iptables -A INPUT -p tcp -m tcp --dport {<!-- -->{item}} -j ACCEPT
        loop: "{<!-- -->{ allowed_tcp_ports | default([]) }}"

      # 执行用户自定义的iptables命令
      - name: execute user iptables command
        shell: "{<!-- -->{item}}"
        loop: "{<!-- -->{user_iptables_rule | default([]) }}"

      # 设置filter表三链的默认规则
      - name: default policies for filter table
        shell: iptables -P {<!-- -->{item.key}} {<!-- -->{item.value}}
        loop: "{<!-- -->{ query('dict', default_policies | default({})) }}"</code></pre> 
<h2>9、远程修改sshd配置文件并重启</h2> 
<p>采用lineinfile模块去修改配置文件，要修改的内容只有两项： 1.将PermitRootLogin指令设置为no，禁止root用户直接登录 2.将PasswordAuthentication指令设置为no，不允许使用密码认证的方式登录</p> 
<pre><code class="language-bash">---
- name: modify sshd_config
  hosts: new
  gather_facts: false
  tasks:
    # 1. 备份/etc/ssh/sshd_config文件
    - name: backup sshd config
      shell: 
        /usr/bin/cp -f {<!-- -->{path}} {<!-- -->{path}}.bak
      vars: 
        - path: /etc/ssh/sshd_config

    # 2. 设置PermitRootLogin no
    - name: disable root login
      lineinfile: 
        path: "/etc/ssh/sshd_config"
        line: "PermitRootLogin no"
        insertafter: "^#PermitRootLogin"
        regexp: "^PermitRootLogin"
      notify: "restart sshd"

    # 3. 设置PasswordAuthentication no
    - name: disable password auth
      lineinfile: 
        path: "/etc/ssh/sshd_config"
        line: "PasswordAuthentication no"
        regexp: "^PasswordAuthentication yes"
      notify: "restart sshd"

  handlers: 
    - name: "restart sshd"
      service: 
        name: sshd
        state: restarted</code></pre> 
<p>&nbsp;</p> 
<p>通过一个入口文件引入所有这些任务文件将它们组织起来。假设入口文件名为main.yaml，其内容为：</p> 
<pre><code class="language-bash">---
- import_playbook: "init_server/sshkey.yaml"
- import_playbook: "init_server/hostname.yaml"
- import_playbook: "init_server/add_dns.yaml"
- import_playbook: "init_server/add_repos.yaml"
- import_playbook: "init_server/synctime.yaml"
- import_playbook: "init_server/disable_selinux.yaml"
- import_playbook: "init_server/iptables.yaml"
- import_playbook: "init_server/sshd_config.yaml"</code></pre> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Shell监控公网IP-变化邮件报警</title><link>http://www.cnblogs.com/heian99/archive/2021/05/01/14999359.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 01 May 2021 05:59:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/05/01/14999359.html</guid><description><![CDATA[
                    <p><strong>Shell监控公网IP-变化邮件报警</strong></p> 
<p><strong>公司用的网线IP，但是有时IP会改变，导致部分业务有问题，我们又不能及时发现，会造成一定的影响。</strong></p> 
<p><strong>现在使用shell监控公网的IP，如发生变化，立即邮件报警。</strong></p> 
<p>&nbsp;</p> 
<h3><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h3> 
<p>centos邮件报警可以参考这个，默认是mailx</p> 
<p>&nbsp;</p> 
<h3>脚本</h3> 
<pre><code class="language-bash">#!/bin/bash
dirfile='/home/ip_change'
new_ip=`curl icanhazip.com`    #获取新公网ip
mail_user=1794@qq.com    #接收收邮件邮箱
mail_subject="IP已经发生变化，及时处理"    #邮件主题
log="/var/log/tool.log"
datetime=`date '+%Y-%m-%d %H:%M:%S'`
#判断文件是否存在
if [ ! -f "$dirfile" ]; then
  touch "$file"
  echo "1.1.1.1" &gt; $dirfile
fi
#判断new_ip是否获取

if [ ! -n "$new_ip" ]; then
    echo "$datetime 公网IP获取失败，检查'curl icanhazip.com' " &gt;&gt; $log
    exit 1
fi
old_ip=`cat $dirfile`     #查看旧ip

# 判断两个IP是否相等 发邮件
if [ "$new_ip" = "$old_ip" ]; then
  echo "$datetime IP正常 - true " &gt;&gt; $log
else
  echo  $new_ip &gt; $dirfile
  echo "IP已经发生变化, 新IP: $new_ip   旧IP： $old_ip  !!! " | mail -s "$mail_subject" "$mail_user"
  echo "$datetime IP已经发生变化 - error 新IP ：$new_ip   旧IP： $old_ip" &gt;&gt; $log
fi</code></pre> 
<p><img alt="" height="204" src="https://img-blog.csdnimg.cn/20210501135739773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="552"></p> 
<p><img alt="" height="218" src="https://img-blog.csdnimg.cn/2021050113570613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="726"></p>
                ]]></description></item><item><title>Kubernetes实战模拟七（wordpress的数据持久化）</title><link>http://www.cnblogs.com/heian99/archive/2021/04/08/14634944.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 07 Apr 2021 16:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/08/14634944.html</guid><description><![CDATA[
                    <h1><a href="https://blog.csdn.net/heian_99/article/details/115422455">Kubernetes实战模拟一（wordpress基础版）</a></h1> 
<h1 id="articleContentId"><a name="t1"></a><a href="https://blog.csdn.net/heian_99/article/details/115422781">Kubernetes实战模拟二（wordpress高可用）</a></h1> 
<h1><a name="t2"></a><a href="https://blog.csdn.net/heian_99/article/details/115433372">Kubernetes实战模拟三（wordpress健康检查和服务质量QoS）</a></h1> 
<h1><a name="t3"></a><a href="https://blog.csdn.net/heian_99/article/details/115468779">Kubernetes实战模拟四（wordpress升级更新）</a></h1> 
<h1><a name="t4"></a><a href="https://blog.csdn.net/heian_99/article/details/115477746">Kubernetes实战模拟五（wordpress的HPA自动扩缩容）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115488011">Kubernetes实战模拟六（wordpress的账号信息加密）</a></h1> 
<p>源码地址：<a href="https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example">https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example</a></p> 
<p><strong>Kubernetes实战模拟六，已经构建wordpress的账号信息加密，和时间校准。</strong></p> 
<p>&nbsp;</p> 
<h1>版本6</h1> 
<p><strong>思路：想mysql和wordpress的数据持久化，总不能把数据放到容器中，如果容器重启或者删除，那么数据将都会消失的。接下来我们采用nfs实践（其实后端存储使用ceph比较好，安全性和高可用。这边方便演示采用nfs）</strong></p> 
<p>&nbsp;</p> 
<h1>NFS</h1> 
<pre><code>#安装
yum install -y nfs-utils rpcbind

mkdir -p /data/nfsdata

# 修改配置
$ vim /etc/exports
/data/nfsdata 192.168.31.* (rw,async,no_root_squash)

# 使配置生效
$ exportfs -r

# 服务端查看下是否生效
$ showmount -e localhost

Export list for localhost:
/data/nfsdata (everyone)
</code></pre> 
<h1>helm安装nfs-client</h1> 
<pre><code>stable       	https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts
helm添加这个源</code></pre> 
<pre><code>下载helm包
helm pull aliyuncs/nfs-client-provisioner
解压
tar -zxvf nfs-client-provisioner-1.2.8.tgz

修复values.yaml 三处
image:
  repository: quay.io/external_storage/nfs-client-provisioner
  tag: v3.1.0-k8s1.11
  pullPolicy: IfNotPresent

nfs:
  server: 192.168.31.73
  path: /data/nfsdata


  reclaimPolicy: Retain
</code></pre> 
<pre><code>安装
helm install nfs-client-provisioner -n nfs .

卸载
helm uninstall -n nfs nfs-client-provisioner</code></pre> 
<p><img alt="" height="333" src="https://img-blog.csdnimg.cn/20210407234925257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h1><strong>mysql</strong>数据持久化</h1> 
<h3><strong>mysql-nfs.yaml.yaml</strong></h3> 
<pre><code>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-nfs
  namespace: kube-example
  labels:
    app: mysql
spec:
  storageClassName: "nfs-client"  #存储后端
  accessModes:
    - ReadWriteOnce  #允许一个容器连接，读写
  resources:
    requests:
      storage: 1G  #存储量</code></pre> 
<h3>mysql.yaml</h3> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  namespace: kube-example
  labels:
    app: wordpress
spec:
  selector:
    app: wordpress
    tier: mysql
  ports:
    - port: 3306
      targetPort: dbport

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-mysql
  namespace: kube-example
  labels:
    app: wordpress
    tier: mysql
spec:
  replicas: 1
  template:
    metadata:
      name: wordpress-mysql
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.6
          args:
          - --character-set-server=utf8mb4
          - --collation-server=utf8mb4_unicode_ci

          volumeMounts:
            - mountPath: /var/lib/mysql
              name: mysql-nfs
          ports:
            - containerPort: 3306
              name: dbport
          env:
          - name: MYSQL_ROOT_PASSWORD
            valueFrom:
              secretKeyRef:
                key: MYSQL_ROOT_PASSWORD
                name: db.conf
          - name: MYSQL_DATABASE
            valueFrom:
              secretKeyRef:
                key: MYSQL_DATABASE
                name: db.conf
          - name: MYSQL_USER
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_USER
                name: db.conf
          - name: MYSQL_PASSWORD
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_PASSWORD
                name: db.conf
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 1000m
              memory: 400Mi
            requests:
              cpu: 1000m
              memory: 400Mi
          startupProbe:  #首次启动探测（如果没有成功，不会运行下面livenessProbe）
            tcpSocket:
              port: 3306
            failureThreshold: 2    #探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。
            initialDelaySeconds: 20  # 容器启动后第一次执行探测是需要等待多少秒
            timeoutSeconds: 10  # 探测超时时间。默认1秒，最小1秒。
            periodSeconds: 10   # 执行探测的频率。默认是10秒，最小1秒。


      restartPolicy: Always
      volumes:
        - name: mysql-nfs
          persistentVolumeClaim:
            claimName: mysql-nfs
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
</code></pre> 
<h1>wordpress数据持久化</h1> 
<h3>wordpress-nfs.yaml</h3> 
<p>但是由于 Wordpress 应用是多个副本，所以需要同时在多个节点进行读写，也就是&nbsp;<code>accessModes</code>&nbsp;需要&nbsp;<code>ReadWriteMany</code>&nbsp;模式</p> 
<pre><code>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-nfs
  namespace: kube-example
  labels:
    app: wordpress
spec:
  storageClassName: "nfs-client"
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 2G</code></pre> 
<h3>wordpress.yaml</h3> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: kube-example
spec:
  selector:
    app: wordpress
    tier: frontend
  ports:
    - port: 80
      name: web
      targetPort: wdport
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: kube-example
  labels:
    app: wordpress
    tier: frontend
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  replicas: 3   #多副本+pod的反亲合力可以实现pod的高可用
  template:
    metadata:
      name: wordpress
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
        - name: wordpress
          image: wordpress:5.3.2-apache
          ports:
            - containerPort: 80
              name: wdport
          #pvc挂载到容器目录
          volumeMounts:
            - mountPath: /var/www/html
              name: wordpress-nfs
          env:
          - name: WORDPRESS_DB_HOST
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_HOST
                name: db.conf
          - name: WORDPRESS_DB_USER
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_USER
                name: db.conf
          - name: WORDPRESS_DB_PASSWORD
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_PASSWORD
                name: db.conf
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 800m
              memory: 150Mi
            requests:
              cpu: 800m
              memory: 150Mi
          startupProbe:  #首次启动探测（如果没有成功，不会运行下面livenessProbe）
            httpGet:
              port: 80
            failureThreshold: 2    #探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。
            initialDelaySeconds: 20  # 容器启动后第一次执行探测是需要等待多少秒
            timeoutSeconds: 10 #  探测超时时间。默认1秒，最小1秒。
            periodSeconds: 5  # 执行探测的频率。默认是10秒，最小1秒。

          readinessProbe:  # （就绪检查） # 如果检查失败，kubernetes会把Pod从service endpoints中剔除
            tcpSocket:
              port: 80
            initialDelaySeconds: 10
            timeoutSeconds: 5
            failureThreshold: 5
            periodSeconds: 5
            successThreshold: 3
      affinity:
        podAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              podAffinityTerm:
                topologyKey: kubernetes.io/hostname
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - wordpress
      restartPolicy: Always
      #挂载的pvc
      volumes:
        - name: wordpress-nfs
          persistentVolumeClaim:
            claimName: wordpress-nfs

</code></pre> 
<h1>测试</h1> 
<p><img alt="" height="139" src="https://img-blog.csdnimg.cn/20210407235714928.png" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="392" src="https://img-blog.csdnimg.cn/20210407235735554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<p>现在删除或者重启pod的数据都不会丢失，我们已经把数据放在固定的节点，通过网络进行访问</p> 
<p>但是，NFS只适合测试环境，或者数据不重要的前提下。如果数据重要，我们需要使用ceph来作为Kubernetes的存储后端</p> 
<p>好了，我们wordpress模拟接近尾声，但是我这些只完成一版，生产环境远远比这复杂和安全，我们后期可以不断慢慢的完善</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes实战模拟六（wordpress的账号信息加密）</title><link>http://www.cnblogs.com/heian99/archive/2021/04/07/14634945.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 07 Apr 2021 08:57:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/07/14634945.html</guid><description><![CDATA[
                    <h1><a href="https://blog.csdn.net/heian_99/article/details/115422455">Kubernetes实战模拟一（wordpress基础版）</a></h1> 
<h1 id="articleContentId"><a name="t1"></a><a href="https://blog.csdn.net/heian_99/article/details/115422781">Kubernetes实战模拟二（wordpress高可用）</a></h1> 
<h1><a name="t2"></a><a href="https://blog.csdn.net/heian_99/article/details/115433372">Kubernetes实战模拟三（wordpress健康检查和服务质量QoS）</a></h1> 
<h1><a name="t3"></a><a href="https://blog.csdn.net/heian_99/article/details/115468779">Kubernetes实战模拟四（wordpress升级更新）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115477746">Kubernetes实战模拟五（wordpress的HPA自动扩缩容）</a></h1> 
<p>源码地址：<a href="https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example">https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example</a></p> 
<p><strong>Kubernetes实战模拟五，已经构建wordpress的HPA自动扩缩容，可以面对业务并发</strong></p> 
<p>&nbsp;</p> 
<h1><a name="t4"></a>版本6</h1> 
<p><strong>思路：想mysql和wordpress，交互连接时，需要账号和密码，我们不希望明文显示，这里我们可以使用secrets加密，然后挂载到env环境中。</strong></p> 
<p>安全性这个和具体的业务应用有关系，比如我们这里的 Wordpress 也就是数据库的密码属于比较私密的信息，我们可以使用 Kubernetes 中的 Secret 资源对象来存储比较私密的信息</p> 
<p>&nbsp;</p> 
<h1>secrets</h1> 
<p><strong>db-secrets.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: v1
data:
  WORDPRESS_DB_HOST: d29yZHByZXNzLW15c3FsOjMzMDY=
  WORDPRESS_DB_PASSWORD: d29yZHByZXNz
  WORDPRESS_DB_USER: d29yZHByZXNz
  MYSQL_ROOT_PASSWORD: cm9vdFBhc3NXMHJk
  MYSQL_DATABASE: d29yZHByZXNz
kind: Secret
metadata:
  name: db.conf
  namespace: kube-example
type: Opaque
</code></pre> 
<p>这边当时遇见一个问题&nbsp;&nbsp;<a href="https://blog.csdn.net/heian_99/article/details/115486589">https://blog.csdn.net/heian_99/article/details/115486589</a>&nbsp; 已经解决，可以参照这个。</p> 
<p>然后将Deployment 资源对象中的数据库密码环境变量通过 Secret 对象读取</p> 
<p><strong>mysql.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  namespace: kube-example
  labels:
    app: wordpress
spec:
  selector:
    app: wordpress
    tier: mysql
  ports:
    - port: 3306
      targetPort: dbport

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-mysql
  namespace: kube-example
  labels:
    app: wordpress
    tier: mysql
spec:
  replicas: 1
  template:
    metadata:
      name: wordpress-mysql
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          args:
          - --default_authentication_plugin=mysql_native_password
          - --character-set-server=utf8mb4
          - --collation-server=utf8mb4_unicode_ci
          ports:
            - containerPort: 3306
              name: dbport
          #环境注入
          env:
          - name: MYSQL_ROOT_PASSWORD
            valueFrom:
              secretKeyRef:
                key: MYSQL_ROOT_PASSWORD
                name: db.conf
          - name: MYSQL_DATABASE
            valueFrom:
              secretKeyRef:
                key: MYSQL_DATABASE
                name: db.conf
          - name: MYSQL_USER
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_USER
                name: db.conf
          - name: MYSQL_PASSWORD
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_PASSWORD
                name: db.conf
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 1000m
              memory: 400Mi
            requests:
              cpu: 1000m
              memory: 400Mi
          startupProbe:  #首次启动探测（如果没有成功，不会运行下面livenessProbe）
            tcpSocket:
              port: 3306
            failureThreshold: 2    #探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。
            initialDelaySeconds: 20  # 容器启动后第一次执行探测是需要等待多少秒
            timeoutSeconds: 10  # 探测超时时间。默认1秒，最小1秒。
            periodSeconds: 10   # 执行探测的频率。默认是10秒，最小1秒。


      restartPolicy: Always
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
</code></pre> 
<p><strong>wordpress.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: kube-example
spec:
  selector:
    app: wordpress
    tier: frontend
  ports:
    - port: 80
      name: web
      targetPort: wdport
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: kube-example
  labels:
    app: wordpress
    tier: frontend
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  replicas: 3   #多副本+pod的反亲合力可以实现pod的高可用
  template:
    metadata:
      name: wordpress
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
        - name: wordpress
          image: wordpress:5.3.2-apache
          ports:
            - containerPort: 80
              name: wdport
          # 环境注入
          env:
          - name: WORDPRESS_DB_HOST
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_HOST
                name: db.conf
          - name: WORDPRESS_DB_USER
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_USER
                name: db.conf
          - name: WORDPRESS_DB_PASSWORD
            valueFrom:
              secretKeyRef:
                key: WORDPRESS_DB_PASSWORD
                name: db.conf
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 800m
              memory: 150Mi
            requests:
              cpu: 800m
              memory: 150Mi
          startupProbe:  #首次启动探测（如果没有成功，不会运行下面livenessProbe）
            httpGet:
              port: 80
            failureThreshold: 2    #探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。
            initialDelaySeconds: 20  # 容器启动后第一次执行探测是需要等待多少秒
            timeoutSeconds: 10 #  探测超时时间。默认1秒，最小1秒。
            periodSeconds: 5  # 执行探测的频率。默认是10秒，最小1秒。

          readinessProbe:  # （就绪检查） # 如果检查失败，kubernetes会把Pod从service endpoints中剔除
            tcpSocket:
              port: 80
            initialDelaySeconds: 10
            timeoutSeconds: 5
            failureThreshold: 5
            periodSeconds: 5
            successThreshold: 3
      affinity:
        podAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              podAffinityTerm:
                topologyKey: kubernetes.io/hostname
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - wordpress
      restartPolicy: Always

</code></pre> 
<p>&nbsp;</p> 
<p>这样我们就不会在 YAML 文件中看到明文的数据库密码了，当然安全性都是相对的，Secret 资源对象也只是简单的将密码做了一次 Base64 编码而已，对于一些特殊场景安全性要求非常高的应用，就需要使用其他功能更加强大的密码系统来进行管理了，比如&nbsp;<a href="https://www.vaultproject.io/">Vault</a>。</p> 
<p>我们的配置也让Secret管理，也方便修改和配置</p> 
<p><img alt="" height="744" src="https://img-blog.csdnimg.cn/20210407162606423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1134"></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>mysql-unknown-option-in-kubernetes错误</title><link>http://www.cnblogs.com/heian99/archive/2021/04/07/14634946.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 07 Apr 2021 07:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/07/14634946.html</guid><description><![CDATA[
                    <h2><strong>错误问题</strong></h2> 
<p><strong>原因：把MySQL的用户密码配置成secrets，然后挂载mysql，mysql会一直报错，无法完成初始</strong></p> 
<pre><code class="language-bash">Version: '5.7.33'  socket: '/var/run/mysqld/mysqld.sock'  port: 0  MySQL Community Server (GPL)
2021-04-07 15:06:32+08:00 [Note] [Entrypoint]: Temporary server started.
Warning: Unable to load '/usr/share/zoneinfo/iso3166.tab' as time zone. Skipping it.
Warning: Unable to load '/usr/share/zoneinfo/leap-seconds.list' as time zone. Skipping it.
2021-04-07T07:06:58.526144Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 24159ms. The settings might not be optimal. (flushed=200 and evicted=0, during the time.)
Warning: Unable to load '/usr/share/zoneinfo/zone.tab' as time zone. Skipping it.
Warning: Unable to load '/usr/share/zoneinfo/zone1970.tab' as time zone. Skipping it.
2021-04-07 15:06:58+08:00 [Note] [Entrypoint]: Creating database wordpress
mysql: [ERROR] unknown option '--"'</code></pre> 
<p><img alt="" height="392" src="https://img-blog.csdnimg.cn/20210407151922867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h2>解决问题</h2> 
<p style="margin-left:0px;"><span style="color:#242729;">问题是我使用该<code>echo 'secret' | base64</code>命令创建了我的机密，而echo命令自动插入了结尾的换行符。</span></p> 
<p style="margin-left:0px;"><span style="color:#242729;">使用<code>echo -n 'secret'&nbsp;| base64</code>代替。✔️</span></p> 
<p style="margin-left:0px;"><span style="color:#242729;">因此我没有注意到日志输出中有换行符。希望这可以帮助一些也使用echo命令对base64进行编码的人。</span></p> 
<p style="margin-left:0px;"><img alt="" height="423" src="https://img-blog.csdnimg.cn/20210407152321646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="763"></p> 
<p><img alt="" height="311" src="https://img-blog.csdnimg.cn/20210407152651461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="843"></p> 
<p>&nbsp;</p> 
<p>参考文章：&nbsp;<a href="https://stackoverflow.com/questions/62985541/mysql-unknown-option-in-kubernetes#">https://stackoverflow.com/questions/62985541/mysql-unknown-option-in-kubernetes#</a></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes实战模拟五（wordpress的HPA自动扩缩容）</title><link>http://www.cnblogs.com/heian99/archive/2021/04/07/14634947.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 07 Apr 2021 03:17:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/07/14634947.html</guid><description><![CDATA[
                    <h1><a href="https://blog.csdn.net/heian_99/article/details/115422455">Kubernetes实战模拟一（wordpress基础版）</a></h1> 
<h1 id="articleContentId"><a name="t1"></a><a href="https://blog.csdn.net/heian_99/article/details/115422781">Kubernetes实战模拟二（wordpress高可用）</a></h1> 
<h1><a name="t2"></a><a href="https://blog.csdn.net/heian_99/article/details/115433372">Kubernetes实战模拟三（wordpress健康检查和服务质量QoS）</a></h1> 
<h1><a name="t3"></a><a href="https://blog.csdn.net/heian_99/article/details/115468779">Kubernetes实战模拟四（wordpress升级更新）</a></h1> 
<p>源码地址：<a href="https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example">https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example</a></p> 
<p><strong>Kubernetes实战模拟四，已经构建wordpress的更新升级策略，确保后期升级时，系统能够稳定的提供业务，不被升级带来影响</strong></p> 
<p>&nbsp;</p> 
<h1><a name="t4"></a>版本5</h1> 
<p><strong>思路：类似wordpress是静态服务，当数据访问过大时，内存和cpu都会上升，这时，我们可以通过提高pod的数量，来分解压力。我们有不可能实时监控数据，手动扩缩容、所有我们采用HPA的自动扩缩容来实现动态控制。</strong></p> 
<p>&nbsp;</p> 
<p>HPA是kubernetes里面pod弹性伸缩的实现,它能根据设置的监控阀值进行pod的弹性扩缩容，目前默认HPA只能支持cpu和内存的阀值检测扩缩容，但也可以通过custom metric api 调用prometheus实现自定义metric 来更加灵活的监控指标实现弹性伸缩。但hpa不能用于伸缩一些无法进行缩放的控制器如DaemonSet。这里我们用的是resource metric api.</p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20190828094044124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzNTk4MDM3,size_16,color_FFFFFF,t_70"></p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">apiVersion: autoscaling/v2beta2
kind: HorizontalPodAutoscaler
metadata:
  name: php-apache
  namespace: default
spec:
  # HPA的伸缩对象描述，HPA会动态修改该对象的pod数量
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: php-apache
  # HPA的最小pod数量和最大pod数量
  minReplicas: 1
  maxReplicas: 10
  # 监控的指标数组，支持多种类型的指标共存
  metrics:
  # Object类型的指标
  - type: Object
    object:
      metric:
        # 指标名称
        name: requests-per-second
      # 监控指标的对象描述，指标数据来源于该对象
      describedObject:
        apiVersion: networking.k8s.io/v1beta1
        kind: Ingress
        name: main-route
      # Value类型的目标值，Object类型的指标只支持Value和AverageValue类型的目标值
      target:
        type: Value
        value: 10k
  # Resource类型的指标
  - type: Resource
    resource:
      name: cpu
      # Utilization类型的目标值，Resource类型的指标只支持Utilization和AverageValue类型的目标值
      target:
        type: Utilization
        averageUtilization: 50
  # Pods类型的指标
  - type: Pods
    pods:
      metric:
        name: packets-per-second
      # AverageValue类型的目标值，Pods指标类型下只支持AverageValue类型的目标值
      target:
        type: AverageValue
        averageValue: 1k
  # External类型的指标
  - type: External
    external:
      metric:
        name: queue_messages_ready
        # 该字段与第三方的指标标签相关联，（此处官方文档有问题，正确的写法如下）
        selector:
          matchLabels:
            env: "stage"
            app: "myapp"
      # External指标类型下只支持Value和AverageValue类型的目标值
      target:
        type: AverageValue
        averageValue: 30</code></pre> 
<blockquote> 
 <ul><li><code>autoscaling/v1</code>版本将metrics字段放在了annotation中进行处理。<br> target共有3种类型：Utilization、Value、AverageValue。Utilization表示平均使用率；Value表示裸值；AverageValue表示平均值。<br> metrics中的type字段有四种类型的值：Object、Pods、Resource、External。<br> Resource指的是当前伸缩对象下的pod的cpu和memory指标，只支持Utilization和AverageValue类型的目标值。<br> Object指的是指定k8s内部对象的指标，数据需要第三方adapter提供，只支持Value和AverageValue类型的目标值。<br> Pods指的是伸缩对象（statefulSet、replicaController、replicaSet）底下的Pods的指标，数据需要第三方的adapter提供，并且只允许AverageValue类型的目标值。<br> External指的是k8s外部的指标，数据同样需要第三方的adapter提供，只支持Value和AverageValue类型的目标值。</li><li><strong>HPA动态伸缩的原理</strong><br> HPA在k8s中也由一个controller控制，controller会间隔循环HPA，检查每个HPA中监控的指标是否触发伸缩条件，默认的间隔时间为15s。一旦触发伸缩条件，controller会向k8s发送请求，修改伸缩对象（statefulSet、replicaController、replicaSet）子对象scale中控制pod数量的字段。k8s响应请求，修改scale结构体，然后会刷新一次伸缩对象的pod数量。伸缩对象被修改后，自然会通过<code>list/watch</code>机制增加或减少pod数量，达到动态伸缩的目的。</li><li><strong>HPA伸缩过程叙述</strong><br> HPA的伸缩主要流程如下：</li></ul>
 <ol><li>判断当前pod数量是否在HPA设定的pod数量区间中，如果不在，过小返回最小值，过大返回最大值，结束伸缩。</li><li>判断指标的类型，并向api server发送对应的请求，拿到设定的监控指标。一般来说指标会根据预先设定的指标从以下三个<code>aggregated APIs</code>中获取：<code>metrics.k8s.io</code>、<code>custom.metrics.k8s.io</code>、&nbsp;<code>external.metrics.k8s.io</code>。其中<code>metrics.k8s.io</code>一般由k8s自带的metrics-server来提供，主要是cpu，memory使用率指标，另外两种需要第三方的adapter来提供。<code>custom.metrics.k8s.io</code>提供自定义指标数据，一般跟k8s集群有关，比如跟特定的pod相关。<code>external.metrics.k8s.io</code>同样提供自定义指标数据，但一般跟k8s集群无关。许多知名的第三方监控平台提供了adapter实现了上述api（如prometheus），可以将监控和adapter一同部署在k8s集群中提供服务，甚至能够替换原来的metrics-server来提供上述三类api指标，达到深度定制监控数据的目的。</li><li>根据获得的指标，应用相应的算法算出一个伸缩系数，并乘以目前pod数量获得期望pod数量。系数是指标的期望值与目前值的比值，如果大于1表示扩容，小于1表示缩容。指标数值有平均值（AverageValue）、平均使用率（Utilization）、裸值（Value）三种类型，每种类型的数值都有对应的算法。以下几点值得注意：如果系数有小数点，统一进一；系数如果未达到某个容忍值，HPA认为变化太小，会忽略这次变化，容忍值默认为0.1。<br> HPA扩容算法是一个非常保守的算法。如果出现获取不到指标的情况，扩容时算最小值，缩容时算最大值；如果需要计算平均值，出现pod没准备好的情况，平均数的分母不计入该pod。<br> 一个HPA支持多个指标的监控，HPA会循环获取所有的指标，并计算期望的pod数量，并从期望结果中获得最大的pod数量作为最终的伸缩的pod数量。一个伸缩对象在k8s中允许对应多个HPA，但是只是k8s不会报错而已，事实上HPA彼此不知道自己监控的是同一个伸缩对象，在这个伸缩对象中的pod会被多个HPA无意义地来回修改pod数量，给系统增加消耗，如果想要指定多个监控指标，可以如上述所说，在一个HPA中添加多个监控指标。</li><li>检查最终的pod数量是否在HPA设定的pod数量范围的区间，如果超过最大值或不足最小值都会修改为最大值或最小值。然后向k8s发出请求，修改伸缩对象的子对象scale的pod数量，结束一个HPA的检查，获取下一个HPA，完成一个伸缩流程。</li></ol>
</blockquote> 
<p>参照博客:<a href="https://www.cnblogs.com/yuhaohao/p/14109787.html">https://www.cnblogs.com/yuhaohao/p/14109787.html</a></p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="https://zhuanlan.zhihu.com/p/89453704">https://zhuanlan.zhihu.com/p/89453704</a></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<h1 id="hpa">HPA</h1> 
<p>现在应用是固定的3个副本，但是往往在生产环境流量是不可控的，很有可能一次活动就会有大量的流量，3个副本很有可能抗不住大量的用户请求，这个时候我们就希望能够自动对 Pod 进行伸缩，直接使用前面我们学习的 HPA 这个资源对象就可以满足我们的需求了。</p> 
<p>直接使用<code>kubectl autoscale</code>命令来创建一个&nbsp;<code>HPA</code>&nbsp;对象</p> 
<pre><code class="language-bash">[root@k8s-master1 ~]# kubectl autoscale deployment wordpress --namespace kube-example --cpu-percent=60 --min=3 --max=6   # cpu超过60%会扩容副本
horizontalpodautoscaler.autoscaling/wordpress autoscaled
[root@k8s-master1 ~]# kubectl get hpa -n kube-example 
NAME        REFERENCE              TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
wordpress   Deployment/wordpress   1%/60%    3         6         4          20s</code></pre> 
<p>hpa.yaml</p> 
<pre><code class="language-bash">apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: wordpress
  namespace: kube-example
spec:
  maxReplicas: 6
  minReplicas: 3
  scaleTargetRef:  # 目标作用对象
    apiVersion: apps/v1
    kind: Deployment
    name: wordpress
  targetCPUUtilizationPercentage: 60  #该使用率基于Pod设置的CPU Request值进行计算</code></pre> 
<p><strong>scaleTargetRef</strong>：目标作用对象，可以是Deployment、ReplicationController或ReplicaSet。<br><strong>targetCPUUtilizationPercentage</strong>：期望每个Pod的CPU使用率都为50%，该使用率基于Pod设置的CPU Request值进行计算，例如该值为200m，那么系统将维持Pod的实际CPU使用值为100m。<br><strong>minReplicas</strong>和<strong>maxReplicas：Pod</strong>副本数量的最小值和最大值，系统将在这个范围内进行自动扩缩容操作， 并维持每个Pod的CPU使用率为50%。<br> 为了使用autoscaling/v1版本的HorizontalPodAutoscaler，需要预先安装Heapster组件或Metrics Server，用于采集Pod的CPU使用率。</p> 
<p>&nbsp;</p> 
<p>此命令创建了一个关联资源 wordpress 的 HPA，最小的 Pod 副本数为3，最大为6。HPA 会根据设定的 cpu 使用率（60%）动态的增加或者减少 Pod 数量。同样，使用上面的 Fortio 工具来进行压测一次，看下能否进行自动的扩缩容：</p> 
<h1>测试</h1> 
<pre><code> fortio load -a -c 8 -qps 1000 -t 60s "http://wordpress.heian.com/"</code></pre> 
<p>在压测的过程中我们可以看到 HPA 的状态变化以及 Pod 数量也变成了6个：</p> 
<p><img alt="" height="728" src="https://img-blog.csdnimg.cn/20210407102326886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1183"></p> 
<p>当压测停止以后正常5分钟后就会自动进行缩容，变成最小的3个 Pod 副本。&nbsp;</p> 
<p><img alt="" height="169" src="https://img-blog.csdnimg.cn/20210407110956943.png" width="656"></p> 
<h1>问题</h1> 
<p>（1）数据持久化</p> 
<p>（2）mysql账号密码注入等</p>
                ]]></description></item><item><title>Kubernetes实战模拟四（wordpress升级更新）</title><link>http://www.cnblogs.com/heian99/archive/2021/04/06/14624033.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 06 Apr 2021 13:35:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/06/14624033.html</guid><description><![CDATA[
                    <h1><a href="https://blog.csdn.net/heian_99/article/details/115422455">Kubernetes实战模拟一（wordpress基础版）</a></h1> 
<h1 id="articleContentId"><a name="t1"></a><a href="https://blog.csdn.net/heian_99/article/details/115422781">Kubernetes实战模拟二（wordpress高可用）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115433372">Kubernetes实战模拟三（wordpress健康检查和服务质量QoS）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115468779">Kubernetes实战模拟四（wordpress升级更新）</a></h1> 
<p>源码地址：<a href="https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example">https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example</a></p> 
<p><strong>Kubernetes实战模拟三，已经构建wordpress的健康检查和服务质量，对后期的稳定运行有一定的帮助</strong></p> 
<p>（1）startupProbe，首次启动探测，如果没有成功，不会运行下面的检测。配置有restartPolicy：Always 会自动的重启</p> 
<p>（2）健康检查，采取readinessProbe方式，如果检查失败，kubernetes会把Pod从service endpoints中剔除，不在提供流量，错误现场保留，方便排查问题</p> 
<p>（3）fortio 压测，模拟生产环境，确定resources的数值。采用Guaranteed(有保证的)，防止宿主机资源不够被优先驱逐</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<h1>版本4</h1> 
<p><strong><span style="color:#f33b45;">思路</span>：类似wordpress是静态服务，后期可能有版本的变更，我们都需要更新和升级pod，我们接下来优化升级更新操作</strong></p> 
<p>&nbsp;</p> 
<p>Kubernetes官方推荐使用Deployment来取代Rep</p> 
<p>lication Controller(rc) ，两者间主要相同点包括确保处在服务状态的Pod数量(replicas)能满足先前所设定的值以及支援滚动升级(Rolling update)，前者额外支持回滚(Roll back)的机制，因此接下来会介绍如何利用Deployment来进行滚动升级。</p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/img_convert/9d8e83fe391252ab804a91aea75dda15.png"></p> 
<p><strong>图中可以看到一个Deployment掌管一或多个Replica Set ，而一个Replica Set掌管一或多个Pod&nbsp;</strong></p> 
<h1>版本升级</h1> 
<p>&nbsp;</p> 
<pre><code class="language-bash">  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 2
      maxUnavailable: 2
  minReadySeconds: 5
  revisionHistoryLimit: 10  # 最多保留10个升级副本，便于回滚</code></pre> 
<p>&nbsp;</p> 
<blockquote> 
 <p>minReadySeconds:<br> &nbsp; &nbsp; Kubernetes在等待设置的时间后才进行升级&nbsp; &nbsp; (容器内应用的启动时间, pod变为run状态, 会在minReadySeconds后继续更新下一个pod.)<br> &nbsp; &nbsp; 如果没有设置该值，Kubernetes会假设该容器启动起来后就提供服务了<br> &nbsp; &nbsp; 如果没有设置该值，在某些极端情况下可能会造成服务不正常运行<br> maxSurge:<br> &nbsp; &nbsp; 升级过程中最多可以比原先设置多出的POD数量<br> &nbsp; &nbsp; 例如：maxSurage=1，replicas=5,则表示Kubernetes会先启动1一个新的Pod后才删掉一个旧的POD，整个升级过程中最多会有5+1个POD。<br> maxUnavaible:<br> &nbsp; &nbsp; 升级过程中最多有多少个POD处于无法提供服务的状态<br> &nbsp; &nbsp; 当maxSurge不为0时，该值也不能为0<br> &nbsp; &nbsp; 例如：maxUnavaible=1，则表示Kubernetes整个升级过程中最多会有1个POD处于无法服务的状态。</p> 
</blockquote> 
<p>Deployment 控制器默认的就是滚动更新的更新策略，该策略可以在任何时间点更新应用的时候保证某些实例依然可以正常运行来防止应用 down 掉，当新部署的 Pod 启动并可以处理流量之后，才会去杀掉旧的 Pod。在使用过程中我们还可以指定 Kubernetes 在更新期间如何处理多个副本的切换方式，比如我们有一个3副本的应用，在更新的过程中是否应该立即创建这3个新的 Pod 并等待他们全部启动，或者杀掉一个之外的所有旧的 Pod，或者还是要一个一个的 Pod 进行替换？</p> 
<p>如果我们从旧版本到新版本进行滚动更新，只是简单的通过输出显示来判断哪些 Pod 是存活并准备就绪的，那么这个滚动更新的行为看上去肯定就是有效的，但是往往实际情况就是从旧版本到新版本的切换的过程并不总是十分顺畅的，应用程序很有可能会丢弃掉某些客户端的请求。比如我们在 Wordpress 应用中添加上如下的滚动更新策略，随便更改以下 Pod Template 中的参数，比如容器名更改为 blog：</p> 
<p>这里修改<strong>wordpress.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: kube-example
spec:
  selector:
    app: wordpress
    tier: frontend
  ports:
    - port: 80
      name: web
      targetPort: wdport
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: kube-example
  labels:
    app: wordpress
    tier: frontend

spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  replicas: 4 #多副本+pod的反亲合力可以实现pod的高可用

  strategy:   # 滚动更新的更新策略
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1   # 表示Kubernetes会先启动1一个新的Pod后才删掉一个旧的POD，整个升级过程中最多会有5+1个POD。
      maxUnavailable: 1  # 表示Kubernetes整个升级过程中最多会有1个POD处于无法服务的状态。
  minReadySeconds: 5  # 容器内应用的启动时间, pod变为run状态, 会在minReadySeconds后继续更新下一个pod.
  revisionHistoryLimit: 10  # 最多保留10个升级副本，便于回滚
  template:
    metadata:
      name: wordpress
      labels:
        app: wordpress
        tier: frontend

    spec:
      containers:
        - name: wordpress
          image: wordpress:5.3.2-apache
          ports:
            - containerPort: 80
              name: wdport
          env:
          - name: WORDPRESS_DB_HOST
            value: wordpress-mysql:3306
          - name: WORDPRESS_DB_USER
            value: wordpress
          - name: WORDPRESS_DB_PASSWORD
            value: wordpress
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 800m
              memory: 150Mi
            requests:
              cpu: 800m
              memory: 150Mi
          startupProbe:  #首次启动探测（如果没有成功，不会运行下面livenessProbe）
            httpGet:
              port: 80
            failureThreshold: 2    #探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。
            initialDelaySeconds: 20  # 容器启动后第一次执行探测是需要等待多少秒
            timeoutSeconds: 10 #  探测超时时间。默认1秒，最小1秒。
            periodSeconds: 5  # 执行探测的频率。默认是10秒，最小1秒。

          readinessProbe:  # （就绪检查） # 如果检查失败，kubernetes会把Pod从service endpoints中剔除
            tcpSocket:
              port: 80
            initialDelaySeconds: 10
            timeoutSeconds: 5
            failureThreshold: 5
            periodSeconds: 5
            successThreshold: 3
      affinity:
        podAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              podAffinityTerm:
                topologyKey: kubernetes.io/hostname
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - wordpress
      restartPolicy: Always

</code></pre> 
<h1>测试</h1> 
<p><strong>运行时压测</strong></p> 
<p><strong><img alt="" height="238" src="https://img-blog.csdnimg.cn/20210406205914358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="747"></strong></p> 
<p><strong>更新时压测（<span style="color:#f33b45;">显示500</span>）</strong></p> 
<p><img alt="" height="329" src="https://img-blog.csdnimg.cn/20210406205948988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="836"></p> 
<h1>问题分析</h1> 
<p>从上面的输出可以看出有部分请求处理失败了（502），要弄清楚失败的原因就需要弄明白当应用在滚动更新期间重新路由流量时，从旧的 Pod 实例到新的实例究竟会发生什么，首先让我们先看看 Kubernetes 是如何管理工作负载连接的。</p> 
<p id="_8"><strong>失败原因</strong></p> 
<p>我们这里通过 NodePort 去访问应用，实际上也是通过每个节点上面的&nbsp;<code>kube-proxy</code>&nbsp;通过更新 iptables 规则来实现的。</p> 
<p><img alt="kubernetes kube-proxy" height="518" src="https://img-blog.csdnimg.cn/img_convert/9939e1eef526cc5f2ff128faf20da95d.png" width="880"></p> 
<p>Kubernetes 会根据 Pods 的状态去更新 Endpoints 对象，这样就可以保证 Endpoints 中包含的都是准备好处理请求的 Pod。一旦新的 Pod 处于活动状态并准备就绪后，Kubernetes 就将会停止就的 Pod，从而将 Pod 的状态更新为&nbsp;<code>“Terminating”</code>，然后从 Endpoints 对象中移除，并且发送一个&nbsp;<code>SIGTERM</code>&nbsp;信号给 Pod 的主进程。<code>SIGTERM</code>&nbsp;信号就会让容器以正常的方式关闭，并且不接受任何新的连接。Pod 从 Endpoints 对象中被移除后，前面的负载均衡器就会将流量路由到其他（新的）Pod 中去。因为在负载均衡器注意到变更并更新其配置之前，终止信号就会去停用 Pod，而这个重新配置过程又是<strong>异步</strong>发生的，并不能保证正确的顺序，所以就可能导致很少的请求会被路由到已经终止的 Pod 上去了，也就出现了上面我们说的情况。</p> 
<h1>问题解决</h1> 
<p>那么如何增强我们的应用程序以实现真正的零宕机迁移更新呢？</p> 
<p>首先，要实现这个目标的先决条件是我们的容器要正确处理终止信号，在&nbsp;<code>SIGTERM</code>&nbsp;信号上实现优雅关闭。下一步需要添加&nbsp;<code>readiness</code>&nbsp;可读探针，来检查我们的应用程序是否已经准备好来处理流量了。为了解决 Pod 停止的时候不会阻塞并等到负载均衡器重新配置的问题，我们还需要使用&nbsp;<code>preStop</code>&nbsp;这个生命周期的钩子，在容器终止之前调用该钩子。</p> 
<p>生命周期钩子函数是<strong>同步</strong>的，所以必须在将最终停止信号发送到容器之前完成，在我们的示例中，我们使用该钩子简单的等待，然后&nbsp;<code>SIGTERM</code>&nbsp;信号将停止应用程序进程。同时，Kubernetes 将从 Endpoints 对象中删除该 Pod，所以该 Pod 将会从我们的负载均衡器中排除，基本上来说我们的生命周期钩子函数等待的时间可以确保在应用程序停止之前重新配置负载均衡器</p> 
<blockquote> 
 <p>lifecycle<br> 创建资源对象时，可以使用lifecycle来管理容 器在运行前和关闭前的一些动作。<br> lifecycle有两种回调函数:<br> PostStart: 容器创建成功后，运行前的任务，用于资源部署、环境准备等。<br> PreStop: 在容器被终止前的任务，用于优雅关闭应用程序、通知其他系统等等。</p> 
</blockquote> 
<p>我们这里使用&nbsp;<code>preStop</code>&nbsp;设置了一个 20s 的宽限期，Pod 在真正销毁前会先 sleep 等待 20s，这就相当于留了时间给 Endpoints 控制器和 kube-proxy 更新去 Endpoints 对象和转发规则，这段时间 Pod 虽然处于 Terminating 状态，即便在转发规则更新完全之前有请求被转发到这个 Terminating 的 Pod，依然可以被正常处理，因为它还在 sleep，没有被真正销毁。</p> 
<p>现在，当我们去查看滚动更新期间的 Pod 行为时，我们将看到正在终止的 Pod 处于&nbsp;<code>Terminating</code>&nbsp;状态，但是在等待时间结束之前不会关闭的，如果我们使用&nbsp;<code>Fortio</code>&nbsp;重新测试下，则会看到零失败请求的理想状态。</p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">          lifecycle:
            preStop:   # 在容器被终止前的任务，用于优雅关闭应用程序
              exec:
                command: ["/bin/bash", "-c", "sleep 20"]  #睡眠20s，优雅关闭</code></pre> 
<p><strong>完整wordpress.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: kube-example
spec:
  selector:
    app: wordpress
    tier: frontend
  ports:
    - port: 80
      name: web
      targetPort: wdport
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: kube-example
  labels:
    app: wordpress
    tier: frontend

spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  replicas: 4 #多副本+pod的反亲合力可以实现pod的高可用

  strategy:   # 滚动更新的更新策略
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1   # 表示Kubernetes会先启动1一个新的Pod后才删掉一个旧的POD，整个升级过程中最多会有5+1个POD。
      maxUnavailable: 1  # 表示Kubernetes整个升级过程中最多会有1个POD处于无法服务的状态。
  minReadySeconds: 5  # 容器内应用的启动时间, pod变为run状态, 会在minReadySeconds后继续更新下一个pod.
  revisionHistoryLimit: 10  # 最多保留10个升级副本，便于回滚
  template:
    metadata:
      name: wordpress
      labels:
        app: wordpress
        tier: frontend

    spec:
      containers:
        - name: blog
          image: wordpress:5.3.2-apache
          ports:
            - containerPort: 80
              name: wdport
          env:
          - name: WORDPRESS_DB_HOST
            value: wordpress-mysql:3306
          - name: WORDPRESS_DB_USER
            value: wordpress
          - name: WORDPRESS_DB_PASSWORD
            value: wordpress
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 800m
              memory: 150Mi
            requests:
              cpu: 800m
              memory: 150Mi
          startupProbe:  #首次启动探测（如果没有成功，不会运行下面livenessProbe）
            httpGet:
              port: 80
            failureThreshold: 2    #探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。
            initialDelaySeconds: 20  # 容器启动后第一次执行探测是需要等待多少秒
            timeoutSeconds: 10 #  探测超时时间。默认1秒，最小1秒。
            periodSeconds: 5  # 执行探测的频率。默认是10秒，最小1秒。

          readinessProbe:  # （就绪检查） # 如果检查失败，kubernetes会把Pod从service endpoints中剔除
            tcpSocket:
              port: 80
            initialDelaySeconds: 10
            timeoutSeconds: 5
            failureThreshold: 5
            periodSeconds: 5
            successThreshold: 3
          lifecycle:
            preStop:   # 在容器被终止前的任务，用于优雅关闭应用程序
              exec:
                command: ["/bin/bash", "-c", "sleep 20"]  #睡眠20s，优雅关闭
      affinity:
        podAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              podAffinityTerm:
                topologyKey: kubernetes.io/hostname
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - wordpress
      restartPolicy: Always

</code></pre> 
<p><strong>再次测试</strong></p> 
<p><img alt="" height="357" src="https://img-blog.csdnimg.cn/20210406213024221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="887"></p> 
<p>&nbsp;</p> 
<h1>版本回滚</h1> 
<p>博客参照：<a href="https://www.ipcpu.com/2017/09/kubernetes-rolling-update/">https://www.ipcpu.com/2017/09/kubernetes-rolling-update/</a></p> 
<p>查询升级状态、暂停和恢复</p> 
<pre><code>#@查询升级状况
$ kubectl rollout status deployment &lt;deployment&gt;
#@暂停滚动升级
$ kubectl rollout pause deployment &lt;deployment&gt;
#@恢复滚动升级
$ kubectl rollout resume deployment &lt;deployment&gt;</code></pre> 
<p>操作都加了–record 的参数，這参数主要是告知 Kubernetes 记录此次下达的指令，所以我们可以通过以下命令来查看</p> 
<pre><code class="language-bash">[root@k8s-master1 v4]# kubectl rollout history deployment -n kube-example wordpress
deployment.apps/wordpress 
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
2         &lt;none&gt;
3         &lt;none&gt;
4         &lt;none&gt;
5         &lt;none&gt;
6         &lt;none&gt;
</code></pre> 
<p>这些个记录能保存多少个呢？默认是全部保存的。可以通过设置.spec.revisionHistoryLimit 来决定记录的个数，一般生产环境记录10个左右就差不多了。要不然可能会被刷屏。</p> 
<pre><code class="language-bash">  minReadySeconds: 5
  revisionHistoryLimit: 10</code></pre> 
<p>可以通过以下命令，来回滚到上一个版本或者特定版本</p> 
<pre><code class="language-bash"># to previous revision
$ kubectl rollout undo deployment &lt;deployment&gt;
# to specific revision
$ kubectl rollout undo deployment &lt;deployment&gt; --to-revision=&lt;revision&gt;
# exmaple
$ kubectl rollout undo deployment buniess --to-revision=3</code></pre> 
<h1>问题</h1> 
<p>（1）自动扩缩容</p> 
<p>（2）数据持久化</p> 
<p>（3）mysql账号密码注入等</p> 
<p>期待下个版本更加优化完美</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes实战模拟三（wordpress健康检查和服务质量QoS）</title><link>http://www.cnblogs.com/heian99/archive/2021/04/05/14624034.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 04 Apr 2021 17:06:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/05/14624034.html</guid><description><![CDATA[
                    <h1>&nbsp;</h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115422455">Kubernetes实战模拟一（wordpress基础版）</a></h1> 
<h1 id="articleContentId"><a name="t1"></a><a href="https://blog.csdn.net/heian_99/article/details/115422781">Kubernetes实战模拟二（wordpress高可用）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115433372">Kubernetes实战模拟三（wordpress健康检查和服务质量QoS）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115468779">Kubernetes实战模拟四（wordpress升级更新）</a></h1> 
<p>源码地址：<a href="https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example">https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example</a></p> 
<p>Kubernetes实战模拟二，已经优化架构，已经采取分离，可以实现高可用，并优化软策略，防止单点故障</p> 
<p>接下来，慢慢实现健康检查和服务质量</p> 
<h1>版本3</h1> 
<p>思路：分别对2个pod的进行端口检查，判断pod是否正常和流量提供，测试性能，设置资源限制</p> 
<p>健康检查：主要检查pod提供正常服务</p> 
<p>资源限制：后期可以根据这个设置HPA。防止宿主资源不足，被驱逐</p> 
<p><strong>1、Pod的健康检查，也叫做探针，探针的种类有两种。</strong></p> 
<p>1）、livenessProbe，健康状态检查，周期性检查服务是否存活，检查结果失败，将重启容器。<br> 2）、readinessProbe，可用性检查，周期性检查服务是否可用，不可用将从service的endpoints中移除。</p> 
<p><strong>livenessProbe (存活检查） # 如果检查失败，将杀死容器，根据Pod的restartPolicy来操作</strong></p> 
<p><strong>readinessProbe（就绪检查） # 如果检查失败，kubernetes会把Pod从service endpoints中剔除</strong></p> 
<p>&nbsp;</p> 
<p><strong>2、探针的检测方法。</strong></p> 
<p>1）、exec，执行一段命令。<br> 2）、httpGet，检测某个http请求的返回状态码。<br> 3）、tcpSocket，测试某个端口是否能够连接。</p> 
<p>&nbsp;</p> 
<p><strong>3、startupProbe检测</strong></p> 
<p>判断容器内的应用程序是否已启动。如果提供了启动探测，则禁用所有其他探测，直到它成功为止。如果启动探测失败，kubelet将杀死容器，容器将服从其重启策略。如果容器没有提供启动探测，则默认状态为成功。</p> 
<p><strong>注意：不要将startupProbe和readinessProbe混淆。</strong></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<blockquote> 
 <h2>配置Probe</h2> 
 <p>Probe中有很多精确和详细的配置，通过它们你能准确的控制liveness和readiness检查：</p> 
 <ul><li> <p><code>initialDelaySeconds</code>：容器启动后第一次执行探测是需要等待多少秒。</p> </li><li> <p><code>periodSeconds</code>：执行探测的频率。默认是10秒，最小1秒。</p> </li><li> <p><code>timeoutSeconds</code>：探测超时时间。默认1秒，最小1秒。</p> </li><li> <p><code>successThreshold</code>：探测失败后，最少连续探测成功多少次才被认定为成功。默认是1。对于liveness必须是1。最小值是1。</p> </li><li> <p><code>failureThreshold</code>：探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。</p> </li></ul>
 <p>HTTP probe中可以给&nbsp;<code>httpGet</code>设置其他配置项：</p> 
 <ul><li> <p><code>host</code>：连接的主机名，默认连接到pod的IP。你可能想在http header中设置”Host”而不是使用IP。</p> </li><li> <p><code>scheme</code>：连接使用的schema，默认HTTP。</p> </li><li> <p><code>path</code>: 访问的HTTP server的path。</p> </li><li> <p><code>httpHeaders</code>：自定义请求的header。HTTP运行重复的header。</p> </li><li> <p><code>port</code>：访问的容器的端口名字或者端口号。端口号必须介于1和65525之间。</p> </li></ul>
</blockquote> 
<p>&nbsp;</p> 
<h1>命名空间：(namespace.yaml)</h1> 
<pre><code class="language-bash">apiVersion: v1
kind: Namespace
metadata:
  name: kube-example</code></pre> 
<h1><a name="t5"></a></h1> 
<h1>mysql资源清单</h1> 
<p><strong>mysql.yaml</strong></p> 
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  namespace: kube-example
  labels:
    app: wordpress
spec:
  selector:
    app: wordpress
    tier: mysql
  ports:
    - port: 3306
      targetPort: dbport

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-mysql
  namespace: kube-example
  labels:
    app: wordpress
    tier: mysql
spec:
  replicas: 1
  template:
    metadata:
      name: wordpress-mysql
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          args:
          - --default_authentication_plugin=mysql_native_password
          - --character-set-server=utf8mb4
          - --collation-server=utf8mb4_unicode_ci
          ports:
            - containerPort: 3306
              name: dbport
          env:
          - name: MYSQL_ROOT_PASSWORD
            value: rootPassW0rd
          - name: MYSQL_DATABASE
            value: wordpress
          - name: MYSQL_USER
            value: wordpress
          - name: MYSQL_PASSWORD
            value: wordpress
          imagePullPolicy: IfNotPresent
          startupProbe:  #首次启动探测（如果没有成功，不会运行下面livenessProbe）
            tcpSocket:
              port: 3306
            failureThreshold: 2    #探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。
            initialDelaySeconds: 20  # 容器启动后第一次执行探测是需要等待多少秒
            timeoutSeconds: 10  # 探测超时时间。默认1秒，最小1秒。
            periodSeconds: 10   # 执行探测的频率。默认是10秒，最小1秒。

         
      restartPolicy: Always
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
</code></pre> 
<p>因为这个是模拟环境，现在数据没有持续化，如果加上下面的检测，如果pod的有问题，直接重启，数据都会丢失，这个后期数据持久化，我们可以加上面</p> 
<pre><code class="language-bash"> livenessProbe:
            tcpSocket:
              port: 3306  # 访问的容器的端口名字或者端口号
            initialDelaySeconds: 10
            timeoutSeconds: 5
            failureThreshold: 5
            periodSeconds: 5
            successThreshold: 3  #探测失败后，最少连续探测成功多少次才被认定为成功。默认是1。对于liveness必须是1。最小值是1。</code></pre> 
<h1>Wordpress 清单</h1> 
<p><strong>wordpress.yaml</strong></p> 
<p>我们的应用现在还有一个非常重要的功能没有提供，那就是健康检查，我们知道健康检查是提高应用健壮性非常重要的手段，当我们检测到应用不健康的时候我们希望可以自动重启容器，当应用还没有准备好的时候我们也希望暂时不要对外提供服务，所以我们需要添加我们前面经常提到的&nbsp;<code>liveness probe</code>&nbsp;和&nbsp;<code>rediness probe</code>&nbsp;两个健康检测探针，检查探针的方式有很多，我们这里当然可以认为如果容器的 80 端口可以成功访问那么就是健康的，对于一般的应用提供一个健康检查的 URL 会更好，这里我们添加一个如下所示的可读性探针，为什么不添加存活性探针呢？这里其实是考虑到线上错误排查的一个问题，如果当我们的应用出现了问题，然后就自动重启去掩盖错误的话，可能这个错误就会被永远忽略掉了，所以其实这是一个折衷的做法，不使用存活性探针，而是结合监控报警，保留错误现场，方便错误排查，但是可读写探针是一定需要添加的：</p> 
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: kube-example
spec:
  selector:
    app: wordpress
    tier: frontend
  ports:
    - port: 80
      name: web
      targetPort: wdport
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: kube-example
  labels:
    app: wordpress
    tier: frontend
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  replicas: 4 #多副本+pod的反亲合力可以实现pod的高可用
  template:
    metadata:
      name: wordpress
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
        - name: wordpress
          image: wordpress:5.3.2-apache
          ports:
            - containerPort: 80
              name: wdport
          env:
          - name: WORDPRESS_DB_HOST
            value: wordpress-mysql:3306
          - name: WORDPRESS_DB_USER
            value: wordpress
          - name: WORDPRESS_DB_PASSWORD
            value: wordpress
          imagePullPolicy: IfNotPresent

          startupProbe:  #首次启动探测（如果没有成功，不会运行下面livenessProbe）
            httpGet:
              port: 80
            failureThreshold: 2    #探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。
            initialDelaySeconds: 10  # 容器启动后第一次执行探测是需要等待多少秒
            timeoutSeconds: 10 #  探测超时时间。默认1秒，最小1秒。
            periodSeconds: 5  # 执行探测的频率。默认是10秒，最小1秒。

          readinessProbe:  # （就绪检查） # 如果检查失败，kubernetes会把Pod从service endpoints中剔除
            httpGet:
              port: 80
            initialDelaySeconds: 10
            timeoutSeconds: 5
            failureThreshold: 5
            periodSeconds: 5
            successThreshold: 3
      affinity:
        podAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              podAffinityTerm:
                topologyKey: kubernetes.io/hostname
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - wordpress
      restartPolicy: Always

</code></pre> 
<p>上面为什么不用livenessProbe检测，首先如果livenessProbe检测失败，会直接重启pod的，会毁坏错误的信息，不方便我们排查问题。我们有多个副本，如果一个出问题，其余会正常工作</p> 
<pre><code class="language-bash">          livenessProbe:  #(存活检查） # 如果检查失败，将杀死容器，根据Pod的restartPolicy来操作
            httpGet:
              port: 80
            initialDelaySeconds: 15
            timeoutSeconds: 5
            periodSeconds: 5
            failureThreshold: 5</code></pre> 
<h1>PDB策略</h1> 
<p><strong>pdb.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: wordpress-pdb
  namespace: kube-example
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: wordpress
      tier: frontend</code></pre> 
<p>&nbsp;</p> 
<h1 id="qos">服务质量 QoS</h1> 
<p><code>QoS</code>&nbsp;是&nbsp;<code>Quality of Service</code>&nbsp;的缩写，即服务质量。为了实现资源被有效调度和分配的同时提高资源利用率，Kubernetes 针对不同服务质量的预期，通过&nbsp;<code>QoS</code>&nbsp;来对 Pod 进行服务质量管理。对于一个 Pod 来说，服务质量体现在两个具体的指标：CPU 和内存。当节点上内存资源紧张时，Kubernetes 会根据预先设置的不同&nbsp;<code>QoS</code>&nbsp;类别进行相应处理。</p> 
<p><code>QoS</code>&nbsp;主要分为&nbsp;<code>Guaranteed</code>、<code>Burstable</code>&nbsp;和&nbsp;<code>Best-Effort</code>三类，优先级从高到低。我们先分别来介绍下这三种服务类型的定义。</p> 
<p><strong>Guaranteed(有保证的)</strong></p> 
<p>属于该级别的 Pod 有以下两种：</p> 
<ul><li>Pod 中的<strong>所有容器</strong>都且<strong>仅</strong>设置了 CPU 和内存的&nbsp;<strong>limits</strong></li><li>Pod 中的所有容器都设置了 CPU 和内存的 requests 和 limits ，且单个容器内的<code>requests==limits</code>（requests不等于0）</li></ul>
<p><strong>Burstable(不稳定的)</strong></p> 
<p>Pod 中只要有一个容器的 requests 和 limits 的设置不相同，那么该 Pod 的 QoS 即为 Burstable。</p> 
<p><strong>Best-Effort(尽最大努力)</strong></p> 
<p>如果 Pod 中所有容器的 resources 均未设置 requests 与 limits，该 Pod 的 QoS 即为 Best-Effort。</p> 
<h1>fortio 部署</h1> 
<pre><code>wget https://github.com/fortio/fortio/releases/download/v1.4.4/fortio-1.4.4-1.x86_64.rpm
rpm -ivh fortio-1.4.4-1.x86_64.rpm
nohup fortio server &amp;
tail -f nohup.out</code></pre> 
<p>开始测压</p> 
<p>命令行</p> 
<blockquote> 
 <p>fortio load -c 5 -n 20 -qps 0 http://www.baidu.com<br> #命令解释如下：<br> &nbsp;-c 表示并发数<br> &nbsp;-n 一共多少请求<br> &nbsp;-qps 每秒查询数，0 表示不限制</p> 
</blockquote> 
<p>Web控制台</p> 
<p>&nbsp; &nbsp;web 控制台方式就是提供给习惯使用 web 界面操作的同学一个途径来使用 Fortio。因为是基于 web &nbsp;方式，所以就需要首先启动一个 web server，这样客户端浏览器才可以访问到 web server 提供的操作界面进行负载压测。默认情况 fortio server 会启动 8080 端口，如下图所示：</p> 
<p>&nbsp; &nbsp;打开浏览器，输入 <a href="http://192.168.10.11:8080/fortio">http://IP:8080/fortio</a>，访问 Fortio server：</p> 
<p>根据实现生成环境访问人数和次数模拟</p> 
<p><img alt="" height="717" src="https://img-blog.csdnimg.cn/20210405005634842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="976"></p> 
<p>测试前</p> 
<p><img alt="" height="210" src="https://img-blog.csdnimg.cn/20210405005707289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="649"></p> 
<p>测试后</p> 
<p><img alt="" height="212" src="https://img-blog.csdnimg.cn/20210405005917148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="757"></p> 
<p><img alt="" height="652" src="https://img-blog.csdnimg.cn/2021040500585839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1044"></p> 
<h1>资源限制</h1> 
<p>采用<strong>Guaranteed(有保证的)，防止宿主机资源不够被优先驱逐</strong></p> 
<p><strong>wordpress</strong></p> 
<pre><code class="language-bash">          resources:
            limits:
              cpu: 800m
              memory: 150Mi
            requests:
              cpu: 800m
              memory: 150Mi</code></pre> 
<p><strong>mysql</strong></p> 
<pre><code class="language-bash">          resources:
            limits:
              cpu: 1000m
              memory: 400Mi
            requests:
              cpu: 1000m
              memory: 400Mi</code></pre> 
<p>此版本实现健康检查和服务质量QoS</p> 
<h1><a name="t7"></a>问题</h1> 
<p>（1）自动扩缩容</p> 
<p>（2）滚动更新策略</p> 
<p>（3）数据持久化</p> 
<p>（4）mysql账号密码注入等</p> 
<p>这些一些列问题，都会在后面的版本架构中优化</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes实战模拟二（wordpress高可用）</title><link>http://www.cnblogs.com/heian99/archive/2021/04/03/14624035.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 03 Apr 2021 15:51:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/03/14624035.html</guid><description><![CDATA[
                    <h1>&nbsp;</h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115422455">Kubernetes实战模拟一（wordpress基础版）</a></h1> 
<h1 id="articleContentId"><a name="t1"></a><a href="https://blog.csdn.net/heian_99/article/details/115422781">Kubernetes实战模拟二（wordpress高可用）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115433372">Kubernetes实战模拟三（wordpress健康检查和服务质量QoS）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115468779">Kubernetes实战模拟四（wordpress升级更新）</a></h1> 
<p>源码地址：<a href="https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example">https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example</a></p> 
<p>上一篇文件我们使用pod的构建两个容器，但是问题也是一大堆，根本不适合生产方面。</p> 
<p>所以我们慢慢解决上面的问题，优化架构。</p> 
<h1>版本2</h1> 
<p>思路：将 Pod 中的两个容器进行拆分，将 Wordpress 和 MySQL 分别部署</p> 
<p>Wordpress 用多个副本进行部署就可以实现应用的高可用了</p> 
<p>由于 MySQL 是有状态应用，一般来说需要用 StatefulSet 来进行管理，但是我们这里部署的 MySQL 并不是集群模式，而是单副本的，所以用 Deployment 也是没有问题的。如果生产环境的话，一般都是集群的，分别在宿主机上部署。</p> 
<p>&nbsp;</p> 
<h1>mysql资源清单</h1> 
<p><strong>mysql.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  namespace: kube-example
  labels:
    app: wordpress
spec:
  selector:
    app: wordpress
    tier: mysql
  ports:
    - port: 3306
      targetPort: dbport

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-mysql
  namespace: kube-example
  labels:
    app: wordpress
    tier: mysql
spec:
  replicas: 1
  template:
    metadata:
      name: wordpress-mysql
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          args:
          - --default_authentication_plugin=mysql_native_password
          - --character-set-server=utf8mb4
          - --collation-server=utf8mb4_unicode_ci
          ports:
            - containerPort: 3306
              name: dbport
          env:
          - name: MYSQL_ROOT_PASSWORD
            value: rootPassW0rd
          - name: MYSQL_DATABASE
            value: wordpress
          - name: MYSQL_USER
            value: wordpress
          - name: MYSQL_PASSWORD
            value: wordpress
          imagePullPolicy: IfNotPresent
      restartPolicy: Always
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
</code></pre> 
<p>这里给 MySQL 应用添加了一个 Service 对象，是因为 Wordpress 应用需要来连接数据库，之前在同一个 Pod 中用&nbsp;<code>localhost</code>&nbsp;即可，现在需要通过 Service 的 DNS 形式的域名进行连接。直接创建上面资源对象</p> 
<pre><code># kubectl apply -f mysql.yaml    
service/wordpress-mysql created
deployment.apps/wordpress-mysql created</code></pre> 
<h1>Wordpress 清单</h1> 
<p><strong>wordpress.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: kube-example
spec:
  selector:
    app: wordpress
    tier: frontend
  ports:
    - port: 80
      name: web
      targetPort: wdport
  type: NodePort

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: kube-example
  labels:
    app: wordpress
    tier: frontend
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  replicas: 4 
  template:
    metadata:
      name: wordpress
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
        - name: wordpress
          image: wordpress:5.3.2-apache
          ports:
            - containerPort: 80
              name: wdport
          env:
          - name: WORDPRESS_DB_HOST
            value: wordpress-mysql:3306
          - name: WORDPRESS_DB_USER
            value: wordpress
          - name: WORDPRESS_DB_PASSWORD
            value: wordpress
          imagePullPolicy: IfNotPresent
      restartPolicy: Always

</code></pre> 
<p>注意这里的环境变量&nbsp;<code>WORDPRESS_DB_HOST</code>&nbsp;的值将之前的&nbsp;<code>localhost</code>&nbsp;地址更改成了上面 MySQL 服务的 DNS 地址，完整的域名应该是&nbsp;<code>wordpress-mysql.kube-example.svc.cluster.local:3306</code>，由于这两个应该都处于同一个命名空间，所以直接简写成&nbsp;<code>wordpress-mysql:3306</code>&nbsp;也是可以的。</p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">[root@k8s-master1 v2]# kubectl apply -f wordpress.yaml 
service/wordpress created
deployment.apps/wordpress created
[root@k8s-master1 v2]# kubectl get pods -l app=wordpress -n kube-example
NAME                              READY   STATUS    RESTARTS   AGE
wordpress-ddb4ff6cf-g2xf8         1/1     Running   0          9s
wordpress-ddb4ff6cf-jjt5k         1/1     Running   0          9s
wordpress-ddb4ff6cf-zmbc4         1/1     Running   0          9s
wordpress-mysql-d9b4b8985-bqv2b   1/1     Running   0          32s
</code></pre> 
<h1>测试</h1> 
<p>可以看到都已经是&nbsp;<code>Running</code>&nbsp;状态了，然后我们需要怎么来验证呢？是不是我们能想到的就是去访问下我们的 Wordpress 服务就可以了，我们这里还是使用的一个 NodePort 类型的 Service 来暴露服务：</p> 
<pre><code class="language-bash">[root@k8s-master1 v2]# kubectl get svc,ep -n kube-example 
NAME                      TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
service/wordpress         NodePort    10.0.0.49    &lt;none&gt;        80:30455/TCP   92s
service/wordpress-mysql   ClusterIP   10.0.0.142   &lt;none&gt;        3306/TCP       115s

NAME                        ENDPOINTS                                       AGE
endpoints/wordpress         10.244.0.5:80,10.244.1.135:80,10.244.1.136:80   92s
endpoints/wordpress-mysql   10.244.1.134:3306                               115s
</code></pre> 
<p>可以看到 wordpress 服务产生了一个 30455的端口，现在我们就可以通过&nbsp;<code>http://&lt;任意节点的NodeIP&gt;:30012</code>&nbsp;访问我们的应用了，在浏览器中打开，如果看到 wordpress 跳转到了安装页面，证明我们的安装是正确的，如果没有出现预期的效果，那么就需要去查看下 Pod 的日志来排查问题了，根据页面提示，填上对应的信息，点击<code>“安装”</code>即可，最终安装成功后</p> 
<p><img alt="" height="856" src="https://img-blog.csdnimg.cn/20210403233421893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="874"></p> 
<h1 id="_4">避免单点故障</h1> 
<p>为什么会有单点故障的问题呢？</p> 
<p>我们不是部署了多个副本的 Wordpress 应用吗？</p> 
<p>当我们设置&nbsp;<code>replicas=1</code>&nbsp;的时候肯定会存在单点故障问题，如果大于 1 但是所有副本都调度到了同一个节点的是不是同样就会存在单点问题了</p> 
<p>这个节点挂了所有副本就都挂了，所以我们不仅需要设置多个副本数量，还需要让这些副本调度到不同的节点上，来打散避免单点故障</p> 
<p><img alt="" height="320" src="https://img-blog.csdnimg.cn/20210403233825187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="560"></p> 
<p>&nbsp;Pod 反亲和性来实现了，我们可以防止单点故障出现。</p> 
<p>但是要考虑要用<strong>弱策略</strong>还是<strong>硬策略</strong></p> 
<p><strong>我们首先弱的，如果硬策略，如果节点有问题，pod就不会被创建</strong></p> 
<p><img alt="" height="399" src="https://img-blog.csdnimg.cn/2021040323393294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="728"></p> 
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: kube-example
spec:
  selector:
    app: wordpress
    tier: frontend
  ports:
    - port: 80
      name: web
      targetPort: wdport
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: kube-example
  labels:
    app: wordpress
    tier: frontend
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  replicas: 4 #多副本+pod的反亲合力可以实现pod的高可用
  template:
    metadata:
      name: wordpress
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
        - name: wordpress
          image: wordpress:5.3.2-apache
          ports:
            - containerPort: 80
              name: wdport
          env:
          - name: WORDPRESS_DB_HOST
            value: wordpress-mysql:3306
          - name: WORDPRESS_DB_USER
            value: wordpress
          - name: WORDPRESS_DB_PASSWORD
            value: wordpress
          imagePullPolicy: IfNotPresent
      affinity: #pod的反亲和力
        podAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              podAffinityTerm:
                topologyKey: kubernetes.io/hostname
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - wordpress
      restartPolicy: Always

</code></pre> 
<h1>PDB策略</h1> 
<p><strong>PDB能够限制同时中断的pod的数量,以保证集群的高可用性</strong></p> 
<p>有些时候线上的某些节点需要做一些维护操作，比如要升级内核，这个时候我们就需要将要维护的节点进行驱逐操作，驱逐节点首先是将节点设置为不可调度，这样可以避免有新的 Pod 调度上来，然后将该节点上的 Pod 全部删除，ReplicaSet 控制器检测到 Pod 数量减少了就会重新创建一个新的 Pod，调度到其他节点上面的，这个过程是先删除，再创建，并非是滚动更新，因此更新过程中，如果一个服务的所有副本都在被驱逐的节点上，则可能导致该服务不可用。</p> 
<p>如果服务本身存在单点故障，所有副本都在同一个节点，驱逐的时候肯定就会造成服务不可用了，这种情况我们使用上面的反亲和性和多副本就可以解决这个问题。但是如果我们的服务本身就被打散在多个节点上，这些节点如果都被同时驱逐的话，那么这个服务的所有实例都会被同时删除，这个时候也会造成服务不可用了，这种情况下我们可以通过配置 PDB（PodDisruptionBudget）对象来避免所有副本同时被删除，比如我们可以设置在驱逐的时候 wordpress 应用最多只有一个副本不可用，其实就相当于逐个删除并在其它节点上重建</p> 
<p><strong>pdb.yaml</strong></p> 
<pre><code class="language-bash">apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: wordpress-pdb
  namespace: kube-example
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: wordpress
      tier: frontend</code></pre> 
<pre><code class="language-bash">[root@k8s-master1 v2]# kubectl apply -f pdb.yaml 
poddisruptionbudget.policy/wordpress-pdb created
[root@k8s-master1 v2]# kubectl get pdb -n kube-example 
NAME            MIN AVAILABLE   MAX UNAVAILABLE   ALLOWED DISRUPTIONS   AGE
wordpress-pdb   N/A             1                 1                     15s
</code></pre> 
<p>&nbsp;PDB 的更多详细信息可以查看官方文档：<a href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/">https://kubernetes.io/docs/tasks/run-application/configure-pdb/</a>。</p> 
<p>&nbsp;</p> 
<p>此版本实现高可用，但是还有一些问题</p> 
<h1>问题</h1> 
<p>（1）pod的健康检查，如果没有这些，pod额度重启策略都无法执行</p> 
<p>（2）内存，cpu等资源限制，服务质量Qos</p> 
<p>（3）数据持久化</p> 
<p>（4）mysql账号密码注入等</p> 
<p>这些一些列问题，都会在后面的版本架构中优化</p>
                ]]></description></item><item><title>Kubernetes实战模拟一（wordpress基础版）</title><link>http://www.cnblogs.com/heian99/archive/2021/04/03/14624036.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 03 Apr 2021 15:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/03/14624036.html</guid><description><![CDATA[
                    <h1><a href="https://blog.csdn.net/heian_99/article/details/115422455">Kubernetes实战模拟一（wordpress基础版）</a></h1> 
<h1 id="articleContentId"><a name="t1"></a><a href="https://blog.csdn.net/heian_99/article/details/115422781">Kubernetes实战模拟二（wordpress高可用）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115433372">Kubernetes实战模拟三（wordpress健康检查和服务质量QoS）</a></h1> 
<h1><a href="https://blog.csdn.net/heian_99/article/details/115468779">Kubernetes实战模拟四（wordpress升级更新）</a></h1> 
<p>Kubernetes是现在比较流行的容器化软件。我们日常也比较使用的多，我们都是慢慢的从陌生到熟悉的进阶，只有不断的学习，才能有收获。</p> 
<p>Kubernetes专栏：<a href="https://blog.csdn.net/heian_99/category_9652886.html">https://blog.csdn.net/heian_99/category_9652886.html</a></p> 
<p>Kubernetes官网地址：<a href="https://kubernetes.io/">https://kubernetes.io/</a></p> 
<p>这个专栏，模拟Kubernetes的日常发布流程。</p> 
<p>源码地址：<a href="https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example">https://github.com/nangongchengfeng/Kubernetes/tree/main/wordpress-example</a></p> 
<p>里面包含多个版本，现在是演示v1版本。</p> 
<h1>环境</h1> 
<blockquote> 
 <p>Kubernetes：v1.18.3</p> 
 <p>docker：19.03.9</p> 
 <p>mysql：5.7</p> 
 <p>wordpress：5.3.2-apache</p> 
</blockquote> 
<h1>版本1</h1> 
<p>思路：由于wordpress和mysql需要进行交互。版本1就把wordpress和mysql集成到一个pod运行，测试访问效果</p> 
<h1>原理</h1> 
<h3>Wordpress&nbsp;</h3> 
<p>Wordpress 是一个基于 PHP 和 MySQL 的流行的开源内容管理系统，拥有丰富的插件和模板系统。一个能够解析 PHP 的程序和 MySQL 数据库。官方提供了镜像&nbsp;<a href="https://hub.docker.com/_/wordpress">https://hub.docker.com/_/wordpress</a></p> 
<p>可以通过一系列环境变量去指定 MySQL 数据库的配置，只需要将这些参数配置上直接运行即可。</p> 
<p>我们知道 Wordpress 应用本身会频繁的和 MySQL 数据库进行交互，这种情况下如果将二者用容器部署在同一个 Pod 下面是不是要高效很多</p> 
<p>因为一个 Pod 下面的所有容器是共享同一个 network namespace 的，下面我们就来部署我们的应用</p> 
<p>&nbsp;</p> 
<h1>命名空间：(namespace.yaml)</h1> 
<pre><code class="language-bash">apiVersion: v1
kind: Namespace
metadata:
  name: kube-example</code></pre> 
<h1>应用清单：（deployment.yaml）</h1> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: kube-example
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:5.3.2-apache
        ports:
        - containerPort: 80
          name: wdport
        env:
        - name: WORDPRESS_DB_HOST
          value: localhost:3306
        - name: WORDPRESS_DB_USER
          value: wordpress
        - name: WORDPRESS_DB_PASSWORD
          value: wordpress
      - name: mysql
        image: mysql:5.7
        imagePullPolicy: IfNotPresent
        args:  # 新版本镜像有更新，需要使用下面的认证插件环境变量配置才会生效
        - --default_authentication_plugin=mysql_native_password
        - --character-set-server=utf8mb4
        - --collation-server=utf8mb4_unicode_ci
        ports:
        - containerPort: 3306
          name: dbport
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: rootPassW0rd
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpress
        - name: MYSQL_PASSWORD
          value: wordpress</code></pre> 
<p>由于我们这里 MySQL 和 Wordpress 在同一个 Pod 下面，所以在 Wordpress 中我们指定数据库地址的时候是用的&nbsp;<code>localhost:3306</code>，因为这两个容器已经共享同一个 network namespace 了，这点很重要，然后如果我们要想把这个服务暴露给外部用户还得创建一个 Service 或者 Ingress 对象</p> 
<h1>NodePort 类型的 Service：(service.yaml)</h1> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: kube-example
spec:
  selector:
    app: wordpress
  type: NodePort
  ports:
  - name: web
    port: 80
    targetPort: wdport</code></pre> 
<p>因为只需要暴露 Wordpress 这个应用，所以只匹配了一个名为&nbsp;<code>wdport</code>&nbsp;的端口，现在我们来创建上面的几个资源对象</p> 
<pre><code>kubectl apply -f namespace.yaml
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml</code></pre> 
<p>接下来就是等待拉取镜像，启动 Pod:</p> 
<pre><code>$ kubectl get pods -n kube-example
NAME                         READY   STATUS    RESTARTS   AGE
wordpress-77dcdb64c6-zdlb8   2/2     Running   0          12m
$ kubectl get svc -n kube-example
NAME        TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
wordpress   NodePort   10.106.237.157   &lt;none&gt;        80:30892/TCP   2m2s</code></pre> 
<h1>测试</h1> 
<p>当 Pod 启动完成后，可以通过上面的&nbsp;<code>http://&lt;任意节点IP&gt;:30892</code>&nbsp;这个 NodePort 端口来访问应用了</p> 
<p>安装界面</p> 
<p><img alt="" height="746" src="https://img-blog.csdnimg.cn/20210403230947740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="653"></p> 
<p><img alt="" height="829" src="https://img-blog.csdnimg.cn/20210403231016271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="859"></p> 
<h1>问题</h1> 
<p>（1）pod中没有先后顺序</p> 
<p>（2）单节点问题，没有高可用</p> 
<p>（3）Wordpress 是无状态服务器，如果增加节点，mysql也会增加，数据不独立</p> 
<p>（4）数据没有持久化</p> 
<p>等等一些列的问题。</p> 
<p>此版本1，为最简单的问题，我们将在此版本上改进架构，不断的优化</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Rook部署测试Ceph和wordpress实战应用</title><link>http://www.cnblogs.com/heian99/archive/2021/04/02/14615403.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 02 Apr 2021 10:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/04/02/14615403.html</guid><description><![CDATA[
                    <h3 id="_8">环境</h3> 
<p>Rook Ceph 需要使用 RBD 内核模块，我们可以通过运行&nbsp;<code>modprobe rbd</code>&nbsp;来测试 Kubernetes 节点是否有该模块，如果没有，则需要更新下内核版本。</p> 
<p>另外需要在节点上安装&nbsp;<code>lvm2</code>&nbsp;软件包：</p> 
<pre id="__code_0"><code># Centos
sudo yum install -y lvm2

# Ubuntu
sudo apt-get install -y lvm2</code></pre> 
<h3 id="_9">安装</h3> 
<p>我们这里部署最新的 release-1.2 版本的 Rook，部署清单文件地址：<a href="https://github.com/rook/rook/tree/release-1.2/cluster/examples/kubernetes/ceph">https://github.com/rook/rook/tree/release-1.2/cluster/examples/kubernetes/ceph</a>。</p> 
<p>从上面链接中下载 common.yaml 与 operator.yaml 两个资源清单文件：<a href="https://github.com/nangongchengfeng/Kubernetes/tree/main/Ceph">https://github.com/nangongchengfeng/Kubernetes/tree/main/Ceph</a>（这个是已经整合好的，方便测试）</p> 
<pre><code class="language-bash"># 会安装crd、rbac相关资源对象
$ kubectl apply -f common.yaml
# 安装 rook operator
$ kubectl apply -f operator.yaml</code></pre> 
<p>在继续操作之前，验证&nbsp;<code>rook-ceph-operator</code>&nbsp;是否处于<code>“Running”</code>状态：&nbsp;</p> 
<pre><code class="language-bash">[root@k8s-master1 ~]# 
[root@k8s-master1 ~]# kubectl get pod -n rook-ceph 
NAME                                                 READY   STATUS      RESTARTS   AGE
csi-cephfsplugin-79wcl                               3/3     Running     0          7h28m
csi-cephfsplugin-jmrgs                               3/3     Running     0          7h28m
csi-cephfsplugin-provisioner-85979bcd-cfgqx          4/4     Running     22         7h28m
csi-cephfsplugin-provisioner-85979bcd-pzjsr          4/4     Running     10         7h28m
csi-rbdplugin-j26wk                                  3/3     Running     0          7h28m
csi-rbdplugin-pdbjl                                  3/3     Running     0          7h28m
csi-rbdplugin-provisioner-66f64ff49c-qwhh9           5/5     Running     18         7h28m
csi-rbdplugin-provisioner-66f64ff49c-sq57h           5/5     Running     37         7h28m
rook-ceph-crashcollector-k8s-node1-fcb4cfc96-4fn26   1/1     Running     0          7h26m
rook-ceph-crashcollector-k8s-node2-d97b797b5-mnc2b   1/1     Running     0          7h26m
rook-ceph-mgr-a-5dcbf79d8b-n9j68                     1/1     Running     0          4h49m
rook-ceph-mon-a-75978c9d5b-vhmkx                     1/1     Running     1          7h27m
rook-ceph-mon-b-7955589ff4-fhbb5                     1/1     Running     0          7h26m
rook-ceph-operator-658dfb6cc4-9z5lw                  1/1     Running     13         7h29m
rook-ceph-osd-0-546d474d95-wkn4k                     1/1     Running     0          7h26m
rook-ceph-osd-1-5c7cc4b9d6-g4g7t                     1/1     Running     0          7h26m
rook-ceph-osd-prepare-k8s-node1-6nttm                0/1     Completed   0          140m
rook-ceph-osd-prepare-k8s-node2-jmddp                0/1     Completed   0          140m
rook-ceph-tools-f56f69476-8mnjf                      1/1     Running     0          7h16m
rook-discover-bgcth                                  1/1     Running     0          7h29m
rook-discover-km45k                                  1/1     Running     0          7h29m
</code></pre> 
<p>我们可以看到 Operator 运行成功后，还会有一个 DaemonSet 控制器运行得 rook-discover 应用，当&nbsp;<code>Rook Operator</code>&nbsp;处于 Running 状态，我们就可以创建 Ceph 集群了。为了使集群在重启后不受影响，请确保设置的&nbsp;<code>dataDirHostPath</code>&nbsp;属性值为有效得主机路径。更多相关设置，可以查看<a href="https://rook.io/docs/rook/v1.2/ceph-cluster-crd.html">集群配置相关文档</a>。</p> 
<p>创建如下的资源清单文件：(cluster.yaml)</p> 
<pre><code class="language-bash">apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    # 最新得 ceph 镜像, 可以查看 https://hub.docker.com/r/ceph/ceph/tags
    image: ceph/ceph:v14.2.5
  dataDirHostPath: /var/lib/rook  # 主机有效目录
  mon:
    count: 3
  dashboard:
    enabled: true
  storage:
    useAllNodes: true
    useAllDevices: false
    # 重要: Directories 应该只在预生产环境中使用
    directories:
    - path: /data/rook</code></pre> 
<p>其中有几个比较重要的字段：</p> 
<ul><li><code>dataDirHostPath</code>：宿主机上的目录，用于每个服务存储配置和数据。如果目录不存在，会自动创建该目录。由于此目录在主机上保留，因此在删除 Pod 后将保留该目录，另外不得使用以下路径及其任何子路径：<code>/etc/ceph</code>、<code>/rook</code>&nbsp;或&nbsp;<code>/var/log/ceph</code>。</li></ul>
<ul><li><code>useAllNodes</code>：用于表示是否使用集群中的所有节点进行存储，如果在&nbsp;<code>nodes</code>&nbsp;字段下指定了各个节点，则必须将<code>useAllNodes</code>设置为 false。</li></ul>
<ul><li><code>useAllDevices</code>：表示 OSD 是否自动使用节点上的所有设备，一般设置为 false，这样可控性较高</li></ul>
<ul><li><code>directories</code>：一般来说应该使用一块裸盘来做存储，有时为了测试方便，使用一个目录也是可以的，当然生成环境不推荐使用目录。</li></ul>
<p>除了上面这些字段属性之外还有很多其他可以细粒度控制得参数，可以查看<a href="https://rook.io/docs/rook/v1.2/ceph-cluster-crd.html">集群配置相关文档</a>。</p> 
<p>现在直接创建上面的&nbsp;<code>CephCluster</code>&nbsp;对象即可：</p> 
<pre><code class="language-bash">$ kubectl apply -f cluster.yaml 
cephcluster.ceph.rook.io/rook-ceph created</code></pre> 
<p>创建完成后，Rook Operator 就会根据我</p> 
<h3 id="_10">验证</h3> 
<p>要验证集群是否处于正常状态，我们可以使用&nbsp;<a href="https://rook.io/docs/rook/v1.2/ceph-toolbox.html">Rook 工具箱</a>&nbsp;来运行&nbsp;<code>ceph status</code>&nbsp;命令查看。</p> 
<p>Rook 工具箱是一个用于调试和测试 Rook 的常用工具容器，该工具基于 CentOS 镜像，所以可以使用 yum 来轻松安装更多的工具包。我们这里用 Deployment 控制器来部署 Rook 工具箱，部署的资源清单文件如下所示：（toolbox.yaml）</p> 
<p>们的描述信息去自动创建 Ceph 集群了。</p> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  name: rook-ceph-tools
  namespace: rook-ceph
  labels:
    app: rook-ceph-tools
spec:
  replicas: 1
  selector:
    matchLabels:
      app: rook-ceph-tools
  template:
    metadata:
      labels:
        app: rook-ceph-tools
    spec:
      dnsPolicy: ClusterFirstWithHostNet
      containers:
      - name: rook-ceph-tools
        image: rook/ceph:v1.2.1
        command: ["/tini"]
        args: ["-g", "--", "/usr/local/bin/toolbox.sh"]
        imagePullPolicy: IfNotPresent
        env:
          - name: ROOK_ADMIN_SECRET
            valueFrom:
              secretKeyRef:
                name: rook-ceph-mon
                key: admin-secret
        securityContext:
          privileged: true
        volumeMounts:
          - mountPath: /dev
            name: dev
          - mountPath: /sys/bus
            name: sysbus
          - mountPath: /lib/modules
            name: libmodules
          - name: mon-endpoint-volume
            mountPath: /etc/rook
      # 如果设置 hostNetwork: false,  "rbd map" 命令会被 hang 住, 参考 https://github.com/rook/rook/issues/2021
      hostNetwork: true
      volumes:
        - name: dev
          hostPath:
            path: /dev
        - name: sysbus
          hostPath:
            path: /sys/bus
        - name: libmodules
          hostPath:
            path: /lib/modules
        - name: mon-endpoint-volume
          configMap:
            name: rook-ceph-mon-endpoints
            items:
            - key: data
              path: mon-endpoints</code></pre> 
<p>然后直接创建这个 Pod：</p> 
<pre id="__code_6"><code>$ kubectl apply -f toolbox.yaml
deployment.apps/rook-ceph-tools created</code></pre> 
<p>一旦 toolbox 的 Pod 运行成功后，我们就可以使用下面的命令进入到工具箱内部进行操作：</p> 
<pre id="__code_7"><code>$ kubectl -n rook-ceph exec -it $(kubectl -n rook-ceph get pod -l "app=rook-ceph-tools" -o jsonpath='{.items[0].metadata.name}') bash</code></pre> 
<p>&nbsp;</p> 
<p>工具箱中的所有可用工具命令均已准备就绪，可满足您的故障排除需求。例如：</p> 
<pre id="__code_8"><code>ceph status
ceph osd status
ceph df
rados df</code></pre> 
<p>&nbsp;</p> 
<p>比如现在我们要查看集群的状态，需要满足下面的条件才认为是健康的：</p> 
<ul><li>所有 mons 应该达到法定数量</li><li>mgr 应该是激活状态</li><li>至少有一个 OSD 处于激活状态</li><li>如果不是 HEALTH_OK 状态，则应该查看告警或者错误信息</li></ul>
<pre id="__code_9"><code>$ ceph status
ceph status
  cluster:
    id:     dae083e6-8487-447b-b6ae-9eb321818439
    health: HEALTH_OK

  services:
    mon: 3 daemons, quorum a,b,c (age 15m)
    mgr: a(active, since 2m)
    osd: 31 osds: 2 up (since 6m), 2 in (since 6m)

  data:
    pools:   0 pools, 0 pgs
    objects: 0 objects, 0 B
    usage:   79 GiB used, 314 GiB / 393 GiB avail
    pgs:</code></pre> 
<p>如果群集运行不正常，可以查看&nbsp;<a href="https://rook.io/docs/rook/v1.2/ceph-common-issues.html">Ceph 常见问题</a>以了解更多详细信息和可能的解决方案。</p> 
<h3 id="dashboard">Dashboard</h3> 
<p>Ceph 有一个 Dashboard 工具，我们可以在上面查看集群的状态，包括总体运行状态，mgr、osd 和其他 Ceph 进程的状态，查看池和 PG 状态，以及显示守护进程的日志等等。</p> 
<p>我们可以在上面的 cluster CRD 对象中开启 dashboard，设置<code>dashboard.enable=true</code>即可，这样 Rook Operator 就会启用 ceph-mgr dashboard 模块，并将创建一个 Kubernetes Service 来暴露该服务，将启用端口 7000 进行 https 访问，如果 Ceph 集群部署成功了，我们可以使用下面的命令来查看 Dashboard 的 Service：</p> 
<pre id="__code_10"><code>$ kubectl get svc -n rook-ceph
NAME                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
rook-ceph-mgr              ClusterIP   10.99.87.1       &lt;none&gt;        9283/TCP            3m6s
rook-ceph-mgr-dashboard    ClusterIP   10.111.195.180   &lt;none&gt;        7000/TCP            3m29s</code></pre> 
<p>&nbsp;</p> 
<p>这里的 rook-ceph-mgr 服务用于报告 Prometheus metrics 指标数据的，而后面的的 rook-ceph-mgr-dashboard 服务就是我们的 Dashboard 服务，如果在集群内部我们可以通过 DNS 名称&nbsp;<code>http://rook-ceph-mgr-dashboard.rook-ceph:7000</code>或者 CluterIP&nbsp;<code>http://10.111.195.180:7000</code>&nbsp;来进行访问，但是如果要在集群外部进行访问的话，我们就需要通过 Ingress 或者 NodePort 类型的 Service 来暴露了，为了方便测试我们这里创建一个新的 NodePort 类型的服务来访问 Dashboard，资源清单如下所示：（dashboard-external.yaml）</p> 
<pre id="__code_11"><code>apiVersion: v1
kind: Service
metadata:
  name: rook-ceph-mgr-dashboard-external
  namespace: rook-ceph
  labels:
    app: rook-ceph-mgr
    rook_cluster: rook-ceph
spec:
  ports:
  - name: dashboard
    port: 7000
    protocol: TCP
    targetPort: 7000
  selector:
    app: rook-ceph-mgr
    rook_cluster: rook-ceph
  type: NodePort</code></pre> 
<p>&nbsp;</p> 
<p>同样直接创建即可：</p> 
<pre id="__code_12"><code>$ kubectl apply -f dashboard-external.yaml</code></pre> 
<p>&nbsp;</p> 
<p>创建完成后我们可以查看到新创建的 rook-ceph-mgr-dashboard-external 这个 Service 服务：</p> 
<pre id="__code_13"><code>$ kubectl get svc -n rook-ceph 
NAME                                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
rook-ceph-mgr                           ClusterIP   10.96.49.29     &lt;none&gt;        9283/TCP            23m
rook-ceph-mgr-dashboard                 ClusterIP   10.109.8.98     &lt;none&gt;        7000/TCP            23m
rook-ceph-mgr-dashboard-external   NodePort    10.109.53.223    &lt;none&gt;        7000:31361/TCP      14s</code></pre> 
<p>&nbsp;</p> 
<p>现在我们需要通过&nbsp;<code>http://&lt;NodeIp&gt;:31361</code>&nbsp;就可以访问到 Dashboard 了。</p> 
<p>但是在访问的时候需要我们登录才能够访问，Rook 创建了一个默认的用户 admin，并在运行 Rook 的命名空间中生成了一个名为&nbsp;<code>rook-ceph-dashboard-admin-password</code>&nbsp;的 Secret，要获取密码，可以运行以下命令：</p> 
<pre id="__code_14"><code>$ kubectl -n rook-ceph get secret rook-ceph-dashboard-password -o jsonpath="{['data']['password']}" | base64 --decode &amp;&amp; echo
xxxx（登录密码）</code></pre> 
<p>&nbsp;</p> 
<p>用上面获得的密码和用户名 admin 就可以登录 Dashboard 了，在 Dashboard 上面可以查看到整个集群的状态：</p> 
<p><img alt="ceph dashboard" src="https://img-blog.csdnimg.cn/img_convert/5be64fa889b70b6a38f230dc179f87ab.png"></p> 
<h2 id="_11">使用</h2> 
<p>现在我们的 Ceph 集群搭建成功了，我们就可以来使用存储了。首先我们需要创建存储池，可以用 CRD 来定义 Pool。Rook 提供了两种机制来维持 OSD：</p> 
<ul><li>副本：缺省选项，每个对象都会根据&nbsp;<code>spec.replicated.size</code>&nbsp;在多个磁盘上进行复制。建议非生产环境至少 2 个副本，生产环境至少 3 个。</li><li>Erasure Code：是一种较为节约的方式。EC 把数据拆分 n 段（<code>spec.erasureCoded.dataChunks</code>），再加入 k 个代码段（<code>spec.erasureCoded.codingChunks</code>），用分布的方式把&nbsp;<code>n+k</code>&nbsp;段数据保存在磁盘上。这种情况下 Ceph 能够隔离 k 个 OSD 的损失。</li></ul>
<p>我们这里使用副本的方式，创建如下所示的 RBD 类型的存储池：(pool.yaml)</p> 
<pre id="__code_15"><code>apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: k8s-test-pool   # operator会监听并创建一个pool，执行完后界面上也能看到对应的pool
  namespace: rook-ceph
spec:
  failureDomain: host  # 数据块的故障域: 值为host时，每个数据块将放置在不同的主机上;值为osd时，每个数据块将放置在不同的osd上
  replicated:
    size: 3   # 池中数据的副本数,1就是不保存任何副本</code></pre> 
<p>&nbsp;</p> 
<p>直接创建上面的资源对象：</p> 
<pre id="__code_16"><code>$ kubectl apply -f pool.yaml 
cephblockpool.ceph.rook.io/k8s-test-pool created</code></pre> 
<p>&nbsp;</p> 
<p>存储池创建完成后我们在 Dashboard 上面的确可以看到新增了一个 pool，但是会发现集群健康状态变成了&nbsp;<code>WARN</code>，我们可以查看到有如下日志出现：</p> 
<pre id="__code_17"><code>Health check update: too few PGs per OSD (6 &lt; min 30) (TOO_FEW_PGS)</code></pre> 
<p>&nbsp;</p> 
<p>这是因为每个 osd 上的 pg 数量小于最小的数目30个。pgs 为8，因为是3副本的配置，所以当有4个 osd 的时候，每个 osd 上均分了8/4 *3=6个pgs，也就是出现了如上的错误小于最小配置30个，集群这种状态如果进行数据的存储和操作，集群会卡死，无法响应io，同时会导致大面积的 osd down。</p> 
<p>我们可以进入 toolbox 的容器中查看上面存储的 pg 数量：</p> 
<pre id="__code_18"><code>$ ceph osd pool get k8s-test-pool pg_num
pg_num: 8</code></pre> 
<p>&nbsp;</p> 
<p>我们可以通过增加 pg_num 来解决这个问题：</p> 
<pre id="__code_19"><code>$ ceph osd pool set k8s-test-pool pg_num 64
set pool 1 pg_num to 64
$ ceph -s
  cluster:
    id:     7851387c-5d18-489a-8c04-b699fb9764c0
    health: HEALTH_OK

  services:
    mon: 3 daemons, quorum a,b,c (age 33m)
    mgr: a(active, since 32m)
    osd: 4 osds: 4 up (since 32m), 4 in (since 32m)

  data:
    pools:   1 pools, 64 pgs
    objects: 0 objects, 0 B
    usage:   182 GiB used, 605 GiB / 787 GiB avail
    pgs:     64 active+clean</code></pre> 
<p>&nbsp;</p> 
<p>这个时候我们再查看就可以看到现在就是健康状态了。不过需要注意的是我们这里的 pool 上没有数据，所以修改 pg 影响并不大，但是如果是生产环境重新修改 pg 数，会对生产环境产生较大影响。因为 pg 数变了，就会导致整个集群的数据重新均衡和迁移，数据越大响应 io 的时间会越长。所以，最好在一开始就设置好 pg 数。</p> 
<p>现在我们来创建一个 StorageClass 来进行动态存储配置，如下所示我们定义一个 Ceph 的块存储的 StorageClass：(storageclass.yaml)</p> 
<pre id="__code_20"><code>apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-block
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
  # clusterID 是 rook 集群运行的命名空间
  clusterID: rook-ceph

  # 指定存储池
  pool: k8s-test-pool

  # RBD image (实际的存储介质) 格式. 默认为 "2".
  imageFormat: "2"

  # RBD image 特性. CSI RBD 现在只支持 `layering` .
  imageFeatures: layering

  # Ceph 管理员认证信息，这些都是在 clusterID 命名空间下面自动生成的
  csi.storage.k8s.io/provisioner-secret-name: rook-csi-rbd-provisioner
  csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph
  csi.storage.k8s.io/node-stage-secret-name: rook-csi-rbd-node
  csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph
  # 指定 volume 的文件系统格式，如果不指定, csi-provisioner 会默认设置为 `ext4`
  csi.storage.k8s.io/fstype: ext4
# uncomment the following to use rbd-nbd as mounter on supported nodes
# **IMPORTANT**: If you are using rbd-nbd as the mounter, during upgrade you will be hit a ceph-csi
# issue that causes the mount to be disconnected. You will need to follow special upgrade steps
# to restart your application pods. Therefore, this option is not recommended.
#mounter: rbd-nbd
reclaimPolicy: Delete</code></pre> 
<p>&nbsp;</p> 
<p>直接创建上面的 StorageClass 资源对象：</p> 
<pre id="__code_21"><code>$ kubectl apply -f storageclass.yaml 
storageclass.storage.k8s.io/rook-ceph-block created
$ kubectl get storageclass
NAME              PROVISIONER                    AGE
rook-ceph-block   rook-ceph.rbd.csi.ceph.com     35s</code></pre> 
<p>&nbsp;</p> 
<p>然后创建一个 PVC 来使用上面的 StorageClass 对象：(pvc.yaml)</p> 
<pre id="__code_22"><code>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  labels:
    app: wordpress
spec:
  storageClassName: rook-ceph-block
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi</code></pre> 
<p>&nbsp;</p> 
<p>同样直接创建上面的 PVC 资源对象：</p> 
<pre id="__code_23"><code>$ kubectl apply -f pvc.yaml 
persistentvolumeclaim/mysql-pv-claim created
$ kubectl get pvc -l app=wordpress
NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE
mysql-pv-claim   Bound    pvc-1eab82e3-d214-4d8e-8fcc-ed379c24e0e3   20Gi       RWO            rook-ceph-block   32m</code></pre> 
<p>&nbsp;</p> 
<p>创建完成后我们可以看到我们的 PVC 对象已经是 Bound 状态了，自动创建了对应的 PV，然后我们就可以直接使用这个 PVC 对象来做数据持久化操作了。</p> 
<p>这个时候可能集群还会出现如下的健康提示：</p> 
<pre id="__code_24"><code>$ ceph health detail
HEALTH_WARN application not enabled on 1 pool(s)
POOL_APP_NOT_ENABLED application not enabled on 1 pool(s)
    application not enabled on pool 'k8s-test-pool'
    use 'ceph osd pool application enable &lt;pool-name&gt; &lt;app-name&gt;', where &lt;app-name&gt; is 'cephfs', 'rbd', 'rgw', or freeform for custom applications.
$ ceph osd pool application enable k8s-test-pool k8srbd
enabled application 'k8srbd' on pool 'k8s-test-pool'</code></pre> 
<p>&nbsp;</p> 
<p>根据提示启用一个 application 即可。</p> 
<p>在官方仓库&nbsp;<a href="https://github.com/rook/rook/tree/release-1.2/cluster/examples/kubernetes">cluster/examples/kubernetes</a>&nbsp;目录下，官方给了个 wordpress 的例子，可以直接运行测试即可：</p> 
<pre id="__code_25"><code>$ kubectl apply -f mysql.yaml
$ kubectl apply -f wordpress.yaml  </code></pre> 
<p>&nbsp;</p> 
<p>官方的这个示例里面的 wordpress 用的 Loadbalancer 类型，我们可以改成 NodePort：</p> 
<pre id="__code_26"><code>$ kubectl get pvc -l app=wordpress
NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE
mysql-pv-claim   Bound    pvc-1eab82e3-d214-4d8e-8fcc-ed379c24e0e3   20Gi       RWO            rook-ceph-block   12h
wp-pv-claim      Bound    pvc-237932ed-5ca7-468c-bd16-220ebb2a1ce3   20Gi       RWO            rook-ceph-block   25s
$ kubectl get pods -l app=wordpress               
NAME                              READY   STATUS    RESTARTS   AGE
wordpress-5b886cf59b-4xwn8        1/1     Running   0          24m
wordpress-mysql-b9ddd6d4c-qhjd4   1/1     Running   0          24m
$ kubectl get svc -l app=wordpress
NAME              TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
wordpress         NodePort    10.106.253.225   &lt;none&gt;        80:30307/TCP   80s
wordpress-mysql   ClusterIP   None             &lt;none&gt;        3306/TCP       87s</code></pre> 
<p><img alt="" height="776" src="https://img-blog.csdnimg.cn/20210402180045917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>当应用都处于 Running 状态后，我们可以通过&nbsp;<code>http://&lt;任意节点IP&gt;:30307</code>&nbsp;去访问 wordpress 应用：</p> 
<p>&nbsp;</p> 
<p>比如我们在第一篇文章中更改下内容，然后我们将应用 Pod 全部删除重建：</p> 
<pre id="__code_27"><code>$ kubectl delete pod wordpress-mysql-b9ddd6d4c-qhjd4 wordpress-5b886cf59b-4xwn8
pod "wordpress-mysql-b9ddd6d4c-qhjd4" deleted
pod "wordpress-5b886cf59b-4xwn8" deleted
$ kubectl get pods -l app=wordpress                                            
NAME                              READY   STATUS    RESTARTS   AGE
wordpress-5b886cf59b-kwxk4        1/1     Running   0          2m52s
wordpress-mysql-b9ddd6d4c-kkcr7   1/1     Running   0          2m52s</code></pre> 
<p>&nbsp;</p> 
<p>当 Pod 重建完成后再次访问 wordpress 应用的主页我们可以发现之前我们添加的数据仍然存在，这就证明我们的数据持久化是正确的。</p> 
<p>&nbsp;</p> 
<p>原文地址：<a href="https://www.qikqiak.com/k8strain/storage/ceph/">https://www.qikqiak.com/k8strain/storage/ceph/</a></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Traefik的中间件，灰度发布，流量复制</title><link>http://www.cnblogs.com/heian99/archive/2021/03/29/14608413.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 29 Mar 2021 12:32:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/29/14608413.html</guid><description><![CDATA[
                    <h1 id="articleContentId"><a href="https://blog.csdn.net/heian_99/article/details/115304849">Kubernetes 1.18.3 部署 Traefik2.2</a></h1> 
<p>Traefik的中间件，灰度发布，流量复制基于上篇文章环境。</p> 
<h2>1.部署<code>whoami</code>&nbsp;应用和SVC</h2> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: whoami
spec:
  ports:
    - protocol: TCP
      name: web
      port: 80
  selector:
    app: whoami
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: whoami
  labels:
    app: whoami
spec:
  replicas: 2
  selector:
    matchLabels:
      app: whoami
  template:
    metadata:
      labels:
        app: whoami
    spec:
      containers:
        - name: whoami
          image: containous/whoami
          ports:
            - name: web
              containerPort: 80</code></pre> 
<h2>2.部署&nbsp;IngressRoute 对象</h2> 
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: simpleingressroute
spec:
  entryPoints:
    - web
  routes:
  - match: Host(`who.heian.com`) &amp;&amp; PathPrefix(`/notls`)
    kind: Rule
    services:
    - name: whoami
      port: 80</code></pre> 
<h3><img alt="" height="443" src="https://img-blog.csdnimg.cn/20210329191217238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1094"></h3> 
<h2>3.配置 HTTPS 路由</h2> 
<pre><code class="language-bash">[root@k8s-master1 who]# openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=who.heian.com" 
Generating a 2048 bit RSA private key
..........................................................................+++
..........+++
writing new private key to 'tls.key'
-----
[root@k8s-master1 who]#  kubectl create secret tls who-tls --cert=tls.crt --key=tls.key
secret/who-tls created
</code></pre> 
<p>创建一个 HTTPS 访问应用的 IngressRoute 对象</p> 
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: ingressroutetls
spec:
  entryPoints:
    - websecure
  routes:
  - match: Host(`who.heian.com`) &amp;&amp; PathPrefix(`/tls`)
    kind: Rule
    services:
    - name: whoami
      port: 80
  tls:
    secretName: who-tls</code></pre> 
<p><img alt="" height="508" src="https://img-blog.csdnimg.cn/20210329193802251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1034"></p> 
<h2>4 .&nbsp;中间件</h2> 
<p>中间件是 Traefik2.0 中一个非常有特色的功能，我们可以根据自己的各种需求去选择不同的中间件来满足服务，Traefik 官方已经内置了许多不同功能的中间件，其中一些可以修改请求，头信息，一些负责重定向，一些添加身份验证等等，而且中间件还可以通过链式组合的方式来适用各种情况。</p> 
<p><img alt="traefik middleware overview" height="731" src="https://img-blog.csdnimg.cn/img_convert/dc561bf67c3bc666dd4a4ad2c4a66e24.png" width="1200"></p> 
<p>同样比如上面我们定义的 whoami 这个应用，我们可以通过&nbsp;<code>https://who.heian.com/tls</code>&nbsp;来访问到应用，但是如果我们用&nbsp;<code>http</code>&nbsp;来访问的话呢就不行了，就会404了，因为我们根本就没有简单80端口这个入口点，</p> 
<p>所以要想通过&nbsp;<code>http</code>&nbsp;来访问应用的话自然我们需要监听下&nbsp;<code>web</code>&nbsp;这个入口点：</p> 
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: ingressroutetls-http
spec:
  entryPoints:
    - web
  routes:
  - match: Host(`who.heian.com`) &amp;&amp; PathPrefix(`/tls`)
    kind: Rule
    services:
    - name: whoami
      port: 80</code></pre> 
<p>注意这里我们创建的 IngressRoute 的 entryPoints 是&nbsp;<code>web</code>，然后创建这个对象，这个时候我们就可以通过 http 访问到这个应用了。</p> 
<p>但是我们如果只希望用户通过 https 来访问应用的话呢？按照以前的知识，我们是不是可以让 http 强制跳转到 https 服务去，对的，在 Traefik 中也是可以配置强制跳转的，只是这个功能现在是通过中间件来提供的了。</p> 
<p>如下所示，我们使用&nbsp;<code>redirectScheme</code>&nbsp;中间件来创建提供强制跳转服务：</p> 
<pre><code class="language-bash">apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: redirect-https
spec:
  redirectScheme:
    scheme: https</code></pre> 
<p>然后将这个中间件附加到 http 的服务上面去，因为 https 的不需要跳转：</p> 
<pre><code class="language-bash">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: ingressroutetls-http
spec:
  entryPoints:
    - web
  routes:
  - match: Host(`who.heian.com`) &amp;&amp; PathPrefix(`/tls`)
    kind: Rule
    services:
    - name: whoami
      port: 80
    middlewares: 
    - name: redirect-https</code></pre> 
<p>这个时候我们再去访问 http 服务可以发现就会自动跳转到 https 去了。关于更多中间件的用法可以查看文档&nbsp;<a href="https://www.qikqiak.com/traefik-book/middlewares/overview/">Traefik Docs</a>。</p> 
<p><img alt="" height="133" src="https://img-blog.csdnimg.cn/20210329194405112.png" width="425"><img alt="" height="357" src="https://img-blog.csdnimg.cn/20210329194443542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="724"></p> 
<h2 id="_4">5. 灰度发布</h2> 
<p>Traefik2.0 的一个更强大的功能就是灰度发布，灰度发布我们有时候也会称为金丝雀发布（Canary），主要就是让一部分测试的服务也参与到线上去，经过测试观察看是否符号上线要求。</p> 
<p><img alt="canary deployment" height="348" src="https://img-blog.csdnimg.cn/img_convert/2fb0b6c154bfbb5c9c3c2a55af72407d.png" width="1102"></p> 
<p>比如现在我们有两个名为&nbsp;<code>appv1</code>&nbsp;和&nbsp;<code>appv2</code>&nbsp;的服务，我们希望通过 Traefik 来控制我们的流量，将 3⁄4 的流量路由到 appv1，¼ 的流量路由到 appv2 去，这个时候就可以利用 Traefik2.0 中提供的<strong>带权重的轮询（WRR）</strong>来实现该功能</p> 
<p>首先在 Kubernetes 集群中部署上面的两个服务。</p> 
<p>为了对比结果我们这里提供的两个服务一个是 heian99/myapp:v2，一个是heian99/myapp:v1，方便测试。</p> 
<p>appv1 服务的资源清单如下所示：（appv1.yaml）heian99/myapp:v1</p> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  name: appv1
spec:
  selector:
    matchLabels:
      app: appv1
  template:
    metadata:
      labels:
        use: test
        app: appv1
    spec:
      containers:
      - name: myappv1
        image: heian99/myapp:v1
        ports:
        - containerPort: 80
          name: portv1
---
apiVersion: v1
kind: Service
metadata:
  name: appv1
spec:
  selector:
    app: appv1
  ports:
  - name: http
    port: 80
    targetPort: portv1
</code></pre> 
<p>&nbsp;</p> 
<p>appv2 服务的资源清单如下所示：（appv2.yaml）heian99/myapp:v2</p> 
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: appv2
spec:
  selector:
    matchLabels:
      app: appv2
  template:
    metadata:
      labels:
        use: test
        app: appv2
    spec:
      containers:
      - name: myappv2
        image: heian99/myapp:v2
        ports:
        - containerPort: 80
          name: portv2
---
apiVersion: v1
kind: Service
metadata:
  name: appv2
spec:
  selector:
    app: appv2
  ports:
  - name: http
    port: 80
    targetPort: portv2</code></pre> 
<p>直接创建上面两个服务：</p> 
<pre><code class="language-bash">
[root@k8s-master1 test]# kubectl apply -f .
deployment.apps/appv1 created
service/appv1 created
deployment.apps/appv2 created
service/appv2 created

[root@k8s-master1 test]# kubectl get pods -l use=test
NAME                     READY   STATUS    RESTARTS   AGE
appv1-597bbc966f-chwpj   1/1     Running   0          69s
appv2-5f5489b4c5-7gsnd   1/1     Running   0          69s

</code></pre> 
<p>&nbsp;</p> 
<p>在 Traefik2.1 中新增了一个&nbsp;<code>TraefikService</code>&nbsp;的 CRD 资源，我们可以直接利用这个对象来配置 WRR，之前的版本需要通过 File Provider，比较麻烦，新建一个描述 WRR 的资源清单：(wrr.yaml)</p> 
<pre><code class="language-bash">apiVersion: traefik.containo.us/v1alpha1
kind: TraefikService
metadata:
  name: app-wrr
spec:
  weighted:
    services:
      - name: appv1
        weight: 3  # 定义权重
        port: 80
        kind: Service  # 可选，默认就是 Service
      - name: appv2
        weight: 1
        port: 80</code></pre> 
<p>然后为我们的灰度发布的服务创建一个 IngressRoute 资源对象：(ingressroute.yaml)</p> 
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: wrringressroute
  namespace: default
spec:
  entryPoints:
    - web
  routes:
  - match: Host(`app.heian.com`)
    kind: Rule
    services:
    - name: app-wrr
      kind: TraefikService</code></pre> 
<p>不过需要注意的是现在我们配置的 Service 不再是直接的 Kubernetes 对象了，而是上面我们定义的 TraefikService 对象，直接创建上面的两个资源对象，这个时候我们对域名&nbsp;<code>app.heian.com</code>&nbsp;做上解析，去浏览器中连续访问 4 次，我们可以观察到 appv1 这应用会收到 3 次请求，而 appv2 这个应用只收到 1 次请求，符合上面我们的&nbsp;<code>3:1</code>&nbsp;的权重配置。</p> 
<p><img alt="" height="186" src="https://img-blog.csdnimg.cn/20210329201249896.png" width="693"><img alt="" height="183" src="https://img-blog.csdnimg.cn/20210329201258604.png" width="704"></p> 
<h2 id="_5">6. 流量复制</h2> 
<p>除了灰度发布之外，Traefik 2.0 还引入了流量镜像服务，是一种可以将流入流量复制并同时将其发送给其他服务的方法，镜像服务可以获得给定百分比的请求同时也会忽略这部分请求的响应。</p> 
<p><img alt="traefik mirror" height="689" src="https://img-blog.csdnimg.cn/img_convert/3ef582f18b961679cb228f6d3a60e999.png" width="988"></p> 
<p>同样的在 2.0 中只能通过 FileProvider 进行配置，在 2.1 版本中我们已经可以通过&nbsp;<code>TraefikService</code>&nbsp;资源对象来进行配置了，现在我们部署两个 whoami 的服务，资源清单文件如下所示：</p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: v1
spec:
  ports:
    - protocol: TCP
      name: web
      port: 80
  selector:
    app: v1
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: v1
  labels:
    app: v1
spec:
  selector:
    matchLabels:
      app: v1
  template:
    metadata:
      labels:
        app: v1
    spec:
      containers:
        - name: v1
          image: heian99/myapp:v1
          ports:
            - name: web
              containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: v2
spec:
  ports:
    - protocol: TCP
      name: web
      port: 80
  selector:
    app: v2
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: v2
  labels:
    app: v2
spec:
  selector:
    matchLabels:
      app: v2
  template:
    metadata:
      labels:
        app: v2
    spec:
      containers:
        - name: v2
          image: heian99/myapp:v2
          ports:
            - name: web
              containerPort: 80</code></pre> 
<p><img alt="" height="340" src="https://img-blog.csdnimg.cn/20210329201913622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="798"></p> 
<p>现在我们创建一个 IngressRoute 对象，将服务 v1 的流量复制 50% 到服务 v2，如下资源对象所示：(mirror-ingress-route.yaml)</p> 
<pre><code>apiVersion: traefik.containo.us/v1alpha1
kind: TraefikService
metadata:
  name: app-mirror
spec:
  mirroring:
    name: v1 # 发送 100% 的请求到 K8S 的 Service "v1"
    port: 80
    mirrors:
    - name: v2 # 然后复制 50% 的请求到 v2
      percent: 50
      port: 80
---
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: mirror-ingress-route
  namespace: default
spec:
  entryPoints:
  - web
  routes:   
  - match: Host(`mirror.heian.com`)
    kind: Rule
    services:
    - name: app-mirror
      kind: TraefikService # 使用声明的 TraefikService 服务，而不是 K8S 的 Service</code></pre> 
<p>这个时候我们在浏览器中去连续访问4次&nbsp;<code>mirror.heian.com</code>&nbsp;可以发现有一半的请求也出现在了&nbsp;<code>v2</code>&nbsp;这个服务中：</p> 
<p><img alt="" height="296" src="https://img-blog.csdnimg.cn/20210329202228445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1060"></p> 
<p><img alt="" height="190" src="https://img-blog.csdnimg.cn/20210329202240576.png" width="1089"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes 1.18.3 部署 Traefik2.2</title><link>http://www.cnblogs.com/heian99/archive/2021/03/29/14608414.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 29 Mar 2021 09:15:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/29/14608414.html</guid><description><![CDATA[
                    <h1 id="hkubernetes1152traefik20">Kubernetes 1.18.3 部署 Traefik2.0</h1> 
<blockquote> 
 <p>Centos 3.10.0-693.el7.x86_64</p> 
 <p>Kubernetes 1.18.3</p> 
 <p>Traefik 2.2</p> 
</blockquote> 
<pre><code class="language-bash">[root@k8s-master1 traefik]# kubectl get cs
NAME                 STATUS    MESSAGE             ERROR
controller-manager   Healthy   ok                  
scheduler            Healthy   ok                  
etcd-0               Healthy   {"health":"true"}   
etcd-2               Healthy   {"health":"true"}   
etcd-1               Healthy   {"health":"true"}   
[root@k8s-master1 traefik]# kubectl get nodes
NAME         STATUS   ROLES    AGE    VERSION
k8s-master   Ready    &lt;none&gt;   6d1h   v1.18.3
k8s-node1    Ready    &lt;none&gt;   6d     v1.18.3
k8s-node2    Ready    &lt;none&gt;   6d     v1.18.3
[root@k8s-master1 traefik]# uname -a
Linux k8s-master1 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux

</code></pre> 
<p>Traefik 2.0 官方文档：https://docs.traefik.io/v2.0/</p> 
<h1>1.Traefik 介绍</h1> 
<p>traefik 是一款反向代理、负载均衡服务，使用 golang 实现的。和 nginx 最大的不同是，它支持自动化更新反向代理和负载均衡配置。在微服务架构越来越流行的今天，一个业务恨不得有好几个数据库、后台服务和 webapp，开发团队拥有一款 “智能” 的反向代理服务，为他们简化服务配置。traefik 就是为了解决这个问题而诞生的。</p> 
<blockquote> 
 <p>Traefik 2.2新增的功能如下：<br> 1. 支持了udp<br> 2. traefik2.2 支持使用K/V存储做为动态配置的源，分别是 consul, etcd, Redis, zookeeper<br> 3. 能够使用kubernetes CRD自定义资源定义UDP负载平衡 IngressRouteUDP。<br> 4. 能够使用 rancher， consul catalog， docker和 marathon中的标签定义UDP的负载平衡<br> 5. 增加了对ingress注解的主持<br> 6. 将TLS存储功能 TLSStores添加到Kubernetes CRD中，使kubernetes用户无需使用配置文件和安装证书即可提供默认证书。<br> 7. 在日志中增加了http的请求方式,是http还是https<br> 8. 因为TLS的配置可能会影响CPU的使用率，因此增加了 TLS version和 TLS cipher使用的指标信息<br> 9. 当前的WRR算法对于权重不平衡端点存在严重的偏差问题，将EDF调度算法用于WeightedRoundRobin， Envoy也是使用了 EOF调度算法<br> 10. 支持请求主体用于流量镜像<br> 11. 增加了 ElasticAPM作为traefik的tracing系统。<br> 12. Traefik的Dashboard增加了UDP的页面<br> 13. Traefik也增加了黑暗主题</p> 
</blockquote> 
<h1>2.部署 Traefik 2.0</h1> 
<p><code>在 traefik v2.0 版本后，开始使用 CRD（Custom Resource Definition）来完成路由配置等，所以需要提前创建 CRD 资源。</code></p> 
<p>下面进行安装过程。</p> 
<blockquote> 
 <p>注：我们这里是将traefik部署在ingress-traefik命名空间，如果你需要部署在其他命名空间，需要更改资源清单，如果你是部署在和我同样的命令空间中，你需要创建该命名空间。</p> 
</blockquote> 
<p>创建命名空间：</p> 
<pre><code class="language-bash">kubectl create ns ingress-traefik</code></pre> 
<p id="1%E3%80%81%E5%88%9B%E5%BB%BACRD%E8%B5%84%E6%BA%90">创建CRD资源</p> 
<p>Traefik 2.0版本后开始使用CRD来对资源进行管理配置，所以我们需要先创建CRD资源。</p> 
<h3>traefik-crd.yaml</h3> 
<pre><code class="language-bash">## IngressRoute
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: ingressroutes.traefik.containo.us
spec:
  scope: Namespaced
  group: traefik.containo.us
  version: v1alpha1
  names:
    kind: IngressRoute
    plural: ingressroutes
    singular: ingressroute
---
## IngressRouteTCP
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: ingressroutetcps.traefik.containo.us
spec:
  scope: Namespaced
  group: traefik.containo.us
  version: v1alpha1
  names:
    kind: IngressRouteTCP
    plural: ingressroutetcps
    singular: ingressroutetcp
---
## Middleware
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: middlewares.traefik.containo.us
spec:
  scope: Namespaced
  group: traefik.containo.us
  version: v1alpha1
  names:
    kind: Middleware
    plural: middlewares
    singular: middleware
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: tlsoptions.traefik.containo.us
spec:
  scope: Namespaced
  group: traefik.containo.us
  version: v1alpha1
  names:
    kind: TLSOption
    plural: tlsoptions
    singular: tlsoption
---
## TraefikService
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: traefikservices.traefik.containo.us
spec:
  scope: Namespaced
  group: traefik.containo.us
  version: v1alpha1
  names:
    kind: TraefikService
    plural: traefikservices
    singular: traefikservice

---
## TraefikTLSStore
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: tlsstores.traefik.containo.us
spec:
  scope: Namespaced
  group: traefik.containo.us
  version: v1alpha1
  names:
    kind: TLSStore
    plural: tlsstores
    singular: tlsstore

---
## IngressRouteUDP
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: ingressrouteudps.traefik.containo.us 
spec:
  scope: Namespaced
  group: traefik.containo.us
  version: v1alpha1
  names:
    kind: IngressRouteUDP
    plural: ingressrouteudps
    singular: ingressrouteudp
</code></pre> 
<p>部署 CRD 资源</p> 
<pre><code class="language-bash">kubectl apply -f traefik-crd.yaml</code></pre> 
<p id="hrbac">创建 RBAC 权限</p> 
<p>Kubernetes 在 1.6 以后的版本中引入了基于角色的访问控制（RBAC）策略，方便对 Kubernetes 资源和 API 进行细粒度控制。Traefik 需要一定的权限，所以这里提前创建好 Traefik ServiceAccount 并分配一定的权限。</p> 
<h3>traefik-rbac.yaml</h3> 
<pre><code class="language-bash">apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: ingress-traefik 
  name: traefik-ingress-controller
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: traefik-ingress-controller
rules:
  - apiGroups: [""]
    resources: ["services","endpoints","secrets"]
    verbs: ["get","list","watch"]
  - apiGroups: ["extensions"]
    resources: ["ingresses"]
    verbs: ["get","list","watch"]
  - apiGroups: ["extensions"]
    resources: ["ingresses/status"]
    verbs: ["update"]
  - apiGroups: ["traefik.containo.us"]
    resources: ["middlewares"]
    verbs: ["get","list","watch"]
  - apiGroups: ["traefik.containo.us"]
    resources: ["ingressroutes","traefikservices"]
    verbs: ["get","list","watch"]
  - apiGroups: ["traefik.containo.us"]
    resources: ["ingressroutetcps","ingressrouteudps"]
    verbs: ["get","list","watch"]
  - apiGroups: ["traefik.containo.us"]
    resources: ["tlsoptions","tlsstores"]
    verbs: ["get","list","watch"]
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: traefik-ingress-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: traefik-ingress-controller
subjects:
  - kind: ServiceAccount
    name: traefik-ingress-controller
    namespace: ingress-traefik</code></pre> 
<p>部署 Traefik RBAC 资源</p> 
<pre><code class="language-bash">kubectl apply -f traefik-rbac.yaml </code></pre> 
<p>&nbsp;</p> 
<p>创建 Traefik 配置文件</p> 
<p>由于 Traefik 配置很多，使用 CLI 定义操作过于繁琐，尽量使用将其配置选项放到配置文件中，然后存入 ConfigMap，将其挂入 traefik 中。</p> 
<h3>traefik-config.yaml</h3> 
<pre><code class="language-bash">kind: ConfigMap
apiVersion: v1
metadata:
  name: traefik-config
  namespace: ingress-traefik
data:
  traefik.yaml: |-
    serversTransport:
      insecureSkipVerify: true
    api:
      insecure: true
      dashboard: true
      debug: true
    metrics:
      prometheus: ""
    entryPoints:
      web:
        address: ":80"
      websecure:
        address: ":443"
    providers:
      kubernetesCRD: ""
      kubernetesingress: ""
    log:
      filePath: ""
      level: error
      format: json
    accessLog:
      filePath: ""
      format: json
      bufferingSize: 0
      filters:
        retryAttempts: true
        minDuration: 20
      fields:
        defaultMode: keep
        names:
          ClientUsername: drop
        headers:
          defaultMode: keep
          names:
            User-Agent: redact
            Authorization: drop
            Content-Type: keep</code></pre> 
<p>部署 Traefik ConfigMap 资源</p> 
<pre><code class="language-bash">kubectl apply -f traefik-config.yaml -n kube-system</code></pre> 
<p>设置Label标签</p> 
<p>由于使用的Kubernetes DeamonSet方式部署Traefik，所以需要提前给节点设置Label，当程序部署Pod会自动调度到设置 Label的node节点上。</p> 
<h3>节点设置 Label 标签</h3> 
<pre><code class="language-bash">kubectl label nodes k8s-node-1 IngressProxy=true</code></pre> 
<p>验证是否成功</p> 
<pre><code class="language-bash">[root@k8s-master1 traefik]# kubectl get node --show-labels 
NAME         STATUS   ROLES    AGE    VERSION   LABELS
k8s-master   Ready    &lt;none&gt;   6d1h   v1.18.3   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master,kubernetes.io/os=linux
k8s-node1    Ready    &lt;none&gt;   6d1h   v1.18.3   IngressProxy=true,beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node1,kubernetes.io/os=linux
k8s-node2    Ready    &lt;none&gt;   6d     v1.18.3   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,ingress=true,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node2,kubernetes.io/os=linux
</code></pre> 
<p>节点删除Label标签</p> 
<pre><code class="language-bash">kubectl label nodes k8s-node-1 IngressProxy-</code></pre> 
<p>Kubernetes 部署 Traefik</p> 
<p>按照以前Traefik1.7部署方式，使用DaemonSet类型部署，以便于在多服务器间扩展，使用 hostport 方式占用服务器 80、443 端口，方便流量进入。</p> 
<h3>traefik-deploy.yaml</h3> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: traefik
  namespace: ingress-traefik
spec:
  ports:
    - name: web
      port: 80
    - name: websecure
      port: 443
    - name: admin
      port: 8080
  selector:
    app: traefik
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: traefik-ingress-controller
  namespace: ingress-traefik
  labels:
    app: traefik
spec:
  selector:
    matchLabels:
      app: traefik
  template:
    metadata:
      name: traefik
      labels:
        app: traefik
    spec:
      serviceAccountName: traefik-ingress-controller
      terminationGracePeriodSeconds: 1
      containers:
        - image: traefik:2.2.0
          name: traefik-ingress-lb
          ports:
            - name: web
              containerPort: 80
              hostPort: 80           #hostPort方式，将端口暴露到集群节点
            - name: websecure
              containerPort: 443
              hostPort: 443          #hostPort方式，将端口暴露到集群节点
            - name: admin
              containerPort: 8080
          resources:
            limits:
              cpu: 2000m
              memory: 1024Mi
            requests:
              cpu: 1000m
              memory: 1024Mi
          securityContext:
            capabilities:
              drop:
                - ALL
              add:
                - NET_BIND_SERVICE
          args:
            - --configfile=/config/traefik.yaml
          volumeMounts:
            - mountPath: "/config"
              name: "config"
      volumes:
        - name: config
          configMap:
            name: traefik-config
      tolerations:              #设置容忍所有污点，防止节点被设置污点
        - operator: "Exists"
      nodeSelector:             #设置node筛选器，在特定label的节点上启动
        IngressProxy: "true"</code></pre> 
<p>部署 Traefik</p> 
<pre><code class="language-bash">kubectl apply -f traefik-deploy.yaml </code></pre> 
<h1>3.Traefik 路由规则基础配置</h1> 
<p>配置 HTTP 路由规则 （Traefik Dashboard 为例）</p> 
<p>Traefik 应用已经部署完成，但是想让外部访问 Kubernetes 内部服务，还需要配置路由规则，这里开启了 Traefik Dashboard 配置，所以首先配置 Traefik Dashboard 看板的路由规则，使外部能够访问 Traefik Dashboard。</p> 
<h3>traefik-dashboard-route.yaml</h3> 
<pre><code class="language-bash">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: traefik-dashboard-route
  namespace: ingress-traefik
spec:
  entryPoints:
    - web
  routes:
    - match: Host(`traefik.example.cn`)
      kind: Rule
      services:
        - name: traefik
          port: 8080</code></pre> 
<p>部署Traefik Dashboard 路由规则对象</p> 
<pre><code>kubectl apply -f traefik-dashboard-route.yaml</code></pre> 
<pre><code class="language-bash">接下来配置dnsmasq，客户端想通过域名访问服务，必须要进行DNS解析，我使用的本地 DNS 服务器进行域名解析，将 Traefik 指定节点的 IP 和自定义 域名 绑定，重启dnsmasq服务即可。
打开任意浏览器输入地址：http://traefik.example.cn进行访问，此处没有配置验证登录，如果想配置验证登录，使用middleware即可。</code></pre> 
<p><img alt="" height="578" src="https://img-blog.csdnimg.cn/20210329165939125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1145"></p> 
<h1>4. 配置 HTTPS 路由规则（Kubernetes Dashboard）</h1> 
<p>这里我们创建 Kubernetes 的 Dashboard，它是 基于 Https 协议方式访问，由于它是需要使用 Https 请求，所以我们需要配置 Https 的路由规则并指定证书。</p> 
<p><a href="http://kuboard.heian.com/">测试域名：kuboard.heian.com</a>&nbsp; （内网建立的）</p> 
<p>创建证书文件</p> 
<pre><code class="language-bash"># 创建自签名证书
openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=kuboard.heian.com"

# 将证书存储到Kubernetes Secret中，新建的k8dash-sa-tls必须与k8dash-route中的tls: secretName一致。
kubectl create secret tls k8dash-sa-tls --key=tls.key --cert=tls.crt -n kube-system</code></pre> 
<h3>k8dash-route.yaml</h3> 
<pre><code class="language-bash">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: k8dash-sa-route
  namespace: kube-system
spec:
  entryPoints:
    - websecure
  tls:
    secretName: k8dash-sa-tls
  routes:
    - match: Host(`kuboard.heian.com`)
      kind: Rule
      services:
# 此处的services是Kubernetes中的svc name 与 端口 可以使用kubectl get svc --namespace=kube-system获取
        - name: kuboard
          port: 80</code></pre> 
<p>打开任意浏览器输入地址：https://<a href="http://kuboard.heian.com/">kuboard.heian.com</a>进行访问&nbsp;</p> 
<p>&nbsp;</p> 
<p><img alt="" height="508" src="https://img-blog.csdnimg.cn/202103291713116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="837"><img alt="" height="514" src="https://img-blog.csdnimg.cn/20210329171353971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="961"></p> 
<p><img alt="" height="637" src="https://img-blog.csdnimg.cn/20210329171851530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="782" src="https://img-blog.csdnimg.cn/20210329171908946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                ]]></description></item><item><title>二进制部署Kubernetes安装metrics-server遇到的问题</title><link>http://www.cnblogs.com/heian99/archive/2021/03/23/14608415.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 23 Mar 2021 11:16:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/23/14608415.html</guid><description><![CDATA[
                    <p>ubernetes部署metrics-server后执行kubectl top pod或kubectl top node报错<br> Error from server (ServiceUnavailable): the server is currently unable to handle the request (get pods.metrics.k8s.io)</p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20200322214527823.png"></p> 
<p>一、问题检查步骤：</p> 
<p>1.1、查看metrics-server服务日志</p> 
<pre><code class="language-bash">Cluster doesn't provide requestheader-client-ca-file in configmap/extension-apiserver-authentication in kube-system, so request-header client certificate authentication won't work.
</code></pre> 
<p>检查发现是由于调用metrics-server无权限，返回了http 403错误</p> 
<p>1.2、检查是否配置了以下参数</p> 
<pre><code class="language-bash">        args:
          - --cert-dir=/tmp
          - --secure-port=4443
          - --kubelet-insecure-tls=true
          - --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,externalDNS</code></pre> 
<p>1.3、问题总结：</p> 
<p>metrics-server服务配置是没有问题的，但服务依然报错 Error from server (ServiceUnavailable): the server is currently unable to handle the request (get pods.metrics.k8s.io)，有两种方法可以解决问题</p> 
<p>1、授权集群角色给用户system:anonymous</p> 
<pre><code>kubectl create clusterrolebinding system:anonymous  --clusterrole=cluster-admin  --user=system:anonymous</code></pre> 
<p>2、创建system:metrics-server角色并授权</p> 
<p>二、问题解决(创建system:metrics-server角色并授权)</p> 
<p>配置metrics-server证书</p> 
<pre><code class="language-bash"># vim metrics-server-csr.json
{
  "CN": "system:metrics-server",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "BeiJing",
      "L": "BeiJing",
      "O": "k8s",
      "OU": "system"
    }
  ]
}</code></pre> 
<p>&nbsp;</p> 
<pre><code class="language-bash">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes metrics-server-csr.json | cfssljson -bare metrics-server
</code></pre> 
<p>配置metrics-server&nbsp; RBAC授权</p> 
<pre><code class="language-bash">cat &gt; auth-metrics-server.yaml &lt;&lt; EOF
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: system:auth-metrics-server-reader
  labels:
    rbac.authorization.k8s.io/aggregate-to-view: "true"
    rbac.authorization.k8s.io/aggregate-to-edit: "true"
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
rules:
- apiGroups: ["metrics.k8s.io"]
  resources: ["pods", "nodes"]
  verbs: ["get", "list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: metrics-server:system:auth-metrics-server
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-metrics-server-reader
subjects:
- kind: User
  name: system:metrics-server
  namespace: kube-system
EOF</code></pre> 
<p>kube-apiserver添加metrics-server需要的配置</p> 
<pre><code class="language-bash">--requestheader-client-ca-file=/opt/kubernetes/ssl/ca.pem \
--requestheader-allowed-names=aggregator,metrics-server \
--requestheader-extra-headers-prefix=X-Remote-Extra- \
--requestheader-group-headers=X-Remote-Group \
--requestheader-username-headers=X-Remote-User \
--proxy-client-cert-file=/opt/kubernetes/ssl/metrics-server.pem \
--proxy-client-key-file=/opt/kubernetes/ssl/metrics-server-key.pem </code></pre> 
<p>检查是否能够正常获取到监控信息</p> 
<p><img alt="" height="140" src="https://img-blog.csdnimg.cn/20210323191550516.png" width="666"></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes Ingress-nginx高级用法</title><link>http://www.cnblogs.com/heian99/archive/2021/03/20/14608416.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 20 Mar 2021 09:39:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/20/14608416.html</guid><description><![CDATA[
                    <h2>1、什么是ingress</h2> 
<p>ngress（在kubernetes v1.1时添加）暴露从集群外到集群内服务的<code>HTTP</code>或<code>HTTPS</code>路由。定义在<code>ingress</code>资源上的规则控制流量的路由。</p> 
<pre><code>    internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
</code></pre> 
<p>一个<code>ingress</code>可以配置用于提供外部可访问的服务url、负载均衡流量、SSL终端和提供虚拟主机名配置。<code>ingress controller</code>负责实现（通常使用负载均衡器(loadbalancer)）入口（ingress）。但是它也可以配置你的边缘路由器或额外的前端来帮助处理流量。<br><code>ingress</code>不暴露任何端口或协议。将HTTP和HTTPS之外的服务公开到因特网通常使用类型是NodePort或loadbalance的service。</p> 
<p>&nbsp;</p> 
<p><img alt="" height="886" src="https://img-blog.csdnimg.cn/20200206204556322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1185"></p> 
<h2>2、Ingress区别</h2> 
<p style="margin-left:0cm;">差别：<a href="https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md">https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md</a></p> 
<h3>Ingress-nginx</h3> 
<p style="margin-left:0cm;">Ingress-nginx：kubernetes官方维护的ingress</p> 
<p style="margin-left:0cm;">Ingress-nginx的官方文档：<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rewrite">https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rewrite</a></p> 
<p style="margin-left:0cm;">Ingress-nginx Github：<a href="https://github.com/kubernetes/ingress-nginx">https://github.com/kubernetes/ingress-nginx</a></p> 
<h3>Nginx-ingress</h3> 
<p style="margin-left:0cm;">Nginx-ingress：nginx官方维护的ingress</p> 
<p style="margin-left:0cm;">Nginx-ingress的官方文档：<a href="https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-annotations/">https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/advanced-configuration-with-annotations/</a></p> 
<p style="margin-left:0cm;">Nginx-ingress Github：<a href="https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md">https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md</a></p> 
<p style="margin-left:0cm;">&nbsp;</p> 
<p>类似的还有：Traefik、HAProxy、Istio</p> 
<p>&nbsp;</p> 
<h2>3、Ingress-nginx部署</h2> 
<p><a href="https://blog.csdn.net/heian_99/article/details/104201990">（1）yaml部署Ingress-nginx</a></p> 
<p><a href="https://www.cnblogs.com/bigberg/p/13926052.html">（2）helm部署Ingress-nginx</a></p> 
<p>&nbsp;</p> 
<p>Ingress-nginx的高级介绍，我这边以Kubernetes的那个插件为主。</p> 
<h2>4、Ingress-nginx创建流程</h2> 
<p>（1）首先创建pod</p> 
<p>（2）创建service</p> 
<p>（3）创建ingress-nginx</p> 
<p><img alt="" height="409" src="https://img-blog.csdnimg.cn/20210319223654383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="748"></p> 
<pre><code class="language-bash">kubectl create ns heian
#创建命名空间后，运行下面yaml，就可以实现上面三个步骤的工作

---
apiVersion: apps/v1
kind: Deployment
metadata:
  namespace: heian
  name: ingress-heian
  annotations:
    k8s.kuboard.cn/workload: ingress-heian
    deployment.kubernetes.io/revision: '1'
    k8s.kuboard.cn/service: ClusterIP
    k8s.kuboard.cn/ingress: 'true'
  labels:
    app: ingress-heian
spec:
  selector:
    matchLabels:
      app: ingress-heian
  revisionHistoryLimit: 10
  template:
    metadata:
      labels:
        app: ingress-heian
    spec:
      affinity: {}
      securityContext:
        seLinuxOptions: {}
      imagePullSecrets: []
      restartPolicy: Always
      initContainers: []
      containers:
        - image: 'wangyanglinux/myapp:v1'
          imagePullPolicy: IfNotPresent
          name: ingress-heian
          volumeMounts:
            - name: tz-config
              mountPath: /usr/share/zoneinfo/Asia/Shanghai
            - name: tz-config
              mountPath: /etc/localtime
            - name: timezone
              mountPath: /etc/timezone
          resources:
            limits:
              cpu: 100m
              memory: 100Mi
            requests:
              cpu: 10m
              memory: 10Mi
          env:
            - name: TZ
              value: Asia/Shanghai
            - name: LANG
              value: C.UTF-8
          lifecycle: {}
          ports:
            - name: web
              containerPort: 80
              protocol: TCP
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
      volumes:
        - name: tz-config
          hostPath:
            path: /usr/share/zoneinfo/Asia/Shanghai
            type: ''
        - name: timezone
          hostPath:
            path: /etc/timezone
            type: ''
      dnsPolicy: ClusterFirst
      dnsConfig:
        options: []
      schedulerName: default-scheduler
      terminationGracePeriodSeconds: 30
  progressDeadlineSeconds: 600
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  replicas: 1

---
apiVersion: v1
kind: Service
metadata:
  namespace: heian
  name: ingress-heian
  annotations:
    k8s.kuboard.cn/workload: ingress-heian
  labels:
    app: ingress-heian
spec:
  selector:
    app: ingress-heian
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 80
      protocol: TCP
      name: ingress-web-1
      nodePort: 0
  sessionAffinity: None

---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  namespace: heian
  name: ingress-heian
  annotations:
    k8s.kuboard.cn/workload: ingress-heian
  labels:
    app: ingress-heian
spec:
  rules:
    - host: ingress.heian.com
      http:
        paths:
          - path: /
            backend:
              serviceName: ingress-heian
              servicePort: 80

</code></pre> 
<p>效果截图：</p> 
<p><img alt="" height="173" src="https://img-blog.csdnimg.cn/20210319230652392.png" width="562"></p> 
<h2>5、Ingress-nginx的域名重定向（Redirect）</h2> 
<p><strong>annotations声明</strong></p> 
<pre><code class="language-bash">#重定向，就是这一句 ，现在访问这个域名，会重定向到我的博客地址
annotations:
    nginx.ingress.kubernetes.io/permanent-redirect: 'https://blog.csdn.net/heian_99'</code></pre> 
<pre><code class="language-bash">---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/permanent-redirect: 'https://blog.csdn.net/heian_99'
  name: ingress-heian
  namespace: heian
spec:
  rules:
    - host: ingress.heian.com
      http:
        paths:
          - backend:
              serviceName: ingress-heian
              servicePort: 80
            path: /
            pathType: ImplementationSpecific</code></pre> 
<p>这个是ingress-nginx里面nginx的配置</p> 
<p><img alt="" height="1200" src="https://img-blog.csdnimg.cn/20210319232247458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<h2>6、Ingress-nginx的前后端分离（Rewrite）</h2> 
<pre><code class="language-bash">  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2</code></pre> 
<pre><code class="language-bash">---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
  name: ingress-heian
  namespace: heian
spec:
  rules:
    - host: ingress.heian.com
      http:
        paths:
          - backend:
              serviceName: ingress-heian
              servicePort: 80
            path: /something(/|$)(.*)
            pathType: ImplementationSpecific</code></pre> 
<p><img alt="" height="237" src="https://img-blog.csdnimg.cn/20210319233725336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1129"></p> 
<p><img alt="" height="198" src="https://img-blog.csdnimg.cn/20210319233746567.png" width="596"></p> 
<h2>7、Ingress-nginx的SSL配置</h2> 
<p>官网：<a href="https://kubernetes.github.io/ingress-nginx/user-guide/tls/">https://kubernetes.github.io/ingress-nginx/user-guide/tls/</a></p> 
<p>创建自建证书（主：浏览器不认可的）</p> 
<p>Ingress-nginx配置了SSL，会自动跳转到https的网页的</p> 
<pre><code class="language-bash">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.cert -subj "/CN=ingress.heian.com/O=ingress.heian.com"

kubectl create secret tls ca-ceart --key tls.key --cert tls.cert -n heian</code></pre> 
<pre><code class="language-bash">---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
  name: ingress-heian
  namespace: heian
spec:
  rules:
    - host: ingress.heian.com
      http:
        paths:
          - backend:
              serviceName: ingress-heian
              servicePort: 80
            path: /something(/|$)(.*)
            pathType: ImplementationSpecific
  tls:
    - hosts:
        - ingress.heian.com
      secretName: ca-ceart</code></pre> 
<pre><code class="language-bash">  tls:
    - hosts:
        - ingress.heian.com
      secretName: ca-ceart</code></pre> 
<p><img alt="" height="181" src="https://img-blog.csdnimg.cn/20210319235729737.png" width="591"></p> 
<p style="margin-left:0cm;"><strong>禁用https强制跳转</strong></p> 
<pre><code class="language-bash">  annotations:
     nginx.ingress.kubernetes.io/ssl-redirect: "false"</code></pre> 
<p style="margin-left:0cm;">设置默认证书：<span style="color:#36464e;">--default-ssl-certificate=default/foo-tls</span></p> 
<p style="margin-left:0cm;"><span style="color:#36464e;">更改的</span><span style="color:#36464e;">ingress-controller</span><span style="color:#36464e;">的启动参数</span></p> 
<h2>8、Ingress-nginx的黑白名单</h2> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Annotations：只对指定的ingress生效</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConfigMap：全局生效</p> 
<p style="margin-left:0cm;">黑名单可以使用ConfigMap去配置，白名单建议使用Annotations去配置。</p> 
<h3 style="margin-left:0cm;">（1）、白名单 添加白名单的方式可以直接写annotation，也可以配置在ConfigMap中。</h3> 
<p style="margin-left:0cm;">写在annotation中：</p> 
<pre><code class="language-bash">---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/whitelist-source-range: 192.168.0.100
  name: ingress-heian
  namespace: heian
spec:
  rules:
    - host: ingress.heian.com
      http:
        paths:
          - backend:
              serviceName: ingress-heian
              servicePort: 80
            path: /
            pathType: ImplementationSpecific</code></pre> 
<p style="margin-left:0cm;"><img alt="" height="270" src="https://img-blog.csdnimg.cn/20210320111859311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="569"></p> 
<p style="margin-left:0cm;"><img alt="" height="154" src="https://img-blog.csdnimg.cn/20210320111926614.png" width="381"></p> 
<p style="margin-left:0cm;">也可以写固定IP，也可以写网段。 配置到ConfigMap中：</p> 
<pre><code class="language-bash">apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    helm.sh/chart: ingress-nginx-2.1.0
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/version: 0.32.0
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
  name: ingress-nginx-controller
  namespace: ingress-nginx
data:
  whitelist-source-range: 10.1.10.0/24</code></pre> 
<h3 style="margin-left:0cm;">（2）、黑名单 黑名单就只能通过ConfigMap来配置</h3> 
<p style="margin-left:0cm;">ConfigMap配置如下：</p> 
<pre><code class="language-bash">apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    helm.sh/chart: ingress-nginx-2.1.0
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/version: 0.32.0
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
  name: ingress-nginx-controller
  namespace: ingress-nginx
data:
  whitelist-source-range: 10.1.10.0/24
  block-cidrs: 10.1.10.100</code></pre> 
<p style="margin-left:0cm;">annotation配置</p> 
<pre><code class="language-bash">---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/server-snippet: |-
      deny 192.168.0.1;
      deny 192.168.0.100;
      allow all;
  creationTimestamp: null
  name: ingress-heian
spec:
  rules:
  - host: ingress.heian.com
    http:
      paths:
      - backend:
          serviceName: ingress-heian
          servicePort: 80
        path: /
        pathType: ImplementationSpecific
status:
  loadBalancer: {}
</code></pre> 
<h2 style="margin-left:0cm;">9、Ingress-nginx的匹配请求头</h2> 
<pre><code class="language-bash">---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/server-snippet: |-
      set $agentflag 0;

              if ($http_user_agent ~* "(iPhone)" ){
                set $agentflag 1;
              }

              if ( $agentflag = 1 ) {
                return 301 https://m.heian.com;
              }
  creationTimestamp: null
  name: ingress-heian
spec:
  rules:
  - host: ingress.heian.com
    http:
      paths:
      - backend:
          serviceName: ingress-heian
          servicePort: 80
        path: /
        pathType: ImplementationSpecific
status:
  loadBalancer: {}
</code></pre> 
<p><img alt="" height="748" src="https://img-blog.csdnimg.cn/20210320113534150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="941"></p> 
<p style="margin-left:0cm;">&nbsp;</p> 
<h2>10、Ingress-nginx的速率限制</h2> 
<pre><code class="language-bash">限速¶
这些注释定义了对连接和传输速率的限制。这些可以用来减轻DDoS攻击。

nginx.ingress.kubernetes.io/limit-connections：单个IP地址允许的并发连接数。超出此限制时，将返回503错误。
nginx.ingress.kubernetes.io/limit-rps：每秒从给定IP接受的请求数。突发限制设置为此限制乘以突发乘数，默认乘数为5。当客户端超过此限制时，将 返回limit-req-status-code默认值： 503。
nginx.ingress.kubernetes.io/limit-rpm：每分钟从给定IP接受的请求数。突发限制设置为此限制乘以突发乘数，默认乘数为5。当客户端超过此限制时，将 返回limit-req-status-code默认值： 503。
nginx.ingress.kubernetes.io/limit-burst-multiplier：突发大小限制速率的倍数。默认的脉冲串乘数为5，此注释将覆盖默认的乘数。当客户端超过此限制时，将 返回limit-req-status-code默认值： 503。
nginx.ingress.kubernetes.io/limit-rate-after：最初的千字节数，在此之后，对给定连接的响应的进一步传输将受到速率的限制。必须在启用代理缓冲的情况下使用此功能。
nginx.ingress.kubernetes.io/limit-rate：每秒允许发送到给定连接的千字节数。零值禁用速率限制。必须在启用代理缓冲的情况下使用此功能。
nginx.ingress.kubernetes.io/limit-whitelist：客户端IP源范围要从速率限制中排除。该值是逗号分隔的CIDR列表。</code></pre> 
<pre><code class="language-bash">apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: ingress-nginx
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/limit-rate: 100K
    nginx.ingress.kubernetes.io/limit-whitelist: 10.1.10.100
    nginx.ingress.kubernetes.io/limit-rps: 1
    nginx.ingress.kubernetes.io/limit-rpm: 30
spec:
  rules:
  - host: iphone.coolops.cn 
    http:
      paths:
      - path: 
        backend:
          serviceName: ng-svc
          servicePort: 80



nginx.ingress.kubernetes.io/limit-rate：限制客户端每秒传输的字节数
nginx.ingress.kubernetes.io/limit-whitelist：白名单中的IP不限速
nginx.ingress.kubernetes.io/limit-rps：单个IP每秒的连接数
nginx.ingress.kubernetes.io/limit-rpm：单个IP每分钟的连接数
</code></pre> 
<p>&nbsp;</p> 
<h2>11、Ingress-nginx的基本认证</h2> 
<p>有些访问是需要认证访问的，比如dubbo-admin，我们在访问的时候会先叫你输入用户名和密码。ingress nginx也可以实现这种。</p> 
<h3>（1）、创建密码，我这里用http的命令工具来生成</h3> 
<pre><code class="language-bash">[root@k8s-master01 ingress]# htpasswd -c auth heian
New password: 
Re-type new password: 
Adding password for user heian
[root@k8s-master01 ingress]# ls
auth  tls.cert  tls.key
[root@k8s-master01 ingress]# cat auth 
heian:$apr1$8LffOJL7$ZIGV4XRNSuginqO5GMxAZ.
[root@k8s-master01 ingress]# 
</code></pre> 
<h3>（2）、创建secret</h3> 
<pre><code class="language-bash">[root@k8s-master01 ingress]# kubectl create secret generic basic-auth --from-file=auth -n heian 
secret/basic-auth created
</code></pre> 
<h3>（3）、配置Ingress</h3> 
<pre><code class="language-bash">---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/auth-realm: Need to longin
    nginx.ingress.kubernetes.io/auth-secret: basic-auth
    nginx.ingress.kubernetes.io/auth-type: basic
  creationTimestamp: null
  name: ingress-heian
spec:
  rules:
  - host: ingress.heian.com
    http:
      paths:
      - backend:
          serviceName: ingress-heian
          servicePort: 80
        path: /
        pathType: ImplementationSpecific
status:
  loadBalancer: {}
</code></pre> 
<p><img alt="" height="357" src="https://img-blog.csdnimg.cn/2021032013214395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1106"></p> 
<h2>12、Ingress-nginx实现灰度金丝雀发布</h2> 
<p>&nbsp;</p> 
<p><img alt="" height="301" src="https://img-blog.csdnimg.cn/20210320132622913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="654"></p> 
<p>&nbsp;</p> 
<blockquote> 
 <p>Nginx Annotations 支持以下 4 种 Canary 规则：</p> 
 <ul><li><code>nginx.ingress.kubernetes.io/canary-by-header</code>：基于 Request Header 的流量切分，适用于灰度发布以及 A/B 测试。当 Request Header 设置为 <code>always</code>时，请求将会被一直发送到 Canary 版本；当 Request Header 设置为 <code>never</code>时，请求不会被发送到 Canary 入口；对于任何其他 Header 值，将忽略 Header，并通过优先级将请求与其他金丝雀规则进行优先级的比较。</li><li><code>nginx.ingress.kubernetes.io/canary-by-header-value</code>：要匹配的 Request Header 的值，用于通知 Ingress 将请求路由到 Canary Ingress 中指定的服务。当 Request Header 设置为此值时，它将被路由到 Canary 入口。该规则允许用户自定义 Request Header 的值，必须与上一个 annotation (即：canary-by-header）一起使用。</li><li><code>nginx.ingress.kubernetes.io/canary-weight</code>：基于服务权重的流量切分，适用于蓝绿部署，权重范围 0 - 100 按百分比将请求路由到 Canary Ingress 中指定的服务。权重为 0 意味着该金丝雀规则不会向 Canary 入口的服务发送任何请求。权重为 100 意味着所有请求都将被发送到 Canary 入口。</li><li><code>nginx.ingress.kubernetes.io/canary-by-cookie</code>：基于 Cookie 的流量切分，适用于灰度发布与 A/B 测试。用于通知 Ingress 将请求路由到 Canary Ingress 中指定的服务的cookie。当 cookie 值设置为 <code>always</code>时，它将被路由到 Canary 入口；当 cookie 值设置为 <code>never</code>时，请求不会被发送到 Canary 入口；对于任何其他值，将忽略 cookie 并将请求与其他金丝雀规则进行优先级的比较。 定义两个版本的代码。</li></ul>
</blockquote> 
<p>创建两个同域名的ingress</p> 
<p><strong>v2版</strong></p> 
<pre><code class="language-bash">apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/canary: "true"
    nginx.ingress.kubernetes.io/canary-by-header: heian
    nginx.ingress.kubernetes.io/canary-by-header-value: v2
    nginx.ingress.kubernetes.io/canary-weight: "50"
  name: ingress-heian2
  namespace: heian
spec:
  rules:
  - host: ingress.heian.com
    http:
      paths:
      - backend:
          serviceName: ingress-heian2
          servicePort: 80
        path: /
        pathType: ImplementationSpecific
</code></pre> 
<p><img alt="" height="187" src="https://img-blog.csdnimg.cn/20210320135014976.png" width="697"></p> 
<p>&nbsp;</p> 
<h2>13、Ingress-nginx自定义错误页面</h2> 
<p>github地址：<a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/customization/custom-errors/custom-default-backend.yaml">https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/customization/custom-errors/custom-default-backend.yaml</a></p> 
<pre><code class="language-bash">kubectl apply -f error.yaml -n heian</code></pre> 
<p>修改ds配置文件，添加这个</p> 
<pre><code class="language-bash">        - --default-backend-service=heian/nginx-errors</code></pre> 
<p><img alt="" height="302" src="https://img-blog.csdnimg.cn/20210320173720693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="719"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="163" src="https://img-blog.csdnimg.cn/20210320173801591.png" width="1106"></p> 
<p>验证</p> 
<p>执行&nbsp;<code>kubectl get pod -n ingress-nginx</code>&nbsp;查看pod是否已经重启过， 如果没有自动重启，需要杀掉pod。<br> 打开一个不存在的链接， 查看是否显示的是定义的错误页面。<br> 部分浏览器不支持页面显示，如谷歌浏览器会显示“无法显示此网站”</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Prometheus_additional传统配置</title><link>http://www.cnblogs.com/heian99/archive/2021/03/18/14608417.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 18 Mar 2021 14:21:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/18/14608417.html</guid><description><![CDATA[
                    <h1 id="articleContentId"><a href="https://blog.csdn.net/heian_99/article/details/114984598">prometheus黑盒测试</a></h1> 
<p>这次使用基于黑盒测试上面。用来收集监控blackbox的数据</p> 
<p style="margin-left:0cm;"><a href="https://github.com/prometheus/blackbox_exporter">https://github.com/prometheus/blackbox_exporter</a></p> 
<p style="margin-left:0cm;"><a href="https://github.com/prometheus/blackbox_exporter/blob/master/blackbox.yml">https://github.com/prometheus/blackbox_exporter/blob/master/blackbox.yml</a></p> 
<p style="margin-left:0cm;"><a href="https://grafana.com/grafana/dashboards/5345">https://grafana.com/grafana/dashboards/5345</a></p> 
<h3>1、创建secrets</h3> 
<p>官网地址：<a href="https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/additional-scrape-config.md">https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/additional-scrape-config.md</a></p> 
<pre><code class="language-bash">cat prometheus-additional.yaml

- job_name: 'blackbox'
  metrics_path: /probe
  params:
    module: [http_2xx]  # Look for a HTTP 200 response.
  static_configs:
    - targets:
      - http://www.baidu.com	  # 这里我们监控百度网站测试
  relabel_configs:
    - source_labels: [__address__]
      target_label: __param_target
    - source_labels: [__param_target]
      target_label: instance
    - target_label: __address__
      replacement: blackbox-exporter:9115  # The blackbox exporter's real hostname:port.
</code></pre> 
<pre><code class="language-bash">kubectl create secret generic additional-scrape-configs --from-file=prometheus-additional.yaml --dry-run -oyaml &gt; additional-scrape-configs.yaml

kubectl apply -f additional-scrape-configs.yaml -n monitoring 

</code></pre> 
<p><img alt="" height="95" src="https://img-blog.csdnimg.cn/20210318213322402.png" width="1021"></p> 
<h3>2、修改Prometheus的CRD</h3> 
<p>&nbsp;</p> 
<pre><code>[root@k8s-master01 manifests]# vim prometheus-prometheus.yaml 

apiVersion: monitoring.coreos.com/v1
kind: Prometheus
metadata:
  labels:
    prometheus: k8s
spec:
  alerting:
    alertmanagers:
    - name: alertmanager-main
      namespace: monitoring
      port: web
  image: quay.io/prometheus/prometheus:v2.15.2
  nodeSelector:
    kubernetes.io/os: linux
  podMonitorNamespaceSelector: {}
  podMonitorSelector: {}
  replicas: 1
  resources:
    requests:
      memory: 700Mi
  ruleSelector:
    matchLabels:
      prometheus: k8s
      role: alert-rules
  securityContext:
    fsGroup: 2000
    runAsNonRoot: true
    runAsUser: 1000
  serviceAccountName: prometheus-k8s
  serviceMonitorNamespaceSelector: {}
  serviceMonitorSelector: {}
  version: v2.15.2
  additionalScrapeConfigs:
    name: additional-scrape-configs
    key: prometheus-additional.yaml

[root@k8s-master01 manifests]# kubectl replace -f prometheus-prometheus.yaml 
prometheus.monitoring.coreos.com/k8s replaced



</code></pre> 
<h3>3、Prometheus测试验证</h3> 
<p><img alt="" height="356" src="https://img-blog.csdnimg.cn/20210318220434421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="304" src="https://img-blog.csdnimg.cn/20210318220344134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="563" src="https://img-blog.csdnimg.cn/20210318220937701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>prometheus黑盒测试</title><link>http://www.cnblogs.com/heian99/archive/2021/03/18/14608418.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 18 Mar 2021 10:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/18/14608418.html</guid><description><![CDATA[
                    <p style="margin-left:0cm;">白盒监控：监控一些内部的数据，topic的监控数据，Redis key的大小。内部暴露的指标被称为白盒监控。比较关注的是原因。</p> 
<p style="margin-left:0cm;">&nbsp;</p> 
<p style="margin-left:0cm;">黑盒监控：站在用户的角度看到的东西。网站不能打开，网站打开的比较慢。比较关注现象，表示正在发生的问题，正在发生的告警。</p> 
<p style="margin-left:0cm;">github文档：<a href="https://github.com/prometheus/blackbox_exporter">https://github.com/prometheus/blackbox_exporter</a></p> 
<p style="margin-left:0cm;">关于部署，已经做成yaml格式，一键部署上去就可以了</p> 
<p style="margin-left:0cm;">创建comfingmap&nbsp; &nbsp;---》 挂载到deployments&nbsp; --》暴露service服务使用</p> 
<p style="margin-left:0cm;">&nbsp;</p> 
<pre><code class="language-bash">[root@k8s-master01 config]# cat exe.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: blackbox-exporter
  name: blackbox-exporter
  namespace: monitoring
spec:
  progressDeadlineSeconds: 600
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: blackbox-exporter
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
    type: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: blackbox-exporter
    spec:
      containers:
      - args:
        - --config.file=/mnt/blackbox.yml
        env:
        - name: TZ
          value: Asia/Shanghai
        - name: LANG
          value: C.UTF-8
        image: prom/blackbox-exporter:master
        imagePullPolicy: IfNotPresent
        lifecycle: {}
        name: blackbox-exporter
        ports:
        - containerPort: 9115
          name: web
          protocol: TCP
        resources:
          limits:
            cpu: 324m
            memory: 443Mi
          requests:
            cpu: 10m
            memory: 10Mi
        securityContext:
          allowPrivilegeEscalation: false
          privileged: false
          readOnlyRootFilesystem: false
          runAsNonRoot: false
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /usr/share/zoneinfo/Asia/Shanghai
          name: tz-config
        - mountPath: /etc/localtime
          name: tz-config
        - mountPath: /etc/timezone
          name: timezone
        - mountPath: /mnt
          name: config
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
      volumes:
      - hostPath:
          path: /usr/share/zoneinfo/Asia/Shanghai
          type: ""
        name: tz-config
      - hostPath:
          path: /etc/timezone
          type: ""
        name: timezone
      - configMap:
          defaultMode: 420
          name: blackbox-conf
        name: config
---
apiVersion: v1
data:
  blackbox.yml: |-
    modules:
      http_2xx:
        prober: http
      http_post_2xx:
        prober: http
        http:
          method: POST
      tcp_connect:
        prober: tcp
      pop3s_banner:
        prober: tcp
        tcp:
          query_response:
          - expect: "^+OK"
          tls: true
          tls_config:
            insecure_skip_verify: false
      ssh_banner:
        prober: tcp
        tcp:
          query_response:
          - expect: "^SSH-2.0-"
      irc_banner:
        prober: tcp
        tcp:
          query_response:
          - send: "NICK prober"
          - send: "USER prober prober prober :prober"
          - expect: "PING :([^ ]+)"
            send: "PONG ${1}"
          - expect: "^:[^ ]+ 001"
      icmp:
        prober: icmp
kind: ConfigMap
metadata:
  name: blackbox-conf
  namespace: monitoring
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: blackbox-exporter
  name: blackbox-exporter
  namespace: monitoring
spec:
  ports:
  - name: container-1-web-1
    port: 9115
    protocol: TCP
    targetPort: 9115
  selector:
    app: blackbox-exporter
  sessionAffinity: None
  type: ClusterIP
</code></pre> 
<p>测试验证</p> 
<pre><code class="language-bash"> curl http://10.96.203.216:9115/probe?target=www.baidu.com&amp;module=http_2xx</code></pre> 
<pre><code>[root@k8s-master01 config]# curl http://10.96.203.216:9115/probe?target=www.baidu.com&amp;module=http_2xx 
[1] 4221
#获取baidu.com的相关信息
[root@k8s-master01 config]# # HELP probe_dns_lookup_time_seconds Returns the time taken for probe dns lookup in seconds
# TYPE probe_dns_lookup_time_seconds gauge
probe_dns_lookup_time_seconds 0.338946599
# HELP probe_duration_seconds Returns how long the probe took to complete in seconds
# TYPE probe_duration_seconds gauge
probe_duration_seconds 0.682111152
# HELP probe_failed_due_to_regex Indicates if probe failed due to regex
# TYPE probe_failed_due_to_regex gauge
probe_failed_due_to_regex 0
# HELP probe_http_content_length Length of http content response
# TYPE probe_http_content_length gauge
probe_http_content_length -1
# HELP probe_http_duration_seconds Duration of http request by phase, summed over all redirects
# TYPE probe_http_duration_seconds gauge
probe_http_duration_seconds{phase="connect"} 0.00913168
probe_http_duration_seconds{phase="processing"} 0.008949937
probe_http_duration_seconds{phase="resolve"} 0.338946599
probe_http_duration_seconds{phase="tls"} 0
probe_http_duration_seconds{phase="transfer"} 0.324605594
# HELP probe_http_redirects The number of redirects
# TYPE probe_http_redirects gauge
probe_http_redirects 0
# HELP probe_http_ssl Indicates if SSL was used for the final redirect
# TYPE probe_http_ssl gauge
probe_http_ssl 0
# HELP probe_http_status_code Response HTTP status code
# TYPE probe_http_status_code gauge
probe_http_status_code 200
# HELP probe_http_uncompressed_body_length Length of uncompressed response body
# TYPE probe_http_uncompressed_body_length gauge
probe_http_uncompressed_body_length 297140
# HELP probe_http_version Returns the version of HTTP of the probe response
# TYPE probe_http_version gauge
probe_http_version 1.1
# HELP probe_ip_addr_hash Specifies the hash of IP address. It's useful to detect if the IP address changes.
# TYPE probe_ip_addr_hash gauge
probe_ip_addr_hash 2.882632397e+09
# HELP probe_ip_protocol Specifies whether probe ip protocol is IP4 or IP6
# TYPE probe_ip_protocol gauge
probe_ip_protocol 4
# HELP probe_success Displays whether or not the probe was a success
# TYPE probe_success gauge
probe_success 1
</code></pre> 
<p>&nbsp;</p>
                ]]></description></item><item><title>解决prometheus监控monitoring/kube-controller-manager/0 (0/0 up)的问题</title><link>http://www.cnblogs.com/heian99/archive/2021/03/18/14608419.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 18 Mar 2021 04:32:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/18/14608419.html</guid><description><![CDATA[
                    <p>我前面使用Kubernetes构建prometheus监控，没有什么大问题，但是monitoring/kube-controller-manager/0 (0/0 up)，这个没有数值。</p> 
<p><img alt="" height="738" src="https://img-blog.csdnimg.cn/20210318123025468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>一般出现这个问题，都是Kubernetes部署时，没有对应的标签，导致无法找到资源</p> 
<h2>问题</h2> 
<h3>问题一：ip地址</h3> 
<p><strong>正常开启的，但是这个监听端口是127.0.0.1的，普罗米修斯无法直接访问</strong></p> 
<pre><code class="language-bash">[root@k8s-master01 jiankong]# netstat -lntp | grep control
tcp        0      0 127.0.0.1:10257         0.0.0.0:*               LISTEN      112736/kube-control 
tcp6       0      0 :::10252                :::*                    LISTEN      112736/kube-control</code></pre> 
<p><img alt="" height="474" src="https://img-blog.csdnimg.cn/20210318115511934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1176"></p> 
<h3>问题二：SVC没有标签资源</h3> 
<pre><code class="language-bash">[root@k8s-master01 jiankong]# kubectl get servicemonitors.monitoring.coreos.com -n monitoring kube-controller-manager -oyaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  annotations:
..............................
      sourceLabels:
      - __name__
    - action: drop
      regex: etcd_(debugging|disk|request|server).*
      sourceLabels:
      - __name__
    port: http-metrics
  jobLabel: k8s-app
  namespaceSelector:
    matchNames:
    - kube-system
  selector:
    matchLabels:
      k8s-app: kube-controller-manager  #通过这个标签匹配kube-controller-manager

[root@k8s-master01 jiankong]# kubectl get svc -n kube-system -l k8s-app= kube-controller-manager
error: name cannot be provided when a selector is specified

#这边在kube-system没有这个标签的svc，所以无法匹配到</code></pre> 
<p>&nbsp;</p> 
<h2>解决：</h2> 
<h3>1、修改监听地址</h3> 
<pre><code>vim /etc/kubernetes/manifests/kube-controller-manager.yaml

    - --bind-address=0.0.0.0

</code></pre> 
<p><img alt="" height="541" src="https://img-blog.csdnimg.cn/2021031812044881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1170"></p> 
<p><img alt="" height="98" src="https://img-blog.csdnimg.cn/20210318121030394.png" width="1200"></p> 
<p>开0.0.0.0，是可以的，因为Kubernetes通信需要证书，是双向的。</p> 
<p>&nbsp;</p> 
<h3>2、添加svc ep标签</h3> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  labels:
    k8s-app: kube-controller-manager
  name: kube-controller-manage-monitor
  namespace: kube-system
spec:
  ports:
  - name: http-metrics
    port: 10252
    protocol: TCP
    targetPort: 10252
  sessionAffinity: None
  type: ClusterIP

apiVersion: v1
kind: Endpoints
metadata:
  labels:
    k8s-app: kube-controller-manager
  name: kube-controller-manage-monitor
  namespace: kube-system
subsets:
- addresses:
  - ip: 192.168.0.100
  ports:
  - name: http-metrics
    port: 10252
    protocol: TCP</code></pre> 
<p>&nbsp;</p> 
<p><img alt="" height="578" src="https://img-blog.csdnimg.cn/20210318122907108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="381" src="https://img-blog.csdnimg.cn/20210318123052749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h3>3、测试</h3> 
<p><img alt="" height="888" src="https://img-blog.csdnimg.cn/20210318123145527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes监控etcd集群（自带metrics接口）</title><link>http://www.cnblogs.com/heian99/archive/2021/03/18/14608420.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 18 Mar 2021 03:38:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/18/14608420.html</guid><description><![CDATA[
                    <h1 id="articleContentId"><a href="https://blog.csdn.net/heian_99/article/details/114953970">Kubernetes用operator部署prometheus</a></h1> 
<p>上面采用Kubernetes部署prometheus</p> 
<p>我们可以使用prometheus来监控自带metrics接口的应用。</p> 
<p>etcd是Kubernetes的数据库，自带接口，我们可以用etcd作为实例来看看怎么操作。</p> 
<p><img alt="" height="540" src="https://img-blog.csdnimg.cn/20210318113651800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="938"></p> 
<p><img alt="" height="559" src="https://img-blog.csdnimg.cn/20210318113706531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="958"></p> 
<h2 id="一、监控etcd集群">一、监控etcd集群</h2> 
<h3>1.1、查看接口信息</h3> 
<p>二进制和kubeadm安装方式不同，他们etcd的存放证书位置也不同</p> 
<p><strong>二进制</strong></p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# curl --cert /etc/etcd/ssl/etcd.pem --key /etc/etcd/ssl/etcd-key.pem  https://192.168.1.201:2379/metrics -k 
# 这样也行
curl -L http://localhost:2379/metrics</code></pre> 
<p><strong>kubeadm</strong></p> 
<pre><code>[root@k8s-master01 ~]# find / -name "etcd"
/etc/kubernetes/pki/etcd


curl --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key  https://localhost:2379/metrics -k</code></pre> 
<p><img alt="" height="754" src="https://img-blog.csdnimg.cn/20210318092912784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h3>1.2、创建service和Endpoints</h3> 
<p><strong>创建ep和svc代理外部的etcd服务，其他自带metrics接口的服务也是如此！</strong></p> 
<pre><code>apiVersion: v1
kind: Endpoints
metadata:
  labels:
    app: etcd-k8s
  name: etcd-k8s
  namespace: kube-system   #注意命名空间
subsets:
- addresses:     # etcd节点对应的主机ip，有几台就写几台
  - ip: 192.168.0.100
  ports:
  - name: etcd-port
    port: 2379   # etcd端口
    protocol: TCP
---
apiVersion: v1
kind: Service 
metadata:
  labels:
    app: etcd-k8s
  name: etcd-k8s
  namespace: kube-system
spec:
  ports:
  - name: etcd-port
    port: 2379
    protocol: TCP
    targetPort: 2379
  type: ClusterIP</code></pre> 
<h3>1.3、测试是否代理成功</h3> 
<pre><code class="language-bash">#再次curl，把IP换成svc的IP测试，输出相同内容即创建成功
[root@k8s-master01 ~]# kubectl get svc -n kube-system etcd-k8s
NAME      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
etcd-ep   ClusterIP   10.103.53.103   &lt;none&gt;        2379/TCP   8m54s

# 再次请求接口
[root@k8s-master01 ~]#curl --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key  https://10.96.156.166:2379/metrics -k
</code></pre> 
<p>有上面测试数值，代表接口已经暴露出来，现在包证书挂载上去。</p> 
<h3>1.4、创建secret</h3> 
<pre><code class="language-bash"># 1、这里我们k8s-master01节点进行创建,ca为k8sca证书，剩下2个为etcd证书，这是我证书所在位置
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'
  
# 2、接下来我们需要创建一个secret，让prometheus pod节点挂载
kubectl create secret generic etcd-ssl --from-file=/etc/kubernetes/pki/etcd/etcd-ca.pem --from-file=/etc/kubernetes/pki/etcd/etcd.pem --from-file=/etc/kubernetes/pki/etcd/etcd-key.pem -n monitoring

# 3、创建完成后可以检查一下
[root@k8s-master01 prometheus-down]# kubectl describe secrets -n monitoring etcd-ssl
Name:         etcd-ssl
Namespace:    monitoring
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  Opaque

Data
====
etcd-ca.pem:   1367 bytes
etcd-key.pem:  1679 bytes
etcd.pem:      1509 bytes</code></pre> 
<h3>1.5、编辑prometheus，把证书挂载进去</h3> 
<pre><code class="language-bash"># 1、通过edit直接编辑prometheus 或者修改yaml文件
[root@k8s-master01 ~]# kubectl edit prometheus k8s -n monitoring
# 在replicas底下加上secret名称
replicas:2
secrets:
- etcd-ssl #添加secret名称

# 进入容器查看，就可以看到证书挂载进去了
[root@k8s-master01 prometheus-down]# kubectl exec -it -n monitoring prometheus-k8s-0 /bin/sh

# 查看文件是否存在
/prometheus $ ls /etc/prometheus/secrets/etcd-ssl/
etcd-ca.pem   etcd-key.pem  etcd.pem</code></pre> 
<h3>1.6、创建ServiceMonitor</h3> 
<p>&nbsp;</p> 
<pre><code>[root@k8s-master01 ~]# cat etcd-servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: etcd-k8s
  namespace: monitoring
  labels:
    app: etcd-k8s
spec:
  jobLabel: app
  endpoints:
    - interval: 30s
      port: etcd-port  # 这个port对应 Service.spec.ports.name
      scheme: https
      tlsConfig:
        caFile: /etc/prometheus/secrets/etcd-ssl/etcd-ca.pem #证书路径 (在prometheus pod里路径)
        certFile: /etc/prometheus/secrets/etcd-ssl/etcd.pem
        keyFile: /etc/prometheus/secrets/etcd-ssl/etcd-key.pem
        insecureSkipVerify: true  # 关闭证书校验
  selector:
    matchLabels:
      app: etcd-k8s  # 跟scv的lables保持一致
  namespaceSelector:
    matchNames:
    - kube-system    # 跟svc所在namespace保持一致
# 匹配Kube-system这个命名空间下面具有app=etcd-k8s这个label标签的Serve，job label用于检索job任务名称的标签。由于证书serverName和etcd中签发的证书可能不匹配，所以添加了insecureSkipVerify=true将不再对服务端的证书进行校验</code></pre> 
<h3>1.7、页面查看etcd节点都获取到数据</h3> 
<p>此处数据获取有点慢，需要等待一下</p> 
<p><img alt="" height="397" src="https://img-blog.csdnimg.cn/20210318113345313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<h3>1.8、grafana模板导入</h3> 
<p>数据采集完成后，接下来可以在grafana中导入dashboard</p> 
<p># 打开官网来的如下图所示，点击下载JSO文件</p> 
<p>grafana官网：https://grafana.com/grafana/dashboards/3070</p> 
<p>中文版ETCD集群插件：https://grafana.com/grafana/dashboards/9733</p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/img_convert/77e241eb8608cb2b5c8ff73c0c283a14.png"></p> 
<p><img alt="" height="1200" src="https://img-blog.csdnimg.cn/20210318113557437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<p>已经成功</p>
                ]]></description></item><item><title>Kubernetes用operator部署prometheus</title><link>http://www.cnblogs.com/heian99/archive/2021/03/17/14552636.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 17 Mar 2021 14:52:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/17/14552636.html</guid><description><![CDATA[
                    <h2>Operator 模式</h2> 
<p>Operator 是 Kubernetes 的扩展软件，它利用&nbsp;<a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/">定制资源</a>&nbsp;管理应用及其组件。 Operator 遵循 Kubernetes 的理念，特别是在<a href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>&nbsp;方面。</p> 
<p>Operator的场景就是专门给有状态应用而设计的。</p> 
<p>为什么只给有状态应用？</p> 
<p>因为无状态应用简单啊，没有服务间的交互，要再开一家火锅店，跟k8s说一声，开一家一样的就可以了。</p> 
<p>有状态不一样，你开了一家火锅店以后，客户的信息怎么同步，就涉及到与别的火锅店交涉的问题，当然你也可以写个别的程序做这个数据同步的操作。</p> 
<p>但是operator做的事情就是能自动识别到火锅店客户信息的不对称，主动同步，你只用告诉operator我要再开一家连锁火锅店就好了。</p> 
<h2 id="kubernetes-上的-operator">Kubernetes 上的 Operator<a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/#kubernetes-%E4%B8%8A%E7%9A%84-operator">&nbsp;</a></h2> 
<p>Kubernetes 为自动化而生。无需任何修改，你即可以从 Kubernetes 核心中获得许多内置的自动化功能。 你可以使用 Kubernetes 自动化部署和运行工作负载，&nbsp;<em>甚至</em>&nbsp;可以自动化 Kubernetes 自身。</p> 
<p>Kubernetes&nbsp;<a href="https://kubernetes.io/zh/docs/concepts/architecture/controller/">控制器</a>&nbsp;使你无需修改 Kubernetes 自身的代码，即可以扩展集群的行为。 Operator 是 Kubernetes API 的客户端，充当&nbsp;<a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/">定制资源</a>&nbsp;的控制器</p> 
<p>官网文档：<a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/">https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/</a></p> 
<h2>部署prometheus</h2> 
<h3>1.1、下载</h3> 
<pre><code class="language-bash">git clone -b release-0.7 --single-branch https://github.com/coreos/kube-prometheus.git</code></pre> 
<h3>1.2、安装operator</h3> 
<pre><code class="language-bash">[root@k8s-master01 ~]# cd /root/kube-prometheus/manifests/setup
[root@k8s-master01 setup]# kubectl create -f .

# 查看是否Running
[root@k8s-master01 ~]# kubectl get pod -n monitoring
NAME                                   READY   STATUS        RESTARTS   AGE
prometheus-operator-848d669f6d-bz2tc   2/2     Running       0          4m16s</code></pre> 
<h3>1.3、安装Prometheus</h3> 
<pre><code class="language-bash">[root@k8s-master01 ~]# cd /root/kube-prometheus/manifests
[root@k8s-master01 manifests]# kubectl create -f .</code></pre> 
<h3>1.4、创建ingress</h3> 
<pre><code class="language-bash">[root@k8s-master01 manifests]# cat svc-ingress.yal 
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: prom-ingresses
  namespace: monitoring
spec:
  rules:
  - host: alert.test.com
    http:
      paths:
      - backend:
          serviceName: alertmanager-main
          servicePort: 9093
        path: /
  - host: grafana.test.com
    http:
      paths:
      - backend:
          serviceName: grafana
          servicePort: 3000
        path: /
  - host: prom.test.com
    http:
      paths:
      - backend:
          serviceName: prometheus-k8s
          servicePort: 9090
        path: /





[root@k8s-master01 manifests]# kubectl get ingress -n monitoring 
NAME             CLASS    HOSTS                                           ADDRESS        PORTS   AGE
prom-ingresses   &lt;none&gt;   alert.test.com,grafana.test.com,prom.test.com   10.96.107.62   80      23h
</code></pre> 
<h3>alert.test.com（报警）</h3> 
<p><img alt="" height="725" src="https://img-blog.csdnimg.cn/20210317224918783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h3>prom.test.com（普罗米修斯）</h3> 
<p><img alt="" height="880" src="https://img-blog.csdnimg.cn/20210317225010450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h3>grafana.test.com（图形展示）</h3> 
<p><img alt="" height="964" src="https://img-blog.csdnimg.cn/20210317225110179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                ]]></description></item><item><title>Kubernetes升级coredns1.8.3</title><link>http://www.cnblogs.com/heian99/archive/2021/03/17/14552638.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 17 Mar 2021 13:39:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/17/14552638.html</guid><description><![CDATA[
                    <p>日常工作中，我们有时会对一些比较低的组件做升级。</p> 
<p>版本的升级，可以解决一下bug和漏洞，稳定系统的性能。</p> 
<p>这次我升级对coredns升级。</p> 
<p>coredns主要是Kubernetes中对域名和ip解析，可以作为内网的dns解析服务器。</p> 
<h2 id="一、查看当前coredns版本">一、查看当前coredns版本</h2> 
<pre><code class="language-bash">[root@k8s-master01 ~]# kubectl get pod -n kube-system coredns-7ff77c879f-h2jw9 -oyaml | grep image
            f:image: {}
            f:imagePullPolicy: {}
    image: registry.aliyuncs.com/google_containers/coredns:1.6.7
    imagePullPolicy: IfNotPresent
    image: registry.aliyuncs.com/google_containers/coredns:1.6.7
    imageID: docker-pullable://registry.aliyuncs.com/google_containers/coredns@sha256:695a5e109604331f843d2c435f488bf3f239a88aec49112d452c1cbf87e88405
</code></pre> 
<h3><img alt="" height="241" src="https://img-blog.csdnimg.cn/20210317212518122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></h3> 
<h2 id="二、升级">二、升级</h2> 
<h3>2.1、查询最新版coredns的版本</h3> 
<pre><code class="language-bash"># coredns官网：https://github.com/coredns/coredns
# 老版本用：kube-dns
# 新版的都用：coredns


# 部署文档：https://github.com/coredns/deployment/tree/master/kubernetes</code></pre> 
<p>最新版地址：<a href="https://github.com/coredns/deployment/blob/master/kubernetes/coredns.yaml.sed">https://github.com/coredns/deployment/blob/master/kubernetes/coredns.yaml.sed</a></p> 
<p><img alt="" height="226" src="https://img-blog.csdnimg.cn/20210317212559119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="502"></p> 
<p>现在最新版是1.8.3</p> 
<h3>2.2、备份原来的cm、deploy、clusterrole、clusterrolebinding</h3> 
<p><span style="color:#f33b45;"><strong>切记：日常我们做任何操作（升级，删除，修改），一定要备份，防止错误操作，导致数据丢失，或者功能无法使用</strong></span></p> 
<p><span style="color:#f33b45;"><strong>备份好处，可以确保数据安全性，如果出现功能不能使用，可以立刻回滚，不长时间影响业务</strong></span></p> 
<pre><code class="language-bash">mkdir coredns &amp;&amp; cd coredns
kubectl get cm -n kube-system coredns -oyaml &gt; coredns-config.yaml
kubectl get deploy -n kube-system coredns -oyaml &gt; coredns-controllers.yaml
kubectl get clusterrole system:coredns -oyaml &gt; coredns-clusterrole.yaml
kubectl get clusterrolebinding  system:coredns -oyaml &gt; coredns-clusterrolebinding.yaml
</code></pre> 
<p><img alt="" height="177" src="https://img-blog.csdnimg.cn/20210317213032740.png" width="1200"></p> 
<h3>2.3、升级coredns</h3> 
<p>下载地址：git clone https://github.com/coredns/deployment.git</p> 
<pre><code class="language-bash"># 1、下载文件
git clone https://github.com/coredns/deployment.git

# 2、升级
cd deployment/kubernetes/
./deploy.sh -s | kubectl apply -f -




[root@k8s-master01 ~]# cd deployment/kubernetes/
[root@k8s-master01 kubernetes]# ./deploy.sh -s | kubectl apply -f -
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
serviceaccount/coredns configured
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
clusterrole.rbac.authorization.k8s.io/system:coredns configured
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
clusterrolebinding.rbac.authorization.k8s.io/system:coredns configured
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
configmap/coredns configured
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
deployment.apps/coredns configured
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
service/kube-dns configured
</code></pre> 
<p><img alt="" height="226" src="https://img-blog.csdnimg.cn/20210317213826746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>已经升级成功</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Failed to create client: error while trying to communicate with apiserver: 报错解决</title><link>http://www.cnblogs.com/heian99/archive/2021/03/16/14552640.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 16 Mar 2021 13:37:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/16/14552640.html</guid><description><![CDATA[
                    <p>问题：Kubernetes安装普罗米修斯，其中kube-state-metrics 容器一直报错</p> 
<p>环境：Kubernetes 1.18</p> 
<pre><code class="language-bash">[root@k8s-master01 manifests]# kubectl logs -f kube-state-metrics-bdb8874fd-tnrrg  -n monitoring -c kube-state-metrics
I0316 13:12:52.295699       1 main.go:86] Using default collectors
I0316 13:12:52.295788       1 main.go:98] Using all namespace
I0316 13:12:52.295798       1 main.go:139] metric white-blacklisting: blacklisting the following items: 
W0316 13:12:52.295807       1 client_config.go:543] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.
I0316 13:12:52.297186       1 main.go:184] Testing communication with server
F0316 13:13:22.298801       1 main.go:147] Failed to create client: error while trying to communicate with apiserver: Get https://10.96.0.1:443/version?timeout=32s: dial tcp 10.96.0.1:443: i/o timeout
</code></pre> 
<p>分析：</p> 
<p>首先，这个kube-state-metrics-bdb8874fd-tnrrg 中有三个容器。问题出现在kube-state-metrics。导致容器不断的重启</p> 
<p>看问题，是无法连接到10.96.0.1:443这个ip和端口上。</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# kubectl get svc
NAME                       TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
csi-metrics-cephfsplugin   ClusterIP   10.96.218.238   &lt;none&gt;        8080/TCP   21h
kubernetes                 ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    83d
nginx                      ClusterIP   10.96.215.251   &lt;none&gt;        80/TCP     16d
</code></pre> 
<p>由svc可见，这个是Kubernetes的核心ip和端口。但是他那边显示无法连接。</p> 
<p>测试一下</p> 
<p><img alt="" height="241" src="https://img-blog.csdnimg.cn/20210316213148931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>这个端口是通的，但是无法连接。报错显示io线程延时。</p> 
<p>解决：</p> 
<p>kube-state-metrics原本安装在k8s-node02上。这边删除，还是从重建k8s-node02.</p> 
<p>分析一下node02的cpu有点高，我直接指定到k8s-node01上。</p> 
<p>然后测试，没有显示io延时报错</p> 
<p><img alt="" height="332" src="https://img-blog.csdnimg.cn/20210316213425478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="170" src="https://img-blog.csdnimg.cn/202103162136066.png" width="515"></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Helm（bitnami）部署zookeeper和kafka集群</title><link>http://www.cnblogs.com/heian99/archive/2021/03/15/14540690.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 15 Mar 2021 08:58:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/15/14540690.html</guid><description><![CDATA[
                    <p>首先介绍一下bitnami</p> 
<p><em>BitNami</em>是一个开源项目，该项目产生的开源软件包括安装 Web应用程序和解决方案堆栈，以及虚拟设备（通俗易懂的说：就是封装好各种应用包，提供人们使用。）</p> 
<p>我们平时要部署一套高可用集群，大部分都是找到模板，没必要重复造轮子。<em>BitNami就是提供轮子的。</em></p> 
<p>&nbsp;bitnami官方地址： &nbsp;<a href="https://bitnami.com/">https://bitnami.com/</a></p> 
<p>这次我们创建部署zookeeper和kafka集群，采取bitnami提供helm仓库，进行安装和部署。</p> 
<p>不懂Helm的可以看看&nbsp;<a href="https://blog.csdn.net/heian_99/article/details/114763052">Helm部署RabbitMQ集群</a>，提供参考</p> 
<p>部署安装文档：<a href="https://docs.bitnami.com/tutorials/deploy-scalable-kafka-zookeeper-cluster-kubernetes">https://docs.bitnami.com/tutorials/deploy-scalable-kafka-zookeeper-cluster-kubernetes</a></p> 
<h3>helm添加<em>BitNami仓库</em></h3> 
<pre><code class="language-bash">helm repo add bitnami https://charts.bitnami.com/bitnami</code></pre> 
<h3>部署zookeeper集群</h3> 
<pre><code class="language-bash">helm install zookeeper bitnami/zookeeper 
  --set replicaCount=3 
  --set auth.enabled=false 
  --set allowAnonymousLogin=true</code></pre> 
<h3>部署kafka集群</h3> 
<pre><code class="language-bash">helm install kafka bitnami/kafka 
  --set zookeeper.enabled=false 
  --set replicaCount=3
  --set externalZookeeper.servers=ZOOKEEPER-SERVICE-NAME</code></pre> 
<p>查看kafka集群，连接zookeeper</p> 
<p><img alt="Zookeeper-Kafka communication" src="https://img-blog.csdnimg.cn/img_convert/f5ef96ca56468ab510b3e66234c8ea97.png"></p> 
<p>&nbsp;</p> 
<h3>扩容和缩容</h3> 
<p>修改下面这个参数，重新运行。</p> 
<pre><code class="language-bash">--set replicaCount=7</code></pre> 
<p>&nbsp;</p> 
<p>如果遇到拉去镜像失败，这可以使用以下的镜像源</p> 
<p><a href="https://www.daocloud.io/mirror">https://www.daocloud.io/mirror</a></p> 
<pre><code class="language-bash">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</code></pre> 
<pre><code class="language-bash">[root@k8s-master01 kafka]# cat /etc/docker/daemon.json
{
  "registry-mirrors": ["http://f1361db2.m.daocloud.io"]
}
</code></pre> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Helm部署RabbitMQ集群</title><link>http://www.cnblogs.com/heian99/archive/2021/03/14/14533540.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 14 Mar 2021 09:37:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/14/14533540.html</guid><description><![CDATA[
                    <p><strong>Helm</strong>&nbsp;帮助您管理 Kubernetes 应用程序——Helm Charts 帮助您定义、安装和升级最复杂的 Kubernetes 应用程序。</p> 
<p>Helm 可以使用 Charts 启动 Kubernetes 集群，提供可用的工作流：</p> 
<ul><li> <p>一个 Redis 集群</p> </li><li> <p>一个 Postgres 数据库</p> </li><li> <p>一个 HAProxy 边界负载均衡</p> </li></ul>
<p>特性：</p> 
<ul><li>查找并使用流行的软件，将其打包为 Helm Charts，以便在 Kubernetes 中运行</li><li>以 Helm Charts 的形式共享您自己的应用程序</li><li>为您的 Kubernetes 应用程序创建可复制的构建</li><li>智能地管理您的 Kubernetes 清单文件</li><li>管理 Helm 包的发行版</li></ul>
<p>&nbsp;</p> 
<h3>helm的安装</h3> 
<p>官方文档：<a href="https://helm.sh/docs/intro/install/">https://helm.sh/docs/intro/install/</a></p> 
<p>版本下载地址：<a href="https://github.com/helm/helm/releases">https://github.com/helm/helm/releases</a></p> 
<pre><code class="language-bash">tar -zxvf helm-v3.0.0-linux-amd64.tar.gz
mv linux-amd64/helm /usr/local/bin/helm

已经安装完成

[root@k8s-master01 ~]# helm version
version.BuildInfo{Version:"v3.5.3", GitCommit:"041ce5a2c17a58be0fcd5f5e16fb3e7e95fea622", GitTreeState:"dirty", GoVersion:"go1.15.8"}
</code></pre> 
<p>至于怎么添加仓库，可以百度</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# helm repo list 
NAME         	URL                                                   
aliyuncs     	https://apphub.aliyuncs.com                           
stable       	https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts
ingress-nginx	https://kubernetes.github.io/ingress-nginx </code></pre> 
<h3>&nbsp;查看可使用tabbitmq-ha的版本</h3> 
<pre><code class="language-bash">[root@k8s-master01 ~]# helm search repo rabbitmq-ha 
NAME                	CHART VERSION	APP VERSION	DESCRIPTION                                       
aliyuncs/rabbitmq-ha	1.39.0       	3.8.0      	Highly available RabbitMQ cluster, the open sou...
stable/rabbitmq-ha  	1.0.0        	3.7.3      	Highly available RabbitMQ cluster, the open sou...
[root@k8s-master01 ~]# helm search repo rabbitmq-ha --versions
NAME                	CHART VERSION	APP VERSION	DESCRIPTION                                       
aliyuncs/rabbitmq-ha	1.39.0       	3.8.0      	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.38.2       	3.8.0      	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.38.1       	3.8.0      	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.36.4       	3.8.0      	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.36.3       	3.8.0      	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.36.0       	3.8.0      	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.34.1       	3.7.19     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.34.0       	3.7.19     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.33.0       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.32.4       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.32.3       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.32.2       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.32.0       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.31.0       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.30.0       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.29.1       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.29.0       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.28.0       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.27.2       	3.7.15     	Highly available RabbitMQ cluster, the open sou...
aliyuncs/rabbitmq-ha	1.27.1       	3.7.12     	Highly available RabbitMQ cluster, the open sou...
stable/rabbitmq-ha  	1.0.0        	3.7.3      	Highly available RabbitMQ cluster, the open sou...
stable/rabbitmq-ha  	0.1.1        	3.7.0      	Highly available RabbitMQ cluster, the open sou...
</code></pre> 
<h3>拉去指定版本的配置</h3> 
<pre><code class="language-bash">[root@k8s-master01 ~]# helm pull aliyuncs/rabbitmq-ha --version=1.33.0
[root@k8s-master01 ~]# ls
helm  old  rabbitmq-cluster  rabbitmq-ha-1.33.0.tgz #这个就只拉去的文件，可以解压</code></pre> 
<h3>查询配置文件</h3> 
<pre><code class="language-bash">[root@k8s-master01 ~]# tar -xf rabbitmq-ha-1.33.0.tgz 
[root@k8s-master01 ~]# ls
helm  old  rabbitmq-cluster  rabbitmq-ha  rabbitmq-ha-1.33.0.tgz
[root@k8s-master01 ~]# tree rabbitmq-ha
rabbitmq-ha
├── Chart.yaml
├── OWNERS
├── README.md
├── templates
│&nbsp;&nbsp; ├── alerts.yaml
│&nbsp;&nbsp; ├── configmap.yaml
│&nbsp;&nbsp; ├── _helpers.tpl
│&nbsp;&nbsp; ├── ingress.yaml
│&nbsp;&nbsp; ├── NOTES.txt
│&nbsp;&nbsp; ├── pdb.yaml
│&nbsp;&nbsp; ├── rolebinding.yaml
│&nbsp;&nbsp; ├── role.yaml
│&nbsp;&nbsp; ├── secret.yaml
│&nbsp;&nbsp; ├── serviceaccount.yaml
│&nbsp;&nbsp; ├── service-discovery.yaml
│&nbsp;&nbsp; ├── servicemonitor.yaml
│&nbsp;&nbsp; ├── service.yaml
│&nbsp;&nbsp; └── statefulset.yaml
└── values.yaml

1 directory, 18 files

</code></pre> 
<p>参考</p> 
<pre><code class="language-bash">

├── charts # 依赖文件
├── Chart.yaml # 这个chart的版本信息
├── templates #模板
│   ├── deployment.yaml
│   ├── _helpers.tpl # 自定义的模板或者函数
│   ├── ingress.yaml
│   ├── NOTES.txt #这个chart的信息
│   ├── serviceaccount.yaml
│   ├── service.yaml
│   └── tests
│       └── test-connection.yaml
└── values.yaml #配置全局变量或者一些参数</code></pre> 
<h3>创建namespaces</h3> 
<p>helm指定namespaces，如果没有namespaces空间，就会报错。需要提前创建</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# helm create rabbitmq-cluster
Creating rabbitmq-cluster
</code></pre> 
<h3>运行rabbitmq集群</h3> 
<p><img alt="" height="137" src="https://img-blog.csdnimg.cn/20210314172044985.png" width="528"></p> 
<p>镜像配置方面，可以修改values.yaml</p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">[root@k8s-master01 rabbitmq-ha]# pwd
/root/rabbitmq-ha
[root@k8s-master01 rabbitmq-ha]# ls
Chart.yaml  OWNERS  README.md  templates  values.yaml
[root@k8s-master01 rabbitmq-ha]# helm install rabbitmq --namespace  rabbitmq-cluster --set ingress.enabled=true,ingress.hostName=rabbitmq.akiraka.net --set rabbitmqUsername=aka,rabbitmqPassword=rabbitmq,managementPassword=rabbitmq,rabbitmqErlangCookie=secretcookie .
NAME: rabbitmq
LAST DEPLOYED: Sun Mar 14 17:25:11 2021
NAMESPACE: rabbitmq-cluster
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
** Please be patient while the chart is being deployed **

  Credentials:

    Username            : aka
    Password            : $(kubectl get secret --namespace rabbitmq-cluster rabbitmq-rabbitmq-ha -o jsonpath="{.data.rabbitmq-password}" | base64 --decode)
    Management username : management
    Management password : $(kubectl get secret --namespace rabbitmq-cluster rabbitmq-rabbitmq-ha -o jsonpath="{.data.rabbitmq-management-password}" | base64 --decode)
    ErLang Cookie       : $(kubectl get secret --namespace rabbitmq-cluster rabbitmq-rabbitmq-ha -o jsonpath="{.data.rabbitmq-erlang-cookie}" | base64 --decode)

  RabbitMQ can be accessed within the cluster on port 5672 at rabbitmq-rabbitmq-ha.rabbitmq-cluster.svc.cluster.local

  To access the cluster externally execute the following commands:

    export POD_NAME=$(kubectl get pods --namespace rabbitmq-cluster -l "app=rabbitmq-ha" -o jsonpath="{.items[0].metadata.name}")
    kubectl port-forward $POD_NAME --namespace rabbitmq-cluster 5672:5672 15672:15672

  To Access the RabbitMQ AMQP port:

    amqp://127.0.0.1:5672/ 

  To Access the RabbitMQ Management interface:

    URL : http://127.0.0.1:15672
[root@k8s-master01 rabbitmq-ha]# 
</code></pre> 
<h3>查看集群</h3> 
<p>已经正常运行起来了</p> 
<pre><code class="language-bash">[root@k8s-master01 rabbitmq-ha]# kubectl get svc,pod,ingress -n rabbitmq-cluster  
NAME                                     TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                       AGE
service/rabbitmq-rabbitmq-ha             ClusterIP   None         &lt;none&gt;        15672/TCP,5672/TCP,4369/TCP   7m23s
service/rabbitmq-rabbitmq-ha-discovery   ClusterIP   None         &lt;none&gt;        15672/TCP,5672/TCP,4369/TCP   7m23s

NAME                         READY   STATUS    RESTARTS   AGE
pod/rabbitmq-rabbitmq-ha-0   1/1     Running   0          7m23s
pod/rabbitmq-rabbitmq-ha-1   1/1     Running   0          6m56s
pod/rabbitmq-rabbitmq-ha-2   1/1     Running   0          6m34s

NAME                                      CLASS    HOSTS                  ADDRESS        PORTS   AGE
ingress.extensions/rabbitmq-rabbitmq-ha   &lt;none&gt;   rabbitmq.akiraka.net   10.96.107.62   80      7m23s
</code></pre> 
<p><img alt="" height="327" src="https://img-blog.csdnimg.cn/20210314173345427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="847" src="https://img-blog.csdnimg.cn/20210314173452536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>很方便的，几个命令就完成集群的部署</p> 
<p>&nbsp;</p> 
<h3>补充</h3> 
<pre><code>helm install helm-test2 --set fullnameOverride=aaaaaaa --dry-run .
这个是模拟运行，懂的人都懂（带值）</code></pre> 
<pre><code>删除helm uninstall rabbitmq-cluster -n public-service  # helm v3 --keep-history
	helm delete/del NAME --purge 
升级helm upgrade rabbitmq-cluster -n public-service .
</code></pre> 
<p>&nbsp;</p> 
<p>卸载保留历史记录</p> 
<pre><code class="language-bash">[root@k8s-master01 rabbitmq-ha]# helm  uninstall rabbitmq -n rabbitmq-cluster --keep-history 
release "rabbitmq" uninstalled
[root@k8s-master01 rabbitmq-ha]# helm list  -n rabbitmq-cluster 
NAME	NAMESPACE	REVISION	UPDATED	STATUS	CHART	APP VERSION
[root@k8s-master01 rabbitmq-ha]# helm list  
NAME	NAMESPACE	REVISION	UPDATED	STATUS	CHART	APP VERSION
[root@k8s-master01 rabbitmq-ha]# helm  ls
NAME	NAMESPACE	REVISION	UPDATED	STATUS	CHART	APP VERSION
[root@k8s-master01 rabbitmq-ha]#  helm status rabbitmq -n rabbitmq-cluster
NAME: rabbitmq
LAST DEPLOYED: Sun Mar 14 17:25:11 2021
NAMESPACE: rabbitmq-cluster
STATUS: uninstalled
REVISION: 1
TEST SUITE: None
NOTES:
** Please be patient while the chart is being deployed **

  Credentials:

    Username            : aka
    Password            : $(kubectl get secret --namespace rabbitmq-cluster rabbitmq-rabbitmq-ha -o jsonpath="{.data.rabbitmq-password}" | base64 --decode)
    Management username : management
    Management password : $(kubectl get secret --namespace rabbitmq-cluster rabbitmq-rabbitmq-ha -o jsonpath="{.data.rabbitmq-management-password}" | base64 --decode)
    ErLang Cookie       : $(kubectl get secret --namespace rabbitmq-cluster rabbitmq-rabbitmq-ha -o jsonpath="{.data.rabbitmq-erlang-cookie}" | base64 --decode)

  RabbitMQ can be accessed within the cluster on port 5672 at rabbitmq-rabbitmq-ha.rabbitmq-cluster.svc.cluster.local

  To access the cluster externally execute the following commands:

    export POD_NAME=$(kubectl get pods --namespace rabbitmq-cluster -l "app=rabbitmq-ha" -o jsonpath="{.items[0].metadata.name}")
    kubectl port-forward $POD_NAME --namespace rabbitmq-cluster 5672:5672 15672:15672

  To Access the RabbitMQ AMQP port:

    amqp://127.0.0.1:5672/ 

  To Access the RabbitMQ Management interface:

    URL : http://127.0.0.1:15672
</code></pre> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes通过插件，自动发现注册Rabbitmq集群</title><link>http://www.cnblogs.com/heian99/archive/2021/03/11/14533541.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 11 Mar 2021 02:58:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/11/14533541.html</guid><description><![CDATA[
                    <p style="margin-left:0cm;"><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）</p> 
<ul><li> <p>可伸缩性：集群服务</p> </li><li> <p>消息持久化：从内存持久化消息到硬盘，再从硬盘加载到内存&nbsp;</p> </li></ul>
<p>&nbsp;</p> 
<p>工作中，我们经常使用到Rabbitmq，有单节点，有集群的。</p> 
<p style="margin-left:0cm;">通过该Kubernetes来安装RabbitMQ，通过插【rabbitmq_management,rabbitmq_peer_discovery_k8s】来自动发现注册集群：</p> 
<p style="margin-left:0cm;">RabbitMQ通过StatefulSet来部署，可以通过域名来访问，方便处理</p> 
<p style="margin-left:0cm;"><img alt="" height="363" src="https://img-blog.csdnimg.cn/20210311094106956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="922" src="https://img-blog.csdnimg.cn/20210311094255588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p style="margin-left:0cm;">&nbsp;</p> 
<h2 style="margin-left:0cm;">（1）环境</h2> 
<p>需要Kubernetes集群</p> 
<p>下载部署文件</p> 
<pre><code class="language-bash">下载地址：https://github.com/dotbalo/k8s/tree/master/k8s-rabbitmq-cluster</code></pre> 
<p style="margin-left:0cm;"><img alt="" height="312" src="https://img-blog.csdnimg.cn/20210311094814793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p style="margin-left:0cm;">&nbsp;</p> 
<h2 style="margin-left:0cm;">（2）创建命名空间</h2> 
<pre><code class="language-bash">kubectl create ns public-service</code></pre> 
<p>如果不使用public-service，需要更改所有yaml文件的public-service为你namespace。</p> 
<pre><code class="language-bash">sed -i "s#public-service#YOUR_NAMESPACE#g" *.yaml</code></pre> 
<h2 style="margin-left:0cm;">（3）修改配置文件</h2> 
<pre><code class="language-bash">在rabbitmq-configmap.yaml配置，添加这两个字段，解决密码不生效的问题
      default_pass = RABBITMQ_PASS
      default_user = RABBITMQ_USER
</code></pre> 
<p style="margin-left:0cm;"><img alt="" height="707" src="https://img-blog.csdnimg.cn/20210311100213362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1090"></p> 
<p style="margin-left:0cm;">这边PV是使用nfs的。测试环境，这边我是手动创建的，也可以使用插件，自动创建，并回收。</p> 
<pre><code class="language-bash">[root@k8s-master01 k8s-rabbitmq-cluster]# cat rabbitmq-pv.yaml 
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-rmq-1
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteMany
  volumeMode: Filesystem
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: "rmq-storage-class"
  nfs:
    # real share directory
    path: /ifs/kubernetts/rabbitmq-cluster-0
    # nfs real ip
    server: 192.168.0.109

---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-rmq-2
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteMany
  volumeMode: Filesystem
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: "rmq-storage-class"
  nfs:
    # real share directory
    path: /ifs/kubernetts/rabbitmq-cluster-1
    # nfs real ip
    server: 192.168.0.109

---

apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-rmq-3
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteMany
  volumeMode: Filesystem
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: "rmq-storage-class"
  nfs:
    # real share directory
    path: /ifs/kubernetts/rabbitmq-cluster-2
    # nfs real ip
    server: 192.168.0.109
</code></pre> 
<h2 style="margin-left:0cm;">（4）创建集群</h2> 
<pre><code class="language-bash">[root@k8s-master01 k8s-rabbitmq-cluster]# kubectl apply -f .
statefulset.apps/rmq-cluster created
configmap/rmq-cluster-config created
persistentvolume/pv-rmq-1 created
persistentvolume/pv-rmq-2 created
persistentvolume/pv-rmq-3 created
serviceaccount/rmq-cluster created
role.rbac.authorization.k8s.io/rmq-cluster created
rolebinding.rbac.authorization.k8s.io/rmq-cluster created
secret/rmq-cluster-secret created
service/rmq-cluster created
service/rmq-cluster-balancer created
</code></pre> 
<h2 style="margin-left:0cm;">查看容器日志，显示这个就是正常的</h2> 
<pre><code class="language-bash">kubectl logs -f rmq-cluster-0    -n public-service 
'/etc/rabbitmq/rabbitmq.conf' -&gt; '/var/lib/rabbitmq/rabbitmq.conf'
2021-03-11 02:24:03.469 [info] &lt;0.9.0&gt; Feature flags: list of feature flags found:
2021-03-11 02:24:03.469 [info] &lt;0.9.0&gt; Feature flags: feature flag states written to 
。。。。。。。。。。。。。。。
。。。。。。。。。。。。。。。
2021-03-11 02:24:04.273 [info] &lt;0.692.0&gt; Statistics database started.
2021-03-11 02:24:04.274 [info] &lt;0.691.0&gt; Starting worker pool 'management_worker_pool' with 3 processes in it
 completed with 5 plugins.
2021-03-11 02:24:04.411 [info] &lt;0.9.0&gt; Server startup complete; 5 plugins started.
 * rabbitmq_management
 * rabbitmq_management_agent
 * rabbitmq_web_dispatch
 * rabbitmq_peer_discovery_k8s
 * rabbitmq_peer_discovery_common
2021-03-11 02:24:23.135 [info] &lt;0.434.0&gt; node 'rabbit@rmq-cluster-1.rmq-cluster.public-service.svc.cluster.local' up
2021-03-11 02:24:23.904 [info] &lt;0.434.0&gt; rabbit on node 'rabbit@rmq-cluster-1.rmq-cluster.public-service.svc.cluster.local' up
2021-03-11 02:24:44.524 [info] &lt;0.434.0&gt; node 'rabbit@rmq-cluster-2.rmq-cluster.public-service.svc.cluster.local' up
2021-03-11 02:24:45.477 [info] &lt;0.434.0&gt; rabbit on node 'rabbit@rmq-cluster-2.rmq-cluster.public-service.svc.cluster.local' up
</code></pre> 
<p style="margin-left:0cm;">创建资源如下</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# kubectl get pod,sts,svc,ep,pv,pvc -n public-service 
NAME                READY   STATUS    RESTARTS   AGE
pod/rmq-cluster-0   1/1     Running   0          8m10s
pod/rmq-cluster-1   1/1     Running   0          7m34s
pod/rmq-cluster-2   1/1     Running   0          7m18s

NAME                           READY   AGE
statefulset.apps/rmq-cluster   3/3     8m11s

NAME                           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                          AGE
service/rmq-cluster            ClusterIP   None           &lt;none&gt;        5672/TCP                         8m11s
service/rmq-cluster-balancer   NodePort    10.96.58.102   &lt;none&gt;        15672:31824/TCP,5672:31993/TCP   8m11s

NAME                             ENDPOINTS                                                              AGE
endpoints/rmq-cluster            10.244.32.129:5672,10.244.58.225:5672,10.244.85.246:5672               8m11s
endpoints/rmq-cluster-balancer   10.244.32.129:5672,10.244.58.225:5672,10.244.85.246:5672 + 3 more...   8m11s

NAME                        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                           STORAGECLASS        REASON   AGE
persistentvolume/pv-rmq-1   1Gi        RWX            Recycle          Bound    public-service/rabbitmq-storage-rmq-cluster-2   rmq-storage-class            8m11s
persistentvolume/pv-rmq-2   1Gi        RWX            Recycle          Bound    public-service/rabbitmq-storage-rmq-cluster-1   rmq-storage-class            8m11s
persistentvolume/pv-rmq-3   1Gi        RWX            Recycle          Bound    public-service/rabbitmq-storage-rmq-cluster-0   rmq-storage-class            8m11s
persistentvolume/pv0001     2Gi        RWO            Recycle          Bound    default/test-pvc2                               slow                         9d

NAME                                                   STATUS   VOLUME     CAPACITY   ACCESS MODES   STORAGECLASS        AGE
persistentvolumeclaim/rabbitmq-storage-rmq-cluster-0   Bound    pv-rmq-3   1Gi        RWX            rmq-storage-class   8m11s
persistentvolumeclaim/rabbitmq-storage-rmq-cluster-1   Bound    pv-rmq-2   1Gi        RWX            rmq-storage-class   7m34s
persistentvolumeclaim/rabbitmq-storage-rmq-cluster-2   Bound    pv-rmq-1   1Gi        RWX            rmq-storage-class   7m18s
[root@k8s-master01 ~]# 
</code></pre> 
<h2 style="margin-left:0cm;">（5）验证集群</h2> 
<p style="margin-left:0cm;">可以通过svc的nodeport端口暴露，或者ingress来访问rabbitmq可视化界面</p> 
<p style="margin-left:0cm;"><img alt="" height="105" src="https://img-blog.csdnimg.cn/20210311103353828.png" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="341" src="https://img-blog.csdnimg.cn/20210311103342131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<pre><code class="language-bash">
      default_user = RABBITMQ_USER   #账号
      default_pass = RABBITMQ_PASS   #密码</code></pre> 
<h2 style="margin-left:0cm;">（6）集群扩容，缩容</h2> 
<p style="margin-left:0cm;"><span style="color:#f33b45;">扩容，如果使用的pv，建议查看pv是否够，不然状态一直是pending</span></p> 
<pre><code class="language-bash">kubectl scale statefulset -n public-service --replicas=4 rmq-cluster

--replicas=4   改这个值，就可以用来扩容和缩容</code></pre> 
<p style="margin-left:0cm;"><img alt="" height="180" src="https://img-blog.csdnimg.cn/20210311104053402.png" width="684"></p> 
<p style="margin-left:0cm;"><img alt="" height="321" src="https://img-blog.csdnimg.cn/20210311105422245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="849" src="https://img-blog.csdnimg.cn/20210311105503765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="307" src="https://img-blog.csdnimg.cn/20210311105728953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p style="margin-left:0cm;"><a href="https://github.com/dotbalo/k8s/tree/master/k8s-rabbitmq-cluster">https://github.com/dotbalo/k8s/tree/master/k8s-rabbitmq-cluster</a></p>
                ]]></description></item><item><title>Kubernetes使用operator安装Redis集群</title><link>http://www.cnblogs.com/heian99/archive/2021/03/09/14508307.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 09 Mar 2021 13:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/09/14508307.html</guid><description><![CDATA[
                    <h2>通过operator部署redis集群</h2> 
<p>operator部署有状态的应用会简单很多</p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20210225160104777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hscm9saXU=,size_16,color_FFFFFF,t_70"></p> 
<p>&nbsp;</p> 
<p>github文档：<a href="https://github.com/ucloud/redis-cluster-operator#deploy-redis-cluster-operator">https://github.com/ucloud/redis-cluster-operator#deploy-redis-cluster-operator</a></p> 
<p>Redis Cluster Operator在Kubernetes上管理Redis-Cluster集群</p> 
<p>每个主节点及其从节点都由statefulSet管理，为每个statefulSet创建无头svc，并为所有节点创建clusterIP服务。<br> 每个有状态集都使用PodAntiAffinity来确保主节点和从节点分散在不同的节点上。同时，当操作员在每个有状态集中选择主节点时，它会优先选择具有不同k8s节点的容器作为主节点。</p> 
<h3>（1）下载redis-cluster-operator</h3> 
<pre><code class="language-bash">git  clone  https://github.com/ucloud/redis-cluster-operator.git</code></pre> 
<p>在名称空间：redis-cluster下部署Redis集群，注意修改yaml文件的namespace参数<br> 创建名称空间Namespace：redis-cluster</p> 
<pre><code class="language-bash">[root@k8s-master01 redis-cluster-operator-master]# kubectl create ns redis-cluster
namespace/redis-node created
[root@k8s-master01 redis-cluster-operator-master]# kubectl get ns
NAME                   STATUS   AGE
default                Active   76d
ingress-nginx          Active   9d
kube-node-lease        Active   76d
kube-public            Active   76d
kube-system            Active   76d
kube-users             Active   2d21h
kubernetes-dashboard   Active   45h
redis-cluster          Active   11s
rook-ceph              Active   33h
[root@k8s-master01 redis-cluster-op</code></pre> 
<h3>（2）创建自定义资源（CRD）</h3> 
<pre><code class="language-bash">[root@k8s-master01 redis]# kubectl apply -f deploy/crds/
customresourcedefinition.apiextensions.k8s.io/distributedredisclusters.redis.kun created
customresourcedefinition.apiextensions.k8s.io/redisclusterbackups.redis.kun created</code></pre> 
<h3>（3）创建operator</h3> 
<pre><code class="language-bash">[root@k8s-master01 redis]# kubectl create -f deploy/service_account.yaml
serviceaccount/redis-cluster-operator created
[root@k8s-master01 redis]# kubectl create -f deploy/cluster/cluster_role.yaml
clusterrole.rbac.authorization.k8s.io/redis-cluster-operator created
[root@k8s-master01 redis]# kubectl create -f deploy/cluster/cluster_role_binding.yaml
clusterrolebinding.rbac.authorization.k8s.io/redis-cluster-operator created
[root@k8s-master01 redis]# kubectl create -f deploy/cluster/operator.yaml
deployment.apps/redis-cluster-operator created
configmap/redis-admin created
[root@k8s-master01 redis]# kubectl get deployment
NAME                     READY   UP-TO-DATE   AVAILABLE   AGE
metrics-metrics-server   1/1     1            1           10d
redis-cluster-operator   1/1     1            1           12s


// cluster-scoped 命令
$ kubectl create -f deploy/service_account.yaml
$ kubectl create -f deploy/cluster/cluster_role.yaml
$ kubectl create -f deploy/cluster/cluster_role_binding.yaml
$ kubectl create -f deploy/cluster/operator.yaml
</code></pre> 
<h3><span style="color:#24292e;">（4）部署样本Redis集群</span></h3> 
<p>注意：<strong>只有使用持久性存储（pvc）的redis集群在意外删除或滚动更新后才能恢复。即使您不使用持久性（如rdb或aof），也需要将pvc设置为redis。</strong></p> 
<pre><code class="language-bash">apiVersion: redis.kun/v1alpha1
kind: DistributedRedisCluster
metadata:
  annotations:
    # if your operator run as cluster-scoped, add this annotations
    redis.kun/scope: cluster-scoped
  name: example-distributedrediscluster
spec:
  image: redis:5.0.4-alpine
  masterSize: 3
  clusterReplicas: 1
  resources:
    limits:
      cpu: 200m
      memory: 200Mi
    requests:
      cpu: 200m
      memory: 100Mi
</code></pre> 
<p>因为使用样本，没有资源限制，会因为内存不足导致初始化失败，限制使用这个测试</p> 
<pre><code class="language-bash">kubectl create -f deploy/example/custom-resources.yaml</code></pre> 
<pre><code class="language-bash">[root@k8s-master01 redis]# kubectl get pod,svc
NAME                                          READY   STATUS    RESTARTS   AGE
pod/drc-example-distributedrediscluster-0-0   1/1     Running   0          6m39s
pod/drc-example-distributedrediscluster-0-1   1/1     Running   0          6m2s
pod/drc-example-distributedrediscluster-1-0   1/1     Running   0          6m39s
pod/drc-example-distributedrediscluster-1-1   1/1     Running   0          6m7s
pod/drc-example-distributedrediscluster-2-0   1/1     Running   0          6m39s
pod/drc-example-distributedrediscluster-2-1   1/1     Running   0          6m6s
pod/metrics-metrics-server-6c7745d876-cw72h   1/1     Running   0          8h
pod/redis-cluster-operator-7f6cf86475-dhttx   1/1     Running   0          11m

NAME                                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)              AGE
service/example-distributedrediscluster     ClusterIP   10.96.104.199   &lt;none&gt;        6379/TCP,16379/TCP   6m38s
service/example-distributedrediscluster-0   ClusterIP   None            &lt;none&gt;        6379/TCP,16379/TCP   6m38s
service/example-distributedrediscluster-1   ClusterIP   None            &lt;none&gt;        6379/TCP,16379/TCP   6m38s
service/example-distributedrediscluster-2   ClusterIP   None            &lt;none&gt;        6379/TCP,16379/TCP   6m38s
service/kubernetes                          ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP              76d
service/metrics-metrics-server              ClusterIP   10.96.86.164    &lt;none&gt;        443/TCP              10d
service/nginx                               ClusterIP   10.96.215.251   &lt;none&gt;        80/TCP               9d
service/redis-cluster-operator-metrics      ClusterIP   10.96.58.127    &lt;none&gt;        8383/TCP,8686/TCP    11m
[root@k8s-master01 redis]# 
</code></pre> 
<p>创建指定命名空间和动态存储的，我这个没有构建动态存储</p> 
<pre><code class="language-bash">cat redis-cluster.yaml 
apiVersion: redis.kun/v1alpha1
kind: DistributedRedisCluster
metadata:
  annotations:
    # if your operator run as cluster-scoped, add this annotations
    redis.kun/scope: cluster-scoped
  name: example-distributedrediscluster
  namespace: redis-cluster
spec:
  image: redis:5.0.4-alpine
  imagePullPolicy: IfNotPresent
  masterSize: 3			#master节点数量
  clusterReplicas: 1	#每个master节点的从节点数量
  serviceName: redis-svc
  # resources config
  resources:
    limits:
      cpu: 300m
      memory: 200Mi
    requests:
      cpu: 200m
      memory: 150Mi
  # pv storage
  storage:
    type: persistent-claim
    size: 2Gi
    class: nfs-storage
    deleteClaim: true
]# kubectl apply -f redis-cluster.yaml
</code></pre> 
<h3>（5）验证集群</h3> 
<pre><code class="language-bash">[root@k8s-master01 redis]# kubectl exec -it  drc-example-distributedrediscluster-0-0 -- sh
/data # redis-cli -c -h redis-svc
Could not connect to Redis at redis-svc:6379: Name does not resolve
not connected&gt; 
/data # redis-cli -c -h example-distributedrediscluster
example-distributedrediscluster:6379&gt;  cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:5
cluster_my_epoch:0
cluster_stats_messages_ping_sent:511
cluster_stats_messages_pong_sent:485
cluster_stats_messages_meet_sent:1
cluster_stats_messages_sent:997
cluster_stats_messages_ping_received:481
cluster_stats_messages_pong_received:512
cluster_stats_messages_meet_received:4
cluster_stats_messages_received:997
example-distributedrediscluster:6379&gt; set a b
-&gt; Redirected to slot [15495] located at 10.244.58.209:6379
OK
10.244.58.209:6379&gt; 
</code></pre> 
<h3>（6）<span style="color:#24292e;">扩展Redis集群</span></h3> 
<p><span style="color:#24292e;">增加masterSize触发放大。（注意：这个也直接可以使用edit修改。）</span></p> 
<pre><code class="language-bash">apiVersion: redis.kun/v1alpha1
kind: DistributedRedisCluster
metadata:
  annotations:
    # if your operator run as cluster-scoped, add this annotations
    redis.kun/scope: cluster-scoped
  name: example-distributedrediscluster
spec:
  # Increase the masterSize to trigger the scaling.
  masterSize: 4
  ClusterReplicas: 1
  image: redis:5.0.4-alpine</code></pre> 
<h3>（7）<span style="color:#24292e;">缩减Redis集群</span></h3> 
<p><span style="color:#24292e;">减小masterSize触发缩小。</span></p> 
<pre><code class="language-bash">apiVersion: redis.kun/v1alpha1
kind: DistributedRedisCluster
metadata:
  annotations:
    # if your operator run as cluster-scoped, add this annotations
    redis.kun/scope: cluster-scoped
  name: example-distributedrediscluster
spec:
  # Increase the masterSize to trigger the scaling.
  masterSize: 3
  ClusterReplicas: 1
  image: redis:5.0.4-alpine</code></pre> 
<h3>（8）删除redis集群</h3> 
<pre><code class="language-bash">]# cd redis-cluster-operator/ 
]# kubectl delete -f redis-cluster.yaml
]# cd cluster/
]# kubectl delete -f operator.yaml 
]# kubectl delete -f cluster_role_binding.yaml 
]# kubectl delete -f cluster_role.yaml 
]# kubectl delete-f service_account.yaml 
]# kubectl delete -f deploy/crds/
]# kubectl delete -f ns-redis-cluster.yaml
</code></pre> 
<p>&nbsp;</p> 
<p>github文档：<a href="https://github.com/ucloud/redis-cluster-operator#deploy-redis-cluster-operator">https://github.com/ucloud/redis-cluster-operator#deploy-redis-cluster-operator</a></p>
                ]]></description></item><item><title>Kubernetes部署单Redis</title><link>http://www.cnblogs.com/heian99/archive/2021/03/09/14508308.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 09 Mar 2021 02:37:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/09/14508308.html</guid><description><![CDATA[
                    <p>Kubernetes集群中，我们时常要部署中间件，nginx，redis等等</p> 
<p>首先，这些中间件要容器化，才可以部署到Kubernetes集群中。</p> 
<p>（1）一般我们到dockerhub官方，寻找镜像&nbsp;&nbsp;<a href="https://hub.docker.com/search?q=redis&amp;type=image">https://hub.docker.com/search?q=redis&amp;type=image</a></p> 
<p>（2）我们可以自己定制，，公司需要的docker 镜像</p> 
<p>部署单个Redis</p> 
<h3>（1）首先下载redis的镜像（版本：）</h3> 
<pre><code class="language-bash">docker pull redis:5.0.4-alpine</code></pre> 
<h3>（2）编写configmap</h3> 
<p>因为需要指定命名空间 redis-node</p> 
<pre><code class="language-bash">kubectl create cm redis-node</code></pre> 
<pre><code class="language-bash">apiVersion: v1
data:
  redis.conf: |-
    #heian
    bind 0.0.0.0
    protected-mode yes
    port 6379
    tcp-backlog 511
    timeout 0
    tcp-keepalive 300
    daemonize no
    supervised no
    pidfile /var/run/redis_6379.pid
    loglevel notice
    logfile /var/log/redis.log
    databases 16
    save 900 1
    save 300 10
    save 60 10000
    stop-writes-on-bgsave-error yes
    rdbcompression yes
    rdbchecksum yes
    dbfilename dump.rdb
    dir /data
    slave-serve-stale-data yes
    slave-read-only yes
    repl-diskless-sync no
    repl-diskless-sync-delay 5
    repl-disable-tcp-nodelay no
    slave-priority 100
    appendonly no
    appendfilename "appendonly.aof"
    appendfsync everysec
    no-appendfsync-on-rewrite no
    auto-aof-rewrite-percentage 100
    auto-aof-rewrite-min-size 64mb
    aof-load-truncated yes
    lua-time-limit 5000
    slowlog-log-slower-than 10000
    slowlog-max-len 128
    latency-monitor-threshold 0
    notify-keyspace-events ""
    hash-max-ziplist-entries 512
    hash-max-ziplist-value 64
    list-max-ziplist-size -2
    list-compress-depth 0
    set-max-intset-entries 512
    zset-max-ziplist-entries 128
    zset-max-ziplist-value 64
    hll-sparse-max-bytes 3000
    activerehashing yes
    client-output-buffer-limit normal 0 0 0
    client-output-buffer-limit slave 256mb 64mb 60
    client-output-buffer-limit pubsub 32mb 8mb 60
    hz 10
    aof-rewrite-incremental-fsync yes
kind: ConfigMap
metadata:
  name: redis-conf
  namespace: redis-node</code></pre> 
<h3>(3)编写单个redis的yaml文件</h3> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: redis-single-node
  name: redis-single-node
  namespace: redis-node
spec:
  progressDeadlineSeconds: 600
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: redis-single-node
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: redis-single-node
    spec:
      containers:
      - command:
        - sh
        - -c
        - redis-server "/mnt/redis.conf"
        env:
        - name: TZ
          value: Asia/Shanghai
        - name: LANG
          value: C.UTF-8
        image: redis:5.0.4-alpine
        imagePullPolicy: IfNotPresent
        lifecycle: {}
        livenessProbe:
          failureThreshold: 2
          initialDelaySeconds: 10
          periodSeconds: 10
          successThreshold: 1
          tcpSocket:
            port: 6379
          timeoutSeconds: 2
        name: redis-single-node
        ports:
        - containerPort: 6379
          name: web
          protocol: TCP
        readinessProbe:
          failureThreshold: 2
          initialDelaySeconds: 10
          periodSeconds: 10
          successThreshold: 1
          tcpSocket:
            port: 6379
          timeoutSeconds: 2
        resources:
          limits:
            cpu: 100m
            memory: 339Mi
          requests:
            cpu: 10m
            memory: 10Mi
        securityContext:
          privileged: false
          runAsNonRoot: false
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /usr/share/zoneinfo/Asia/Shanghai
          name: tz-config
        - mountPath: /etc/localtime
          name: tz-config
        - mountPath: /etc/timezone
          name: timezone
        - mountPath: /mnt
          name: redis-conf
          readOnly: true
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
      tolerations:
      - effect: NoExecute
        key: node.kubernetes.io/unreachable
        operator: Exists
        tolerationSeconds: 30
      - effect: NoExecute
        key: node.kubernetes.io/not-ready
        operator: Exists
        tolerationSeconds: 30
      volumes:
      - hostPath:
          path: /usr/share/zoneinfo/Asia/Shanghai
          type: ""
        name: tz-config
      - hostPath:
          path: /etc/timezone
          type: ""
        name: timezone
      - configMap:
          defaultMode: 420
          name: redis-conf
        name: redis-conf
</code></pre> 
<p>因为修改configmap，不会自动更新，需要删除容器才会重新加载。我这边尝试挂载configmap为文件，指定启动配置文件</p> 
<p><img alt="" height="205" src="https://img-blog.csdnimg.cn/2021030910361041.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="687"></p> 
<h3>(4)暴露端口，service</h3> 
<p>这边我做了service暴露。用的ClusterIP，接下来可以通过ingress包这个ip通过域名映射出去</p> 
<pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  labels:
    app: redis-single-node
spec:
  ports:
  - name: redis-port
    port: 6379
    protocol: TCP
    targetPort: 6379
  selector:
    app: redis-single-node
  sessionAffinity: None
  type: ClusterIP</code></pre> 
<p><img alt="" height="166" src="https://img-blog.csdnimg.cn/20210309105037391.png" width="788"></p>
                ]]></description></item><item><title>Kubernetes搭建RooK+Ceph</title><link>http://www.cnblogs.com/heian99/archive/2021/03/08/14508309.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 08 Mar 2021 14:05:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/08/14508309.html</guid><description><![CDATA[
                    <p style="margin-left:0cm;">Rook：</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个自我管理的分布式存储编排系统，它本身并不是存储系统，在存储和k8s之前搭建了一个桥梁，存储系统的搭建或者维护变得特别简单，Rook支持CSI，CSI做一些PVC的快照、PVC扩容等操作。</p> 
<p>Rook是专用于Cloud-Native环境的文件、块、对象存储服务。它实现了一个自我管理的、自我扩容的、自我修复的分布式存储服务。</p> 
<p>Rook支持自动部署、启动、配置、分配（provisioning）、扩容/缩容、升级、迁移、灾难恢复、监控，以及资源管理。 为了实现所有这些功能，Rook依赖底层的容器编排平台。</p> 
<p>目前Rook仍然处于Alpha版本，初期专注于Kubernetes+Ceph。Ceph是一个分布式存储系统，支持文件、块、对象存储，在生产环境中被广泛应用。</p> 
<p style="margin-left:0cm;"><img alt="" src="https://img-blog.csdnimg.cn/20190104133544110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ldHdvcmtlbg==,size_16,color_FFFFFF,t_70"></p> 
<p style="margin-left:0cm;"><img alt="" height="494" src="https://img-blog.csdnimg.cn/20210308105542765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="958"></p> 
<p style="margin-left:0cm;">Operator：主要用于有状态的服务，或者用于比较复杂应用的管理。</p> 
<p style="margin-left:0cm;">Helm：主要用于无状态的服务，配置分离。&nbsp;</p> 
<p style="margin-left:0cm;">Rook：</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Agent：在每个存储节点上运行，用于配置一个FlexVolume插件，和k8s的存储卷进行集成。挂载网络存储、加载存储卷、格式化文件系统。</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Discover：主要用于检测链接到存储节点上的存储设备。</p> 
<p style="margin-left:0cm;">Ceph：</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OSD：直接连接每一个集群节点的物理磁盘或者是目录。集群的副本数、高可用性和容错性。</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MON：集群监控，所有集群的节点都会向Mon汇报。他记录了集群的拓扑以及数据存储位置的信息。</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MDS：元数据服务器，负责跟踪文件层次结构并存储ceph元数据。</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RGW：restful API接口。</p> 
<p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MGR：提供额外的监控和界面。</p> 
<p style="margin-left:0cm;">Rook 官方文档:<a href="https://rook.io/docs/rook/v1.5/ceph-quickstart.html">https://rook.io/docs/rook/v1.5/ceph-quickstart.html</a></p> 
<p style="margin-left:0cm;"><strong>环境部署</strong></p> 
<pre><code class="language-bash">git clone --single-branch --branch v1.5.8 https://github.com/rook/rook.git
cd rook/cluster/examples/kubernetes/ceph
kubectl create -f crds.yaml -f common.yaml -f operator.yaml

修改cluster.yaml文件
kubectl create -f cluster.yaml</code></pre> 
<pre><code class="language-bash">  vim cluster.yaml

  storage: # cluster level storage configuration and selection
    useAllNodes: false #所有结节为存储节点，改为false
    useAllDevices: false  #使用所有的磁盘   改为false



    nodes:
    - name: "k8s-node02"
      devices: # specific devices to use for storage can be specified for each node
      - name: "sdb"  #k8s-node02新加的裸盘
    - name: "k8s-node01"
      directories:
      - path: "/data/ceph"

</code></pre> 
<p style="margin-left:0cm;"><img alt="" height="144" src="https://img-blog.csdnimg.cn/20210308114814270.png" width="656"></p> 
<p style="margin-left:0cm;"><img alt="" height="499" src="https://img-blog.csdnimg.cn/20210308124554144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="324" src="https://img-blog.csdnimg.cn/20210308124742127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="926"></p> 
<p style="margin-left:0cm;"><strong><a href="https://rook.io/docs/rook/v1.5/ceph-dashboard.html">r</a>ook的<a href="https://rook.io/docs/rook/v1.5/ceph-dashboard.html">dashboard</a>：</strong>&nbsp;&nbsp;<a href="https://rook.io/docs/rook/v1.5/ceph-dashboard.html">https://rook.io/docs/rook/v1.5/ceph-dashboard.html</a></p> 
<p style="margin-left:0cm;">&nbsp;</p> 
<pre><code class="language-bash">kubectl -n rook-ceph get service
NAME                         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
rook-ceph-mgr                ClusterIP   10.108.111.192   &lt;none&gt;        9283/TCP         3h
rook-ceph-mgr-dashboard      ClusterIP   10.110.113.240   &lt;none&gt;        8443/TCP         3h</code></pre> 
<p style="margin-left:0cm;">第一项服务用于报告<a href="https://rook.io/docs/rook/v1.5/ceph-monitoring.html">Prometheus指标</a>，而后一项服务用于仪表板。如果您在集群中的节点上，则可以通过使用服务的DNS名称<code class="language-plaintext">https://rook-ceph-mgr-dashboard-https:8443</code>或通过连接到集群IP（在本示例中为）来连接到仪表板<code class="language-plaintext">https://10.110.113.240:8443</code>。或者使用NodePort暴露端口使用</p> 
<p style="margin-left:0cm;"><strong>查询密码</strong></p> 
<pre><code class="language-bash">kubectl -n rook-ceph get secret rook-ceph-dashboard-password -o jsonpath="{['data']['password']}" | base64 --decode &amp;&amp; echo</code></pre> 
<p style="margin-left:0cm;">&nbsp;</p> 
<p style="margin-left:0cm;"><img alt="" height="835" src="https://img-blog.csdnimg.cn/20210308175946763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p style="margin-left:0cm;">&nbsp;</p> 
<p style="margin-left:0cm;"><img alt="" height="416" src="https://img-blog.csdnimg.cn/20210308220450364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="729"></p>
                ]]></description></item><item><title>Kubernetes的服务质量（QoS）</title><link>http://www.cnblogs.com/heian99/archive/2021/03/07/14496155.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 07 Mar 2021 09:40:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/07/14496155.html</guid><description><![CDATA[
                    <h3 id="一、什么是qos">一、什么是Qos</h3> 
<pre><code>   QoS类是Kubernetes用来决定Pod的调度和驱逐的策略
   本文介绍怎样配置Pod让其获得特定的服务质量（QoS）类</code></pre> 
<h3 id="二、qos级别">二、QoS级别</h3> 
<p>2.1、QoS级别</p> 
<ul><li>Guaranteed：POD中所有容器都必须统一设置了limits，并且设置参数都一致，如果有一个容器要设置requests，那么所有容器都要设置，并设置参数同limits一致</li><li>Burstable：POD中只要有一个容器，这个容器requests和limits的设置同其他容器设置的不一致</li><li>BestEffort：POD中的所有容器都没有指定CPU和内存的requests和limits</li></ul>
<p><strong>删除策略</strong>：先删除服务质量为BestEffort，然后在删除Burstable，Guaranteed最后被删除</p> 
<h3 id="三、举例说明">三、举例说明</h3> 
<p>3.0、创建命名空间</p> 
<p>创建一个命名空间，以便将本练习所创建的资源与集群的其余资源相隔离</p> 
<pre><code class="language-bash">kubectl create namespace qos-example</code></pre> 
<h2 id="创建一个-qos-类为-guaranteed-的-pod">创建一个 QoS 类为 Guaranteed 的 Pod</h2> 
<p>对于 QoS 类为 Guaranteed 的 Pod：</p> 
<ul><li>Pod 中的每个容器，包含初始化容器，必须指定内存请求和内存限制，并且两者要相等。</li><li>Pod 中的每个容器，包含初始化容器，必须指定 CPU 请求和 CPU 限制，并且两者要相等。</li></ul>
<p>下面是包含一个容器的 Pod 配置文件。 容器设置了内存请求和内存限制，值都是 200 MiB。 容器设置了 CPU 请求和 CPU 限制，值都是 700 milliCPU：</p> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: qos-demo
  namespace: qos-example
spec:
  containers:
  - name: qos-demo-ctr
    image: nginx
    resources:
      limits:
        memory: "200Mi"
        cpu: "700m"
      requests:
        memory: "200Mi"
        cpu: "700m"</code></pre> 
<p><img alt="" height="249" src="https://img-blog.csdnimg.cn/20210307173437930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="529">&nbsp;</p> 
<p><img alt="" height="310" src="https://img-blog.csdnimg.cn/20210307173413111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="561"></p> 
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Guaranteed。 结果也确认了 Pod 容器设置了与内存限制匹配的内存请求，设置了与 CPU 限制匹配的 CPU 请求。</p> 
<pre><code class="language-bash">root@k8s-master01 ~]# kubectl get pod qos-demo --namespace=qos-example --output=yaml
spec:
  containers:
  - image: nginx:1.15.2
    imagePullPolicy: IfNotPresent
    name: qos-demo-ctr
    resources:
      limits:
        cpu: 700m
        memory: 200Mi
      requests:
        cpu: 700m
        memory: 200Mi
  ............
status:
  qosClass: Guaranteed 
# 4、删除Pod
[root@k8s-master01 ~]# kubectl delete pod qos-demo --namespace=qos-example
pod "qos-demo" deleted</code></pre> 
<p><strong>说明：</strong>&nbsp;如果容器指定了自己的内存限制，但没有指定内存请求，Kubernetes 会自动为它指定与内存限制匹配的内存请求。 同样，如果容器指定了自己的 CPU 限制，但没有指定 CPU 请求，Kubernetes 会自动为它指定与 CPU 限制匹配的 CPU 请求</p> 
<p>3.2、创建一个 QoS 类为 Burstable 的 Pod</p> 
<p>如果满足下面条件，将会指定 Pod 的 QoS 类为 Burstable：</p> 
<ul><li>Pod 不符合 Guaranteed QoS 类的标准。</li><li>Pod 中至少一个容器具有内存或 CPU 请求。</li></ul>
<p>下面是包含一个容器的 Pod 配置文件。 容器设置了内存限制 200 MiB 和内存请求 100 MiB。</p> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: qos-demo-2
  namespace: qos-example
spec:
  containers:
  - name: qos-demo-2-ctr
    image: nginx
    resources:
      limits:
        memory: "200Mi"
      requests:
        memory: "100Mi"

# 结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Guaranteed。 结果也确认了 Pod 容器设置了与内存限制匹配的内存请求，设置了与 CPU 限制匹配的 CPU 请求。
spec:
  containers:
    ...
    resources:
      limits:
        cpu: 700m
        memory: 200Mi
      requests:
        cpu: 700m
        memory: 200Mi
  ......
status:
  qosClass: Guaranteed</code></pre> 
<p>3.3、创建一个 QoS 类为 BestEffort 的 Pod</p> 
<ul><li>对于 QoS 类为 BestEffort 的 Pod，Pod 中的容器必须没有设置内存和 CPU 限制或请求</li></ul>
<p>下面是包含一个容器的 Pod 配置文件。 容器没有设置内存和 CPU 限制或请求。</p> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: qos-demo-3
  namespace: qos-example
spec:
  containers:
  - name: qos-demo-3-ctr
    image: nginx
    
# 结果表明 Kubernetes 为 Pod 配置的 QoS 类为 BestEffort。
spec:
  containers:
    ...
    resources: {}
  ...
status:
  qosClass: BestEffort</code></pre> 
<p>3.4、创建包含两个容器的 Pod</p> 
<p>下面是包含两个容器的 Pod 配置文件。 一个容器指定了内存请求 200 MiB。 另外一个容器没有指定任何请求和限制。</p> 
<pre><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: qos-demo-4
  namespace: qos-example
spec:
  containers:

  - name: qos-demo-4-ctr-1
    image: nginx
    resources:
      requests:
        memory: "200Mi"

  - name: qos-demo-4-ctr-2
    image: redis
    
# 结果表明
spec:
  containers:
    ...
    name: qos-demo-4-ctr-1
    resources:
      requests:
        memory: 200Mi
    ...
    name: qos-demo-4-ctr-2
    resources: {}
    ...
status:
  qosClass: Burstable</code></pre> 
<p>注意此 Pod 满足 Burstable QoS 类的标准。 也就是说它不满足 Guaranteed QoS 类标准，因为它的一个容器设有内存请求。</p> 
<p>&nbsp;</p> 
<p>原文地址：<a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/quality-service-pod/">https://kubernetes.io/zh/docs/tasks/configure-pod-container/quality-service-pod/</a></p>
                ]]></description></item><item><title>Kubernetes准入控制</title><link>http://www.cnblogs.com/heian99/archive/2021/03/07/14496156.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 07 Mar 2021 05:37:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/07/14496156.html</guid><description><![CDATA[
                    <h3 id="一、什么是k8s之准入控制">一、什么是K8S之准入控制</h3> 
<pre><code>   就是在创建资源经过身份验证之后，kube-apiserver在数据写入etcd之前做一次拦截，然后对资源进行更改、判断正确性等操作。</code></pre> 
<p>一个&nbsp;<em>LimitRange（限制范围）</em>&nbsp;对象提供的限制能够做到：</p> 
<ul><li>在一个命名空间中实施对每个 Pod 或 Container 最小和最大的资源使用量的限制。</li><li>在一个命名空间中实施对每个 PersistentVolumeClaim 能申请的最小和最大的存储空间大小的限制。</li><li>在一个命名空间中实施对一种资源的申请值和限制值的比值的控制。</li><li>设置一个命名空间中对计算资源的默认申请/限制值，并且自动的在运行时注入到多个 Container 中。</li></ul>
<h3 id="二、启用-limitrang">二、启用 LimitRang</h3> 
<ul><li>对 LimitRange 的支持自 Kubernetes 1.10 版本默认启用。</li><li>LimitRange 支持在很多 Kubernetes 发行版本中也是默认启用的。</li><li>LimitRange 的名称必须是合法的&nbsp;<a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">DNS 子域名</a>。</li></ul>
<h3 id="三、限制范围总览">三、限制范围总览</h3> 
<ul><li>管理员在一个命名空间内创建一个&nbsp;<code>LimitRange</code>&nbsp;对象。</li><li>用户在命名空间内创建 Pod ，Container 和 PersistentVolumeClaim 等资源。</li><li><code>LimitRanger</code>&nbsp;准入控制器对所有没有设置计算资源需求的 Pod 和 Container 设置默认值与限制值， 并跟踪其使用量以保证没有超出命名空间中存在的任意 LimitRange 对象中的最小、最大资源使用量以及使用量比值。</li><li>若创建或更新资源（Pod、 Container、PersistentVolumeClaim）违反了 LimitRange 的约束， 向 API 服务器的请求会失败，并返回 HTTP 状态码&nbsp;<code>403 FORBIDDEN</code>&nbsp;与描述哪一项约束被违反的消息。</li><li>若命名空间中的 LimitRange 启用了对&nbsp;<code>cpu</code>&nbsp;和&nbsp;<code>memory</code>&nbsp;的限制， 用户必须指定这些值的需求使用量与限制使用量。否则，系统将会拒绝创建 Pod。</li><li>LimitRange 的验证仅在 Pod 准入阶段进行，不对正在运行的 Pod 进行验证。</li></ul>
<p>能够使用限制范围创建的策略示例有：</p> 
<ul><li>在一个有两个节点，8 GiB 内存与16个核的集群中，限制一个命名空间的 Pod 申请 100m 单位，最大 500m 单位的 CPU，以及申请 200Mi，最大 600Mi 的内存。</li><li>为 spec 中没有 cpu 和内存需求值的 Container 定义默认 CPU 限制值与需求值 150m，内存默认需求值 300Mi。</li></ul>
<p>在命名空间的总限制值小于 Pod 或 Container 的限制值的总和的情况下，可能会产生资源竞争。 在这种情况下，将不会创建 Container 或 Pod。</p> 
<p><strong>竞争和对 LimitRange 的改变都不会影响任何已经创建了的资源</strong></p> 
<h3 id="四、配置limitrange（对pod进行配置、限额）">四、配置LimitRange（对Pod进行配置、限额）</h3> 
<p>4.1、配置 CPU 最小和最大约束</p> 
<pre><code># 创建一个命名空间，以便本练习中创建的资源和集群的其余资源相隔离
[root@k8s-master01 ~]# kubectl create namespace constraints-cpu-example
namespace/constraints-cpu-example created</code></pre> 
<pre><code class="language-bash"># 1、LimitRange 的配置文件
[root@k8s-master01 ~]# cat cpu-constraints.yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-min-max-demo-lr
spec:
  limits:
  - max:
      cpu: "800m"
    min:
      cpu: "200m"
    type: Container
    
# 2、创建 LimitRange:
[root@k8s-master01 ~]# kubectl apply -f  cpu-constraints.yaml -n constraints-cpu-example
limitrange/cpu-min-max-demo-lr created

# 3、查看结果
# 输出结果显示 CPU 的最小和最大限制符合预期。但需要注意的是，尽管你在 LimitRange 的配置文件中你没有声明默认值，默认值也会被自动创建。
[root@k8s-master01 ~]# kubectl get limitrange cpu-min-max-demo-lr --output=yaml --namespace=constraints-cpu-example
# 只列出关键的
spec:
  limits:
  - default:
      cpu: 800m
    defaultRequest:
      cpu: 800m
    max:
      cpu: 800m
    min:
      cpu: 200m
    type: Container</code></pre> 
<p>现在不管什么时候在 constraints-cpu-example 命名空间中创建容器，Kubernetes 都会执行下面这些步骤：</p> 
<ul><li>如果容器没有声明自己的 CPU 请求和限制，将为容器指定默认 CPU 请求和限制。</li><li>核查容器声明的 CPU 请求确保其大于或者等于 200 millicpu。</li><li>核查容器声明的 CPU 限制确保其小于或者等于 800 millicpu。</li></ul>
<p>流程就是说，我们创建了一个namespace=constraints-cpu-example的名称空间，然后在这个名称空间创建了一个LimitRange。然后现在不管什么时候在 constraints-cpu-example 命名空间中创建容器，Kubernetes 都会执行上面那些步骤！我们创建的LimitRange对这个namespace=constraints-cpu-example的名称空间里面起低调Pod都起了限制的作用</p> 
<p>4.2、配置命名空间的最小和最大内存约束</p> 
<p>LimitRange 的配置文件</p> 
<pre><code class="language-bash">apiVersion: v1
kind: LimitRange
metadata:
  name: mem-min-max-demo-lr
spec:
  limits:
  - max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
# 输出显示预期的最小和最大内存约束。 但请注意，即使你没有在 LimitRange 的配置文件中指定默认值，也会自动创建它们。
  limits:
  - default:
      memory: 1Gi
    defaultRequest:
      memory: 1Gi
    max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container</code></pre> 
<p>现在，只要在 constraints-mem-example 命名空间中创建容器，Kubernetes 就会执行下面的步骤：</p> 
<ul><li>如果 Container 未指定自己的内存请求和限制，将为它指定默认的内存请求和限制。</li><li>验证 Container 的内存请求是否大于或等于500 MiB。</li><li>验证 Container 的内存限制是否小于或等于1 GiB。</li></ul>
<p>4.3、配置 CPU 最小和最大约束</p> 
<p>LimitRange 的配置文件</p> 
<pre><code class="language-bash">apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-min-max-demo-lr
spec:
  limits:
  - max:
      cpu: "800m"
    min:
      cpu: "200m"
    type: Container
#  输出结果显示 CPU 的最小和最大限制符合预期。但需要注意的是，尽管你在 LimitRange 的配置文件中你没有声明默认值，默认值也会被自动创建。
  limits:
  - default:
      cpu: 800m
    defaultRequest:
      cpu: 800m
    max:
      cpu: 800m
    min:
      cpu: 200m
    type: Container</code></pre> 
<p>在不管什么时候在 constraints-cpu-example 命名空间中创建容器，Kubernetes 都会执行下面这些步骤：</p> 
<ul><li>如果容器没有声明自己的 CPU 请求和限制，将为容器指定默认 CPU 请求和限制。</li><li>核查容器声明的 CPU 请求确保其大于或者等于 200 millicpu。</li><li>核查容器声明的 CPU 限制确保其小于或者等于 800 millicpu。</li></ul>
<p><strong>说明：</strong>&nbsp;当创建 LimitRange 对象时，你也可以声明大页面和 GPU 的限制。 当这些资源同时声明了 'default' 和 'defaultRequest' 参数时，两个参数值必须相同。</p> 
<h3 id="五、resourcequot（对名称空间进行配置、限额）">五、ResourceQuot（对名称空间进行配置、限额）</h3> 
<p>5.1、配置内存和 CPU 配额</p> 
<pre><code class="language-bash"># 1、创建命名空间，以便本练习中创建的资源和集群的其余部分相隔离。
[root@k8s-master01 ~]# kubectl create namespace quota-mem-cpu-example
namespace/quota-mem-cpu-example created

# 2、创建 ResourceQuota 
[root@k8s-master01 ~]# vim quota-mem-cpu.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: mem-cpu-demo
spec:
  hard:
    requests.cpu: "1"
    requests.memory: 1Gi
    limits.cpu: "2"
    limits.memory: 2Gi

# 3、创建 ResourceQuota
[root@k8s-master01 ~]# kubectl apply -f quota-mem-cpu.yaml -n quota-mem-cpu-example         
resourcequota/mem-cpu-demo created

# 4、查看 ResourceQuota 详情：
[root@k8s-master01 ~]# kubectl get resourcequota mem-cpu-demo --namespace=quota-mem-cpu-example --output=yaml
# 跟我们配置的一样
spec:
  hard:
    limits.cpu: "2"
    limits.memory: 2Gi
    requests.cpu: "1"
    requests.memory: 1Gi</code></pre> 
<p>ResourceQuota 在 quota-mem-cpu-example 命名空间中设置了如下要求：</p> 
<ul><li>每个容器必须有内存请求和限制，以及 CPU 请求和限制。</li><li>所有容器的内存请求总和不能超过1 GiB。</li><li>所有容器的内存限制总和不能超过2 GiB。</li><li>所有容器的 CPU 请求总和不能超过1 cpu。</li><li>所有容器的 CPU 限制总和不能超过2 cpu。</li></ul>
<p><code>也就是在名称空间 quota-mem-cpu-example种创建Pod，必须遵守我们在上面定义的要求</code></p> 
<p>5.1.1、创建 Pod</p> 
<pre><code class="language-bash">cat &gt; quota-mem-cpu-pod.yaml &lt;&lt; EFO
apiVersion: v1
kind: Pod
metadata:
  name: quota-mem-cpu-demo
spec:
  containers:
  - name: quota-mem-cpu-demo-ctr
    image: nginx
    resources:
      limits:
        memory: "800Mi"
        cpu: "800m"
      requests:
        memory: "600Mi"
        cpu: "400m"
EFO 
# create Pod
kubectl apply -f quota-mem-cpu-pod.yaml --namespace=quota-mem-cpu-example

# 查看配额，能看到用了多少
[root@k8s-master01 ~]# kubectl get resourcequota mem-cpu-demo --namespace=quota-mem-cpu-example --output=yaml
spec:
  hard:
    limits.cpu: "2"
    limits.memory: 2Gi
    requests.cpu: "1"
    requests.memory: 1Gi
status:
  hard:
    limits.cpu: "2"
    limits.memory: 2Gi
    requests.cpu: "1"
    requests.memory: 1Gi
  used:
    limits.cpu: 800m
    limits.memory: 800Mi
    requests.cpu: 400m
    requests.memory: 600Mi</code></pre> 
<p>5.1.2、尝试创建第二个 Pod</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# cat  quota-mem-cpu-pod-2.yaml    
apiVersion: v1
kind: Pod
metadata:
  name: quota-mem-cpu-demo-2
spec:
  containers:
  - name: quota-mem-cpu-demo-2-ctr
    image: redis
    resources:
      limits:
        memory: "1Gi"
        cpu: "800m"
      requests:
        memory: "700Mi"
        cpu: "400m"

# 尝试创建        
[root@k8s-master01 ~]# kubectl apply -f  quota-mem-cpu-pod-2.yaml --namespace=quota-mem-cpu-example
Error from server (Forbidden): error when creating "quota-mem-cpu-pod-2.yaml": pods "quota-mem-cpu-demo-2" is forbidden: exceeded quota: mem-cpu-demo, requested: requests.memory=700Mi, used: requests.memory=600Mi, limited: requests.memory=1Gi

# 第二个 Pod 不能被创建成功。输出结果显示创建第二个 Pod 会导致内存请求总量超过内存请求配额。

# 删除你的命名空间：
kubectl delete namespace quota-mem-cpu-example</code></pre> 
<p>5.2、配置命名空间下 Pod 配额</p> 
<p>如何配置一个命名空间下可运行的 Pod 个数配额？</p> 
<pre><code class="language-bash"># 1、创建一个命名空间 
kubectl create namespace quota-pod-example

# 2、创建 ResourceQuota，指定改ns只可以创建2个pod
apiVersion: v1
kind: ResourceQuota
metadata:
  name: pod-demo
spec:
  hard:
    pods: "2"
    
# 3、apply ResourceQuota
kubectl apply -f quota-pod.yaml --namespace=quota-pod-example

# 4、查看资源配额的详细信息：
kubectl get resourcequota pod-demo --namespace=quota-pod-example --output=yaml

# 5、创建Deployment，且replicas是3，那么肯定只有2个Pod能正常运行！自己去试试吧
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pod-quota-demo
spec:
  selector:
    matchLabels:
      purpose: quota-demo
  replicas: 3
  template:
    metadata:
      labels:
        purpose: quota-demo
    spec:
      containers:
      - name: pod-quota-demo
        image: nginx</code></pre> 
<p>中文官网文档：<a href="https://kubernetes.io/zh/docs/concepts/policy/limit-range/">https://kubernetes.io/zh/docs/concepts/policy/limit-range/</a></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes安装Ratel</title><link>http://www.cnblogs.com/heian99/archive/2021/03/07/14496157.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 07 Mar 2021 02:18:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/07/14496157.html</guid><description><![CDATA[
                    <p>Ratel是有杜宽开发一个类似<strong>Kubernetes</strong>-<strong>Dashboard，</strong>功能正在慢慢完善</p> 
<p><a href="https://github.com/dotbalo">dotbalo (dotbalo)杜宽github</a></p> 
<p>ratel地址：<a href="https://github.com/dotbalo/ratel-doc">https://github.com/dotbalo/ratel-doc</a></p> 
<pre><code>    Ratel是一个Kubernetes资源平台，基于管理Kubernetes的资源开发，

    可以管理Kubernetes的Deployment、DaemonSet、StatefulSet、Service、Ingress、Pods、Nodes。

    也可以管理Kubernetes的Role、ClusterRole、Rolebinding、ClusterRoleBinding、Secret、ConfigMap、PV、PVC等。

    立志于基于图形界面管理所有的Kubernetes的资源。</code></pre> 
<h2 id="一、安装ratel">一、安装Ratel</h2> 
<h3><strong>1.1、安装说明</strong></h3> 
<pre><code class="language-bash"> 集群安装配置需要两类文件: servers.yaml和集群管理的kubeconfig文件
    
    servers.yaml是ratel的配置文件, 格式如下:
        - serverName: 'xiqu'
          serverAddress: 'https://1.1.1.1:8443'
          #serverAdminUser: 'xxx'
          #serverAdminPassword: 'xxx#'
          serverAdminToken: 'null'
          serverDashboardUrl: "https://k8s.xxx.com.cn/#"
          production: 'false'
          kubeConfigPath: "/mnt/xxx.config"
          harborConfig: "HarborUrl, HarborUsername, HarborPassword, HarborEmail"
        其中管理的方式有两种(Token暂不支持): 
            账号密码和kubeconfig形式, 只需配置一种即可, kubeconfig优先级高

    参数解析:
        serverName: 集群别名
        serverAddress: Kubernetes APIServer地址
        serverAdminUser: Kubernetes管理员账号(需要配置basic auth)
        serverAdminPassword: Kubernetes管理员密码
        serverAdminToken: Kubernetes管理员Token // 暂不支持
        serverDashboardUrl: Kubernetes官方dashboard地址，1.x版本需要添加/#!，2.x需要添加/#
        kubeConfigPath: Kubernetes kube.config路径(绝对路径)
        harborConfig: 对于多集群管理的情况下，可能会存在不同的harbor仓库，配置此参数可以在拷贝资源的时候自动替换harbor配置
    kubeConfigPath 通过secret挂载到容器的/mnt目录或者其他目录

    本文档是将Ratel安装在Kubernetes集群，如果没有Kubernetes集群，可以参考本人写的另一篇文章，CentOS 8二进制高可用安装Kubernetes集群: https://www.cnblogs.com/dukuan/p/11780729.html</code></pre> 
<h3>1.2 创建Secret</h3> 
<pre><code class="language-bash">假设配置两个集群，对应的kubeconfig是test1.config和test2.config
    ratel配置文件servers.yaml内容如下:
        - serverName: 'test1'
          serverAddress: 'https://1.1.1.1:8443'
          #serverAdminUser: 'xxx'
          #serverAdminPassword: 'xxx#'
          serverAdminToken: 'null'
          serverDashboardUrl: "https://k8s.test1.com.cn/#"
          production: 'false'
          kubeConfigPath: "/mnt/test1.config"
          harborConfig: "HarborUrl, HarborUsername, HarborPassword, HarborEmail"
        - serverName: 'test2'
          serverAddress: 'https://1.1.1.2:8443'
          #serverAdminUser: 'xxx'
          #serverAdminPassword: 'xxx#'
          serverAdminToken: 'null'
          serverDashboardUrl: "https://k8s.test2.com.cn/#!"
          production: 'false'
          kubeConfigPath: "/mnt/test2.config"
          harborConfig: "HarborUrl, HarborUsername, HarborPassword, HarborEmail"
    创建Secret: 
        kubectl create secret generic ratel-config  --from-file=test1.config --from-file=test2.config --from-file=servers.yaml -n kube-system


#test1.config是master的权限配置

cp /root/.kube/config test1.config

我的配置
- serverName: 'test1'
  serverAddress: 'https://192.168.0.100:6443'
  #serverAdminUser: 'xxx'
  #serverAdminPassword: 'xxx#'
  serverAdminToken: 'null'
  serverDashboardUrl: "http://krm.test.com/#"
  production: 'false'
  kubeConfigPath: "/mnt/test1.config"

kubectl create secret generic ratel-config  --from-file=test1.config  --from-file=servers.yaml -n kube-system</code></pre> 
<h3>1.3 创建RBAC</h3> 
<pre><code class="language-bash">创建权限管理namespace
kubectl create ns kube-users

然后添加如下的ClusterroleBinding
vim ratel-rbac.yaml


apiVersion: v1
items:
- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    annotations:
      rbac.authorization.kubernetes.io/autoupdate: "true"
    labels:
      kubernetes.io/bootstrapping: rbac-defaults
      rbac.authorization.k8s.io/aggregate-to-edit: "true"
    name: ratel-namespace-readonly
  rules:
  - apiGroups:
    - ""
    resources:
    - namespaces
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - metrics.k8s.io
    resources:
    - pods
    verbs:
    - get
    - list
    - watch
- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    name: ratel-pod-delete
  rules:
  - apiGroups:
    - ""
    resources:
    - pods
    verbs:
    - get
    - list
    - delete
- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    name: ratel-pod-exec
  rules:
  - apiGroups:
    - ""
    resources:
    - pods
    - pods/log
    verbs:
    - get
    - list
  - apiGroups:
    - ""
    resources:
    - pods/exec
    verbs:
    - create
- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    annotations:
      rbac.authorization.kubernetes.io/autoupdate: "true"
    name: ratel-resource-edit
  rules:
  - apiGroups:
    - ""
    resources:
    - configmaps
    - persistentvolumeclaims
    - services
    - services/proxy
    verbs:
    - patch
    - update
  - apiGroups:
    - apps
    resources:
    - daemonsets
    - deployments
    - deployments/rollback
    - deployments/scale
    - statefulsets
    - statefulsets/scale
    verbs:
    - patch
    - update
  - apiGroups:
    - autoscaling
    resources:
    - horizontalpodautoscalers
    verbs:
    - patch
    - update
  - apiGroups:
    - batch
    resources:
    - cronjobs
    - jobs
    verbs:
    - patch
    - update
  - apiGroups:
    - extensions
    resources:
    - daemonsets
    - deployments
    - deployments/rollback
    - deployments/scale
    - ingresses
    verbs:
    - patch
    - update
- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    name: ratel-resource-readonly
  rules:
  - apiGroups:
    - ""
    resources:
    - configmaps
    - endpoints
    - persistentvolumeclaims
    - pods
    - replicationcontrollers
    - replicationcontrollers/scale
    - serviceaccounts
    - services
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - bindings
    - events
    - limitranges
    - namespaces/status
    - pods/log
    - pods/status
    - replicationcontrollers/status
    - resourcequotas
    - resourcequotas/status
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - namespaces
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - apps
    resources:
    - controllerrevisions
    - daemonsets
    - deployments
    - deployments/scale
    - replicasets
    - replicasets/scale
    - statefulsets
    - statefulsets/scale
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - autoscaling
    resources:
    - horizontalpodautoscalers
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - batch
    resources:
    - cronjobs
    - jobs
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - extensions
    resources:
    - daemonsets
    - deployments
    - deployments/scale
    - ingresses
    - networkpolicies
    - replicasets
    - replicasets/scale
    - replicationcontrollers/scale
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - policy
    resources:
    - poddisruptionbudgets
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - networking.k8s.io
    resources:
    - networkpolicies
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - metrics.k8s.io
    resources:
    - pods
    verbs:
    - get
    - list
    - watch
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""</code></pre> 
<pre><code class="language-bash">kubectl create -f ratel-rbac.yaml</code></pre> 
<pre><code class="language-bash">vim ratel-rbac-binding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: ratel-namespace-readonly-sa
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ratel-namespace-readonly
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:serviceaccounts:kube-users
  
  kubectl create -f ratel-rbac-binding.yaml</code></pre> 
<h3>1.4 部署ratel</h3> 
<pre><code>    ratel的部署文件内容如下:</code></pre> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
        app: ratel
  name: ratel
  namespace: kube-system
spec:
  replicas: 1
  selector:
	matchLabels:
	  app: ratel
  strategy:
	rollingUpdate:
	  maxSurge: 1
	  maxUnavailable: 0
	type: RollingUpdate
  template:
	metadata:
	  creationTimestamp: null
	  labels:
		app: ratel
	spec:
	  containers:
		- command:
			- sh
			- -c
			- ./ratel -c /mnt/servers.yaml
		  env:
			- name: TZ
			  value: Asia/Shanghai
			- name: LANG
			  value: C.UTF-8
			- name: ProRunMode
			  value: prod
			- name: ADMIN_USERNAME
			  value: admin
			- name: ADMIN_PASSWORD
			  value: password
		  image: registry.cn-beijing.aliyuncs.com/dotbalo/ratel:latest
		  imagePullPolicy: Always
		  livenessProbe:
			failureThreshold: 2
			initialDelaySeconds: 10
			periodSeconds: 60
			successThreshold: 1
			tcpSocket:
			  port: 8888
			timeoutSeconds: 2
		  name: ratel
		  ports:
			- containerPort: 8888
			  name: web
			  protocol: TCP
		  readinessProbe:
			failureThreshold: 2
			initialDelaySeconds: 10
			periodSeconds: 60
			successThreshold: 1
			tcpSocket:
			  port: 8888
			timeoutSeconds: 2
		  resources:
			limits:
			  cpu: 500m
			  memory: 512Mi
			requests:
			  cpu: 500m
			  memory: 512Mi
		  volumeMounts:
			- mountPath: /mnt
			  name: ratel-config
	  dnsPolicy: ClusterFirst
#     imagePullSecrets:
#       - name: myregistrykey
	  restartPolicy: Always
	  schedulerName: default-scheduler
	  securityContext: {}
	  terminationGracePeriodSeconds: 30
	  volumes:
		- name: ratel-config
		  secret:
			defaultMode: 420
			secretName: ratel-config


    需要更改的内容如下:
        ProRunMode: 区别在于dev模式打印的是debug日志, 其他模式是info级别的日志, 实际使用时应该配置为非dev
        ADMIN_USERNAME: ratel自己的管理员账号
        ADMIN_PASSWORD: ratel自己的管理员密码
        实际使用时账号密码应满足复杂性要求,因为ratel可以直接操作所有配置的资源。
        其他无需配置, 端口配置暂不支持。</code></pre> 
<h3>1.5 Service和Ingress配置</h3> 
<p>注意：如果没有安装ingress controller，需要把type: ClusterIP改成type: NodePort，然后通过主机IP+Port进行访问</p> 
<pre><code class="language-bash">创建ratel Service的文件如下:
apiVersion: v1
kind: Service
metadata:
  labels:
    app: ratel
  name: ratel
  namespace: kube-system
spec:
  ports:
    - name: container-1-web-1
      port: 8888
      protocol: TCP
      targetPort: 8888
  selector:
    app: ratel
  type: ClusterIP

创建ratel Ingress: 


apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ratel
  namespace: kube-system
  labels:
        app: ratel
spec:
  rules:
  - host: krm.test.com
    http:
      paths:
      - backend:
          serviceName: ratel
          servicePort: 8888
        path: /
</code></pre> 
<h3>1.6 访问ratel</h3> 
<p>注意：如果没有安装ingress controller，需要把type: ClusterIP改成type: NodePort，然后通过主机IP+Port进行访问</p> 
<pre><code>    通过Ingress配置的krm.test.com/ratel访问，ratel登录页如下:</code></pre> 
<p><img alt="" height="893" src="https://img-blog.csdnimg.cn/20210307101611564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="914" src="https://img-blog.csdnimg.cn/20210307101631822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Docker无法访问gcr.io的几种解决办法</title><link>http://www.cnblogs.com/heian99/archive/2021/03/06/14496158.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 06 Mar 2021 14:47:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/06/14496158.html</guid><description><![CDATA[
                    <p>&nbsp;</p> 
<p>由于一些原因,在国内无法访问gcr.io上的镜像,在安装kubernetes时经常访问阿里云的地址。面结合实际经验,列举出几种常用的办法来解决这个问题！</p> 
<h3 id="一、使用阿里云镜像地址">一、使用阿里云镜像地址</h3> 
<pre><code>地址一：registry.aliyuncs.com/google_containers
地址二：registry.cn-hangzhou.aliyuncs.com/google_containers</code></pre> 
<p>&nbsp;</p> 
<h3 id="二、使用dockerhub下的mirrorgooglecontainers">二、使用dockerhub下的<code>mirrorgooglecontainers</code></h3> 
<p>​ 这个域名下同步了很多谷歌镜像,比如说要下载<code>gcr.io/google_containers/coredns:1.7.0</code>,</p> 
<p>可以使用<code>docker pull mirrorgooglecontainers/coredns:1.7.0</code>来进行下载,下载以后对镜像重新打标签:</p> 
<pre><code class="language-bash"># 1、先pull下来
[root@k8s-master01 Ratel]# docker pull mirrorgooglecontainers/kube-proxy-amd64:v1.11.3
v1.11.3: Pulling from mirrorgooglecontainers/kube-proxy-amd64
06545d1c6152: Pull complete 
d5f5a75f5817: Pull complete 
c21dcda023ab: Pull complete 
Digest: sha256:cd0c257e3f4a79a0ae7964b3429c491e9d43bf1bb015618a4c311165d3915b7b
Status: Downloaded newer image for mirrorgooglecontainers/kube-proxy-amd64:v1.11.3
docker.io/mirrorgooglecontainers/kube-proxy-amd64:v1.11.3

# 2、重新打标签
[root@k8s-master01 Ratel]# docker tag docker.io/mirrorgooglecontainers/kube-proxy-amd64:v1.11.3   k8s.gcr.io/kube-proxy-amd64:v1.11.3

# 3、查看镜像，然后就可以直接使用这个镜像了
[root@k8s-master01 Ratel]# docker images | grep k8s.gcr.io/kube-proxy-amd64
k8s.gcr.io/kube-proxy-amd64                                       v1.11.3   be5a6e1ecfa6   2 years ago     97.8MB</code></pre> 
<h3 id="三、使用国内作者制作的gcrio镜像安装工具">三、使用国内作者制作的gcr.io镜像安装工具</h3> 
<pre><code class="language-bash">项目地址: https://github.com/zhangguanzhang/gcr.io</code></pre> 
<p>3.0、使用search命令的时候,如果没有安装jq则会提示安装jq.jq在centos下安装方法:</p> 
<ul><li>安装EPEL源：</li></ul>
<pre><code>[root@k8s-master01 ~]# yum install epel-release
</code></pre> 
<ul><li>安装完EPEL源后，可以查看下jq包是否存在：</li></ul>
<pre><code>[root@k8s-master01 ~]# yum list jq
</code></pre> 
<ul><li>安装jq：</li></ul>
<pre><code>[root@k8s-master01 ~]# yum install jq -y</code></pre> 
<p>3.1、查询namespace</p> 
<pre><code>[root@k8s-master01 ~]# curl -s https://zhangguanzhang.github.io/bash/pull.sh | bash -s search gcr.io
cloud-builders
cloud-datalab
cloudsql-docker
distroless
google-appengine
google-samples
google_containers
google_samples
heptio-images
</code></pre> 
<p>3.2、查询某一名称空间下镜像列表</p> 
<pre><code>[root@k8s-master01 ~]# curl -s https://zhangguanzhang.github.io/bash/pull.sh | bash -s search gcr.io/google_containers
# gcr.io/google_containers ---&gt; namespace ——————&gt; 根据上面查询出来的namespace查
addon-builder
addon-resizer-amd64
addon-resizer-arm
addon-resizer-arm64
addon-resizer-ppc64le
addon-resizer-s390x
addon-resizer
aggregator
alpine-iptables-amd64
alpine-iptables-arm
alpine-iptables-arm64</code></pre> 
<p>3.3、查询某一镜像的版本所有版本tag</p> 
<pre><code>[root@k8s-master01 ~]# curl -s https://zhangguanzhang.github.io/bash/pull.sh | bash -s search gcr.io/google_containers/coredns 

# 在namespace后面搜索image的版本tag
1.0.1
1.0.1__amd64_linux
1.0.1__arm64_linux
1.0.1__arm_linux
1.0.1__ppc64le_linux
1.0.1__s390x_linux
1.0.6
1.0.6__amd64_linux
1.0.6__arm64_linux
1.0.6__arm_linux
1.0.6__ppc64le_linux
1.0.6__s390x_linux
1.1.3
1.1.3__amd64_linux</code></pre> 
<p>原文地址：<a href="https://www.cnblogs.com/tylerzhou/p/10971341.html">https://www.cnblogs.com/tylerzhou/p/10971341.html</a>&nbsp;</p>
                ]]></description></item><item><title>Kubernetes认证之RBAC</title><link>http://www.cnblogs.com/heian99/archive/2021/03/06/14496159.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 06 Mar 2021 14:16:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/03/06/14496159.html</guid><description><![CDATA[
                    <h3 id="一、什么是rbac？">一、什么是RBAC？</h3> 
<blockquote> 
 <p>&nbsp;&nbsp; &nbsp;Role-based access control(RBAC)基于企业内个人用户属于角色来访问计算和网络的常规访问控制方法。<br> &nbsp;&nbsp; &nbsp;简单理解为权限与角色关联，用户通过成为角色的成员来得到角色的权限。K8S的RBAC使用rbac.authorization.k8s.io/v1 API组驱动认证决策，准许管理员通过API动态配置策略。为了启用RBAC，需要在apiserver启动参数添加--authorization-mode=RBAC。目前支持RBAC,ABAC(基于属性的访问控制)，Node（默认node和apiserver就是采用这种模式）,Webhook。</p> 
</blockquote> 
<h3 id="二、rbac分类介绍（api-对象）">二、RBAC分类介绍（API 对象）</h3> 
<p>2.1、RBAC有4种顶级资源</p> 
<ul><li>Role</li><li>ClusterRole</li><li>RoleBinding</li><li>ClusterRoleBinding</li></ul>
<p>2.2、资源介绍</p> 
<p><strong>Role</strong>：角色，包含一组权限的规则。没有拒绝规则，只是附加允许。Namespace隔离，只作用于命名空间内！</p> 
<p><strong>ClusterRole</strong>：集群角色，和Role一样。和Role的区别，Role是只作用于命名空间内，ClusterRole作用于整个集群！</p> 
<p><strong>RoleBinding</strong>：作用于命令空间内，将ClusterRole或者Role绑定到User、Group、ServiceAccount！</p> 
<p><strong>ClusterRoleBinding</strong>：作用于整个集群。</p> 
<p><strong>中文官方文档</strong>：<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/">https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/</a></p> 
<h3 id="三、示例">三、示例</h3> 
<p>3.1、Role 示例</p> 
<p>Role 总是用来在某个名字空间内设置访问权限；在你创建 Role 时，你必须指定该 Role 所属的名字空间</p> 
<pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""] # "" 标明 core API 组
  resources: ["pods"]
  verbs: ["get", "watch", "list"]</code></pre> 
<p>3.2、ClusterRole 示例</p> 
<p>ClusterRole 有若干用法。你可以用它来：</p> 
<ol><li>定义对某名字空间域对象的访问权限，并将在各个名字空间内完成授权；</li><li>为名字空间作用域的对象设置访问权限，并跨所有名字空间执行授权；</li><li>为集群作用域的资源定义访问权限。</li></ol>
<pre><code class="language-bash">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  # "namespace" 被忽略，因为 ClusterRoles 不受名字空间限制
  name: secret-reader
rules:
- apiGroups: [""]
  # 在 HTTP 层面，用来访问 Secret 对象的资源的名称为 "secrets"
  resources: ["secrets"]
  verbs: ["get", "watch", "list"]</code></pre> 
<p>3.3、RoleBinding 示例</p> 
<p>下面的例子中的 RoleBinding 将 "pod-reader" Role 授予在 "default" 名字空间中的用户 "jane"。 这样，用户 "jane" 就具有了读取 "default" 名字空间中 pods 的权限。</p> 
<pre><code class="language-bash">apiVersion: rbac.authorization.k8s.io/v1
# 此角色绑定允许 "jane" 读取 "default" 名字空间中的 Pods
kind: RoleBinding
metadata:
  name: read-pods
  namespace: default
subjects:
# 你可以指定不止一个“subject（主体）”
- kind: User # 这里可以是User,Group,ServiceAccount
  name: jane # "name" 是不区分大小写的
  apiGroup: rbac.authorization.k8s.io
roleRef:
  # "roleRef" 指定与某 Role 或 ClusterRole 的绑定关系
  kind: Role # 此字段必须是 Role 或 ClusterRole
  name: pod-reader     # 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配
  apiGroup: rbac.authorization.k8s.io</code></pre> 
<p>3.3.1、RoleBinding 引用 ClusterRole</p> 
<p>RoleBinding 也可以引用 ClusterRole，以将对应 ClusterRole 中定义的访问权限授予 RoleBinding 所在名字空间的资源。这种引用使得你可以跨整个集群定义一组通用的角色， 之后在多个名字空间中复用！</p> 
<p>下面的例子中的 RoleBinding，将"secret-reader" ClusterRole授予在"development" namespace中的用户"dave"。这样，用户 "dave" 就具有了读取 "development" 名字空间中 pods 的权限。</p> 
<pre><code class="language-bash">apiVersion: rbac.authorization.k8s.io/v1
# 此角色绑定使得用户 "dave" 能够读取 "default" 名字空间中的 Secrets
# 你需要一个名为 "secret-reader" 的 ClusterRole
kind: RoleBinding
metadata:
  name: read-secrets
  # RoleBinding 的名字空间决定了访问权限的授予范围。
  # 这里仅授权在 "development" 名字空间内的访问权限。
  namespace: development
subjects:
- kind: User
  name: dave # 'name' 是不区分大小写的
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io</code></pre> 
<p>3.4、ClusterRoleBinding 示例</p> 
<p>要跨整个集群完成访问权限的授予，你可以使用一个 ClusterRoleBinding。 下面的 ClusterRoleBinding 允许 "manager" 组内的所有用户访问任何名字空间中的 Secrets。</p> 
<pre><code class="language-bash">apiVersion: rbac.authorization.k8s.io/v1
# 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 secrets
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
- kind: Group
  name: manager # 'name' 是不区分大小写的
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io</code></pre> 
<p><strong>注意：</strong></p> 
<p>​ 创建了绑定之后，你不能再修改绑定对象所引用的 Role 或 ClusterRole。 试图改变绑定对象的&nbsp;<code>roleRef</code>&nbsp;将导致合法性检查错误。 如果你想要改变现有绑定对象中&nbsp;<code>roleRef</code>&nbsp;字段的内容，必须删除重新创建绑定对象。</p> 
<p><strong>这种限制有两个主要原因：</strong></p> 
<ol><li>针对不同角色的绑定是完全不一样的绑定。要求通过删除/重建绑定来更改&nbsp;<code>roleRef</code>, 这样可以确保要赋予绑定的所有主体会被授予新的角色（而不是在允许修改&nbsp;<code>roleRef</code>&nbsp;的情况下导致所有现有主体胃镜验证即被授予新角色对应的权限）。</li><li>将&nbsp;<code>roleRef</code>&nbsp;设置为不可以改变，这使得可以为用户授予对现有绑定对象的&nbsp;<code>update</code>&nbsp;权限， 这样可以让他们管理主体列表，同时不能更改被授予这些主体的角色。</li></ol>
<p>命令&nbsp;<code>kubectl auth reconcile</code>&nbsp;可以创建或者更新包含 RBAC 对象的清单文件， 并且在必要的情况下删除和重新创建绑定对象，以改变所引用的角色</p> 
<p>3.5、聚合的 ClusterRole</p> 
<p>下面是一个聚合 ClusterRole 的示例：</p> 
<pre><code class="language-bash">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: monitoring
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac.example.com/aggregate-to-monitoring: "true"
rules: [] # 控制面自动填充这里的规则

-------
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: monitoring-endpoints
  labels:
    rbac.example.com/aggregate-to-monitoring: "true"
# 当你创建 "monitoring-endpoints" ClusterRole 时，
# 下面的规则会被添加到 "monitoring" ClusterRole 中
rules:
- apiGroups: [""]
  resources: ["services", "endpoints", "pods"]
  verbs: ["get", "list", "watch"]</code></pre> 
<p>下面的 ClusterRoles 让默认角色 "admin" 和 "edit" 拥有管理自定义资源 "CronTabs" 的权限， "view" 角色对 CronTab 资源拥有读操作权限。 你可以假定 CronTab 对象在 API 服务器所看到的 URL 中被命名为&nbsp;<code>"crontabs"</code>。</p> 
<pre><code class="language-bash">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: aggregate-cron-tabs-edit
  labels:
    # 添加以下权限到默认角色 "admin" 和 "edit" 中
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
    rbac.authorization.k8s.io/aggregate-to-edit: "true"
rules:
- apiGroups: ["stable.example.com"]
  resources: ["crontabs"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: aggregate-cron-tabs-view
  labels:
    # 添加以下权限到 "view" 默认角色中
    rbac.authorization.k8s.io/aggregate-to-view: "true"
rules:
- apiGroups: ["stable.example.com"]
  resources: ["crontabs"]
  verbs: ["get", "list", "watch"]</code></pre> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>SaltStack脚本安装</title><link>http://www.cnblogs.com/heian99/archive/2021/02/27/14466669.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 27 Feb 2021 10:39:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/02/27/14466669.html</guid><description><![CDATA[
                    <p>无聊，近期痴迷编程，没事就写写shell和Python代码练练手。</p> 
<p>这次写了个自动安装saltstack的shell代码菜单</p> 
<p><img alt="" height="240" src="https://img-blog.csdnimg.cn/20210227183529467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="446"></p> 
<p>功能比较low，相对比较省事。多台主机安装方便。仅供参考，大佬勿喷</p> 
<p><img alt="" height="312" src="https://img-blog.csdnimg.cn/20210227183642189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="531"></p> 
<p>&nbsp;</p> 
<pre><code class="language-bash"> #!/bin/bash


#颜色控制
red='\033[1;31m'
black='\033[0m'
Orange='\033[35m'
background='\033[0m'
minion_file='/etc/salt/minion'
datetime=`date +"%F %T"`

#判断软件是否安装
function if_installed(){
    salt_name=$1
    salt_status=`rpm -qa | grep $salt_name`
    if [  ! -n "$salt_status" ];then
        echo "$salt_name没有安装"
        return 2
    else
        echo "$salt_name已经安装"
        echo $salt_status
    fi
    
}

#安装master组件
function install_master(){
    salt_name=$1
    if_installed $salt_name
    if [ $? -eq 2 ];then
        yum install -y https://repo.saltstack.com/yum/redhat/salt-repo-latest-2.el7.noarch.rpm
        sed -i "s/repo.saltstack.com/mirrors.aliyun.com\/saltstack/g" /etc/yum.repos.d/salt-latest.repo
        yum install -y $salt_name
        systemctl enable $salt_name
        systemctl start $salt_name	
        echo "s$salt_name已经安装"
    fi 
}


#4)salt-minion配置
function salt-minion(){
    read -p "请输salt-master的IP:" master_ip
	if [ ! -n "$master_ip" ];then
		echo "未获取salt-master的IP，无法配置salt-minion"
	else
		if [ -f "$minion_file" ]; then
            num1=`grep -vE '^#|^$' $minion_file | grep master |wc -l `
            old_ip=`grep -vE '^#|^$' $minion_file | grep master | awk -F ":"  '{print $2}'`
            if [ $num1 -eq 0 ];then
                sed -i "17i master: $master_ip" $minion_file
                echo "salt-minion配置salt-master的IP为：$master_ip"
            else
                sed  -i "s/$old_ip/$master_ip/"  $minion_file
                echo "salt-minion配置salt-master的IP为：$master_ip"
            fi
        
        else
            echo "$minion_file文件不存在"
        fi
	fi
}


#删除软件
function salt_remove(){
    salt_name=$1
    salt_status=`rpm -qa | grep $salt_name`
    if [  ! -n "$salt_status" ];then
        echo "$salt_name没有安装"
    else
        rpm -qa | grep $salt_name | xargs rpm -e
        if [ $? -eq 0 ];then
            echo "$salt_name已经卸载"
        fi
    fi
}

#重启服务
function salt_restart(){
    salt_name=$1
    if_installed $salt_name
    if [ $? -eq 2 ];then
        echo ""
    else
        systemctl restart $salt_name
        echo "$salt_name已经重启"
    fi
}



#菜单
function menu()
{
echo -e "         $datetime"
cat &lt;&lt;EOF
--------------------------------------------
`echo -e "        $black SaltStack菜单主页$background"`
`echo -e "$Orange  1)安装slat-master $background"`    `echo -e "$Orange   2)安装salt-minion$background"`
`echo -e "$Orange  3)是否软件安装查询$background"`     `echo -e "$Orange   4)salt-minion配置$background"`
`echo -e "$Orange  5)卸载slat-master$background"`      `echo -e "$Orange  6)卸载slat-minion$background"`
`echo -e "$Orange  7)重启slat-master$background"`      `echo -e "$Orange  8)重启slat-minion$background"`
`echo -e "$Orange  Q)退出$background"`                
--------------------------------------------
EOF
read -p "请输入对应序列号：" num1
case $num1 in
    1)
    install_master salt-master
    menu
    ;;
    2)
    install_master salt-minion
    menu
    ;;
    3)
    if_installed salt-master
    if_installed salt-minion
    menu
    ;;
    4)
    salt-minion
    menu
    ;;
    5)
    salt_remove salt-master
    menu
    ;;
    6)
    salt_remove salt-minion
    menu
    ;;
    7)
    salt_restart salt-master
    menu
    ;;
    8)
    salt_restart salt-minion
    menu
    ;;
    Q|q)
    exit 0
    ;;
    *)
    echo -e "\033[31m err：请输入正确的编号\033[0m"
    menu
esac
}

menu
</code></pre> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Redhat机器巡检脚本</title><link>http://www.cnblogs.com/heian99/archive/2021/02/25/14466670.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 25 Feb 2021 06:11:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/02/25/14466670.html</guid><description><![CDATA[
                    <p>此脚本适合Redhat系列</p> 
<p>centos系列，内存缓存计数位置不同，可能不准确</p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">#!/bin/bash
##系统信息##
sys_check(){
os_type=`uname`
echo "操作系统类型是:$os_type"
os_banben=`cat /etc/redhat-release`
echo "操作系统版本号是:$os_banben"
os_neihe=`uname -r`
echo "操作系统的内核是:$os_neihe"
os_time=`date +%F_%T`
echo "操作系统当前时间是:$os_time"
os_uptime=`uptime | awk '{print $3}'|awk -F , '{print $1}'`
echo "操作系统最后重启时间为:$os_uptime"
os_hostname=`hostname`
echo "操作系统主机名称为:$os_hostname"
}
##网络信息##
net_check(){
net_ip=`/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d "addr:"`
echo "操作系统的ip是:$net_ip"
ping -c1 www.baidu.com &gt;/dev/null
if [ $? -eq 0 ];then
        echo "外网可以连通"
else
        echo "外网连不通，请检查"
fi
}
cpu_check(){
physical_id=`cat /proc/cpuinfo | grep "physical id"|sort|uniq|wc -l`
echo "操作系统cpu物理个数是:$physical_id"
cpu_core=`cat /proc/cpuinfo | grep "cpu cores"|sort|uniq|awk -F ':' '{print $2}'`
echo "操作系统的cpu核心数是:$cpu_core"
cpu_type=`cat /proc/cpuinfo | grep "model name"|sort|uniq|awk -F ':' '{print $2}'`
echo "操作系统的cpu型号是:$cpu_type"
free_total=`free -m | grep Mem|awk '{printf $2}'`
echo "操作系统的内存总大小为:$free_total M"
free_used=`free -m | grep Mem|awk '{printf $3}'`
echo "操作系统已使用内存为:$free_used M"
free_shengyu=`free -m | grep Mem|awk '{printf $4}'`
echo "操作系统剩余内存为:$free_shengyu M"
used_baifen=`echo "scale=2;$free_used/$free_total*100"|bc`
echo "已使用内存百分比是:$used_baifen"%
shengyu_baifen=`echo "scale=2;$free_shengyu/$free_total*100"|bc`
echo "未使用内存百分比是:$shengyu_baifen"%
}
disk_check(){
disk_size=`lsblk | grep -w sda |awk '{print $4}'`
echo "磁盘总量为:$disk_size"
a=($(df -m | grep -v "tmpfs" | egrep -A 1 "mapper|sd" | awk 'NF&gt;1{print $(NF-2)}'))
sum=0
for i in ${a[*]}
do
        let sum=sum+$i
done
shengfree=$[$sum/1024]
echo "剩余磁盘总量为:$shengfree" G
}
sys_check
net_check
cpu_check
disk_check</code></pre> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Mysql数据库备份脚本</title><link>http://www.cnblogs.com/heian99/archive/2021/02/25/14533542.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 25 Feb 2021 06:08:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/02/25/14533542.html</guid><description><![CDATA[
                    <p><strong>数据库备份脚本</strong></p> 
<p><strong>按照时间来创建目录备份数据，需要配合crontab</strong></p> 
<pre><code class="language-bash">00 1 * * * root /etc/mysqldumpjumpser.sh</code></pre> 
<p>每天早上凌晨1点备份数据</p> 
<pre><code class="language-bash">#!/bin/bash
USER=jumpserver
PASS=jumpserver
DBDIR=/databak/Data_Backup
#DAY=`date  +%Y%m%d`
#年月
MONTH=`date +%Y%m`
#日期时间
DT=`date '+%Y%m%d%H%M'`
#主机ip
DBIP=`cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | awk -F '"' '{print $2}'`
#创建备份目录
mkdir -p $DBDIR/$DBIP/$MONTH
备份数据库
for  dbname in jumpserver
do
	mysqldump  -u$USER   -p$PASS -R    --single-transaction  $dbname 2&gt;&gt;$DBDIR/$DBIP/$MONTH/error-$DT.log   |gzip  &gt; $DBDIR/$DBIP/$MONTH/$dbname-$DBIP-$DT.sql.gz
  	# 生成md5sum文件
 	md5sum $DBDIR/$DBIP/$MONTH/$dbname-$DBIP-$DT.sql.gz &gt; $DBDIR/$DBIP/$MONTH/$dbname-$DBIP-$DT.sql.gz.MD5
done

# check and delete old datafile.
#删除超过30天的文件，并删除目录
del_backup_dir=/databak/Data_Backup/$DBIP
cd $del_backup_dir
if [ $? = 0 ]; then
        find ./ -type f -mtime +30 -exec rm -rf {} \; &gt;/dev/null 2&gt;&amp;1
        find -depth -type d -empty -exec rmdir {} \;
fi

#压缩备份
#mysqldump -uroot -proot --databases abc 2&gt;/dev/null |gzip &gt;/abc.sql.gz
#还原
#gunzip -c abc.sql.gz |mysql -uroot -proot abc</code></pre> 
<p><img alt="" height="309" src="https://img-blog.csdnimg.cn/20210306124931833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="832"></p> 
<p>每月备份的数据会放到一个目录，十分乱，不容易看，这边改进一下</p> 
<p>没有多大的改变，就是加了<span style="color:#f33b45;">DAY=`date -d '-1 days' +%d` </span>：显示上一天的日期，我们crontab是凌晨1点备份，也就是备份上一天的数据。</p> 
<pre><code class="language-bash">#!/bin/bash
USER=jumpserver
PASS=jumpserver
DBDIR=/databak/Data_Backup
DAY=`date -d '-1 days' +%d`
MONTH=`date +%Y%m`
DT=`date '+%Y%m%d%H%M'`
DBIP=`cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IP | awk -F '"' '{print $2}'`



mkdir -p $DBDIR/$DBIP/$MONTH/$DAY
for  dbname in jumpserver
do
	mysqldump  -u$USER   -p$PASS -R    --single-transaction  $dbname 2&gt;&gt;$DBDIR/$DBIP/$MONTH/$DAY/error-$DT.log   |gzip  &gt; $DBDIR/$DBIP/$MONTH/$DAY/$dbname-$DBIP-$DT.sql.gz
  	# 生成md5sum文件
 	md5sum $DBDIR/$DBIP/$MONTH/$DAY/$dbname-$DBIP-$DT.sql.gz &gt; $DBDIR/$DBIP/$MONTH/$DAY/$dbname-$DBIP-$DT.sql.gz.MD5
done



# check and delete old datafile.
del_backup_dir=/databak/Data_Backup/$DBIP
cd $del_backup_dir
if [ $? = 0 ]; then
        find ./ -type f -mtime +30 -exec rm -rf {} \; &gt;/dev/null 2&gt;&amp;1
        find -depth -type d -empty -exec rmdir {} \;
fi

#压缩备份
#mysqldump -uroot -proot --databases abc 2&gt;/dev/null |gzip &gt;/abc.sql.gz
#还原
#gunzip -c abc.sql.gz |mysql -uroot -proot abc</code></pre> 
<p><img alt="" height="53" src="https://img-blog.csdnimg.cn/2021030612555155.png" width="244"></p> 
<p>以日期目录分类，可以更方便的清楚</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>sersync+rsync原理及部署</title><link>http://www.cnblogs.com/heian99/archive/2021/01/29/14466672.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 29 Jan 2021 15:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/01/29/14466672.html</guid><description><![CDATA[
                    <h2>rsync</h2> 
<p><strong>1.1 rsync是什么</strong><br> rsync是一款开源的，快速的、多功能的、可实现全量及增量的本地或远程数据同步备份的优秀工具同步备份的优秀工具</p> 
<p><strong>1.2 rsync的特性如下：</strong></p> 
<ol><li>支持拷贝特殊文件如链接文件，设备等</li><li>可以有排除指定文件或目录同步的功能，相当于打包命令tar的排除功能。</li><li>可以做到保持原文件或目录等权限，时间，软硬链接，属主，属组等所有属性均不改变 –p</li><li>可实现增量同步，即只同步发生变化的数据，因此数据传输效率很高</li><li>可以使用rcp,rsh,ssh等方式来配置传输文件（rsync本身不对数据加密）</li><li>可以通过socket（守护进程方式）传输文件和数据（服务端和客户端）</li><li>支持匿名或认证（无需系统用户）的进程模式传输，可实现方便安全的进行数据备份及镜像</li><li>rsync也相当于ls命令</li></ol>
<p><strong>1.3 rsync的企业工作场景说明</strong></p> 
<ol><li>两台服务器之间数据同步（定时任务+rsync）</li><li>实时同步（解决存储服务器的单点问题）</li></ol>
<h2>Rsync+Inotify-tools与Rsync+sersync这两种架构有什么区别</h2> 
<h3><strong>1．Rsync+Inotify-tools</strong></h3> 
<p>（1）：Inotify-tools只能记录下被监听的目录发生了变化（包括增加、删除、修改），并没有把具体是哪个文件或者哪个目录发生了变化记录下来；<br> （2）：rsync在同步的时候，并不知道具体是哪个文件或者哪个目录发生了变化，每次都是对整个目录进行同步，当数据量很大时，整个目录同步非常耗时（rsync要对整个目录遍历查找对比文件），因此，效率很低。</p> 
<h3><strong>2．Rsync+sersync</strong></h3> 
<p>（1）sersync可以记录下被监听目录中发生变化的（包括增加、删除、修改）具体某一个文件或某一个目录的名字；<br> （2）rsync在同步的时候，只同步发生变化的这个文件或者这个目录（每次发生变化的数据相对整个同步目录数据来说是很小的，rsync在遍历查找比对文件时，速度很快），因此，效率很高。</p> 
<p>&nbsp;</p> 
<h3><strong>同步过程：</strong></h3> 
<p>1.&nbsp;&nbsp;在同步服务器上开启sersync服务，sersync负责监控配置路径中的文件系统事件变化；</p> 
<p>2.&nbsp;&nbsp;调用rsync命令把更新的文件同步到目标服务器；</p> 
<p>3.&nbsp;&nbsp;需要在主服务器配置sersync，在同步目标服务器配置rsync server（注意：是rsync服务）</p> 
<h3>&nbsp;同步过程和原理：</h3> 
<p>1.&nbsp;&nbsp;用户实时的往sersync服务器上写入更新文件数据；</p> 
<p>2.&nbsp;&nbsp;此时需要在同步主服务器上配置sersync服务；</p> 
<p>3.&nbsp;&nbsp;在另一台服务器开启rsync守护进程服务，以同步拉取来自sersync服务器上的数据；</p> 
<p>通过rsync的守护进程服务后可以发现，实际上sersync就是监控本地的数据写入或更新事件；然后，在调用rsync客户端的命令，将写入或更新事件对应的文件通过rsync推送到目标服务器</p> 
<p><strong>小结：当同步的目录数据量不大时，建议使用Rsync+Inotify-tools；当数据量很大（几百G甚至1T以上）、文件很多时，建议使用Rsync+sersync。</strong></p> 
<h2>三、配置操作</h2> 
<p>&nbsp;</p> 
<p><strong>一台装rsync服务 &nbsp;</strong>192.168.0.10</p> 
<p><strong>一台装sersync&nbsp; &nbsp; &nbsp;</strong>192.168.0.20</p> 
<p><strong>对20网站根目录的/backup目录备份到10的/backup</strong></p> 
<p><strong>Rsync服务器（备份端磁盘大专门用来存储数据&nbsp;,目标机器）：</strong>192.168.0.10</p> 
<p><strong>Sersync服务器（数据源【部署的项目，代码等】,源机器 ）：&nbsp;</strong>192.168.0.20<br> &nbsp;</p> 
<h3><strong>（1）、使用rsync备份数据 系统用户</strong></h3> 
<p><strong>两台服务器都需要安装rsync</strong></p> 
<pre><code class="language-bash">yum -y install xinetd rsync</code></pre> 
<p><strong>20需要安装sersync</strong></p> 
<p><strong>原理：10 上 使用系统配置文件 &nbsp; vim&nbsp;/etc/rsyncd.conf &nbsp; 来备份数据，创建备份账户，最后把rsync以deamon方式运行</strong></p> 
<p><strong>&nbsp;vim&nbsp;/etc/rsyncd.conf&nbsp; &nbsp; &nbsp;&nbsp;rsyncd.conf配置文件</strong></p> 
<pre><code class="language-bash">#!/bin/bash
uid = root
gid = root
use chroot = no
disable = no
fake super = yes 
max connections = 200
timeout = 300
pid file=/var/run/rsyncd.pid
lock file=/var/run/rsync.lock
log file = /var/log/rsyncd.log
[backup]
path = /backup
ignore errors
read only = false
list = false
hosts allow = 192.168.0.0/24  
host deny = 0.0.0.0/0 
auth users = rsync_backup
secrets file = /etc/rsync.password


[root@backup ~]# useradd -M -s /sbin/nologin rsync   #可以使用rsync，我使用的是root
[root@backup backup]# mkdir /backup/ &nbsp; &nbsp;创建备份的目录</code></pre> 
<p>创建密码文件</p> 
<pre><code class="language-bash">[root@backup ~]# echo 'rsync_backup:123456' &gt;/etc/rsync.password
[root@backup ~]# cat /etc/rsync.password
rsync_backup:123456</code></pre> 
<p>修改权限</p> 
<pre><code class="language-bash">[root@backup ~]# chmod 600 /etc/rsync.password
[root@backup ~]# ll /etc/rsync.password
-rw-------. 1 root root 20 Jul 24 04:27 /etc/rsync.password
</code></pre> 
<p>启动rsync服务</p> 
<pre><code class="language-bash">[root@backup ~]# rsync -–daemon
</code></pre> 
<p>加入开机自启动</p> 
<pre><code class="language-bash">[root@backup ~]# vim /etc/rc.local
# rsync server progress
/usr/bin/rsync --daemon

1.5.7 第六个里程碑-检查  rsync的端口号为873
[root@backup ~]# ss -tlunp|grep rsync
tcp    LISTEN     0      5                     :::873                  :::*      users:(("rsync",2452,5))
tcp    LISTEN     0      5                      *:873                   *:*      users:(("rsync",2452,4))
</code></pre> 
<p>重启rsync</p> 
<pre><code class="language-bash">[root@rsync-client-sersync ~]# ps -ef | grep rsync
root       1287      1  0 22:52 ?        00:00:00 rsync --daemon
root       1294   1248  0 22:52 pts/0    00:00:00 grep --color=auto rsync
[root@rsync-client-sersync ~]# kill -9 1287
[root@rsync-client-sersync ~]# ps -ef | grep rsync
root       1298   1248  0 22:53 pts/0    00:00:00 grep --color=auto rsync
[root@rsync-client-sersync ~]# rsync --daemon
[root@rsync-client-sersync ~]# ps -ef | grep rsync
root       1300      1  0 22:53 ?        00:00:00 rsync --daemon
root       1302   1248  0 22:53 pts/0    00:00:00 grep --color=auto rsync

重启，就是杀掉rsync的进程，重新rsync --daemon</code></pre> 
<p>在客户端进行测试（20）</p> 
<pre><code class="language-bash">[root@rsync-client-sersync ~]# rsync -avz /etc/hosts rsync_backup@192.168.0.10::backup
Password: 
sending incremental file list
hosts

sent 140 bytes  received 43 bytes  33.27 bytes/sec
total size is 158  speedup is 0.86
成功的将hosts文件推向服务器端的/backup目录中
</code></pre> 
<p>客户端添加密码</p> 
<pre><code class="language-bash">[root@nfs01 tmp]# echo '123456' &gt;/etc/rsync.password   将密码重定向到/etc/rsync.password文件
[root@nfs01 tmp]# cat /etc/rsync.password   查看
123456
[root@nfs01 tmp]# chmod 600 /etc/rsync.password   给/etc/rsync.password文件600的权限
</code></pre> 
<pre><code class="language-bash">rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup --password-file=/etc/rsync.password    指定密码文件</code></pre> 
<p>实例：排除文件</p> 
<pre><code>[root@backup tmp]# rsync -a –-exclude=/etc/hosts /etc/services 172.16.1.31:/tmp/
–-exclude=/etc/hosts  排除/etc/services中的/etc/hosts文件

--bwlimit=RATE  limt socket I/O bandwidth  传输的时候限速
--delete  让源目录和目标目录一模一样（即：我有什么你就有什么，我没什么你就没有什么）
</code></pre> 
<ul><li>实例：无差异同步</li></ul>
<pre><code>[root@backup tmp]# rsync -a --delete /tmp/ 172.16.1.31:/tmp/
root@172.16.1.31's password:
--delete  本地有什么，远端就有什么 本地没有什么，远端就没有什么 本地有远端没有，就会删除远</code></pre> 
<h3><strong>（2）、使用sersync实时监控推送</strong></h3> 
<p><strong>1</strong><strong>、下载sersync</strong></p> 
<p>&nbsp;在google code下载sersync的可执行文件版本，里面有配置文件与可执行文件，这用</p> 
<pre><code class="language-bash">mkdir -p /applition/tools
cd /applition/tools
wgethttps://sersync.googlecode.com/files/sersync2.5.4_64bit_binary_stable_final.tar.gz
【有时下载失败，所有要本地留存才行】
[root@web ~]# tar fxzsersync2.5.4_64bit_binary_stable_final.tar.gz -C /usr/local/
[root@web ~]# cd /usr/local/
[root@cache local]# mv GNU-Linux-x86 sersync
[root@cache local]# treesersync/
sersync/
├── confxml.xml      #   配置文件
└── sersync2         #   二进制文件【启动sersync使用】
 
0 directories, 2 files</code></pre> 
<p><strong>2</strong><strong>、配置sersync</strong></p> 
<pre><code class="language-bash">[root@cache local]# cp sersync/confxml.xmlsersync/confxml.xml.$(date +%F)
[root@cache local]# ll sersync/confxml.xml
-rwxr-xr-x. 1 root root 2214Oct 26  2011 sersync/confxml.xml
[root@cache local]# llsersync/confxml.xml*
-rwxr-xr-x. 1 root root 2214Oct 26  2011 sersync/confxml.xml
-rwxr-xr-x. 1 root root 2214Jun  5 06:38sersync/confxml.xml.2015-06-05</code></pre> 
<p><strong>更改优化sersync配置文件：</strong></p> 
<pre><code class="language-bash">     &lt;localpathwatch="/opt/tongbu"&gt;     # 定义本地要同步的目录
         &lt;remote ip="127.0.0.1"name="tongbu1"/&gt;
         &lt;!--&lt;remoteip="192.168.8.39" name="tongbu"/&gt;--&gt;        # 同步到哪台机器上 tongbu模块rsync端模块名字
         &lt;!--&lt;remoteip="192.168.8.40" name="tongbu"/&gt;--&gt;        # 同步到哪台机器上 tongbu模块
     &lt;/localpath&gt;</code></pre> 
<p><strong>b</strong><strong>）修改31--34行，认证部分【rsync密码认证】</strong></p> 
<pre><code>  &lt;rsync&gt;
            &lt;commonParamsparams="-artuz"/&gt;
            &lt;auth start="false"users="root" passwordfile="/etc/rsync.pas"/&gt;
             &lt;userDefinedPortstart="false" port="874"/&gt;&lt;!-- port=874 --&gt;
             &lt;timeoutstart="false" time="100"/&gt;&lt;!-- timeout=100 --&gt;
             &lt;sshstart="false"/&gt;
         &lt;/rsync&gt;

# ***修改内容为 rsync的密码文件以及 同步所使用的账号类似：
rsync -avzP /data/www/rsync_backup@172.16.1.25::www/ --password-file=/etc/rsync.password</code></pre> 
<pre><code>        &lt;failLog path="/usr/local/sersync/logs/rsync_fail_log.sh"timeToExecute="60"/&gt;&lt;!--default every 60mins execute once--&gt;
# 当同步失败后，日志记录到/usr/local/sersync/logs/rsync_fail_log.sh文件中，并且每60分钟对失败的log进行重新同步</code></pre> 
<p><strong>修改后的完整配置文件为：</strong></p> 
<pre><code class="language-bash">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;head version="2.5"&gt;
    &lt;host hostip="localhost" port="8008"&gt;&lt;/host&gt;
    &lt;debug start="false"/&gt;
    &lt;fileSystem xfs="false"/&gt;
    &lt;filter start="false"&gt;
	&lt;exclude expression="(.*)\.svn"&gt;&lt;/exclude&gt;
	&lt;exclude expression="(.*)\.gz"&gt;&lt;/exclude&gt;
	&lt;exclude expression="^info/*"&gt;&lt;/exclude&gt;
	&lt;exclude expression="^static/*"&gt;&lt;/exclude&gt;
    &lt;/filter&gt;
    &lt;inotify&gt;
	&lt;delete start="true"/&gt;
	&lt;createFolder start="true"/&gt;
	&lt;createFile start="false"/&gt;
	&lt;closeWrite start="true"/&gt;
	&lt;moveFrom start="true"/&gt;
	&lt;moveTo start="true"/&gt;
	&lt;attrib start="false"/&gt;
	&lt;modify start="false"/&gt;
    &lt;/inotify&gt;

    &lt;sersync&gt;
	&lt;localpath watch="/etc/openvpn"&gt;
	    &lt;remote ip="192.168.0.10" name="openvpn"/&gt;
	    &lt;!--&lt;remote ip="192.168.8.39" name="tongbu"/&gt;--&gt;
	    &lt;!--&lt;remote ip="192.168.8.40" name="tongbu"/&gt;--&gt;
	&lt;/localpath&gt;
	&lt;rsync&gt;
	    &lt;commonParams params="-artuz"/&gt;
	    &lt;auth start="true" users="rsync_backup" passwordfile="/etc/rsync.password"/&gt;
	    &lt;userDefinedPort start="false" port="874"/&gt;&lt;!-- port=874 --&gt;
	    &lt;timeout start="start" time="100"/&gt;&lt;!-- timeout=100 --&gt;
	    &lt;ssh start="false"/&gt;
	&lt;/rsync&gt;
	&lt;failLog path="/tmp/rsync_fail_log.sh" timeToExecute="60"/&gt;&lt;!--default every 60mins execute once--&gt;
	&lt;crontab start="false" schedule="600"&gt;&lt;!--600mins--&gt;
	    &lt;crontabfilter start="false"&gt;
		&lt;exclude expression="*.php"&gt;&lt;/exclude&gt;
		&lt;exclude expression="info/*"&gt;&lt;/exclude&gt;
	    &lt;/crontabfilter&gt;
	&lt;/crontab&gt;
	&lt;plugin start="false" name="command"/&gt;
    &lt;/sersync&gt;

    &lt;plugin name="command"&gt;
	&lt;param prefix="/bin/sh" suffix="" ignoreError="true"/&gt;	&lt;!--prefix /opt/tongbu/mmm.sh suffix--&gt;
	&lt;filter start="false"&gt;
	    &lt;include expression="(.*)\.php"/&gt;
	    &lt;include expression="(.*)\.sh"/&gt;
	&lt;/filter&gt;
    &lt;/plugin&gt;

    &lt;plugin name="socket"&gt;
	&lt;localpath watch="/opt/tongbu"&gt;
	    &lt;deshost ip="192.168.138.20" port="8009"/&gt;
	&lt;/localpath&gt;
    &lt;/plugin&gt;
    &lt;plugin name="refreshCDN"&gt;
	&lt;localpath watch="/data0/htdocs/cms.xoyo.com/site/"&gt;
	    &lt;cdninfo domainname="ccms.chinacache.com" port="80" username="xxxx" passwd="xxxx"/&gt;
	    &lt;sendurl base="http://pic.xoyo.com/cms"/&gt;
	    &lt;regexurl regex="false" match="cms.xoyo.com/site([/a-zA-Z0-9]*).xoyo.com/images"/&gt;
	&lt;/localpath&gt;
    &lt;/plugin&gt;
&lt;/head&gt;
</code></pre> 
<p><strong>3</strong><strong>、开启sersync守护进程同步数据</strong></p> 
<pre><code class="language-bash">[root@web ~]# /usr/local/sersync/sersync2  -d -r -o /usr/local/sersync/confxml.xml
配置sersync环境变量
[root@web ~]# echo"PATH=$PATH:/usr/local/sersync/"&gt;&gt;/etc/profile
[root@web ~]# source /etc/profile
[root@web ~]# sersync2</code></pre> 
<p><strong>启动命令后返回结果如下为正常：</strong></p> 
<pre><code class="language-bash">set the system param
execute：echo50000000 &gt; /proc/sys/fs/inotify/max_user_watches
execute：echo 327679&gt; /proc/sys/fs/inotify/max_queued_events
parse the command param
option: -d      run as a daemon
option: -r      rsync all the local files to the remoteservers before the sersync work
option: -o      config xml name：  /usr/local/sersync/confxml.xml
daemon thread num: 10
parse xml config file
host ip : localhost     host port: 8008
daemon start，sersync runbehind the console 
use rsync password-file :
user is rsync_backup
passwordfile is         /etc/rsync.password
config xml parse success
please set /etc/rsyncd.confmax connections=0 Manually
sersync working thread 12  = 1(primary thread) + 1(fail retry thread) + 10(daemon sub threads)
Max threads numbers is: 32 = 12(Thread pool nums) +20(Sub threads)
please according your cpu ，use -n paramto adjust the cpu rate
chmod: cannot access`/usr/local/sersync/logs/rsync_fail_log.sh': No such file or directory
------------------------------------------
rsync the directory recursivlyto the remote servers once
working please wait...
execute command: cd /backup&amp;&amp; rsync -artuz -R --delete ./ --timeout=100 rsync_backup@192.168.0.10::www--password-file=/etc/rsync.password &gt;/dev/null 2&gt;&amp;1 
run the sersync: 
watch path is: /data/www</code></pre> 
<p>如果你上面的配置和验证都没问题，可以下面的配置了。设置开机自启动</p> 
<pre><code class="language-bash">#vi /etc/rc.d/rc.local
 
/usr/local/sersync/sersync2 -d -r -o  /usr/local/sersync/confxml.xml ＃设置开机自动运行脚本
 
# chmod +x /etc/rc.d/rc.local</code></pre> 
<p>添加脚本监控sersync是否正常</p> 
<pre><code class="language-bash">cd /root
touch check_sersync.sh
chmod 755 check.sersync.sh
vim check_sersync.sh


#!/bin/sh
sersync="/usr/local/sersync/sersync2"
confxml="/usr/local/sersync/confxml.xml"
status=$(ps aux |grep 'sersync2'|grep -v 'grep'|wc -l)
if [ $status -eq 0 ];
then
$sersync -d -r -o $confxml &amp;
else
exit 0;
fi

check_sersync.sh</code></pre> 
<pre><code>#vi /etc/crontab
 
*/5 * * * * root /root/check_sersync.sh &gt;/dev/null 2&gt;&amp;1  #每隔5分钟执行一次脚本
</code></pre> 
<p>注意：</p> 
<p>　　1、手动执行check_sersync.sh检测sersync是否运行正常。</p> 
<p>　　2、如果着急测试，不用等重启服务器后执行，先执行　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>/</code><code>usr</code><code>/</code><code>local</code><code>/</code><code>sersync</code><code>/</code><code>sersync2&nbsp;</code><code>-</code><code>d&nbsp;</code><code>-</code><code>r&nbsp;</code><code>-</code><code>o&nbsp;&nbsp;</code><code>/</code><code>usr</code><code>/</code><code>local</code><code>/</code><code>sersync</code><code>/</code><code>confxml.xml</code></p> </td></tr></tbody></table>
<p>　　3、在源服务器指定目录下对文件文件夹做出更改，查看目标服务器同步目录下是否同步成功。</p> 
<pre><code class="language-bash">1 -v, --verbose 详细模式输出
  2 
  3 -q, --quiet 精简输出模式
  4 
  5 -c, --checksum 打开校验开关，强制对文件传输进行校验
  6 
  7 -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD
  8 
  9 -r, --recursive 对子目录以递归模式处理
 10 
 11 -R, --relative 使用相对路径信息
 12 
 13 -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。
 14 
 15 --backup-dir 将备份文件(如~filename)存放在在目录下。
 16 
 17 -suffix=SUFFIX 定义备份文件前缀
 18 
 19 -u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)
 20 
 21 -l, --links 保留软链结
 22 
 23 -L, --copy-links 想对待常规文件一样处理软链结
 24 
 25 --copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结
 26 
 27 --safe-links 忽略指向SRC路径目录树以外的链结
 28 
 29 -H, --hard-links 保留硬链结
 30 
 31 -p, --perms 保持文件权限
 32 
 33 -o, --owner 保持文件属主信息
 34 
 35 -g, --group 保持文件属组信息
 36 
 37 -D, --devices 保持设备文件信息
 38 
 39 -t, --times 保持文件时间信息
 40 
 41 -S, --sparse 对稀疏文件进行特殊处理以节省DST的空间
 42 
 43 -n, --dry-run现实哪些文件将被传输
 44 
 45 -W, --whole-file 拷贝文件，不进行增量检测
 46 
 47 -x, --one-file-system 不要跨越文件系统边界
 48 
 49 -B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节
 50 
 51 -e, --rsh=COMMAND 指定使用rsh、ssh方式进行数据同步
 52 
 53 --rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息
 54 
 55 -C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件
 56 
 57 --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件
 58 
 59 --delete 删除那些DST中SRC没有的文件
 60 
 61 --delete-excluded 同样删除接收端那些被该选项指定排除的文件
 62 
 63 --delete-after 传输结束以后再删除
 64 
 65 --ignore-errors 及时出现IO错误也进行删除
 66 
 67 --max-delete=NUM 最多删除NUM个文件
 68 
 69 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输
 70 
 71 --force 强制删除目录，即使不为空
 72 
 73 --numeric-ids 不将数字的用户和组ID匹配为用户名和组名
 74 
 75 --timeout=TIME IP超时时间，单位为秒
 76 
 77 -I, --ignore-times 不跳过那些有同样的时间和长度的文件
 78 
 79 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间
 80 
 81 --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0
 82 
 83 -T --temp-dir=DIR 在DIR中创建临时文件
 84 
 85 --compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份
 86 
 87 -P 等同于 --partial
 88 
 89 --progress 显示备份过程
 90 
 91 -z, --compress 对备份的文件在传输时进行压缩处理
 92 
 93 --exclude=PATTERN 指定排除不需要传输的文件模式
 94 
 95 --include=PATTERN 指定不排除而需要传输的文件模式
 96 
 97 --exclude-from=FILE 排除FILE中指定模式的文件
 98 
 99 --include-from=FILE 不排除FILE指定模式匹配的文件
100 
101 --version 打印版本信息
102 
103 --address 绑定到特定的地址
104 
105 --config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件
106 
107 --port=PORT 指定其他的rsync服务端口
108 
109 --blocking-io 对远程shell使用阻塞IO
110 
111 -stats 给出某些文件的传输状态
112 
113 --progress 在传输时现实传输过程
114 
115 --log-format=formAT 指定日志文件格式
116 
117 --password-file=FILE 从FILE中得到密码
118 
119 --bwlimit=KBPS 限制I/O带宽，KBytes per second
120 
121 -h, --help 显示帮助信息
rsync详细参数</code></pre> 
<p>参考地址：</p> 
<p><a href="https://blog.51cto.com/liubao0312/1677586">https://blog.51cto.com/liubao0312/1677586</a></p> 
<p><a href="https://blog.csdn.net/ljx1528/article/details/105348259">https://blog.csdn.net/ljx1528/article/details/105348259</a></p> 
<p><a href="https://www.cnblogs.com/lei0213/p/8598072.html">https://www.cnblogs.com/lei0213/p/8598072.html</a></p>
                ]]></description></item><item><title>谁动了我的主机?（ History）</title><link>http://www.cnblogs.com/heian99/archive/2021/01/22/14466673.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 22 Jan 2021 02:31:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/01/22/14466673.html</guid><description><![CDATA[
                    <p>Linux系统下可通过history命令查看用户所有的历史操作记录，在安全应急响应中起着非常重要的作用，但在未进行附加配置情况下，history命令只能查看用户历史操作记录，并不能区分用户以及操作时间，不便于审计分析。</p> 
<p>当然，一些不好的操作习惯也可能通过命令历史泄露敏感信息。下面我们来介绍如何让history日志记录更细化，更便于我们审计分析。</p> 
<p><img alt="图片" src="https://img-blog.csdnimg.cn/img_convert/c5ee7c661ce1daa542d25862d986a755.png"></p> 
<h2>&nbsp;History</h2> 
<p><strong>通过设置export HISTTIMEFORMAT='%F %T '，让历史记录中带上命令执行时间。</strong></p> 
<blockquote> 
 <p>注意”%T”和后面的”’”之间有空格，不然查看历史记录的时候，时间和命令之间没有分割。</p> 
 <p>要一劳永逸，这个配置可以写在/etc/profile中，当然如果要对指定用户做配置，这个配置可以写在/home/$USER/.bash_profile中。</p> 
 <p>本文将以/etc/profile为例进行演示。</p> 
</blockquote> 
<pre><code class="language-bash"> vim /etc/profile
export HISTTIMEFORMAT='%F %T  '
source /etc/profile


要使配置立即生效请执行source /etc/profile，我们再查看history记录，可以看到记录中带上了命令执行时间。</code></pre> 
<p><img alt="" height="256" src="https://img-blog.csdnimg.cn/20210122093349178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="643"></p> 
<p><img alt="" height="303" src="https://img-blog.csdnimg.cn/20210122093423492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="540"></p> 
<p><strong>如果想要实现更细化的记录，比如登陆过系统的用户、IP地址、操作命令以及操作时间一一对应，可以通过在/etc/profile里面加入以下代码实现</strong></p> 
<pre><code class="language-bash">USER_IP=`who -u am i 2&gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g'`
export HISTTIMEFORMAT="[%F %T][`whoami`][${USER_IP}] "

修改/etc/profile并加载后，history记录如下，时间、IP、用户及执行的命令都一一对应。

</code></pre> 
<p><img alt="" height="142" src="https://img-blog.csdnimg.cn/20210122094533272.png" width="795"></p> 
<p>通过以上配置，我们基本上可以满足日常的审计工作了，但了解系统的朋友应该很容易看出来，这种方法只是设置了环境变量，攻击者unset掉这个环境变量，或者直接删除命令历史，对于安全应急来说，这无疑是一个灾难。</p> 
<p>针对这样的问题，我们应该如何应对，通过修改bash源码，让history记录通过syslog发送到远程logserver中，大大增加了攻击者对history记录完整性破坏的难度。</p> 
<p><strong>history高级用法</strong></p> 
<p>上面是记录History的方法。我们也可以通过写入文件，更加方便的记录和审计命令</p> 
<pre><code class="language-bash">#histroy
HISTSIZE=409600
export HISTTIMEFORMAT="[%F %T]"
export HISTORY_FILE=/var/log/.audit.log
export PROMPT_COMMAND='{ thisHistID=`history 1|awk "{print \\$1}"`;lastCommand=`history 1| awk "{\\$1=\"\" ;print}"`;user=`id -un`;whoStr=(`who -u am i`);realUser=${whoStr[0]};logMonth=${whoStr[2]};logDay=${whoStr[3]};logTime=${whoStr[4]};pid=${whoStr[6]};ip=${whoStr[7]};if [ ${thisHistID}x != ${lastHistID}x ];then echo -E `date "+%Y/%m/%d %H:%M:%S"` $user\($realUser\)@$ip[PID:$pid][LOGIN:$logMonth $logDay $logTime] --- $lastCommand ;lastHistID=$thisHistID;fi; } &gt;&gt; $HISTORY_FILE'
</code></pre> 
<p>这个命令会在生成<span style="color:#f33b45;"><strong>/var/log/.audit.log 文件&nbsp;&nbsp;</strong></span>这里面记录的是命令</p> 
<p>这样更为直观的分析和审计</p> 
<p><img alt="" height="257" src="https://img-blog.csdnimg.cn/20210122103009686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1161"></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>MySQL容器部署及数据持久化（主从复制）</title><link>http://www.cnblogs.com/heian99/archive/2021/01/18/14466674.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 18 Jan 2021 11:53:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/01/18/14466674.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%AE%89%E8%A3%85docker%E4%B8%8Edocker-compose-toc" style="margin-left:40px;"><a href="#1.%20%E5%AE%89%E8%A3%85docker%E4%B8%8Edocker-compose">1. 安装docker与docker-compose</a></p> 
<p id="2.%20%E7%8E%AF%E5%A2%83%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2.%20%E7%8E%AF%E5%A2%83%E6%9D%A1%E4%BB%B6">2. 环境条件</a></p> 
<p id="3.%20%E5%88%9B%E5%BB%BA%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#3.%20%E5%88%9B%E5%BB%BA%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3. 创建主从配置文件</a></p> 
<p id="4.%20%E5%88%9B%E5%BB%BAdocker-compose.yml%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#4.%20%E5%88%9B%E5%BB%BAdocker-compose.yml%E6%96%87%E4%BB%B6">4. 创建docker-compose.yml文件</a></p> 
<p id="5.%20docker-compose%E5%90%AF%E5%8A%A8mysql%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#5.%20docker-compose%E5%90%AF%E5%8A%A8mysql%E5%AE%B9%E5%99%A8">5. docker-compose启动mysql容器</a></p> 
<p id="6.%20%E9%94%80%E6%AF%81%E4%B8%A4%E4%B8%AA%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#6.%20%E9%94%80%E6%AF%81%E4%B8%A4%E4%B8%AA%E5%AE%B9%E5%99%A8">6. 销毁两个容器</a></p> 
<p id="7.%20%E9%87%8D%E5%BB%BAMySQL%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#7.%20%E9%87%8D%E5%BB%BAMySQL%E5%AE%B9%E5%99%A8">7. 重建MySQL容器</a></p> 
<hr id="hr-toc">
<p>经常拉去数据库做测试，还需要主从，每次环境还要还原，经常重复比较麻烦。</p> 
<p>现在采用docker和docker-compose一键构建集成环境，方便测试。</p> 
<h2 id="1.%20%E5%AE%89%E8%A3%85docker%E4%B8%8Edocker-compose">1. 安装docker与docker-compose</h2> 
<pre><code class="language-bash"># 卸载老版本docker
[root@docker ~]# yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine

[root@docker ~]# yum -y install epel-release wget
[root@docker ~]# wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo
[root@docker ~]# sed -i 's#download.docker.com#mirrors.tuna.tsinghua.edu.cn/docker-ce#g' /etc/yum.repos.d/docker-ce.repo
[root@docker ~]# yum -y install docker-ce

# 启动并配置镜像加速
[root@docker ~]# systemctl start docker.service &amp;&amp; systemctl enable docker.service

[root@docker ~]# cat /etc/docker/daemon.json
{
  "registry-mirrors": ["https://99dxqyb6.mirror.aliyuncs.com"]
}


[root@docker ~]# systemctl restart docker.service</code></pre> 
<ul><li>安装docker-compose</li></ul>
<pre><code class="language-bash">[root@docker ~]# curl -L "https://github.com/docker/compose/releases/download/1.25.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
[root@docker ~]# chmod +x /usr/local/bin/docker-compose
[root@docker ~]# ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></pre> 
<h2 id="2.%20%E7%8E%AF%E5%A2%83%E6%9D%A1%E4%BB%B6">2. 环境条件</h2> 
<pre><code class="language-bash">[root@docker ~]# docker pull mysql:5.7 

[root@Master new_date]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/mysql     5.7                 cc8775c0fe94        6 days ago          449 MB


[root@docker ~]# mkdir -p /data/mysql/master/{conf,data}
[root@docker ~]# mkdir -p /data/mysql/slave/conf
[root@docker ~]# mkdir -p /data/mysql/{init-db-m,init-db-s}
[root@docker ~]# chown -R mysql.mysql /data/mysql

# 主库的创建用户SQL脚本
[root@docker ~]# cat /data/mysql/init-db-m/create_user_1.sql
grant all on *.* to 'dumpuser'@'%' identified by '123456';
grant replication slave on *.* to 'repl'@'%' identified by '123456';

# 从库远程备份主库及创建主从通道Bash脚本
[root@docker ~]# cat /data/mysql/init-db-s/dump-repl_1.sh
#!/bin/bash
while ! mysql -uping -p123456 -hmysql_m_compose -P3306 -e "select 1"
do
    sleep 1
done
sleep 3
    mysqldump -udumpuser -p123456 -hmysql_m_compose -P3306 --single-transaction --default-character-set=utf8mb4 --set-gtid-purged=on --master-data=2 --flush-logs --hex-blob --triggers --routines --events --all-databases &gt; /tmp/full.sql
    mysql -uroot -p123456 -e "reset master;"
    mysql -uroot -p123456 -e "source /tmp/full.sql;"
    mysql -uroot -p123456 -e "CHANGE MASTER TO MASTER_HOST='mysql_m_compose',MASTER_USER='repl',MASTER_PASSWORD='123456',MASTER_PORT=3306,MASTER_CONNECT_RETRY=10,MASTER_AUTO_POSITION=1;"
    mysql -uroot -p123456 -e "start slave;"</code></pre> 
<h2 id="3.%20%E5%88%9B%E5%BB%BA%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3. 创建主从配置文件</h2> 
<pre><code class="language-bash"># mysql_m_compose节点
[root@docker ~]# cat /data/mysql/master/conf/my.cnf
[mysqld]
server_id = 33060000
port = 3306
log_timestamps=SYSTEM
max_allowed_packet = 16M
read_only = 0
character_set_server = utf8mb4
secure_file_priv = ""
max_connect_errors = 100000
interactive_timeout = 1800
wait_timeout = 1800

# BINLOG
log_bin = mysql-bin
binlog_format = row
log_slave_updates = 1
max_binlog_size = 200M
relay_log = relay-bin
sync_binlog = 1

# GTID
gtid_mode = ON
enforce_gtid_consistency = 1
binlog_gtid_simple_recovery = 1

# ENGINE
default_storage_engine = InnoDB
innodb_flush_log_at_trx_commit=1

# ----------------------------------------------------------------------------------------------------------------------

# mysql_s_compose节点
[root@docker ~]# cat /data/mysql/slave/conf/my.cnf
[mysqld]
server_id = 33060001
port = 3306
log_timestamps=SYSTEM
max_allowed_packet = 16M
read_only = 0
character_set_server = utf8mb4
secure_file_priv = ""
max_connect_errors = 100000
interactive_timeout = 1800
wait_timeout = 1800

# BINLOG
log_bin = mysql-bin
binlog_format = row
log_slave_updates = 1
max_binlog_size = 200M
relay_log = relay-bin
sync_binlog = 1

# GTID
gtid_mode = ON
enforce_gtid_consistency = 1
binlog_gtid_simple_recovery = 1

# ENGINE
default_storage_engine = InnoDB
innodb_flush_log_at_trx_commit=1</code></pre> 
<h2 id="4.%20%E5%88%9B%E5%BB%BAdocker-compose.yml%E6%96%87%E4%BB%B6">4. 创建docker-compose.yml文件</h2> 
<ul><li>将init_sql下的文件映射到<code>/docker-entrypoint-initdb.d</code>目录下(注：/docker-entrypoint-initdb.d下以<code>sql</code>或<code>sh</code>结尾的文件会在数据库<code>初始化完成后自动执行</code>)</li></ul>
<pre><code class="language-bash">[root@docker ~]# cat /data/mysql/docker-compose.yml
version: '3'
services:
  mysql_m_compose:
    image: mysql:5.7.30
    container_name: mysql_m
    restart: always
    ports:
      - 33061:3306
    environment:
      - MYSQL_USER=ping
      - MYSQL_PASSWORD=123456
      - MYSQL_ROOT_PASSWORD=123456
    volumes:
      - ./master/conf/my.cnf:/etc/my.cnf
      - ./master/data:/var/lib/mysql
      - ./init-db-m:/docker-entrypoint-initdb.d

  mysql_s_compose:
    image: mysql:5.7.30
    container_name: mysql_s
    restart: always
    ports:
      - 33062:3306
    depends_on:
      - mysql_m_compose
    environment:
      - MYSQL_ROOT_PASSWORD=123456
    volumes:
      - ./slave/conf/my.cnf:/etc/my.cnf
      - ./init-db-s:/docker-entrypoint-initdb.d</code></pre> 
<h2 id="5.%20docker-compose%E5%90%AF%E5%8A%A8mysql%E5%AE%B9%E5%99%A8">5. docker-compose启动mysql容器</h2> 
<pre><code class="language-bash">[root@docker mysql]# docker-compose up -d
Creating network "mysql_default" with the default driver
Creating mysql_m ... done
Creating mysql_s ... done

[root@docker ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                NAMES
35cc9c6fbf52        mysql:5.7.30        "docker-entrypoint.s…"   6 minutes ago       Up 6 minutes        33060/tcp, 0.0.0.0:33062-&gt;3306/tcp   mysql_s
53a04e176ecc        mysql:5.7.30        "docker-entrypoint.s…"   6 minutes ago       Up 6 minutes        33060/tcp, 0.0.0.0:33061-&gt;3306/tcp   mysql_m

# 检查主从复制关系
# 主库
mysql&gt;  CREATE DATABASE`db` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
mysql_m&gt; use db
Database changed
mysql_m&gt; create table t1(id int,name varchar(32));
Query OK, 0 rows affected (0.01 sec)

mysql_m&gt; insert into t1 values(1,'aa'),(2,'bb'),(3,'cc');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql_m&gt; select  * from db.t1;
+------+------+
| id   | name |
+------+------+
|    1 | aa   |
|    2 | bb   |
|    3 | cc   |
+------+------+
3 rows in set (0.00 sec)

# 从库
mysql_s&gt; select  * from db.t1;
+------+------+
| id   | name |
+------+------+
|    1 | aa   |
|    2 | bb   |
|    3 | cc   |
+------+------+
3 rows in set (0.00 sec)

# 查看主从复制状态信息
mysql&gt; show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: mysql_m_compose
                  Master_User: repl
                  Master_Port: 3306
                Connect_Retry: 10
              Master_Log_File: mysql-bin.000004
          Read_Master_Log_Pos: 845
               Relay_Log_File: relay-bin.000004
                Relay_Log_Pos: 1018
        Relay_Master_Log_File: mysql-bin.000004
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 845
              Relay_Log_Space: 1219
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 33060000
                  Master_UUID: f28ef661-597b-11eb-beb8-0242ac120002
             Master_Info_File: /var/lib/mysql/master.info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
           Master_Retry_Count: 86400
                  Master_Bind: 
      Last_IO_Error_Timestamp: 
     Last_SQL_Error_Timestamp: 
               Master_SSL_Crl: 
           Master_SSL_Crlpath: 
           Retrieved_Gtid_Set: f28ef661-597b-11eb-beb8-0242ac120002:10-12
            Executed_Gtid_Set: f28ef661-597b-11eb-beb8-0242ac120002:1-12
                Auto_Position: 1
         Replicate_Rewrite_DB: 
                 Channel_Name: 
           Master_TLS_Version: 
1 row in set (0.00 sec)
</code></pre> 
<h2 id="6.%20%E9%94%80%E6%AF%81%E4%B8%A4%E4%B8%AA%E5%AE%B9%E5%99%A8">6. 销毁两个容器</h2> 
<pre><code class="language-bash">[root@Master mysql]# ls
docker-compose.yml  init-db-m  init-db-s  master  slave
[root@Master mysql]# docker-compose down
Stopping mysql_s ... done
Stopping mysql_m ... 
Stopping mysql_m ... done
Removing mysql_s ... done
Removing mysql_m ... done
Removing network mysql_default
</code></pre> 
<pre><code class="language-cpp">[root@Master mysql]#  ll -sh /data/mysql/master/data/
总用量 188M
4.0K -rw-r----- 1 polkitd ssh_keys   56 1月  18 18:57 auto.cnf
4.0K -rw------- 1 polkitd ssh_keys 1.7K 1月  18 18:57 ca-key.pem
4.0K -rw-r--r-- 1 polkitd ssh_keys 1.1K 1月  18 18:57 ca.pem
4.0K -rw-r--r-- 1 polkitd ssh_keys 1.1K 1月  18 18:57 client-cert.pem
4.0K -rw------- 1 polkitd ssh_keys 1.7K 1月  18 18:57 client-key.pem
   0 drwxr-x--- 2 polkitd ssh_keys   48 1月  18 19:09 db
4.0K -rw-r----- 1 polkitd ssh_keys 1.4K 1月  18 18:57 ib_buffer_pool
 76M -rw-r----- 1 polkitd ssh_keys  76M 1月  18 19:34 ibdata1
 48M -rw-r----- 1 polkitd ssh_keys  48M 1月  18 19:34 ib_logfile0
 48M -rw-r----- 1 polkitd ssh_keys  48M 1月  18 18:57 ib_logfile1
 12M -rw-r----- 1 polkitd ssh_keys  12M 1月  18 19:34 ibtmp1
4.0K drwxr-x--- 2 polkitd ssh_keys 4.0K 1月  18 18:57 mysql
4.0K -rw-r----- 1 polkitd ssh_keys  177 1月  18 18:57 mysql-bin.000001
3.0M -rw-r----- 1 polkitd ssh_keys 3.0M 1月  18 18:57 mysql-bin.000002
4.0K -rw-r----- 1 polkitd ssh_keys  241 1月  18 18:57 mysql-bin.000003
4.0K -rw-r----- 1 polkitd ssh_keys  845 1月  18 19:34 mysql-bin.000004
4.0K -rw-r----- 1 polkitd ssh_keys  241 1月  18 19:34 mysql-bin.000005
4.0K -rw-r----- 1 polkitd ssh_keys  194 1月  18 19:34 mysql-bin.000006
4.0K -rw-r----- 1 polkitd ssh_keys  114 1月  18 19:34 mysql-bin.index
 12K drwxr-x--- 2 polkitd ssh_keys 8.0K 1月  18 18:57 performance_schema
4.0K -rw------- 1 polkitd ssh_keys 1.7K 1月  18 18:57 private_key.pem
4.0K -rw-r--r-- 1 polkitd ssh_keys  452 1月  18 18:57 public_key.pem
4.0K -rw-r--r-- 1 polkitd ssh_keys 1.1K 1月  18 18:57 server-cert.pem
4.0K -rw------- 1 polkitd ssh_keys 1.7K 1月  18 18:57 server-key.pem
 12K drwxr-x--- 2 polkitd ssh_keys 8.0K 1月  18 18:57 sys
</code></pre> 
<h2 id="7.%20%E9%87%8D%E5%BB%BAMySQL%E5%AE%B9%E5%99%A8">7. 重建MySQL容器</h2> 
<pre><code class="language-bash">[root@docker mysql]# docker-compose up -d
Creating network "mysql_default" with the default driver
Creating mysql_m ... done
Creating mysql_s ... done

[root@docker mysql]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                NAMES
7cd912fa9721        mysql:5.7.30        "docker-entrypoint.s…"   8 seconds ago       Up 8 seconds        33060/tcp, 0.0.0.0:33062-&gt;3306/tcp   mysql_s
d9e3514a1e19        mysql:5.7.30        "docker-entrypoint.s…"   9 seconds ago       Up 8 seconds        33060/tcp, 0.0.0.0:33061-&gt;3306/tcp   mysql_m

# 主库
mysql_m&gt; select * from db.t1;
+------+------+
| id   | name |
+------+------+
|    1 | aa   |
|    2 | bb   |
|    3 | cc   |
+------+------+
3 rows in set (0.00 sec)

# 从库
mysql_s&gt; select * from db.t1;
+------+------+
| id   | name |
+------+------+
|    1 | aa   |
|    2 | bb   |
|    3 | cc   |
+------+------+
3 rows in set (0.01 sec)

mysql_s&gt; show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: mysql_m_compose
                  Master_User: repl
                  Master_Port: 3306
                Connect_Retry: 10
              Master_Log_File: mysql-bin.000006
          Read_Master_Log_Pos: 194
               Relay_Log_File: relay-bin.000004
                Relay_Log_Pos: 367
        Relay_Master_Log_File: mysql-bin.000006
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 194
              Relay_Log_Space: 568
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 33060000
                  Master_UUID: f93b936b-9b6b-11ea-9bda-0242c0a82002
             Master_Info_File: mysql.slave_master_info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
           Master_Retry_Count: 86400
                  Master_Bind:
      Last_IO_Error_Timestamp:
     Last_SQL_Error_Timestamp:
               Master_SSL_Crl:
           Master_SSL_Crlpath:
           Retrieved_Gtid_Set:
            Executed_Gtid_Set: f93b936b-9b6b-11ea-9bda-0242c0a82002:1-12
                Auto_Position: 1
         Replicate_Rewrite_DB:
                 Channel_Name:
           Master_TLS_Version:
1 row in set (0.00 sec)</code></pre> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>当MySQL主从数据不一致，怎么解决？？？（2）</title><link>http://www.cnblogs.com/heian99/archive/2021/01/18/14466675.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 18 Jan 2021 04:34:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/01/18/14466675.html</guid><description><![CDATA[
                    <h2><a href="https://blog.csdn.net/heian_99/article/details/112759177">当MySQL主从数据不一致，怎么解决？？？</a></h2> 
<p>上面是采用<strong>mysqldbcompare工具，对比数据库的信息是否一致。</strong></p> 
<h2><strong>percona-toolkit</strong></h2> 
<p><strong>percona-toolkit官网：</strong><a href="https://www.percona.com/doc/percona-toolkit/LATEST/installation.html">https://www.percona.com/doc/percona-toolkit/LATEST/installation.html</a></p> 
<p>我们可以使用percona-toolkit工具做校验，而该工具包含</p> 
<p>1. pt-table-checksum 负责检测MySQL主从数据一致性</p> 
<p>2. pt-table-sync负责挡住从数据不一致时修复数据，让他们保存数据的一致性</p> 
<p>3. pt-heartbeat 负责监控MySQL主从同步延迟</p> 
<p><strong>一致性校验思路：</strong></p> 
<p>1、确定校验的主库，根据需要校验的表，分段获取数据</p> 
<p>2、与从库进行校验（根据id）</p> 
<p>3、校验的过程发现数据不一致的时候</p> 
<p>4、在主库创建一个表 记录校验不一致的数据</p> 
<p>5、恢复只需要读取这个表</p> 
<p><strong>工具下载：</strong><a href="https://downloads.percona.com/downloads/percona-toolkit/percona-toolkit-3.3.0/binary/redhat/7/x86_64/percona-toolkit-3.3.0-1.el7.x86_64.rpm">https://downloads.percona.com/downloads/percona-toolkit/percona-toolkit-3.3.0/binary/redhat/7/x86_64/percona-toolkit-3.3.0-1.el7.x86_64.rpm</a></p> 
<h3>安装<strong>percona-toolkit</strong></h3> 
<pre><code class="language-bash">非docker容器安装
yum install perl-IO-Socket-SSL perl-DBD-MySQL perl-Time-HiRes perl perl-DBI -y
wget https://downloads.percona.com/downloads/percona-toolkit/percona-toolkit-3.3.0/binary/redhat/7/x86_64/percona-toolkit-3.3.0-1.el7.x86_64.rpm

yum install percona-toolkit-3.3.0-1.el7.x86_64.rpm 
 
yum list | grep percona-toolkit -y
 
[root@Master new_date]# yum list | grep percona
percona-toolkit.x86_64                   3.3.0-1.el7                   installed

 
 
 
docker容器中安装
apt-get update 
 
apt-get install percona-toolkit
 
 
pt-table-checksum --help
 
pt-table-checksum使用
pt-table-checksum [options] [dsn]
 
pt-table-checksum：在主（master）上通过执行校验的查询对复制的一致性进行检查，对比主从的校验值，从而产生结果。DSN指向的是主的地址，该工具的退出状态不为零，如果发现有任何差别，或者如果出现任何警告或错误，更多信息请查看官方资料。</code></pre> 
<p><img alt="" height="444" src="https://img-blog.csdnimg.cn/20210118111131386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="722"></p> 
<h3>1、准备实战模拟一下数据的不一致，首先在主库中创建一个数据库，创建数据表，然后添加一些数据</h3> 
<p>环境已经准备好</p> 
<p>有需要的可以参考</p> 
<p>这边我才用docker来模拟，环境很快构建完成来演示。</p> 
<p>下面是链接，可以参考</p> 
<h1 id="articleContentId"><a name="t3"></a><a href="https://blog.csdn.net/heian_99/article/details/103609082">Docker安装MySQL集群【读写分离】</a></h1> 
<p><img alt="" height="238" src="https://img-blog.csdnimg.cn/2021011811134256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="431"></p> 
<h3>2、主库中进行检测数据是否一致</h3> 
<pre><code class="language-bash">create database mytest;
 
use mytest;
 
create table user(
    id int auto_increment not null primary key,
    name varchar(20) 
)engine=InnoDB charset=utf8;
 
 
show tables;
 
insert into user values (1,'aa');
 
insert into user values (2,'bb');
 
insert into user values (3,'cc');
 
select * from user;</code></pre> 
<pre><code class="language-bash">注意常用的参数解释：
--nocheck-replication-filters ：不检查复制过滤器，建议启用。后面可以用--databases来指定需要检查的数据库。
 
--no-check-binlog-format : 不检查复制的binlog模式，要是binlog模式是ROW，则会报错。
 
--replicate-check-only :只显示不同步的信息。
 
--replicate= ：把checksum的信息写入到指定表中，建议直接写到被检查的数据库当中。
 
--databases= ：指定需要被检查的数据库，多个则用逗号隔开。
 
--tables= ：指定需要被检查的表，多个用逗号隔开
 
--host | h= ：Master的地址
 
--user | u= ：用户名
 
--passwork | p=：密码
 
--Port | P= ：端口
 
检测
root@71399784f284:/# pt-table-checksum --nocheck-replication-filters --replicate=check_data.checksums --databases=mytest --tables=user --user=root --password=123456
 
Checking if all tables can be checksummed ...
Starting checksum ...
Replica 00847056d2fa has binlog_format ROW which could cause pt-table-checksum to break replication.  Please read "Replicas using row-based replication" in the LIMITATIONS section of the tool's documentation.  If you understand the risks, specify --no-check-binlog-format to disable this check.
1)上面的错误信息主要是因为，检测主库与从库的binlog日志的模式 - 通常来说可以不用改binlog添加 --no-check-binlog-format 跳过检测,但是可能也会出现如下的问题
root@71399784f284:/# pt-table-checksum --nocheck-replication-filters --replicate=check_data.checksums --databases=mytest --no-check-binlog-format --tables=user --user=root --password=123456
Diffs cannot be detected because no slaves were found. Please read the —recursion-method documentation for information.
2)问题原因是没有找到从库的地址，MySQL在做主从的时候可能会因为环境配置等因素，让pt-table-checksum没有很好地找到从库的地址 检测的方式：
1. 是否是指定在主库运行进行校验
2. 就是配置--recursion-method参数，然后在从库中指定好对应的地址
正确情况下：
root@71399784f284:/# pt-table-checksum --nocheck-replication-filters --replicate=check_data.checksums --databases=mytest --no-check-binlog-format --tables=user --user=root --password=123456
Checking if all tables can be checksummed ...
Starting checksum ...
            TS ERRORS  DIFFS     ROWS  DIFF_ROWS  CHUNKS SKIPPED    TIME TABLE
05-14T09:48:45      0      0        3          0       1       0   0.030 mytest.user</code></pre> 
<h3>补充（pt-mysql-summary）</h3> 
<p><strong>pt-summary #显示和系统相关的基本信息：</strong></p> 
<pre><code class="language-bash">[root@master ~]# pt-summary </code></pre> 
<p><img alt="" height="645" src="https://img-blog.csdnimg.cn/20210118114907409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="961"></p> 
<p><strong>pt-mysql-summary #查看mysql的各个统计信息：</strong></p> 
<pre><code class="language-bash">pt-mysql-summary --host=192.168.0.10 --port=3307 --user=root --password=root --all-databases</code></pre> 
<p><img alt="" height="522" src="https://img-blog.csdnimg.cn/20210118114427698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1040"></p> 
<p><strong>pt-slave-find #查找和显示指定的Master 有多少个Slave：</strong></p> 
<pre><code class="language-bash">[root@Master ~]# pt-slave-find --host=192.168.0.10 --port=3307 --user=root --password=root
192.168.0.10:3307
Version         5.7.32-log
Server ID       1
Uptime          36:46 (started 2021-01-18T11:10:35)
Replication     Is not a slave, has 1 slaves connected, is not read_only
Filters         binlog_do_db=CMS,CRM
Binary logging  ROW
Slave status    
Slave mode      STRICT
Auto-increment  increment 1, offset 1
InnoDB version  5.7.32
</code></pre> 
<h2 id="pt-table-sync%E5%B7%A5%E5%85%B7%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><strong>pt-table-sync工具恢复数据</strong></h2> 
<p>手册地址：https://www.percona.com/doc/percona-toolkit/LATEST/pt-table-sync.html</p> 
<p>1、在从数据库中人为添加两条数据，从而让主从数据不一致</p> 
<p><img alt="" height="302" src="https://img-blog.csdnimg.cn/2021011812312251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="550"></p> 
<p>2、主库中进行检测数据一致性问题</p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20200516160044956.png"></p> 
<p>3、主库打印恢复数据</p> 
<pre><code class="language-bash">pt-table-sync --replicate=rep_test.checksums h=172.17.0.2,u=root,p=123456 h=172.17.0.3,u=slave_check,p=123456 --print
 
pt-table-sync --replicate=rep_test.checksums h=172.17.0.2,u=root,p=123456 h=172.17.0.3,u=slave_check,p=123456 --execute 
 
或者
pt-table-sync --sync-to-master h=172.17.0.3,u=slave_check,p=123456,P=3306 --databases=mytest --print
 
pt-table-sync --sync-to-master h=172.17.0.3,u=slave_check,p=123456,P=3306 --databases=mytest --execute 
 
--replicate= ：指定通过pt-table-checksum得到的表，这2个工具差不多都会一直用。
--databases= : 指定执行同步的数据库，多个用逗号隔开。
--tables= ：指定执行同步的表，多个用逗号隔开。
--sync-to-master ：指定一个DSN，即从的IP，他会通过show processlist或show slave status 去自动的找主。
h=127.0.0.1 ：服务器地址，命令里有2个ip，第一次出现的是Master的地址，第2次是Slave的地址。
u=root ：帐号。
p=123456 ：密码。
--print ：打印，但不执行命令。
--execute ：执行命令。</code></pre> 
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/20200518172920136.png"></p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/2020051616251731.png"></p> 
<p>4、主库执行数据恢复&nbsp;，从库中查看数据发现已经恢复。</p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20200516163038142.png"><img alt="" src="https://img-blog.csdnimg.cn/20200518174046775.png"></p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20200516163111753.png"></p> 
<p>上面操作是手动执行的数据检测与数据恢复，但实际工作中是不可能每天手动这样进行操作的，那么怎么做呢？</p> 
<p>接下来我们可以写一个shell脚本来定时执行检测与恢复操作，这样就可以省掉不少麻烦。&nbsp;</p> 
<pre><code class="language-bash">vi /home/pt-check-sync.sh
 
#!/bin/bash
NUM=`pt-table-checksum --tables=user  --databases=mytest --user=root --password='123456' --replicate=check_data.checksums --no-check-binlog-format --recursion-method dsn=t=mytest.dsns,h=172.17.0.3,u=slave_check,p=123456,P=3306 | awk 'NR&gt;1{sum+=$3}END{print sum}'`
if [ $NUM -eq 0 ] ;
then
    echo "Data is ok!"
else
    echo "Data is error!"
    pt-table-sync --sync-to-master h=172.17.0.3,u=slave_check,p=123456,P=3306 --databases=mytest --print
 
    pt-table-sync --sync-to-master h=172.17.0.3,u=slave_check,p=123456,P=3306 --databases=mytest --execute 
fi</code></pre> 
<p>&nbsp;执行sh pt-check-sync.sh文件，也可以写定时器执行</p> 
<pre><code class="language-bash">apt-get update 
 
apt-get install -y --no-install-recommends cron
 
chmod +x ./docker-entrypoint.sh
 
# 保存环境变量，开启crontab服务
env &gt;&gt; /etc/default/locale
/etc/init.d/cron start
 
crontab -e 
 
20 23 * * * /home/pt-check-sync.sh
 
表示每天晚上23:20运行这个脚本</code></pre> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20200518230632492.png"><img alt="" src="https://img-blog.csdnimg.cn/2020051823070033.png"></p>
                ]]></description></item><item><title>当MySQL主从数据不一致，怎么解决？？？</title><link>http://www.cnblogs.com/heian99/archive/2021/01/17/14466676.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 17 Jan 2021 15:46:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/01/17/14466676.html</guid><description><![CDATA[
                    <h2>当MySQL主从数据不一致，怎么解决？？？</h2> 
<ul><li> <p>在使用mysql replication时，有时候会担心，如果主库和备库的数据不一致，怎么办？以前是重新停掉从库，重新做主从，但是耗费时间太多</p> </li><li> <p>最近找到了一个mysql的工具，<code>mysqldbcompare</code>，可以实现对多库数据的对比。</p> </li></ul>
<h2>下面MySQL主从原理</h2> 
<p>一、主从复制</p> 
<p>MySQL数据库复制操作大致可以分成三个步骤：</p> 
<p>1. 主服务器将数据的改变记录到二进制日志（binary log）中。</p> 
<p>2. 从服务器将主服务器的binary log events 复制到它的中继日志（relay log）中。</p> 
<p>3. 从服务器重做中继日志中的事件，将数据的改变与从服务器保持同步。</p> 
<p>首先，主服务器会记录二进制日志，每个事务更新数据完成之前，主服务器将这些操作的信息记录在二进制日志里面在事件写入二进制日志完成后主服务器通知 存储引擎提交事务。</p> 
<p>准备： 了解binlog日志，MySQL用户-权限 mysql服务器配置复制不难，但是因为场景不同可能会存在一定的差异化，总的来说分为一下几步：</p> 
<p>1. 在服务器上创建复制账号。</p> 
<p>2. 通知备库连接到主库并从主库复制数据。</p> 
<p><img alt="" src="https://img-blog.csdnimg.cn/20191219104313635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p> 
<p id="%E4%BA%8C%E3%80%81%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E6%A0%A1%E9%AA%8C">二、主从一致性问题校验</p> 
<p>在理想情况下，备库和主库的数据应该是完全一样的。但事实上备库可能发生错误并导致数据不一致。即使没有明显的错误，备库同样可能因为MySQL自身的特性导致数据不一致，例如MySQL的Bug感、网络中断、服务器崩溃，非正常关闭或者其他一些错误。 按照我们的经验来看，主备一致应该是一种规范，而不是例外，也就是说，检查你的主备库一致性应该是一个日常工作，特别是当使用备库来做备份时尤为重要，因为肯定不希望从一个已经损坏的备库里获得备份数据。</p> 
<p><strong>产生原因：</strong></p> 
<p>1、网络中断</p> 
<p>2、服务器产生了问题</p> 
<p>3、mysql自带bug</p> 
<p>4、从库进行了非正当的操作（比如从库进行了添加，删除，修改，主库就会断开）</p> 
<h2>环境构建</h2> 
<p>这边我才用docker来模拟，环境很快构建完成来演示。</p> 
<p>下面是链接，可以参考</p> 
<h1 id="articleContentId"><a href="https://blog.csdn.net/heian_99/article/details/103609082">Docker安装MySQL集群【读写分离】</a></h1> 
<p><strong>MySQL：5.7</strong></p> 
<p><img alt="" height="198" src="https://img-blog.csdnimg.cn/20210117223406449.png" width="1200"></p> 
<p><img alt="" height="535" src="https://img-blog.csdnimg.cn/20210117230333924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="457"></p> 
<p>环境以及构建完成，下面开始试验吧。</p> 
<h2>安装工具：</h2> 
<pre><code class="language-bash">[root@db03 ~]# wget  https://downloads.mysql.com/archives/get/p/30/file/mysql-utilities-1.6.5-1.el7.noarch.rpm
[root@db03 ~]# wget https://downloads.mysql.com/archives/get/p/29/file/mysql-connector-python-2.1.7-1.el7.x86_64.rpm

[root@db03 ~]# yum -y localinstall mysql-connector-python-2.1.7-1.el7.x86_64.rpm
[root@db03 ~]# yum -y localinstall mysql-utilities-1.6.5-1.el7.noarch.rpm</code></pre> 
<p>检查两个实例的数据：</p> 
<p>可以看到mster和salver都有CMS库，可以同步数据。</p> 
<p><img alt="" height="268" src="https://img-blog.csdnimg.cn/20210117230712635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="413"></p> 
<p>现在数据都是一致的。现在对比看一下。</p> 
<blockquote> 
 <p><code>mysqldbcompare</code>的语法如下：</p> 
 <pre><code class="language-html hljs">$&nbsp;mysqldbcompare --server1=user:pass@host:port:socket --server2=user:pass@host:port:socket db1:db2</code></pre> 
 <p>以上参数中：</p> 
 <ul><li><code>--server1</code>：MySQL服务器1配置。</li><li><code>--server2</code>：MySQL服务器2配置。如果是同一服务器，<code>--server2</code>可以省略。</li><li><code>db1:db2</code>：要比较的两个数据库。如果比较不同服务器上的同名数据库，可以省略<code>:db2</code>。</li><li><code>--all</code>：比较所有两服务器上所有的同名数据库。<code>--exclude</code>排除无需比较的数据库。</li><li><code>--run-all-tests</code>：运行完整比较，遇到第一次差异时不停止。</li><li><code>--changes-for=</code>：修改对象。例如<code>--changes-for=server2</code>，那么对比以<code>sever1</code>为主，生成的差异的修改也是针对<code>server2</code>的对象的修改。</li><li><code>-d DIFFTYPE</code>,<code>--difftype=DIFFTYPE</code>：差异的信息显示的方式，有<code>[unified|context|differ|sql]</code>，默认是<code>unified</code>。如果使用sql，那么就直接生成差异的SQL，这样非常方便。</li><li><code>--show-reverse</code>：在生成的差异修改里面，同时会包含<code>server2</code>和<code>server1</code>的修改。</li><li><code>--skip-table-options</code>：保持表的选项不变，即对比的差异里面不包括<code>表名</code>、<code>AUTO_INCREMENT</code>、<code>ENGINE</code>、<code>CHARSET</code>等差异。</li><li><code>--skip-diff</code>：跳过对象定义比较检查。所谓对象定义，就是<code>CREATE</code>语句<code>()</code>里面的部分，<code>--skip-table-options</code>是()外面的部分。</li><li><code>--skip-object-compare</code>：默认情况下，先检查两个数据库中相互缺失的对象，再对都存在对象间的差异。这个参数的作用就是，跳过第一步，不检查相互缺失的对象。</li><li><code>--skip-checksum-table</code>：数据一致性验证时跳过<code>CHECKSUM TABLE</code>。</li><li><code>--skip-data-check</code>：跳过数据一致性验证。</li><li><code>--skip-row-count</code>：跳过字段数量检查。</li></ul>
</blockquote> 
<pre><code class="language-bash"> mysqldbcompare --server1=root:root@127.0.0.1:3307 --server2=root:root@127.0.0.1:3316 --changes-for=server2 --difftype=sql --run-all-tests --all &gt; mysqldbcompare_diff_2.sql</code></pre> 
<p><img alt="" height="572" src="https://img-blog.csdnimg.cn/20210117232019824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="748"></p> 
<p><img alt="" height="616" src="https://img-blog.csdnimg.cn/20210117232030945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="757"></p> 
<p>检查没有错误</p> 
<h2>停掉主从同步</h2> 
<p>从库执行</p> 
<pre><code class="language-bash">stop slave;
</code></pre> 
<h2>修改主库数据</h2> 
<p><img alt="" height="337" src="https://img-blog.csdnimg.cn/20210117232844565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>看这边已经对比出修改的字段了</p> 
<pre><code class="language-bash">UPDATE `CMS`.`CI_CHANNEL` SET `SHORT_NAME` = 'welcome heian', `UPDATE_TIME` = '2021-01-14 15:36:59' WHERE `ID` = '1'</code></pre> 
<p>&nbsp;</p> 
<p>我已经在从库执行这条语句</p> 
<p><img alt="" height="522" src="https://img-blog.csdnimg.cn/20210117233123762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="798"></p> 
<p><img alt="" height="385" src="https://img-blog.csdnimg.cn/20210117233200945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="953"></p> 
<p>&nbsp;</p> 
<p>删除大量的数据做对比</p> 
<p><img alt="" height="869" src="https://img-blog.csdnimg.cn/20210117234437196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="945" src="https://img-blog.csdnimg.cn/20210117234500153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<p>数据就可以恢复了</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>OpenVPN项目异地组网，远程访问</title><link>http://www.cnblogs.com/heian99/archive/2021/01/01/14220689.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 01 Jan 2021 11:27:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/01/01/14220689.html</guid><description><![CDATA[<h2>1.OpenVPN基本概述</h2>
<p>VPN直译就是虚拟专用通道，是提供给企业之间或者个人与公司之间安全数据传输的隧道，OpenVPN无疑是Linux下开源VPN先锋，提供了良好的性能和友好的用户界面GUI。OpenVPN和传统的VPN相比，它的优点是安全、简单易用。</p>
<p>其它vpn：pptp 互联网上服务商给拦截。不稳定。</p>
<h3>openvpn原理（面试重点）</h3>
<p>OpenVpn的技术核心是虚拟网卡，其次是SSL协议实现，由于SSL协议在其它的词条中介绍的比较清楚了，这里重点对虚拟网卡及其在OpenVpn的中的工作机理进行介绍：</p>
<p>虚拟网卡是使用网络底层编程技术实现的一个驱动软件，安装后在主机上多出现一个网卡，可以像其它网卡一样进行配置。服务程序可以在应用层打开虚拟网卡，如果应用软件（如IE）向虚拟网卡发送数据，则服务程序可以读取到该数据，如果服务程序写合适的数据到虚拟网卡，应用软件也可以接收得到。虚拟网卡在很多的操作系统下都有相应的实现，这也是OpenVpn能够跨平台一个很重要的理由。</p>
<p>在OpenVpn中，如果用户访问一个远程的虚拟地址（属于虚拟网卡配用的地址系列，区别于真实地址），则操作系统会通过路由机制将数据包（TUN模式）或数据帧（TAP模式）发送到虚拟网卡上，服务程序接收该数据并进行相应的处理后，通过SOCKET从外网上发送出去，远程服务程序通过SOCKET从外网上接收数据，并进行相应的处理后，发送给虚拟网卡，则应用软件可以接收到，完成了一个单向传输的过程，反之亦然。</p>
<h2>2.OpenVPN应用场景</h2>
<p>Peer-to-Peer VPN(点对点连接)，将Internet两台机器（公网地址）使用VPN连接起来，比如上海服务器和北京服务器之间的数据需要相互调用，但是数据又比较敏感，直接通过http公共网络传输，容易被窃取，如果拉一条专线成本又太高。那么我们可以通过VPN使用现有网络，将两台主机逻辑上捆绑在一个虚拟网络中，这样既保证了数据传输安全，同时又节省了成本。</p>
<h2>3.OpenVPN场景实践（通过任何网络远程访问企业内部服务器）</h2>
<p>1.用户通过Internet连接vpn服务通过加密技术进行数据传输；</p>
<p>2.加密实现方式是客户端公钥加密，服务端私钥解密；</p>
<p>3.客户端连接vpn后，vpn会给客户端推送一条内网路由以此实现内部主机通信</p>
<h2>4.配置</h2>
<h3>1、搭建流程图</h3>
<h2>1.OpenVPN基本概述</h2>
<p>VPN直译就是虚拟专用通道，是提供给企业之间或者个人与公司之间安全数据传输的隧道，OpenVPN无疑是Linux下开源VPN先锋，提供了良好的性能和友好的用户界面GUI。OpenVPN和传统的VPN相比，它的优点是安全、简单易用。</p>
<p>其它vpn：pptp 互联网上服务商给拦截。不稳定。</p>
<h3>openvpn原理（面试重点）</h3>
<p>OpenVpn的技术核心是虚拟网卡，其次是SSL协议实现，由于SSL协议在其它的词条中介绍的比较清楚了，这里重点对虚拟网卡及其在OpenVpn的中的工作机理进行介绍：</p>
<p>虚拟网卡是使用网络底层编程技术实现的一个驱动软件，安装后在主机上多出现一个网卡，可以像其它网卡一样进行配置。服务程序可以在应用层打开虚拟网卡，如果应用软件（如IE）向虚拟网卡发送数据，则服务程序可以读取到该数据，如果服务程序写合适的数据到虚拟网卡，应用软件也可以接收得到。虚拟网卡在很多的操作系统下都有相应的实现，这也是OpenVpn能够跨平台一个很重要的理由。</p>
<p>在OpenVpn中，如果用户访问一个远程的虚拟地址（属于虚拟网卡配用的地址系列，区别于真实地址），则操作系统会通过路由机制将数据包（TUN模式）或数据帧（TAP模式）发送到虚拟网卡上，服务程序接收该数据并进行相应的处理后，通过SOCKET从外网上发送出去，远程服务程序通过SOCKET从外网上接收数据，并进行相应的处理后，发送给虚拟网卡，则应用软件可以接收到，完成了一个单向传输的过程，反之亦然。</p>
<h2>2.OpenVPN应用场景</h2>
<p>Peer-to-Peer VPN(点对点连接)，将Internet两台机器（公网地址）使用VPN连接起来，比如上海服务器和北京服务器之间的数据需要相互调用，但是数据又比较敏感，直接通过http公共网络传输，容易被窃取，如果拉一条专线成本又太高。那么我们可以通过VPN使用现有网络，将两台主机逻辑上捆绑在一个虚拟网络中，这样既保证了数据传输安全，同时又节省了成本。</p>
<h2>3.OpenVPN场景实践（通过任何网络远程访问企业内部服务器）</h2>
<p>1.用户通过Internet连接vpn服务通过加密技术进行数据传输；</p>
<p>2.加密实现方式是客户端公钥加密，服务端私钥解密；</p>
<p>3.客户端连接vpn后，vpn会给客户端推送一条内网路由以此实现内部主机通信</p>
<h2>4.配置</h2>
<h3>1、搭建流程图</h3>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="27"><img src="https://img-blog.csdnimg.cn/2021010118224537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="776" height="310" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/2021010118224537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/2021010118224537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;776&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;310&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></span></p>
<h3>2、安装openvpn、easy-rsa、iptables-server</h3>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="26">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;yum install epel-* -y\nyum -y install openvpn easy-rsa iptables-services\n&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">yum install epel-* -y
yum -y install openvpn easy-rsa iptables-services
</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<h3>3、生成证书及相关文件</h3>
<p>利用easy-rsa生成相关证书文件</p>
<ul>
<li>
<p>CA根证书</p>
</li>
<li>
<p>openvpn服务器证书</p>
</li>
<li>
<p>Diffie-Hellman算法用到的key 复制easy-rsa脚本到/etc/openvpn下面，该脚本是用来生成CA证书和各种key文件</p>
</li>
</ul>
<p>复制easy-rsa脚本到/etc/openvpn下面，该脚本是用来生成CA证书和各种key文件</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="25">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;cp -r /usr/share/easy-rsa/ /etc/openvpn/&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">cp -r /usr/share/easy-rsa/ /etc/openvpn/</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="24"><img src="https://img-blog.csdnimg.cn/20210101182410654.png" alt="" width="597" height="143" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/20210101182410654.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20210101182410654.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;597&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;143&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></span></p>
<p>查看证书版本号进入相关目录，创建文件并设置变量</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="23"><img src="https://img-blog.csdnimg.cn/20210101182422745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="883" height="606" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/20210101182422745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20210101182422745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;883&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;606&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></span></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="22">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpn openvpn]# cd /etc/openvpn/easy-rsa/3.0.8/\n[root@openvpn 3.0.8]# ls\neasyrsa  openssl-easyrsa.cnf    vars  x509-types\n#新建vars文件，编辑变量，初始化\n[root@openvpn 3.0.8]# vim vars \n\nexport KEY_COUNTRY=\&amp;quot;CN\&amp;quot;\nexport KEY_PROVINCE=\&amp;quot;ShangHai\&amp;quot;\nexport KEY_CITY=\&amp;quot;ShangHai\&amp;quot;\nexport KEY_ORG=\&amp;quot;YCZB\&amp;quot;\nexport KEY_EMAIL=\&amp;quot;heian@heian.com\&amp;quot;\n\n[root@openvpn 3.0.8]# source ./vars\n&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">[root@openvpn openvpn]<span class="hljs-comment"># cd /etc/openvpn/easy-rsa/3.0.8/
[root@openvpn 3.0.8]<span class="hljs-comment"># ls
easyrsa  openssl-easyrsa.cnf    vars  x509-types
<span class="hljs-comment">#新建vars文件，编辑变量，初始化
[root@openvpn 3.0.8]<span class="hljs-comment"># vim vars 

<span class="hljs-built_in">export KEY_COUNTRY=<span class="hljs-string">"CN"
<span class="hljs-built_in">export KEY_PROVINCE=<span class="hljs-string">"ShangHai"
<span class="hljs-built_in">export KEY_CITY=<span class="hljs-string">"ShangHai"
<span class="hljs-built_in">export KEY_ORG=<span class="hljs-string">"YCZB"
<span class="hljs-built_in">export KEY_EMAIL=<span class="hljs-string">"heian@heian.com"

[root@openvpn 3.0.8]<span class="hljs-comment"># source ./vars
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>生成CA根证书</p>
<blockquote>
<p>#初始化 pki 相关目录</p>
<p>./easyrsa init-pki</p>
</blockquote>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="21"><img src="https://img-blog.csdnimg.cn/20210101182504691.png" alt="" width="767" height="130" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/20210101182504691.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20210101182504691.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;767&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;130&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></span></p>
<p>生成 CA 根证书, 输入 Common Name，名字随便起。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="20">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;./easyrsa build-ca nopass &amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">./easyrsa build-ca nopass </code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="19"><img src="https://img-blog.csdnimg.cn/20210101182527653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="764" height="366" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/20210101182527653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20210101182527653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;764&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;366&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></span></p>
<p>生成openvpn服务器证书和密钥，第一个参数是证书名称</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="18">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;./easyrsa build-server-full server nopass&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">./easyrsa build-server-full server nopass</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="17"><img src="https://img-blog.csdnimg.cn/20210101182550413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="792" height="303" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/20210101182550413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20210101182550413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;792&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;303&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></span></p>
<p>生成Diffie-Hellman算法需要的密钥文件</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="16">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;  ./easyrsa gen-dh   #创建 Diffie-Hellman ，时间比较久一些&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">  ./easyrsa gen-dh   <span class="hljs-comment">#创建 Diffie-Hellman ，时间比较久一些</span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="15"><img src="https://img-blog.csdnimg.cn/20210101182614295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="766" height="224" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/20210101182614295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20210101182614295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;766&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;224&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></span></p>
<p>生成tls-auth key，为了防止DDOS和TLS攻击，这个属于可选安全配置</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="14">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;openvpn --genkey --secret ta.key&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">openvpn --genkey --secret ta.key</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>openvpn文件整理</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="13">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;mkdir /etc/openvpn/server/certs \ncd /etc/openvpn/server/certs/\n# SSL 协商时 Diffie-Hellman 算法需要的 key\ncp /etc/openvpn/easy-rsa/3/pki/dh.pem ./  \n# CA 根证书\ncp /etc/openvpn/easy-rsa/3/pki/ca.crt ./  \n# open VPN 服务器证书\ncp /etc/openvpn/easy-rsa/3/pki/issued/yczbjt.crt ./server.crt \n# open VPN 服务器证书 key\ncp /etc/openvpn/easy-rsa/3/pki/private/yczbjt.key ./server.key \n# tls-auth key\ncp /etc/openvpn/easy-rsa/3/ta.key ./  \n&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">mkdir /etc/openvpn/server/certs 
<span class="hljs-built_in">cd /etc/openvpn/server/certs/
<span class="hljs-comment"># SSL 协商时 Diffie-Hellman 算法需要的 key
cp /etc/openvpn/easy-rsa/3/pki/dh.pem ./  
<span class="hljs-comment"># CA 根证书
cp /etc/openvpn/easy-rsa/3/pki/ca.crt ./  
<span class="hljs-comment"># open VPN 服务器证书
cp /etc/openvpn/easy-rsa/3/pki/issued/yczbjt.crt ./server.crt 
<span class="hljs-comment"># open VPN 服务器证书 key
cp /etc/openvpn/easy-rsa/3/pki/private/yczbjt.key ./server.key 
<span class="hljs-comment"># tls-auth key
cp /etc/openvpn/easy-rsa/3/ta.key ./  
</span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>创建openvpn日志目录</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="12">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpnservice certs]# /etc/openvpn/cdd\n#创建日志目录\n[root@openvpnservice certs]# mkdir -p /var/log/openvpn/\n#给予权限\n[root@openvpnservice certs]# chown openvpn:openvpn /var/log/openvpn\n&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">[root@openvpnservice certs]<span class="hljs-comment"># /etc/openvpn/cdd
<span class="hljs-comment">#创建日志目录
[root@openvpnservice certs]<span class="hljs-comment"># mkdir -p /var/log/openvpn/
<span class="hljs-comment">#给予权限
[root@openvpnservice certs]<span class="hljs-comment"># chown openvpn:openvpn /var/log/openvpn
</span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<h3>4、配置OpenVPN</h3>
<p>创建配置文件（原配置文件在 /usr/share/doc/openvpn-2.4.9/sample/sample-config-files/server.conf ）</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="11">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpnservice ~]# cd /etc/openvpn/\n[root@openvpnservice openvpn]# vim server.conf\nport 1194                               #端口\nproto udp                               #协议\ndev tun                                 #采用路由隧道模式tun\nca ca.crt                               #ca证书文件位置\ncert server.crt                         #服务端公钥名称\nkey server.key                          #服务端私钥名称\ndh dh.pem                               #交换证书\nserver 10.8.0.0 255.255.255.0           #给客户端分配地址池，注意：不能和VPN服务器内网网段有相同\npush \&amp;quot;route 172.16.1.0 255.255.255.0\&amp;quot;   #允许客户端访问内网172.16.1.0网段\nifconfig-pool-persist ipp.txt           #地址池记录文件位置\nkeepalive 10 120                        #存活时间，10秒ping一次,120 如未收到响应则视为断线\nmax-clients 100                         #最多允许100个客户端连接\nstatus openvpn-status.log               #日志记录位置\nverb 3                                  #openvpn版本\nclient-to-client                        #客户端与客户端之间支持通信\nlog /var/log/openvpn.log                #openvpn日志记录位置\npersist-key     #通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keys。\npersist-tun     #检测超时后，重新启动VPN，一直保持tun是linkup的。否则网络会先linkdown然后再linkup\nduplicate-cn&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">[root@openvpnservice ~]<span class="hljs-comment"># cd /etc/openvpn/
[root@openvpnservice openvpn]<span class="hljs-comment"># vim server.conf
port 1194                               <span class="hljs-comment">#端口
proto udp                               <span class="hljs-comment">#协议
dev tun                                 <span class="hljs-comment">#采用路由隧道模式tun
ca ca.crt                               <span class="hljs-comment">#ca证书文件位置
cert server.crt                         <span class="hljs-comment">#服务端公钥名称
key server.key                          <span class="hljs-comment">#服务端私钥名称
dh dh.pem                               <span class="hljs-comment">#交换证书
server 10.8.0.0 255.255.255.0           <span class="hljs-comment">#给客户端分配地址池，注意：不能和VPN服务器内网网段有相同
push <span class="hljs-string">"route 172.16.1.0 255.255.255.0"   <span class="hljs-comment">#允许客户端访问内网172.16.1.0网段
ifconfig-pool-persist ipp.txt           <span class="hljs-comment">#地址池记录文件位置
keepalive 10 120                        <span class="hljs-comment">#存活时间，10秒ping一次,120 如未收到响应则视为断线
max-clients 100                         <span class="hljs-comment">#最多允许100个客户端连接
status openvpn-status.log               <span class="hljs-comment">#日志记录位置
verb 3                                  <span class="hljs-comment">#openvpn版本
client-to-client                        <span class="hljs-comment">#客户端与客户端之间支持通信
<span class="hljs-built_in">log /var/<span class="hljs-built_in">log/openvpn.log                <span class="hljs-comment">#openvpn日志记录位置
persist-key     <span class="hljs-comment">#通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keys。
persist-tun     <span class="hljs-comment">#检测超时后，重新启动VPN，一直保持tun是linkup的。否则网络会先linkdown然后再linkup
duplicate-cn</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>我的配置Server端的文件：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="10">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;port 1194\nproto udp\ndev tun\nca /etc/openvpn/server/certs/ca.crt\ncert /etc/openvpn/server/certs/server.crt\nkey /etc/openvpn/server/certs/server.key\ndh /etc/openvpn/server/certs/dh.pem\ntls-auth /etc/openvpn/server/certs/ta.key 0\nserver 10.0.1.0 255.255.255.0\npush \&amp;quot;route 192.168.103.0 255.255.255.0\&amp;quot;\npush \&amp;quot;dhcp-option DNS 8.8.8.8\&amp;quot; \npush \&amp;quot;dhcp-option DNS 8.8.4.4\&amp;quot;\nifconfig-pool-persist ipp.txt\ncompress lzo\nduplicate-cn\nkeepalive 10 120\nclient-config-dir ccd\ncomp-lzo\npersist-key\npersist-tun\nuser openvpn\ngroup openvpn\nlog /var/log/openvpn/server.log\nlog-append /var/log/openvpn/server.log\nstatus /var/log/openvpn/status.log\nverb 3\nexplicit-exit-notify 1\n&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">port 1194
proto udp
dev tun
ca /etc/openvpn/server/certs/ca.crt
cert /etc/openvpn/server/certs/server.crt
key /etc/openvpn/server/certs/server.key
dh /etc/openvpn/server/certs/dh.pem
tls-auth /etc/openvpn/server/certs/ta.key 0
server 10.0.1.0 255.255.255.0
push <span class="hljs-string">"route 192.168.103.0 255.255.255.0"
push <span class="hljs-string">"dhcp-option DNS 8.8.8.8" 
push <span class="hljs-string">"dhcp-option DNS 8.8.4.4"
ifconfig-pool-persist ipp.txt
compress lzo
duplicate-cn
keepalive 10 120
client-config-dir ccd
comp-lzo
persist-key
persist-tun
user openvpn
group openvpn
<span class="hljs-built_in">log /var/<span class="hljs-built_in">log/openvpn/server.log
<span class="hljs-built_in">log-append /var/<span class="hljs-built_in">log/openvpn/server.log
status /var/<span class="hljs-built_in">log/openvpn/status.log
verb 3
explicit-exit-notify 1
</span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="9"><img src="https://img-blog.csdnimg.cn/2021010118275864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="678" height="740" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/2021010118275864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/2021010118275864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;678&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;740&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></span></p>
<h3>5、配置防火墙及安全服务</h3>
<p><strong>禁用firewalld，启用iptables</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="8">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpnservice openvpn]# systemctl stop firewalld\n[root@openvpnservice openvpn]# systemctl disable firewalld&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">[root@openvpnservice openvpn]<span class="hljs-comment"># systemctl stop firewalld
[root@openvpnservice openvpn]<span class="hljs-comment"># systemctl disable firewalld</span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>关闭selinux</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="7">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpnservice openvpn]# sed -i 's/SELINUX=enforcinf/SELINUX=disabled/g' /etc/sysconfig/selinux\n[root@openvpnservice openvpn]# setenforce 0&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">[root@openvpnservice openvpn]<span class="hljs-comment"># sed -i 's/SELINUX=enforcinf/SELINUX=disabled/g' /etc/sysconfig/selinux
[root@openvpnservice openvpn]<span class="hljs-comment"># setenforce 0</span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>启用iptables</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="6">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpnservice openvpn]# systemctl start iptables\n[root@openvpnservice openvpn]# systemctl enable iptables\n\niptables -F\n\n添加防火墙规则\n[root@openvpnservice openvpn]# iptables -t nat -A POSTROUTING -s 10.8.0.0/24  -j MASQUERADE\n[root@openvpnservice openvpn]# service iptables save\niptables: Saving firewall rules to /etc/sysconfig/iptables:[  确定  ]\n[root@openvpnservice openvpn]# systemctl restart iptables&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">[root@openvpnservice openvpn]<span class="hljs-comment"># systemctl start iptables
[root@openvpnservice openvpn]<span class="hljs-comment"># systemctl enable iptables

iptables -F

添加防火墙规则
[root@openvpnservice openvpn]<span class="hljs-comment"># iptables -t nat -A POSTROUTING -s 10.8.0.0/24  -j MASQUERADE
[root@openvpnservice openvpn]<span class="hljs-comment"># service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  确定  ]
[root@openvpnservice openvpn]<span class="hljs-comment"># systemctl restart iptables</span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<h3>6、服务器启用IP地址转发</h3>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="5">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;cpp&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpnservice openvpn]# echo net.ipv4.ip_forward = 1 &amp;gt;&amp;gt;/etc/sysctl.conf\n[root@openvpnservice openvpn]# sysctl -p\nnet.ipv4.ip_forward = 1&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-cpp hljs">[root@openvpnservice openvpn]<span class="hljs-meta"># echo net.ipv4.ip_forward = 1 &gt;&gt;/etc/sysctl.conf
[root@openvpnservice openvpn]<span class="hljs-meta"># sysctl -p
net.ipv4.ip_forward = <span class="hljs-number">1</span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<h3>7、启动服务</h3>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="4">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;systemctl start openvpn@server  # 启动\nsystemctl enable openvpn@server  # 开机自启动\nsystemctl status openvpn@server  # 查看服务状态&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">systemctl start openvpn@server  <span class="hljs-comment"># 启动
systemctl <span class="hljs-built_in">enable openvpn@server  <span class="hljs-comment"># 开机自启动
systemctl status openvpn@server  <span class="hljs-comment"># 查看服务状态</span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<h3>8、添加客户端用户</h3>
<p><strong>创建模版配置文件</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="3">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpnservice ~]# cd /etc/openvpn/client/\n[root@openvpnservice client]# touch sample.ovpn\n[root@openvpnservice client]# vim sample.ovpn\nclient\nproto udp\ndev tun\nremote 49.234.26.34 1194  #openvpn公网映射的ip地址和端口\nca ca.crt\ncert admin.crt\nkey admin.key\ntls-auth ta.key 1\nremote-cert-tls server\npersist-tun\npersist-key\ncomp-lzo\nverb 3\nmute-replay-warnings&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">[root@openvpnservice ~]<span class="hljs-comment"># cd /etc/openvpn/client/
[root@openvpnservice client]<span class="hljs-comment"># touch sample.ovpn
[root@openvpnservice client]<span class="hljs-comment"># vim sample.ovpn
client
proto udp
dev tun
remote 49.234.26.34 1194  <span class="hljs-comment">#openvpn公网映射的ip地址和端口
ca ca.crt
cert admin.crt
key admin.key
tls-auth ta.key 1
remote-cert-tls server
persist-tun
persist-key
comp-lzo
verb 3
mute-replay-warnings</span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>创建用户脚本（为了创建用户更方便）</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="2">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;# ! /bin/bash\nset -e\nOVPN_USER_KEYS_DIR=/etc/openvpn/client/keys\nEASY_RSA_VERSION=3\nEASY_RSA_DIR=/etc/openvpn/easy-rsa/\nPKI_DIR=$EASY_RSA_DIR/$EASY_RSA_VERSION/pki\n\nfor user in \&amp;quot;$@\&amp;quot;\ndo\n  if [ -d \&amp;quot;$OVPN_USER_KEYS_DIR/$user\&amp;quot; ]; then\n    rm -rf $OVPN_USER_KEYS_DIR/$user\n    rm -rf  $PKI_DIR/reqs/$user.req\n    sed -i '/'\&amp;quot;$user\&amp;quot;'/d' $PKI_DIR/index.txt\n  fi\n  cd $EASY_RSA_DIR/$EASY_RSA_VERSION\n  # 生成客户端 ssl 证书文件\n  ./easyrsa build-client-full $user nopass\n  # 整理下生成的文件\n  mkdir -p  $OVPN_USER_KEYS_DIR/$user\n  cp $PKI_DIR/ca.crt $OVPN_USER_KEYS_DIR/$user/   # CA 根证书\n  cp $PKI_DIR/issued/$user.crt $OVPN_USER_KEYS_DIR/$user/   # 客户端证书\n  cp $PKI_DIR/private/$user.key $OVPN_USER_KEYS_DIR/$user/  # 客户端证书密钥\n  cp /etc/openvpn/client/sample.ovpn $OVPN_USER_KEYS_DIR/$user/$user.ovpn # 客户端配置文件\n  sed -i 's/admin/'\&amp;quot;$user\&amp;quot;'/g' $OVPN_USER_KEYS_DIR/$user/$user.ovpn\n  cp /etc/openvpn/server/certs/ta.key $OVPN_USER_KEYS_DIR/$user/ta.key  # auth-tls 文件\n  cd $OVPN_USER_KEYS_DIR\n  zip -r $user.zip $user\ndone\nexit 0&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs"><span class="hljs-comment"># ! /bin/bash
<span class="hljs-built_in">set -e
OVPN_USER_KEYS_DIR=/etc/openvpn/client/keys
EASY_RSA_VERSION=3
EASY_RSA_DIR=/etc/openvpn/easy-rsa/
PKI_DIR=<span class="hljs-variable">$EASY_RSA_DIR/<span class="hljs-variable">$EASY_RSA_VERSION/pki

<span class="hljs-keyword">for user <span class="hljs-keyword">in <span class="hljs-string">"<span class="hljs-variable">$@"
<span class="hljs-keyword">do
  <span class="hljs-keyword">if [ -d <span class="hljs-string">"<span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user" ]; <span class="hljs-keyword">then
    rm -rf <span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user
    rm -rf  <span class="hljs-variable">$PKI_DIR/reqs/<span class="hljs-variable">$user.req
    sed -i <span class="hljs-string">'/'<span class="hljs-string">"<span class="hljs-variable">$user"<span class="hljs-string">'/d' <span class="hljs-variable">$PKI_DIR/index.txt
  <span class="hljs-keyword">fi
  <span class="hljs-built_in">cd <span class="hljs-variable">$EASY_RSA_DIR/<span class="hljs-variable">$EASY_RSA_VERSION
  <span class="hljs-comment"># 生成客户端 ssl 证书文件
  ./easyrsa build-client-full <span class="hljs-variable">$user nopass
  <span class="hljs-comment"># 整理下生成的文件
  mkdir -p  <span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user
  cp <span class="hljs-variable">$PKI_DIR/ca.crt <span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user/   <span class="hljs-comment"># CA 根证书
  cp <span class="hljs-variable">$PKI_DIR/issued/<span class="hljs-variable">$user.crt <span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user/   <span class="hljs-comment"># 客户端证书
  cp <span class="hljs-variable">$PKI_DIR/private/<span class="hljs-variable">$user.key <span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user/  <span class="hljs-comment"># 客户端证书密钥
  cp /etc/openvpn/client/sample.ovpn <span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user/<span class="hljs-variable">$user.ovpn <span class="hljs-comment"># 客户端配置文件
  sed -i <span class="hljs-string">'s/admin/'<span class="hljs-string">"<span class="hljs-variable">$user"<span class="hljs-string">'/g' <span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user/<span class="hljs-variable">$user.ovpn
  cp /etc/openvpn/server/certs/ta.key <span class="hljs-variable">$OVPN_USER_KEYS_DIR/<span class="hljs-variable">$user/ta.key  <span class="hljs-comment"># auth-tls 文件
  <span class="hljs-built_in">cd <span class="hljs-variable">$OVPN_USER_KEYS_DIR
  zip -r <span class="hljs-variable">$user.zip <span class="hljs-variable">$user
<span class="hljs-keyword">done
<span class="hljs-built_in">exit 0</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>创建用户执行脚本，后面跟用户名字，执行成功后会生成证书文件</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="1">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;[root@openvpnservice client]# sh ovpn_user.sh wangxuejin&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">[root@openvpnservice client]<span class="hljs-comment"># sh ovpn_user.sh wangxuejin</span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>导出压缩包解压后放到客户端目录中即可</p>
<h3>9、核心交换机添加路由</h3>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="0">
<pre class="cke_widget_element" data-cke-widget-data="{&amp;quot;lang&amp;quot;:&amp;quot;bash&amp;quot;,&amp;quot;code&amp;quot;:&amp;quot;ip route-static 10.10.0.0 255.255.255.0 172.18.1.182&amp;quot;,&amp;quot;classes&amp;quot;:[]}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet"><code class="language-bash hljs">ip route-static 10.10.0.0 255.255.255.0 172.18.1.182</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>备注：外网防火墙需要映射UDP 1194端口</p>]]></description></item><item><title>OpenVPN项目异地组网，远程访问</title><link>http://www.cnblogs.com/heian99/archive/2021/01/01/14999360.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 01 Jan 2021 11:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2021/01/01/14999360.html</guid><description><![CDATA[
                    <h2>1.OpenVPN基本概述</h2> 
<p>VPN直译就是虚拟专用通道，是提供给企业之间或者个人与公司之间安全数据传输的隧道，OpenVPN无疑是Linux下开源VPN先锋，提供了良好的性能和友好的用户界面GUI。OpenVPN和传统的VPN相比，它的优点是安全、简单易用。</p> 
<p>其它vpn：pptp 互联网上服务商给拦截。不稳定。</p> 
<h3>openvpn原理（面试重点）</h3> 
<p>OpenVpn的技术核心是虚拟网卡，其次是SSL协议实现，由于SSL协议在其它的词条中介绍的比较清楚了，这里重点对虚拟网卡及其在OpenVpn的中的工作机理进行介绍：</p> 
<p>虚拟网卡是使用网络底层编程技术实现的一个驱动软件，安装后在主机上多出现一个网卡，可以像其它网卡一样进行配置。服务程序可以在应用层打开虚拟网卡，如果应用软件（如IE）向虚拟网卡发送数据，则服务程序可以读取到该数据，如果服务程序写合适的数据到虚拟网卡，应用软件也可以接收得到。虚拟网卡在很多的操作系统下都有相应的实现，这也是OpenVpn能够跨平台一个很重要的理由。</p> 
<p>在OpenVpn中，如果用户访问一个远程的虚拟地址（属于虚拟网卡配用的地址系列，区别于真实地址），则操作系统会通过路由机制将数据包（TUN模式）或数据帧（TAP模式）发送到虚拟网卡上，服务程序接收该数据并进行相应的处理后，通过SOCKET从外网上发送出去，远程服务程序通过SOCKET从外网上接收数据，并进行相应的处理后，发送给虚拟网卡，则应用软件可以接收到，完成了一个单向传输的过程，反之亦然。</p> 
<h2>2.OpenVPN应用场景</h2> 
<p>Peer-to-Peer VPN(点对点连接)，将Internet两台机器（公网地址）使用VPN连接起来，比如上海服务器和北京服务器之间的数据需要相互调用，但是数据又比较敏感，直接通过http公共网络传输，容易被窃取，如果拉一条专线成本又太高。那么我们可以通过VPN使用现有网络，将两台主机逻辑上捆绑在一个虚拟网络中，这样既保证了数据传输安全，同时又节省了成本。</p> 
<h2>3.OpenVPN场景实践（通过任何网络远程访问企业内部服务器）</h2> 
<p>1.用户通过Internet连接vpn服务通过加密技术进行数据传输；</p> 
<p>2.加密实现方式是客户端公钥加密，服务端私钥解密；</p> 
<p>3.客户端连接vpn后，vpn会给客户端推送一条内网路由以此实现内部主机通信</p> 
<h2>4.配置</h2> 
<h3>1、搭建流程图</h3> 
<h2>1.OpenVPN基本概述</h2> 
<p>VPN直译就是虚拟专用通道，是提供给企业之间或者个人与公司之间安全数据传输的隧道，OpenVPN无疑是Linux下开源VPN先锋，提供了良好的性能和友好的用户界面GUI。OpenVPN和传统的VPN相比，它的优点是安全、简单易用。</p> 
<p>其它vpn：pptp 互联网上服务商给拦截。不稳定。</p> 
<h3>openvpn原理（面试重点）</h3> 
<p>OpenVpn的技术核心是虚拟网卡，其次是SSL协议实现，由于SSL协议在其它的词条中介绍的比较清楚了，这里重点对虚拟网卡及其在OpenVpn的中的工作机理进行介绍：</p> 
<p>虚拟网卡是使用网络底层编程技术实现的一个驱动软件，安装后在主机上多出现一个网卡，可以像其它网卡一样进行配置。服务程序可以在应用层打开虚拟网卡，如果应用软件（如IE）向虚拟网卡发送数据，则服务程序可以读取到该数据，如果服务程序写合适的数据到虚拟网卡，应用软件也可以接收得到。虚拟网卡在很多的操作系统下都有相应的实现，这也是OpenVpn能够跨平台一个很重要的理由。</p> 
<p>在OpenVpn中，如果用户访问一个远程的虚拟地址（属于虚拟网卡配用的地址系列，区别于真实地址），则操作系统会通过路由机制将数据包（TUN模式）或数据帧（TAP模式）发送到虚拟网卡上，服务程序接收该数据并进行相应的处理后，通过SOCKET从外网上发送出去，远程服务程序通过SOCKET从外网上接收数据，并进行相应的处理后，发送给虚拟网卡，则应用软件可以接收到，完成了一个单向传输的过程，反之亦然。</p> 
<h2>2.OpenVPN应用场景</h2> 
<p>Peer-to-Peer VPN(点对点连接)，将Internet两台机器（公网地址）使用VPN连接起来，比如上海服务器和北京服务器之间的数据需要相互调用，但是数据又比较敏感，直接通过http公共网络传输，容易被窃取，如果拉一条专线成本又太高。那么我们可以通过VPN使用现有网络，将两台主机逻辑上捆绑在一个虚拟网络中，这样既保证了数据传输安全，同时又节省了成本。</p> 
<h2>3.OpenVPN场景实践（通过任何网络远程访问企业内部服务器）</h2> 
<p>1.用户通过Internet连接vpn服务通过加密技术进行数据传输；</p> 
<p>2.加密实现方式是客户端公钥加密，服务端私钥解密；</p> 
<p>3.客户端连接vpn后，vpn会给客户端推送一条内网路由以此实现内部主机通信</p> 
<h2>4.配置</h2> 
<h3>1、搭建流程图</h3> 
<p><img alt="" height="310" src="https://img-blog.csdnimg.cn/2021010118224537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="776"></p> 
<h3>2、安装openvpn、easy-rsa、iptables-server</h3> 
<pre><code class="language-bash">yum install epel-* -y
yum -y install openvpn easy-rsa iptables-services
</code></pre> 
<h3>3、生成证书及相关文件</h3> 
<p>利用easy-rsa生成相关证书文件</p> 
<ul><li> <p>CA根证书</p> </li><li> <p>openvpn服务器证书</p> </li><li> <p>Diffie-Hellman算法用到的key 复制easy-rsa脚本到/etc/openvpn下面，该脚本是用来生成CA证书和各种key文件</p> </li></ul>
<p>复制easy-rsa脚本到/etc/openvpn下面，该脚本是用来生成CA证书和各种key文件</p> 
<pre><code class="language-bash">cp -r /usr/share/easy-rsa/ /etc/openvpn/</code></pre> 
<p>&nbsp;</p> 
<p><img alt="" height="143" src="https://img-blog.csdnimg.cn/20210101182410654.png" width="597"></p> 
<p>查看证书版本号进入相关目录，创建文件并设置变量</p> 
<p><img alt="" height="606" src="https://img-blog.csdnimg.cn/20210101182422745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="883"></p> 
<pre><code class="language-bash">[root@openvpn openvpn]# cd /etc/openvpn/easy-rsa/3.0.8/
[root@openvpn 3.0.8]# ls
easyrsa  openssl-easyrsa.cnf    vars  x509-types
#新建vars文件，编辑变量，初始化
[root@openvpn 3.0.8]# vim vars 

export KEY_COUNTRY="CN"
export KEY_PROVINCE="ShangHai"
export KEY_CITY="ShangHai"
export KEY_ORG="YCZB"
export KEY_EMAIL="heian@heian.com"

[root@openvpn 3.0.8]# source ./vars
</code></pre> 
<p>生成CA根证书</p> 
<blockquote> 
 <p>#初始化 pki 相关目录</p> 
 <p>./easyrsa init-pki</p> 
</blockquote> 
<p><img alt="" height="130" src="https://img-blog.csdnimg.cn/20210101182504691.png" width="767"></p> 
<p>生成 CA 根证书, 输入 Common Name，名字随便起。</p> 
<pre><code class="language-bash">./easyrsa build-ca nopass </code></pre> 
<p><img alt="" height="366" src="https://img-blog.csdnimg.cn/20210101182527653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="764"></p> 
<p>生成openvpn服务器证书和密钥，第一个参数是证书名称</p> 
<pre><code class="language-bash">./easyrsa build-server-full server nopass</code></pre> 
<p><img alt="" height="303" src="https://img-blog.csdnimg.cn/20210101182550413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="792"></p> 
<p>生成Diffie-Hellman算法需要的密钥文件</p> 
<pre><code class="language-bash">  ./easyrsa gen-dh   #创建 Diffie-Hellman ，时间比较久一些</code></pre> 
<p><img alt="" height="224" src="https://img-blog.csdnimg.cn/20210101182614295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="766"></p> 
<p>生成tls-auth key，为了防止DDOS和TLS攻击，这个属于可选安全配置</p> 
<pre><code class="language-bash">openvpn --genkey --secret ta.key</code></pre> 
<p>openvpn文件整理</p> 
<pre><code class="language-bash">mkdir /etc/openvpn/server/certs 
cd /etc/openvpn/server/certs/
# SSL 协商时 Diffie-Hellman 算法需要的 key
cp /etc/openvpn/easy-rsa/3/pki/dh.pem ./  
# CA 根证书
cp /etc/openvpn/easy-rsa/3/pki/ca.crt ./  
# open VPN 服务器证书
cp /etc/openvpn/easy-rsa/3/pki/issued/yczbjt.crt ./server.crt 
# open VPN 服务器证书 key
cp /etc/openvpn/easy-rsa/3/pki/private/yczbjt.key ./server.key 
# tls-auth key
cp /etc/openvpn/easy-rsa/3/ta.key ./  
</code></pre> 
<p>创建openvpn日志目录</p> 
<pre><code class="language-bash">[root@openvpnservice certs]# /etc/openvpn/cdd
#创建日志目录
[root@openvpnservice certs]# mkdir -p /var/log/openvpn/
#给予权限
[root@openvpnservice certs]# chown openvpn:openvpn /var/log/openvpn
</code></pre> 
<h3>4、配置OpenVPN</h3> 
<p>创建配置文件（原配置文件在 /usr/share/doc/openvpn-2.4.9/sample/sample-config-files/server.conf ）</p> 
<pre><code class="language-bash">[root@openvpnservice ~]# cd /etc/openvpn/
[root@openvpnservice openvpn]# vim server.conf
port 1194                               #端口
proto udp                               #协议
dev tun                                 #采用路由隧道模式tun
ca ca.crt                               #ca证书文件位置
cert server.crt                         #服务端公钥名称
key server.key                          #服务端私钥名称
dh dh.pem                               #交换证书
server 10.8.0.0 255.255.255.0           #给客户端分配地址池，注意：不能和VPN服务器内网网段有相同
push "route 172.16.1.0 255.255.255.0"   #允许客户端访问内网172.16.1.0网段
ifconfig-pool-persist ipp.txt           #地址池记录文件位置
keepalive 10 120                        #存活时间，10秒ping一次,120 如未收到响应则视为断线
max-clients 100                         #最多允许100个客户端连接
status openvpn-status.log               #日志记录位置
verb 3                                  #openvpn版本
client-to-client                        #客户端与客户端之间支持通信
log /var/log/openvpn.log                #openvpn日志记录位置
persist-key     #通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keys。
persist-tun     #检测超时后，重新启动VPN，一直保持tun是linkup的。否则网络会先linkdown然后再linkup
duplicate-cn</code></pre> 
<p>我的配置Server端的文件：</p> 
<pre><code class="language-bash">port 1194
proto udp
dev tun
ca /etc/openvpn/server/certs/ca.crt
cert /etc/openvpn/server/certs/server.crt
key /etc/openvpn/server/certs/server.key
dh /etc/openvpn/server/certs/dh.pem
tls-auth /etc/openvpn/server/certs/ta.key 0
server 10.0.1.0 255.255.255.0
push "route 192.168.103.0 255.255.255.0"
push "dhcp-option DNS 8.8.8.8" 
push "dhcp-option DNS 8.8.4.4"
ifconfig-pool-persist ipp.txt
compress lzo
duplicate-cn
keepalive 10 120
client-config-dir ccd
comp-lzo
persist-key
persist-tun
user openvpn
group openvpn
log /var/log/openvpn/server.log
log-append /var/log/openvpn/server.log
status /var/log/openvpn/status.log
verb 3
explicit-exit-notify 1
</code></pre> 
<p><img alt="" height="740" src="https://img-blog.csdnimg.cn/2021010118275864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="678"></p> 
<h3>5、配置防火墙及安全服务</h3> 
<p><strong>禁用firewalld，启用iptables</strong></p> 
<pre><code class="language-bash">[root@openvpnservice openvpn]# systemctl stop firewalld
[root@openvpnservice openvpn]# systemctl disable firewalld</code></pre> 
<p>关闭selinux</p> 
<pre><code class="language-bash">[root@openvpnservice openvpn]# sed -i 's/SELINUX=enforcinf/SELINUX=disabled/g' /etc/sysconfig/selinux
[root@openvpnservice openvpn]# setenforce 0</code></pre> 
<p>启用iptables</p> 
<pre><code class="language-bash">[root@openvpnservice openvpn]# systemctl start iptables
[root@openvpnservice openvpn]# systemctl enable iptables

iptables -F

添加防火墙规则
[root@openvpnservice openvpn]# iptables -t nat -A POSTROUTING -s 10.8.0.0/24  -j MASQUERADE
[root@openvpnservice openvpn]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  确定  ]
[root@openvpnservice openvpn]# systemctl restart iptables</code></pre> 
<h3>6、服务器启用IP地址转发</h3> 
<pre><code class="language-cpp">[root@openvpnservice openvpn]# echo net.ipv4.ip_forward = 1 &gt;&gt;/etc/sysctl.conf
[root@openvpnservice openvpn]# sysctl -p
net.ipv4.ip_forward = 1</code></pre> 
<h3>7、启动服务</h3> 
<pre><code class="language-bash">systemctl start openvpn@server  # 启动
systemctl enable openvpn@server  # 开机自启动
systemctl status openvpn@server  # 查看服务状态</code></pre> 
<h3>8、添加客户端用户</h3> 
<p><strong>创建模版配置文件</strong></p> 
<pre><code class="language-bash">[root@openvpnservice ~]# cd /etc/openvpn/client/
[root@openvpnservice client]# touch sample.ovpn
[root@openvpnservice client]# vim sample.ovpn
client
proto udp
dev tun
remote 49.234.26.34 1194  #openvpn公网映射的ip地址和端口
ca ca.crt
cert admin.crt
key admin.key
tls-auth ta.key 1
remote-cert-tls server
persist-tun
persist-key
comp-lzo
verb 3
mute-replay-warnings</code></pre> 
<p>创建用户脚本（为了创建用户更方便）</p> 
<pre><code class="language-bash"># ! /bin/bash
set -e
OVPN_USER_KEYS_DIR=/etc/openvpn/client/keys
EASY_RSA_VERSION=3
EASY_RSA_DIR=/etc/openvpn/easy-rsa/
PKI_DIR=$EASY_RSA_DIR/$EASY_RSA_VERSION/pki

for user in "$@"
do
  if [ -d "$OVPN_USER_KEYS_DIR/$user" ]; then
    rm -rf $OVPN_USER_KEYS_DIR/$user
    rm -rf  $PKI_DIR/reqs/$user.req
    sed -i '/'"$user"'/d' $PKI_DIR/index.txt
  fi
  cd $EASY_RSA_DIR/$EASY_RSA_VERSION
  # 生成客户端 ssl 证书文件
  ./easyrsa build-client-full $user nopass
  # 整理下生成的文件
  mkdir -p  $OVPN_USER_KEYS_DIR/$user
  cp $PKI_DIR/ca.crt $OVPN_USER_KEYS_DIR/$user/   # CA 根证书
  cp $PKI_DIR/issued/$user.crt $OVPN_USER_KEYS_DIR/$user/   # 客户端证书
  cp $PKI_DIR/private/$user.key $OVPN_USER_KEYS_DIR/$user/  # 客户端证书密钥
  cp /etc/openvpn/client/sample.ovpn $OVPN_USER_KEYS_DIR/$user/$user.ovpn # 客户端配置文件
  sed -i 's/admin/'"$user"'/g' $OVPN_USER_KEYS_DIR/$user/$user.ovpn
  cp /etc/openvpn/server/certs/ta.key $OVPN_USER_KEYS_DIR/$user/ta.key  # auth-tls 文件
  cd $OVPN_USER_KEYS_DIR
  zip -r $user.zip $user
done
exit 0</code></pre> 
<p>创建用户执行脚本，后面跟用户名字，执行成功后会生成证书文件</p> 
<pre><code class="language-bash">[root@openvpnservice client]# sh ovpn_user.sh wangxuejin</code></pre> 
<p>导出压缩包解压后放到客户端目录中即可</p> 
<h3>9、核心交换机添加路由</h3> 
<pre><code class="language-bash">ip route-static 10.10.0.0 255.255.255.0 172.18.1.182</code></pre> 
<p>备注：外网防火墙需要映射UDP 1194端口</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>在Kubernetes（k8s）中部署Java应用</title><link>http://www.cnblogs.com/heian99/archive/2020/12/25/14466677.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 25 Dec 2020 02:13:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/12/25/14466677.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E5%88%B0k8s%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%80%8E%E6%A0%B7%E7%9A%84%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E5%88%B0k8s%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%80%8E%E6%A0%B7%E7%9A%84%E6%B5%81%E7%A8%8B">1、项目迁移到k8s平台的怎样的流程</a></p> 
<p style="margin-left:0px;"><a href="#2%E3%80%81Kubernetes%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2、Kubernetes基本概念</a></p> 
<p style="margin-left:0px;"><a href="#3%E3%80%81%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E9%95%9C%E5%83%8F">3、构建项目镜像</a></p> 
<p style="margin-left:0px;"><a href="#4%E3%80%81%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E9%95%9C%E5%83%8F%E5%88%B0Kubernetes%E5%B9%B3%E5%8F%B0">4、部署项目镜像到Kubernetes平台</a></p> 
<hr id="hr-toc">
<h1 id="1%E3%80%81%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E5%88%B0k8s%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%80%8E%E6%A0%B7%E7%9A%84%E6%B5%81%E7%A8%8B">1、项目迁移到k8s平台的怎样的流程</h1> 
<p><img alt="" class="has" height="480" src="https://img-blog.csdnimg.cn/2020010911345217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h2 id="2%E3%80%81Kubernetes%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2、Kubernetes基本概念</h2> 
<p><span style="color:#f33b45;"><strong> Pod</strong></span> • 最小部署单元 • 一组容器的集合 • 一个Pod中的容器共享网络命名空间 • Pod是短暂的</p> 
<p><span style="color:#f33b45;"><strong> Controllers</strong></span> • Deployment ： 无状态应用部署 • StatefulSet ： 有状态应用部署 • DaemonSet ： 确保所有Node运行同一个Pod • Job ： 一次性任务 • Cronjob ： 定时任务<br> 更高级层次对象，部署和管理Pod</p> 
<p><span style="color:#f33b45;"><strong> Service </strong></span>• 防止Pod失联 • 定义一组Pod的访问策略<br><span style="color:#f33b45;"><strong> Label </strong></span>： 标签，附加到某个资源上，用于关联对象、查询和筛选<br><span style="color:#f33b45;"><strong> Namespaces </strong></span>： 命名空间，将对象逻辑上隔离</p> 
<h2 id="3%E3%80%81%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E9%95%9C%E5%83%8F">3、构建项目镜像</h2> 
<h2>1、准备Jar包</h2> 
<p><img alt="" class="has" height="194" src="https://img-blog.csdnimg.cn/20200109133438926.png" width="410"></p> 
<h2>2、制作镜像</h2> 
<p>解压文件</p> 
<pre class="has"><code>yum install -y unzip &amp;&amp; unzip tomcat-java-demo-master.zip 
</code></pre> 
<p>把这个sql文件导入mysql。</p> 
<p><img alt="" class="has" height="306" src="https://img-blog.csdnimg.cn/2020010913432272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="603"></p> 
<p>在Node1上下载mysql:5.6的镜像。</p> 
<pre class="has"><code>docker run -p 3306:3306 --name mysql-master \
-v /mydata/mysql/master/log:/var/log/mysql \
-v /mydata/mysql/master/data:/var/lib/mysql \
-v /mydata/mysql/master/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.6</code></pre> 
<p><img alt="" class="has" height="583" src="https://img-blog.csdnimg.cn/20200109134158834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1097"></p> 
<p>接下导入sql数据。</p> 
<p>可以使用工具导入方便。</p> 
<p><img alt="" class="has" height="491" src="https://img-blog.csdnimg.cn/20200109134655562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="720"></p> 
<p>修改代码里的配置文件</p> 
<p><img alt="" class="has" height="232" src="https://img-blog.csdnimg.cn/20200109135014179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="648"></p> 
<p><img alt="" class="has" height="367" src="https://img-blog.csdnimg.cn/20200109134951198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="596"></p> 
<p>安装JDk和Maven环境</p> 
<pre class="has"><code> yum install -y java-1.8.0-openjdk maven
</code></pre> 
<p>修改maven源</p> 
<pre><code class="language-bash">vim /etc/maven/settings.xml


&lt;mirror&gt;
    &lt;id&gt;alimaven&lt;/id&gt;
    &lt;name&gt;aliyun maven&lt;/name&gt;
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;/mirror&gt;
</code></pre> 
<p><img alt="" height="272" src="https://img-blog.csdnimg.cn/20201222131952108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="653"></p> 
<p>编译源码 【漫长的等待】</p> 
<pre class="has"><code>mvn clean package -D maven.test.skip=true
</code></pre> 
<p><img alt="" class="has" height="321" src="https://img-blog.csdnimg.cn/20200109142726284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1118"></p> 
<p>准备使用DockerFile文件来构建镜像。</p> 
<p><img alt="" class="has" height="262" src="https://img-blog.csdnimg.cn/20200109160811294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="568"></p> 
<pre class="has"><code class="language-bash">FROM lizhenliang/tomcat 
LABEL maintainer www.ctnrs.com
RUN rm -rf /usr/local/tomcat/webapps/*
ADD target/*.war /usr/local/tomcat/webapps/ROOT.war 
</code></pre> 
<p>构建镜像</p> 
<pre class="has"><code class="language-bash">docker build -t lizhenliang/java-demo -f Dockerfile .</code></pre> 
<p><img alt="" class="has" height="245" src="https://img-blog.csdnimg.cn/2020010916181546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="750"></p> 
<p>已经成功</p> 
<p><img alt="" class="has" height="307" src="https://img-blog.csdnimg.cn/2020010916261039.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="994"></p> 
<p>写ymal文件【生成模板，在修改】</p> 
<pre class="has"><code class="language-bash">kubectl create deployment java-demo --image=lizhenliang/java-demo --dry-run -o yaml 

#内容
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: java-demo
  name: java-demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: java-demo
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: java-demo
    spec:
      containers:
      - image: lizhenliang/java-demo
        name: java-demo
        resources: {}
status: {}
</code></pre> 
<p>重定向，生成本地的yaml</p> 
<pre class="has"><code class="language-bash">kubectl create deployment java-demo --image=lizhenliang/java-demo --dry-run -o yaml &gt; deploy.yaml
</code></pre> 
<pre class="has"><code class="language-bash">[root@master ~]# cat deploy.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: java-demo
  name: java-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: java-demo
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: java-demo
    spec:
      containers:
      - image: lizhenliang/java-demo
        name: java-demo
</code></pre> 
<p>运行</p> 
<pre class="has"><code>kubectl apply -f deploy.yaml 
</code></pre> 
<p><img alt="" class="has" height="85" src="https://img-blog.csdnimg.cn/2020010916434881.png" width="538"></p> 
<pre class="has"><code class="language-bash">kubectl get pods</code></pre> 
<p><img alt="" class="has" height="177" src="https://img-blog.csdnimg.cn/20200109164626209.png" width="947"></p> 
<h2 id="4%E3%80%81%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E9%95%9C%E5%83%8F%E5%88%B0Kubernetes%E5%B9%B3%E5%8F%B0">4、部署项目镜像到Kubernetes平台</h2> 
<p><img alt="" height="819" src="https://img-blog.csdnimg.cn/20201222145905995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Python构建简单的ATM+购物功能项目</title><link>http://www.cnblogs.com/heian99/archive/2020/11/30/14124796.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 30 Nov 2020 13:08:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/11/30/14124796.html</guid><description><![CDATA[
                    <hr>
<p><strong>南宫乘风：我在学Python哦</strong></p> 
<p><strong>Python：你不写Python项目，是不会有进步的，年轻人，耗子尾汁吧</strong></p> 
<p><strong>南宫乘风：我要进步，要学习，开始项目</strong></p> 
<p><strong>Python：来骗，来偷袭。很快啊！年轻人，不讲码德</strong></p> 
<hr>
<p><strong>学了一点时间Python，为了巩固基础，拿一个简单的项目练手。</strong></p> 
<h1><strong>ATM+购物车功能（ps：很简单，大佬不要嘲笑哈）</strong></h1> 
<h2><strong>项目需求：</strong></h2> 
<blockquote> 
 <pre><code class="language-html hljs">1.额度15000或自定义     --&gt;  注册功能
2.实现购物商城，买东西加入购物车，调用信用卡接口结账  --&gt; 购物功能、支付功能
3.可以提现，手续费5%   --&gt; 提现功能
4.支持多账户登录  --&gt; 登录功能
5.支持账户间转账  --&gt; 转账功能
6.记录日常消费 --&gt;  记录流水功能
7.提供还款接口 --&gt;  还款功能
8.ATM记录操作日志 --&gt; 记录日志功能
9.提供管理接口，包括添加账户、用户额度，冻结账户等。。。 ---&gt; 管理员功能
10.用户认证用装饰器  --&gt; 登录认证装饰器</code></pre> 
</blockquote> 
<h2>"用户视图层" 展示给用户选择的功能</h2> 
<blockquote> 
 <pre><code class="language-html hljs">user

1、注册功能
2、登录功能
3、查看余额
4、提现功能
5、还款功能
6、转账功能
7、查看流水
8、购物功能
9、查看购物车
10、管理员功能</code></pre> 
 <p>admin</p> 
 <pre><code class="language-html hljs">1、添加账号
2、修改额度
3、冻结账号
4、解冻账号
5、返回上一层</code></pre> 
</blockquote> 
<h2>架构流程图</h2> 
<p><strong>采取MVC的架构方式</strong></p> 
<p><strong>各层分开，编写接口</strong></p> 
<p><strong>三层架构：</strong></p> 
<blockquote> 
 <pre><code class="language-html hljs">1、把每个功能都分层三部分，逻辑清晰
2、如果用户更换不同的用户界面或不同的数据库存储机制，不会影响接口层的核心逻辑代码，扩展性强。
3）可以在接口层，准确的记录日志与流水。</code></pre> 
</blockquote> 
<p><img alt="" height="504" src="https://img-blog.csdnimg.cn/20201130203919950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="720" src="https://img-blog.csdnimg.cn/20201130204117864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<h2>三层架构构建&nbsp; <a href="https://wwx.lanzoux.com/i1vhGixijzi">&nbsp;项目代码</a>：<a href="https://wwx.lanzoux.com/i1vhGixijzi">https://wwx.lanzoux.com/i1vhGixijzi</a></h2> 
<p><img alt="" height="802" src="https://img-blog.csdnimg.cn/20201130204442412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="503"></p> 
<p><img alt="" height="1022" src="https://img-blog.csdnimg.cn/2020113020454357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h2>启动界面</h2> 
<h3><img alt="" height="662" src="https://img-blog.csdnimg.cn/20201130205843243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1137"></h3> 
<p><img alt="" height="853" src="https://img-blog.csdnimg.cn/20201130205906346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="707"></p> 
<h3>start.py（程序的入口）</h3> 
<pre><code class="language-python">'''
程序入口
'''
import os
import sys
from core import src

# 添加解释器的环境变量
sys.path.append(
    os.path.dirname(__file__)
)
# 开始执行项目main
if __name__ == "__main__":
    src.run()
</code></pre> 
<h2>conf</h2> 
<h3>setting.py（log日志的配置文件，项目的环境配置）</h3> 
<pre><code class="language-python">'''
配置文件设置

'''
import os
BASE=os.path.dirname(os.path.dirname(__file__))
# print(BASE)
#获取user_date文件夹路径
USER_DATE=os.path.join(BASE,'db','user_date')
# print(USER_DATE)

"""
日志配置字典LOGGING_DIC
"""
# 1、定义三种日志输出格式，日志中可能用到的格式化串如下
# %(name)s Logger的名字
# %(levelno)s 数字形式的日志级别
# %(levelname)s 文本形式的日志级别
# %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有
# %(filename)s 调用日志输出函数的模块的文件名
# %(module)s 调用日志输出函数的模块名
# %(funcName)s 调用日志输出函数的函数名
# %(lineno)d 调用日志输出函数的语句所在的代码行
# %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示
# %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数
# %(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒
# %(thread)d 线程ID。可能没有
# %(threadName)s 线程名。可能没有
# %(process)d 进程ID。可能没有
# %(message)s用户输出的消息
import os
BASE_PATH=os.path.dirname(os.path.dirname(__file__))
a1_path=os.path.join(BASE_PATH,'log','a1.log')
a2_path=os.path.join(BASE_PATH,'log','a2.log')
# print(a1_path+'\n'+a2_path)

# 2、强调：其中的%(name)s为getlogger时指定的名字
standard_format = '%(asctime)s - %(threadName)s:%(thread)d - 日志名字:%(name)s - %(filename)s:%(lineno)d -' \
                  '%(levelname)s - %(message)s'

simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s'

test_format = '%(asctime)s] %(message)s'

# 3、日志配置字典
LOGGING_DIC = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'standard': {
            'format': standard_format
        },
        'simple': {
            'format': simple_format
        },
        'test': {
            'format': test_format
        },
    },

    'filters': {},
    # handlers是日志的接收者，不同的handler会将日志输出到不同的位置
    'handlers': {
        #打印到终端的日志
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',  # 打印到屏幕
            'formatter': 'simple'
        },
        'default': {
            'level': 'DEBUG',
            'class': 'logging.handlers.RotatingFileHandler',  # 保存到文件
            # 'maxBytes': 1024*1024*5,  # 日志大小 5M
            'maxBytes': 1024*1024*5,
            'backupCount': 5,
            'filename': a1_path,  # os.path.join(os.path.dirname(os.path.dirname(__file__)),'log','a2.log')
            'encoding': 'utf-8',
            'formatter': 'standard',

        },
        #打印到文件的日志,收集info及以上的日志
        'other': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',  # 保存到文件
            'filename': a1_path, # os.path.join(os.path.dirname(os.path.dirname(__file__)),'log','a2.log')
            'encoding': 'utf-8',
            'formatter': 'standard',


        },
    },
    # loggers是日志的产生者，产生的日志会传递给handler然后控制输出
    'loggers': {
        #logging.getLogger(__name__)拿到的logger配置
        'kkk': {
            'handlers': ['console','other'],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            'level': 'DEBUG', # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制)
            'propagate': False,  # 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递
        },
        '终端提示': {
            'handlers': ['console',],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            'level': 'DEBUG',  # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制)
            'propagate': False,  # 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递
        },
        '': {
            'handlers': ['default', ],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            'level': 'DEBUG',  # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制)
            'propagate': False,  # 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递
        },
    },
}

</code></pre> 
<h2>core</h2> 
<h3>admin.py（admin用户视图）</h3> 
<pre><code class="language-python">from core import src
from interface import admin_interface


def add_user():
    src.register()


def change_balance():
    while True:
        # 输入修改修改用户名
        change_user = input('请输入需要修改额度的用户：').strip()
        change_money = input('请输入需要修改的用户额度：').strip()
        if not change_money.isdigit():
            continue
        if int(change_money) &gt;= 0:
            flag, msg = admin_interface.change_balance_interafce(change_user, change_money)
            if flag:
                print(msg)
            else:
                print(msg)
        else:
            print('输入的额度不正确')


def disable_user():
    # 输入要冻结的用户
    while True:
        dis_user = input('请输入要冻结的用户：').strip()
        flag, msg = admin_interface.disable_user_interface(dis_user)
        if flag:
            print(msg)
            break
        else:
            print(msg)


def enable_user():
    # 输入要解冻冻结的用户
    while True:
        dis_user = input('请输入要解冻冻结的用户：').strip()
        flag, msg = admin_interface.enable_user_interface(dis_user)
        if flag:
            print(msg)
            break
        else:
            print(msg)


def lsat_men():
    from core import src
    src.run()


func_dic = {
    '1': add_user,
    '2': change_balance,
    '3': disable_user,
    '4': enable_user,
    '5': lsat_men,

}


def admin_run():
    while True:
        print('''
            1、添加账号
            2、修改额度
            3、冻结账号
            4、解冻账号
            5、返回上一层
        ''')
        choice = input('请输入管理员功能编号：').strip()
        if choice not in func_dic:
            print("请输入正确的功能编号")
            continue
        func_dic.get(choice)()

# if __name__ == '__main__':
#     admin()
</code></pre> 
<h3>src.py（用户的视图）</h3> 
<pre><code class="language-python">'''
用户视图层
'''

from interface import user_interface, bank_interface, shop_interface
from lib import common
from core import admin

# 1、注册功能
'''def register():
    while True:
        # 1 让用户输入用户名称和密码进行校验
        username = input('请输入用户：').strip()
        if username.strip()=='':
            print("请输入正确的用户名")
            continue

        user_path = os.path.join(setting.USER_DATE, f"{username}.json")
        if os.path.exists(user_path):
            print(f"您输入的用户名：{username}已经存在")
            continue
        password = input("请输入密码：").strip()
        re_password = input("请确认密码：").strip()
        # 判断密码是否一致
        if password == re_password:

            # 2 查看用户是否存在
            # 3 如用户存在，则让用户重新输入
            # 4 如用户不存在，则保存用户数据
            # 4.1 组织用户的数据的字典信息
            user_dic = {
                'username': username,
                'password': password,
                'balance': 15000,
                # 用于记录用户的流水类表

                'flow': [],
                # 用于记录用户购物车
                'shop_car': [],
                # locaked :用于记录用户是否冻结
                # false：未冻结  True：已经被冻结
                'locaked': False
            }
            # 用户数据tank.json
            user_path = os.path.join(setting.USER_DATE, f"{username}.json")
            with open(user_path, 'w', encoding='utf-8') as f:
                json.dump(user_dic, f)
        else:
            print('您的两次密码不一致,请重新输入')'''

login_user = None


# 分层版
def register():
    while True:
        # 1 让用户输入用户名称和密码进行校验
        username = input('请输入用户：').strip()
        if username.strip() == '':
            print("请输入正确的用户名")
            continue
        password = input("请输入密码：").strip()
        re_password = input("请确认密码：").strip()
        # 判断密码是否一致
        if password == re_password:
            # 2 调用接口层的注册结果。将用户名和密码传到接口层
            # (True, 用户注册成功)，  (False, 注册失败)
            flag, msg = user_interface.register_interface(
                username, password
            )

            # 3) 根据flag判断用户注册是否成功，flag控制break的结束
            if flag:
                print(msg)
                break
            else:
                print(msg)
        else:
            print('您的两次密码不一致,请重新输入')


# 2、登录功能
def login():
    # 登录视图层
    while True:
        username = input('请输入用户名：').strip()
        password = input('请输入用户名密码：').strip()

        flag, msg = user_interface.longin_interface(username, password)
        if flag:
            global login_user
            login_user = username
            print(msg)
            break
        else:
            print(msg)


# 3、查看余额
@common.login_auth
def check_balance():
    # 直接调用查看用户接口，获取用余额
    balance = user_interface.check_balance_interface(login_user)
    print(f'用户：{login_user}账号余额为：{balance}')


# 4、提现功能
@common.login_auth
def withdraw():
    while True:
        # 让用户输入体现金额
        input_money = input('请输入提现金额：').strip()
        # 判断用户输入的金额是否是数字
        if not input_money.isdigit():
            print('请重新输入：')
            continue
        # 用户提现，将金额提交接口处理
        flag, msg = bank_interface.withdraw_interface(login_user, int(input_money))
        if flag:
            print(msg)
            break
        else:
            print(msg)


# 5、还款功能
@common.login_auth
def repay():
    while True:
        # 让用户输入体现金额
        repay_money = input('请输入还款金额：').strip()
        # 判断用户输入的金额是否是数字
        if not repay_money.isdigit():
            print('请重新输入')
            continue
        # 用户提现，将金额提交接口处理
        if int(repay_money) &gt; 0:
            flag, msg = bank_interface.repay_interface(login_user, int(repay_money))
            if flag:
                print(msg)
                break
        else:
            print('不能输入小于0的数字')


# 6、转账功能
@common.login_auth
def transfer():
    '''
    接收用户的转账金额
    接收用户输入的转账目标
    :return:
    '''
    while True:
        user_money = input('请输入转账目标用户：').strip()
        money = input('请输入转账金额：').strip()
        if not money.isdigit():
            print('请输入正确的金额！')
            continue
        money = int(money)
        if money &gt; 0:
            # 转账接口
            flag, msg = bank_interface.transfer_interface(login_user, user_money, money)
            if flag:
                print(msg)
                break
            else:
                print(msg)
        else:
            print('请输入正确的金额！')


# 7、查看流水
@common.login_auth
def check_flow():
    # 直接调用查看流水的列表
    flow_list = bank_interface.check_flow_interface(login_user)
    if flow_list:
        for flow in flow_list:
            print(flow)
    else:
        print('当前用户没有流水记录')


# 8、购物功能
@common.login_auth
def shopping():
    '''
    {
        '0':{'name':'包子','price':30},
        '0': {'name': '包子', 'price': 30},
        '0': {'name': '包子', 'price': 30},
    }
    :return:
    '''
    shop_list = [
        ['包子', 30],
        ['衣服', 150],
        ['安全套', 25],
        ['情趣内衣', 520],
        ['cosplay', 250],
    ]
    shopping_car = {}
    while True:
        # 先打印商品的信息，让用户选择
        print('===================欢迎来到情趣商城================')
        for index, shop in enumerate(shop_list):
            shop_name, shop_price = shop
            print(f'商品编号：{index}, 商品名称：{shop_name},商品单价：{shop_price}')
        print('========================end======================')

        shop_choice = input("请输入你要选购的商品编号(是否结账y or n)：").strip()
        if shop_choice.upper() == 'Y':
            if not shopping_car:
                print('购物车是空的，不能支付，请重新输入')
                continue
            # 调用支付接口进行支付
            flag,msg=shop_interface.shopping_interface(login_user,shopping_car)
            if flag:
                print(msg)
                break
            else:
                print(msg)
        elif shop_choice.upper() == 'N':
            # 判断当前用户是否添加过购物车
            if not shopping_car:
                print('购物车是空的，不能添加，请重新输入')
                continue

            flag,msg=shop_interface.add_shop_car_interface(login_user,shopping_car)
            if flag:
                print(msg)
                break

        if not shop_choice.isdigit():
            print('请输入正确的编号！')
            continue
        shop_choice = int(shop_choice)
        if shop_choice not in range(len(shop_list)):
            print('请输入正确的编号！')
            continue
        shop_name, shop_price = shop_list[shop_choice]

        if shop_name in shopping_car:
            shopping_car[shop_name][1] += 1
        else:
            shopping_car[shop_name] = [shop_price, 1]

        print("当前购物车：",shopping_car)

# 9、查看购物车
@common.login_auth
def check_shop_car():
    shop_list = shop_interface.check_shop_car_interface(login_user)
    if shop_list:
        for shop_name,print_number in shop_list.items():
            print(f'商品：[{shop_name}],数量：[{print_number[1]}]')
    else:
        print('当前用户没有流水记录')


@common.login_auth
def admin_spuer():
    admin.admin_run()


# 创建函数功能字典

func_dic = {
    '1': register,
    '2': login,
    '3': check_balance,
    '4': withdraw,
    '5': repay,
    '6': transfer,
    '7': check_flow,
    '8': shopping,
    '9': check_shop_car,
    '10': admin_spuer,
}


def run():
    while True:
        print('''
        ==========ATM+购物车==========
                1、注册功能
                2、登录功能
                3、查看余额
                4、提现功能
                5、还款功能
                6、转账功能
                7、查看流水
                8、购物功能
                9、查看购物车
                10、管理员功能
        ==========  end  ==========
        ''')
        choice = input("请输入功能编号：").strip()
        if choice not in func_dic:
            print("请输入正确的功能编号")
            continue
        func_dic.get(choice)()
</code></pre> 
<h2>db</h2> 
<h2>user_date (用户存放json的目录)</h2> 
<h3>q.json （用户数据的存放文件，字典形式）<br> &nbsp;</h3> 
<pre><code class="language-python">{"username": "q", "password": "099b3b060154898840f0ebdfb46ec78f", "balance": 14375.0, "flow": ["用户[q] 提现金额 [500],手续费为：[25.0]", "用户：[q]给用户[w] 转账：[100] 元 成功"], "shop_car": {}, "locked": false}</code></pre> 
<p>json格式</p> 
<pre><code class="language-python">{
	"username": "q",
	"password": "099b3b060154898840f0ebdfb46ec78f",
	"balance": 14375.0,
	"flow": ["用户[q] 提现金额 [500],手续费为：[25.0]", "用户：[q]给用户[w] 转账：[100] 元 成功"],
	"shop_car": {},
	"locked": false
}</code></pre> 
<h3>db_hander.py（对数据处理，相当于mysql接口处理）</h3> 
<pre><code class="language-python">'''
数据处理层
    专门用户处理数据的
'''
import json
import os
from conf import setting


# 判断用户是否已经注册
def user_select(username):
    # 1) 接收接口层传过来的username用户名，拼接用户json文件路径
    user_path = os.path.join(
        setting.USER_DATE, f'{username}.json'
    )

    # 2）校验用户json文件是否存在
    if os.path.exists(user_path):
        # 3) 打开数据，并返回给接口层
        with open(user_path, 'r', encoding='utf-8') as f:
            user_dic = json.load(f)
            return user_dic

    # 3) 不return，默认return None

# 保存数据处理
def user_save(user_dic):
    user_path = os.path.join(setting.USER_DATE, f"{user_dic['username']}.json")
    with open(user_path, 'w', encoding='utf-8') as f:
        json.dump(user_dic, f, ensure_ascii=False)
</code></pre> 
<h2>interface</h2> 
<h3>admin_interface.py（admin的业务接口处理）</h3> 
<pre><code class="language-python">from db import db_hander
from lib import common
user_logger=common.get_log('admin')

# 修改额度接口
def change_balance_interafce(change_user, change_money):
    user_dic = db_hander.user_select(change_user)

    if user_dic:
        user_dic['balance'] = int(change_money)
        db_hander.user_save(user_dic)
        msg=f'[{change_user}]的额度修改{change_money}成功'
        user_logger.info(msg)
        return True, msg
    return False, '修改额度用户不存在'


def disable_user_interface(dis_user):
    user_dic = db_hander.user_select(dis_user)
    if user_dic:
        user_dic['locked'] = True
        db_hander.user_save(user_dic)
        msg = f'[{dis_user}]的冻结成功'
        user_logger.info(msg)
        return True, msg
    else:
        return False, '冻结用户不存在'

# 解冻用户的接口
def enable_user_interface(dis_user):
    user_dic = db_hander.user_select(dis_user)
    if user_dic:
        if user_dic['locked']:
            user_dic['locked'] = False
            db_hander.user_save(user_dic)
            msg = f'[{dis_user}]的冻结成功'
            user_logger.info(msg)
            return True, msg
        return False,f'用户：{dis_user}处于正常状态'
    else:
        return False, '冻结用户不存在'</code></pre> 
<h3>bank_interface.py（银行业务处理接口）</h3> 
<pre><code class="language-python">'''
银行相关的业务
'''
from db import db_hander
from lib import common
user_logger=common.get_log('bank')

# 用户的提现金额接口
def withdraw_interface(login_user, input_money):
    # 先获取用户字典
    user_dic = db_hander.user_select(login_user)
    # 获取银行的金额
    balance = int(user_dic.get('balance'))
    # 本金+ 手续费
    money = int(input_money) * 1.05
    repair = round(money - input_money, 2)
    # 判断用户金额是否足够
    if balance &gt;= money:
        # 修改用户字典的金额
        balance -= money
        user_dic['balance'] = balance
        flow = f'用户[{login_user}] 提现金额 [{input_money}],手续费为：[{repair}]'
        user_dic['flow'].append(flow)
        # 在保存数据
        db_hander.user_save(user_dic)
        msg=f'用户[{login_user}] 提现金额 [{input_money}],手续费为：[{repair}]'
        user_logger.info(msg)
        return True, msg
    return False, '提现金额不足，请重新输入'


# 还款接口
def repay_interface(login_user, repay_money):
    # 先获取用户字典
    user_dic = db_hander.user_select(login_user)
    # 获取银行的金额
    balance = int(user_dic.get('balance'))
    # 本金+ 手续费
    money = int(repay_money)
    # repair = round(money - repay_money, 2)
    # 修改用户字典的金额
    balance += money
    user_dic['balance'] = balance
    # 在保存数据
    flow = f'用户：[{login_user}] 还款金额 ：[{repay_money}]成功]'
    user_dic['flow'].append(flow)
    db_hander.user_save(user_dic)
    msg = f'用户：[{login_user}] 还款金额 ：[{repay_money}]成功]'
    user_logger.info(msg)
    return True, msg


# 转账接口
def transfer_interface(login_user, user_money, money):
    # 先获取用户字典
    login_user_dic = db_hander.user_select(login_user)
    user_money_dic = db_hander.user_select(user_money)
    # 判断目标用户是否存在
    if not user_money_dic:
        return False, '目标用户不存在'
    if login_user == user_money:
        return False, '不能给自己转账'
    if login_user_dic['balance'] &gt;= money:
        login_user_dic['balance'] -= money
        user_money_dic['balance'] += money
        flow1 = f'用户：[{login_user}]给用户[{user_money}] 转账：[{money}] 元 成功'
        login_user_dic['flow'].append(flow1)
        flow2 = f'用户：[{user_money}]接受用户[{login_user}] 转账：[{money}] 元 成功'
        user_money_dic['flow'].append(flow2)
        db_hander.user_save(login_user_dic)
        db_hander.user_save(user_money_dic)
        msg = f'用户：[{login_user}]给用户[{user_money}] 转账：[{money}] 元 成功'
        user_logger.info(msg)
        return True, msg
    msg = f'用户：[{login_user}]银行余额不足'
    user_logger.info(msg)
    return False, msg


# 流水接口列表查询
def check_flow_interface(login_user):
    # 先获取用户字典
    login_user_dic = db_hander.user_select(login_user)
    flow_list = login_user_dic['flow']
    return flow_list


# 支付接口
def pay_interface(login_user, cost):
    user_dic = db_hander.user_select(login_user)
    if user_dic.get('balance') &gt;= cost:
        user_dic['balance'] -= cost

        flow = f'用户：{login_user}消费金额：{cost}'
        user_dic['flow'].append(flow)
        db_hander.user_save(user_dic)
        user_logger.info(flow)
        return True
    return False


</code></pre> 
<h3>shop_interface.py（购物业务接口处理）</h3> 
<pre><code class="language-python">'''
购物商城接口
'''
from interface import bank_interface
from db import db_hander
from lib import common
shop_logger = common.get_log(log_type='shop')

# 商品准备结算接口
def shopping_interface(login_user, shopping_car):
    # 计算商品总价
    cost = 0
    for shop_price in shopping_car.values():
        price, number = shop_price
        cost += (price * number)

    # 逻辑校验成功，调用银行的支付接口
    flag = bank_interface.pay_interface(login_user, cost)
    if flag:
        msg = f'用户:[{login_user}]支付 [{cost}$] 成功, 准备发货!'
        shop_logger.info(msg)
        return True, msg

    return False, '支付失败，金额不足'


# 商品添加购物车功能
def add_shop_car_interface(login_user, shopping_car):
    # 获取当前用户的购物车
    user_dic = db_hander.user_select(login_user)
    #原来用户的字典的商城列表
    shop_car = user_dic.get('shop_car')

    for shop_name, price_number in shopping_car.items():
        number = price_number[1]
        if shop_name in shop_car:
            user_dic['shop_car'][shop_name][1] += number
        else:
            user_dic['shop_car'].update(
                {shop_name: price_number}
            )
        db_hander.user_save(user_dic)
    return True, '添加购物车成功'

# 查看购物车接口
def check_shop_car_interface(login_user):
    # 获取当前用户的购物车
    user_dic = db_hander.user_select(login_user)
    shop_list = user_dic['shop_car']
    return shop_list
</code></pre> 
<h3>user_interface.py（用户业务接口处理）</h3> 
<pre><code class="language-python">'''
用户相关的接口

'''
import os
import json

from db import db_hander
from lib import common
user_logger=common.get_log('user')

# 用户注册
def register_interface(username, password, balance=15000):
    # 2）查看用户是否存在
    # 2.1) 调用 数据处理层 中的 select函数，会返回 用户字典 或 None
    user_dic = db_hander.user_select(username)

    # {user: user, pwd: pwd...}   or  None
    # 若用户存在，则return，告诉用户重新输入
    if user_dic:
        # return (False, '用户名已存在!')
        return False, '用户名已存在!'

    # 3）若用户不存在，则保存用户数据
    # 做密码加密
    password = common.salt(username, password)

    # 3.1) 组织用户的数据的字典信息
    user_dic = {
        'username': username,
        'password': password,
        'balance': balance,
        # 用于记录用户流水的列表
        'flow': [],
        # 用于记录用户购物车
        'shop_car': {},
        # locked：用于记录用户是否被冻结
        # False: 未冻结   True: 已被冻结
        'locked': False
    }

    # 3.2）保存数据
    db_hander.user_save(user_dic)
    msg=f'{username} 注册成功!'
    user_logger.info(msg)
    return True, msg


# 登录接口
def longin_interface(username, password):
    # 先查看用户是否存在
    user_dic = db_hander.user_select(username)
    password_md5 = common.salt(username, password)

    if user_dic:
        print(user_dic.get('locked'))
        if user_dic.get('locked'):
            return False, f'用户：[{username}]已经被冻结'
        if password_md5 == user_dic['password']:
            msg=f'用户：[{username}] 登录成功  '
            user_logger.info(msg)
            return True,msg

        else:
            msg = f'用户：[{username}]密码错误'
            user_logger.warning(msg)
            return False, msg
    msg = f'用户[{username}]不存在，请重新输入'
    user_logger.info(msg)
    return False, msg


# 查看用户余额接口
def check_balance_interface(login_user):
    user_dic = db_hander.user_select(login_user)
    return user_dic.get('balance')
</code></pre> 
<h2>lib</h2> 
<h3>common.py（公用类，盐MD5加密，登录装饰器）</h3> 
<pre><code class="language-python">import hashlib
from core import src
from conf import setting
import logging.config


# 盐加密，通名字加密 密码

def salt(username, password):
    password_ms5= hashlib.md5()
    password_ms5.update((username+password).encode('utf-8'))
    res = password_ms5.hexdigest()
    return res


# 登录认证装饰器
def login_auth(func):
    def inner(*args, **kwargs):
        if src.login_user:
            res = func(*args, **kwargs)
            return res
        else:
            print('未出示证明，无法享受服务')
            src.login()

    return inner


# 添加日志功能(日志功能在接口层使用)
def get_log(log_type):
    '''
    :param log_type:  user日志   bank日志   购物商城日志
    :return:
    '''
    # 1、加载日志配置信息
    logging.config.dictConfig(
        setting.LOGGING_DIC
    )
    # 获取日志对象
    logger = logging.getLogger(log_type)
    return logger
</code></pre> 
<h2>log（日志文件记录）</h2> 
<h3>a1.log</h3> 
<pre><code class="language-bash">2020-11-29 23:03:52,782 - MainThread:13396 - 日志名字:user - user_interface.py:58 -INFO - 用户：[q]登录成功！
2020-11-29 23:04:11,089 - MainThread:13396 - 日志名字:user - user_interface.py:58 -INFO - 用户：[w]登录成功！
2020-11-29 23:04:15,584 - MainThread:13396 - 日志名字:user - user_interface.py:69 -INFO - 用户不存在，请重新输入</code></pre> 
<p>整体项目架构不错，可以很清楚了解到三层架构的构建</p> 
<p>用户点击：用户视图层————————》业务接口处理————————》数据库数据处理</p> 
<p>数据返回用户：数据处理完数据————————》业务接口处理————————》用户视图层</p>
                ]]></description></item><item><title>kubeadm高可用安装k8s集群1.18.5</title><link>http://www.cnblogs.com/heian99/archive/2020/11/27/14124797.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 27 Nov 2020 11:11:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/11/27/14124797.html</guid><description><![CDATA[
                    <h2>1、 基本环境配置</h2> 
<blockquote> 
 <p>1、Kubectl debug 设置一个临时容器</p> 
 <p>2、Sidecar</p> 
 <p>3、Volume：更改目录权限，fsGroup</p> 
 <p>4、ConfigMap和Secret</p> 
 <p>K8S官网：https://kubernetes.io/docs/setup/</p> 
 <p>最新版高可用安装：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/</p> 
</blockquote> 
<table border="1" cellspacing="0" style="margin-left:5.4pt;"><tbody><tr><td style="width:156.1pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">主机名</span></p> </td><td style="width:145.4pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">IP地址</span></p> </td><td style="width:107.9pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">说明</span></p> </td></tr><tr><td style="vertical-align:top;width:156.1pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">k8s-master01 ~ 03</span></p> </td><td style="vertical-align:top;width:145.4pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">192.168.0.106 ~ 20</span></p> </td><td style="vertical-align:top;width:107.9pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">master节点 * 3</span></p> </td></tr><tr><td style="vertical-align:top;width:156.1pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">k8s-master-lb</span></p> </td><td style="vertical-align:top;width:145.4pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">192.168.0.200</span></p> </td><td style="vertical-align:top;width:107.9pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">keepalived虚拟IP</span></p> </td></tr><tr><td style="vertical-align:top;width:156.1pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">k8s-node01 ~ 02</span></p> </td><td style="vertical-align:top;width:145.4pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">192.168.0.108 ~ 22</span></p> </td><td style="vertical-align:top;width:107.9pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">worker节点 * 2</span></p> </td></tr></tbody></table>
<p><strong>VIP（虚拟IP）不要和公司内网IP重复，首先去ping一下，不通才可用。VIP需要和主机在同一个局域网内！</strong></p> 
<p>所有节点配置hosts，修改/etc/hosts如下：</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# cat /etc/hosts
192.168.0.100 k8s-master01
192.168.0.106 k8s-master02
192.168.0.107 k8s-master03
192.168.0.200 k8s-master-lb
192.168.0.108 k8s-node01
192.168.0.109 k8s-node02
</code></pre> 
<p>所有节点关闭防火墙、selinux、dnsmasq、swap。服务器配置如下</p> 
<pre><code class="language-bash">systemctl disable --now firewalld 
systemctl disable --now dnsmasq
#systemctl disable --now NetworkManager  #CentOS8无需关闭

setenforce 0
</code></pre> 
<pre><code class="language-bash">[root@k8s-master01 ~]# cat !$
cat /etc/sysconfig/selinux
SELINUX=disabled

swapoff -a &amp;&amp; sysctl -w vm.swappiness=0
[root@k8s-master01 ~]# vi /etc/fstab 
[root@k8s-master01 ~]# cat /etc/fstab 

#
# /etc/fstab
# Created by anaconda on Fri Nov  1 23:02:53 2019
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/cl-root     /                       xfs     defaults        0 0
UUID=6897cd7b-9b3a-42b0-a827-57991141b297 /boot                   ext4    defaults        1 2
#/dev/mapper/cl-swap     swap                    swap    defaults        0 0
 </code></pre> 
<p>安装ntpdate（CentOS 7 无需安装，自带ntpdate命令）</p> 
<p>所有节点同步时间。时间同步配置如下：</p> 
<pre><code class="language-bash">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
echo 'Asia/Shanghai' &gt;/etc/timezone
ntpdate time2.aliyun.com
# 加入到crontab
*/5 * * * * ntpdate time2.aliyun.com
# 加入到开机自动同步，/etc/rc.local
ntpdate time2.aliyun.com
</code></pre> 
<p>所有节点配置limit：</p> 
<pre><code class="language-bash">ulimit -SHn 65535</code></pre> 
<p>Master01节点免密钥登录其他节点，安装过程中生成配置文件和证书均在Master01上操作，集群管理也在Master01上操作，阿里云或者AWS上需要单独一台kubectl服务器。密钥配置如下：</p> 
<pre><code class="language-bash">ssh-keygen -t rsa
for i in k8s-master01 k8s-master02 k8s-master03 k8s-node01 k8s-node02;do ssh-copy-id -i .ssh/id_rsa.pub $i;done
 </code></pre> 
<p>在源码中的repo目录配置使用的是国内仓库源，将其复制到所有节点：</p> 
<pre><code class="language-bash">git clone https://github.com/dotbalo/k8s-ha-install.git
 </code></pre> 
<h2>2、CentOS 7安装yum源如下</h2> 
<pre><code class="language-bash">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo
 </code></pre> 
<p>所有节点升级系统并重启，此处升级没有升级内核，下节会单独升级内核：</p> 
<pre><code class="language-bash">yum install wget jq psmisc vim net-tools telnet yum-utils device-mapper-persistent-data lvm2 -y
yum update -y --exclude=kernel* &amp;&amp; reboot #CentOS7需要升级，8不需要
 </code></pre> 
<p>3、内核配置</p> 
<p><strong>（如果内核达到，可以不用跳过此步骤）</strong></p> 
<p><strong>CentOS7 需要升级内核至4.18+</strong></p> 
<pre><code class="language-bash">使用如下方式安装最新版内核
rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm

查看最新版内核yum --disablerepo="*" --enablerepo="elrepo-kernel" list available

[root@k8s-node01 ~]# yum --disablerepo="*" --enablerepo="elrepo-kernel" list available

安装最新版：
yum --enablerepo=elrepo-kernel install kernel-ml kernel-ml-devel –y
安装完成后reboot
更改内核顺序：
grub2-set-default  0 &amp;&amp; grub2-mkconfig -o /etc/grub2.cfg &amp;&amp; grubby --args="user_namespace.enable=1" --update-kernel="$(grubby --default-kernel)" &amp;&amp; reboot
开机后查看内核
[appadmin@k8s-node01 ~]$ uname -a
Linux k8s-node01 5.7.7-1.el7.elrepo.x86_64 #1 SMP Wed Jul 1 11:53:16 EDT 2020 x86_64 x86_64 x86_64 GNU/Linux
 </code></pre> 
<p><img alt="" height="485" src="https://img-blog.csdnimg.cn/20201127185737268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1031"></p> 
<p>本所有节点安装ipvsadm：</p> 
<pre><code class="language-bash">yum install ipvsadm ipset sysstat conntrack libseccomp -y</code></pre> 
<p>所有节点配置ipvs模块，在内核4.19+版本nf_conntrack_ipv4已经改为nf_conntrack，本例安装的内核为4.18，使用nf_conntrack_ipv4即可：</p> 
<pre><code class="language-bash">modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
cat /etc/modules-load.d/ipvs.conf 
ip_vs
ip_vs_rr
ip_vs_wrr
ip_vs_sh
nf_conntrack_ipv4
ip_tables
ip_set
xt_set
ipt_set
ipt_rpfilter
ipt_REJECT
ipip

然后执行systemctl enable --now systemd-modules-load.service即可
 </code></pre> 
<p>检查是否加载：</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# lsmod | grep -e ip_vs -e nf_conntrack_ipv4
nf_conntrack_ipv4      16384  23 
nf_defrag_ipv4         16384  1 nf_conntrack_ipv4
nf_conntrack          135168  10 xt_conntrack,nf_conntrack_ipv6,nf_conntrack_ipv4,nf_nat,nf_nat_ipv6,ipt_MASQUERADE,nf_nat_ipv4,xt_nat,nf_conntrack_netlink,ip_vs
 </code></pre> 
<p>开启一些k8s集群中必须的内核参数，所有节点配置k8s内核：</p> 
<pre><code class="language-bash">cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf
net.ipv4.ip_forward = 1
net.bridge.bridge-nf-call-iptables = 1
fs.may_detach_mounts = 1
vm.overcommit_memory=1
vm.panic_on_oom=0
fs.inotify.max_user_watches=89100
fs.file-max=52706963
fs.nr_open=52706963
net.netfilter.nf_conntrack_max=2310720

net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_keepalive_intvl =15
net.ipv4.tcp_max_tw_buckets = 36000
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_max_orphans = 327680
net.ipv4.tcp_orphan_retries = 3
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.ip_conntrack_max = 65536
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.tcp_timestamps = 0
net.core.somaxconn = 16384
EOF


sysctl --system
 </code></pre> 
<p>所有节点配置完内核后，重启服务器，保证重启后内核依旧加载</p> 
<pre><code class="language-bash">reboot
lsmod | grep --color=auto -e ip_vs -e nf_conntrack
</code></pre> 
<h2>4、基本组件安装</h2> 
<p>本节主要安装的是集群中用到的各种组件，比如Docker-ce、Kubernetes各组件等。</p> 
<h3>4.1安装Docker组件</h3> 
<p>查看可用docker-ce版本：</p> 
<pre><code class="language-bash">yum list docker-ce.x86_64 --showduplicates | sort -r
[root@k8s-master01 k8s-ha-install]# wget https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.13-3.2.el7.x86_64.rpm 

[root@k8s-master01 k8s-ha-install]# yum install containerd.io-1.2.13-3.2.el7.x86_64.rpm -y

安装指定版本的Docker：
yum -y install docker-ce-17.09.1.ce-1.el7.centos
安装最新版本的Docker
yum install docker-ce –y

[root@k8s-master01 ~]# docker -v
Docker version 19.03.13, build 4484c46d9d
 </code></pre> 
<p><strong>温馨提示：</strong></p> 
<p>由于新版kubelet建议使用systemd，所以可以把docker的CgroupDriver改成systemd</p> 
<pre><code class="language-bash">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF
{
  "exec-opts": ["native.cgroupdriver=systemd"]
}
EOF
 </code></pre> 
<h3>4.2安装k8s组件：</h3> 
<pre><code class="language-bash">yum list kubeadm.x86_64 --showduplicates | sort -r
所有节点安装最新版本kubeadm：
yum install kubeadm -y
所有节点安装指定版本k8s组件：

yum install -y kubeadm-1.18.5-0.x86_64 kubelet-1.18.5-0.x86_64 kubectl-1.18.5-0.x86_64
 </code></pre> 
<h3>4.3启动Docker和Kubernetes</h3> 
<p>所有节点设置开机自启动Docker：</p> 
<pre><code class="language-bash">systemctl daemon-reload &amp;&amp; systemctl enable --now docker
 </code></pre> 
<p>默认配置的pause镜像使用gcr.io仓库，国内可能无法访问，所以这里配置Kubelet使用阿里云的pause镜像：</p> 
<pre><code class="language-bash">cat &gt;/etc/sysconfig/kubelet&lt;&lt;EOF
KUBELET_EXTRA_ARGS="--cgroup-driver=$DOCKER_CGROUPS --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1"
EOF
 </code></pre> 
<p>设置Kubelet开机自启动：</p> 
<pre><code class="language-bash">systemctl daemon-reload
systemctl enable --now kubelet
</code></pre> 
<h2>5、高可用组件安装</h2> 
<h3>5.1<strong>所有Master节点通过yum安装HAProxy和KeepAlived</strong></h3> 
<pre><code class="language-cpp">yum install keepalived haproxy -y</code></pre> 
<p>所有Master节点配置HAProxy（详细配置参考HAProxy文档，所有Master节点的HAProxy配置相同）：</p> 
<pre><code class="language-bash">[root@k8s-master01 etc]# mkdir /etc/haproxy
[root@k8s-master01 etc]# vim /etc/haproxy/haproxy.cfg 
global
  maxconn  2000
  ulimit-n  16384
  log  127.0.0.1 local0 err
  stats timeout 30s

defaults
  log global
  mode  http
  option  httplog
  timeout connect 5000
  timeout client  50000
  timeout server  50000
  timeout http-request 15s
  timeout http-keep-alive 15s

frontend monitor-in
  bind *:33305
  mode http
  option httplog
  monitor-uri /monitor

frontend k8s-master
  bind 0.0.0.0:16443
  bind 127.0.0.1:16443
  mode tcp
  option tcplog
  tcp-request inspect-delay 5s
  default_backend k8s-master

backend k8s-master
  mode tcp
  option tcplog
  option tcp-check
  balance roundrobin
  default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100
  server k8s-master01	192.168.0.100:6443  check
  server k8s-master02	192.168.0.106:6443  check
  server k8s-master03	192.168.0.107:6443  check
 </code></pre> 
<h3>5.2<strong>Master01节点的配置：</strong></h3> 
<pre><code class="language-cpp">[root@k8s-master01 etc]# mkdir /etc/keepalived

[root@k8s-master01 ~]# vim /etc/keepalived/keepalived.conf 
! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
}
vrrp_script chk_apiserver {
    script "/etc/keepalived/check_apiserver.sh"
    interval 2
    weight -5
    fall 3  
    rise 2
}
vrrp_instance VI_1 {
    state MASTER
    interface ens33
    mcast_src_ip 192.168.0.100
    virtual_router_id 51
    priority 100
    advert_int 2
    authentication {
        auth_type PASS
        auth_pass K8SHA_KA_AUTH
    }
    virtual_ipaddress {
        192.168.0.200
    }
#    track_script {
#       chk_apiserver
#    }
}
 </code></pre> 
<h3>5.3Master02节点的配置：</h3> 
<pre><code class="language-bash">[root@k8s-master02 etc]# mkdir /etc/keepalived

[root@k8s-master02 ~]# vim /etc/keepalived/keepalived.conf 

! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
}
vrrp_script chk_apiserver {
    script "/etc/keepalived/check_apiserver.sh"
    interval 2
    weight -5
    fall 3  
    rise 2
}
vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    mcast_src_ip 192.168.0.106
    virtual_router_id 51
    priority 101
    advert_int 2
    authentication {
        auth_type PASS
        auth_pass K8SHA_KA_AUTH
    }
    virtual_ipaddress {
        192.168.0.200
    }
#    track_script {
#       chk_apiserver
#    }
}

 </code></pre> 
<h3>5.4Master03节点的配置：</h3> 
<pre><code class="language-bash">[root@k8s-master03 etc]# mkdir /etc/keepalived

[root@k8s-master03 ~]# vim /etc/keepalived/keepalived.conf 

! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
}
vrrp_script chk_apiserver {
    script "/etc/keepalived/check_apiserver.sh"
    interval 2
    weight -5
    fall 3  
    rise 2
}
vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    mcast_src_ip 192.168.0.1067
    virtual_router_id 51
    priority 101
    advert_int 2
    authentication {
        auth_type PASS
        auth_pass K8SHA_KA_AUTH
    }
    virtual_ipaddress {
        192.168.0.200
    }
#    track_script {
#       chk_apiserver
#    }
}
 </code></pre> 
<h3>5.5<strong>注意上述的健康检查是关闭的，集群建立完成后再开启：</strong></h3> 
<pre><code class="language-cpp">#    track_script {
#       chk_apiserver
#    }
</code></pre> 
<h3>5.6配置KeepAlived健康检查文件（所有Master节点）</h3> 
<p>&nbsp;</p> 
<pre><code class="language-bash">[root@k8s-master01 keepalived]# cat /etc/keepalived/check_apiserver.sh 
#!/bin/bash

err=0
for k in $(seq 1 5)
do
    check_code=$(pgrep kube-apiserver)
    if [[ $check_code == "" ]]; then
        err=$(expr $err + 1)
        sleep 5
        continue
    else
        err=0
        break
    fi
done

if [[ $err != "0" ]]; then
    echo "systemctl stop keepalived"
    /usr/bin/systemctl stop keepalived
    exit 1
else
    exit 0
fi

 </code></pre> 
<h3>5.7启动haproxy和keepalived（所有Master节点）</h3> 
<pre><code>[root@k8s-master01 keepalived]# systemctl enable --now haproxy
[root@k8s-master01 keepalived]# systemctl enable --now keepalived
 </code></pre> 
<p><img alt="" height="629" src="https://img-blog.csdnimg.cn/20201127190230849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="858"></p> 
<h3>5.8配置K8S组件</h3> 
<blockquote> 
 <p>https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/</p> 
 <p>各Master节点的kubeadm-config.yaml配置文件如下：</p> 
 <p>Master01：</p> 
 <p>daocloud.io/daocloud</p> 
</blockquote> 
<pre><code class="language-bash">apiVersion: kubeadm.k8s.io/v1beta2
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: 7t2weq.bjbawausm0jaxury
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
localAPIEndpoint:
  advertiseAddress: 192.168.0.100
  bindPort: 6443
nodeRegistration:
  criSocket: /var/run/dockershim.sock
  name: k8s-master01
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
---
apiServer:
  certSANs:
  - 192.168.0.200
  timeoutForControlPlane: 4m0s
apiVersion: kubeadm.k8s.io/v1beta2
certificatesDir: /etc/kubernetes/pki
clusterName: kubernetes
controlPlaneEndpoint: 192.168.0.200:16443
controllerManager: {}
dns:
  type: CoreDNS
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers
kind: ClusterConfiguration
kubernetesVersion: v1.18.5
 
networking:
  dnsDomain: cluster.local
  podSubnet: 172.168.0.0/16
  serviceSubnet: 10.96.0.0/12
scheduler: {}

==============================================
#如果这个镜像地址无法下载，可以替换：daocloud.io/daocloud   下载
imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers
kubernetesVersion: v1.18.5
 #注意安装的Kubernetes的版本

 </code></pre> 
<p>更新kubeadm文件，如果你使用高版本的，可以使用这条命令生成高版本的yaml文件</p> 
<pre><code class="language-bash">kubeadm config migrate --old-config kubeadm-config.yaml --new-config new.yaml
 </code></pre> 
<p><span style="color:#f33b45;"><strong>所有Master节点提前下载镜像，可以节省初始化时间：</strong></span></p> 
<pre><code class="language-bash">kubeadmconfig images pull --config /root/kubeadm-config.yaml -

所有节点设置开机自启动kubelet
systemctl enable --now kubelet
</code></pre> 
<p>Master01节点初始化，初始化以后会在/etc/kubernetes目录下生成对应的证书和配置文件，之后其他Master节点加入Master01即可：</p> 
<pre><code class="language-bash">kubeadminit --config /root/kubeadm-config.yaml  --upload-certs</code></pre> 
<pre><code class="language-bash">不用配置文件初始化：
kubeadm init --control-plane-endpoint "LOAD_BALANCER_DNS:LOAD_BALANCER_PORT" --upload-certs
 </code></pre> 
<p>如果初始化失败，重置后再次初始化，命令如下：</p> 
<pre><code class="language-bash">kubeadm reset
</code></pre> 
<p><strong>初始化成功以后，会产生Token值，用于其他节点加入时使用，因此要记录下初始化成功生成的token值（令牌值）：</strong></p> 
<pre><code class="language-bash">Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

You can now join any number of the control-plane node running the following command on each as root:

  kubeadm join 192.168.0.200:16443 --token 5joxsb.zo1vh747wljgzrlt \
    --discovery-token-ca-cert-hash sha256:86ee9b6a65c6d8641507e9e56e66dad47cfa15b41b52a11e175c5f9588a485b8 \
    --control-plane --certificate-key bc4726d06255be0cd54592e29068e32c5a49eb8fd30a691342412cf79b3d47c7

Please note that the certificate-key gives access to cluster sensitive data, keep it secret!
As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use
"kubeadm init phase upload-certs --upload-certs" to reload certs afterward.

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.0.200:16443 --token 5joxsb.zo1vh747wljgzrlt \
    --discovery-token-ca-cert-hash sha256:86ee9b6a65c6d8641507e9e56e66dad47cfa15b41b52a11e175c5f9588a485b8

 </code></pre> 
<h3>5.9所有Master节点配置环境变量，用于访问Kubernetes集群：</h3> 
<pre><code class="language-bash">cat &lt;&lt;EOF &gt;&gt; /root/.bashrc
export KUBECONFIG=/etc/kubernetes/admin.conf
EOF
source /root/.bashrc
</code></pre> 
<p>查看节点状态：</p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# kubectl get nodes
NAME           STATUS     ROLES     AGE       VERSION
k8s-master01   NotReady   master    14m       v1.12.3

 </code></pre> 
<p>采用初始化安装方式，所有的系统组件均以容器的方式运行并且在kube-system命名空间内，此时可以查看Pod状态：</p> 
<pre><code>[root@k8s-master01 ~]# kubectl get pods -n kube-system -o wide
NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE
coredns-777d78ff6f-kstsz               0/1       Pending   0          14m       &lt;none&gt;          &lt;none&gt;
coredns-777d78ff6f-rlfr5               0/1       Pending   0          14m       &lt;none&gt;          &lt;none&gt;
etcd-k8s-master01                      1/1       Running   0          14m       192.168.0.100   k8s-master01
kube-apiserver-k8s-master01            1/1       Running   0          13m       192.168.0.100   k8s-master01
kube-controller-manager-k8s-master01   1/1       Running   0          13m       192.168.0.100   k8s-master01
kube-proxy-8d4qc                       1/1       Running   0          14m       192.168.0.100   k8s-master01
kube-scheduler-k8s-master01            1/1       Running   0          13m       192.168.0.100   k8s-master01

 </code></pre> 
<h2>6、Calico组件的安装</h2> 
<p>注意：如果国内用户下载Calico较慢，所有节点可以配置加速器(如果该文件有其他配置，别忘了加上去)</p> 
<pre><code class="language-bash">vim  /etc/docker/daemon.json
{
"exec-opts": ["native.cgroupdriver=systemd"], 
  "registry-mirrors": [
    "https://registry.docker-cn.com",
    "http://hub-mirror.c.163.com",
    "https://docker.mirrors.ustc.edu.cn"
  ]
}
systemctl daemon-reload
systemctl restart docker
</code></pre> 
<pre><code class="language-cpp">Calico：https://www.projectcalico.org/
https://docs.projectcalico.org/getting-started/kubernetes/self-managed-onprem/onpremises


curl https://docs.projectcalico.org/manifests/calico.yaml -O
            - name: CALICO_IPV4POOL_CIDR
              value: "172.168.0.0/16"

kubectl apply -f calico.yaml
</code></pre> 
<h2>7、高可用Master</h2> 
<pre><code class="language-bash">[root@k8s-master01 ~]# kubectl get secret -n kube-system

[root@k8s-master01 ~]# kubectl get secret -n kube-system bootstrap-token-7t2weq -oyaml Token过期后生成新的token：


Node节点生成
kubeadm token create --print-join-command

Master需要生成--certificate-key
kubeadm init phase upload-certs  --upload-certs
 </code></pre> 
<pre><code class="language-bash">kubeadm join 192.168.0.200:16443 --token 9zp1xe.h5kpi1b9kd5blk76     --discovery-token-ca-cert-hash sha256:6ba6e5205ac27e39e03d3b89a639ef70f6503fb877b1cf8a332b399549471740 \
    --control-plane --certificate-key 309f945f612dd7f0d830b11868edd5135e6cf358ed503107eb645dc8d7c84405
 </code></pre> 
<p><img alt="" height="190" src="https://img-blog.csdnimg.cn/20201127190558370.png" width="445"></p> 
<h2>8、Node节点的配置</h2> 
<p>Node节点上主要部署公司的一些业务应用，生产环境中不建议Master节点部署系统组件之外的其他Pod，测试环境可以允许Master节点部署Pod以节省系统资源。</p> 
<pre><code class="language-bash">kubeadm join 192.168.0.200:16443 --token 9zp1xe.h5kpi1b9kd5blk76     --discovery-token-ca-cert-hash sha256:6ba6e5205ac27e39e03d3b89a639ef70f6503fb877b1cf8a332b399549471740
 </code></pre> 
<h2>9、 Metrics部署</h2> 
<p>在新版的Kubernetes中系统资源的采集均使用Metrics-server，可以通过Metrics采集节点和Pod的内存、磁盘、CPU和网络的使用率。</p> 
<p>Heapster更改metrics的部署文件证书，将metrics-server-3.6.1/metrics-server-deployment.yaml的front-proxy-ca.pem改为front-proxy-ca.crt</p> 
<p><img alt="" height="142" src="https://img-blog.csdnimg.cn/2020112719064248.png" width="556"></p> 
<pre><code class="language-bash">将Master01节点的front-proxy-ca.crt复制到所有Node节点
scp /etc/kubernetes/pki/front-proxy-ca.crt k8s-node01:/etc/kubernetes/pki/front-proxy-ca.crt
scp /etc/kubernetes/pki/front-proxy-ca.crt k8s-node(其他节点自行拷贝):/etc/kubernetes/pki/front-proxy-ca.crt
安装metrics server
kubectl  create -f  metrics-server-3.6.1/
</code></pre> 
<h2>10、Dashboard部署</h2> 
<p>官方GitHub：https://github.com/kubernetes/dashboard</p> 
<p>Dashboard用于展示集群中的各类资源，同时也可以通过Dashboard实时查看Pod的日志和在容器中执行一些命令等。</p> 
<p>可以在官方dashboard查看到最新版dashboard</p> 
<pre><code class="language-bash">kubectl apply –f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.4/aio/deploy/recommended.yaml

[root@k8s-master01 ]# kubectl get svc -n kubernetes-dashboard
[root@k8s-master01]# kubectl edit svc kubernetes-dashboard -n !$

 </code></pre> 
<p><img alt="" height="132" src="https://img-blog.csdnimg.cn/20201127190725310.png" width="703"></p> 
<p><strong>在谷歌浏览器（Chrome）启动文件中加入启动参数，用于解决无法访问Dashboard的问题</strong></p> 
<blockquote> 
 <p><code>--test-type--ignore-certificate-errors</code></p> 
</blockquote> 
<p>访问Dashboard：https://192.168.0.200:30000，选择登录方式为令牌（即token方式）</p> 
<p><img alt="" height="239" src="https://img-blog.csdnimg.cn/20201127190746844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="398"></p> 
<p>&nbsp;</p> 
<pre><code class="language-bash">vim admin.yaml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding 
metadata: 
  name: admin-user
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system


kubectl apply -f admin.yaml

kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
 </code></pre> 
<p><img alt="" height="410" src="https://img-blog.csdnimg.cn/20201127190809503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="998"></p> 
<p>将token值输入到令牌后，单击登录即可访问Dashboard</p> 
<p><img alt="" height="925" src="https://img-blog.csdnimg.cn/20201127190827605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<pre><code class="language-bash">将Kube-proxy改为ipvs模式，因为在初始化集群的时候注释了ipvs配置，所以需要自行修改一下：
kubectl edit cm kube-proxy -n kube-system
mode: “ipvs”
更新Kube-Proxy的Pod：
kubectl patch daemonset kube-proxy -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"date\":\"`date +'%s'`\"}}}}}" -n kube-system
验证Kube-Proxy模式
[root@k8s-master01 1.1.1]# curl 127.0.0.1:10249/proxyMode
ipvs
</code></pre> 
<p><img alt="" height="101" src="https://img-blog.csdnimg.cn/20201127190943755.png" width="517"></p> 
<pre><code class="language-bash">[root@k8s-master01 ~]# kubectl get node
NAME           STATUS   ROLES    AGE     VERSION
k8s-master01   Ready    master   5h50m   v1.18.5
k8s-master02   Ready    master   5h31m   v1.18.5
k8s-master03   Ready    master   5h30m   v1.18.5
k8s-node01     Ready    &lt;none&gt;   5h26m   v1.18.5
k8s-node02     Ready    &lt;none&gt;   5h26m   v1.18.5

</code></pre> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Python迭代对象和迭代器</title><link>http://www.cnblogs.com/heian99/archive/2020/11/15/14124798.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 15 Nov 2020 15:53:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/11/15/14124798.html</guid><description><![CDATA[
                    <h2><strong>1、可迭代对象</strong></h2> 
<h3><strong>1)、可迭代对象定义</strong></h3> 
<p>对于迭代器来说，我们更熟悉的应该是可迭代对象，之前无论是源码还是讲课中或多或少我们提到过可迭代对象这个词。之前为了便于大家理解可迭代对象，可能解释的不是很正确，所以今天我们正式的聊一聊什么是可迭代对象。从字面意思来说，我们先对其进行拆解：什么是对象？Python中一切皆对象，之前我们讲过的一个变量，一个列表，一个字符串，文件句柄，函数名等等都可称作一个对象，其实一个对象就是一个实例，就是一个实实在在的东西。那么什么叫迭代？其实我们在日常生活中经常遇到迭代这个词儿，更新迭代等等，迭代就是一个重复的过程，但是不能是单纯的重复（如果只是单纯的重复那么他与循环没有什么区别）每次重复都是基于上一次的结果而来。比如你爹生你，你生你爹，哦不对，你生你儿子，你儿子生你孙子等等，每一代都是不一样的；还有你使用过得app，微信，抖音等，隔一段时间就会基于上一次做一些更新，那么这就是迭代。可迭代对象从字面意思来说就是一个可以重复取值的实实在在的东西。</p> 
<p>&nbsp;&nbsp;&nbsp;str&nbsp; list&nbsp; &nbsp;tuple&nbsp; dic&nbsp; set&nbsp; range 文件句柄等，那么int，bool这些为什么不能称为可迭代对象呢？虽然在字面意思这些看着不符合，但是我们要有一定的判断标准或者规则去判断该对象是不是可迭代对象。</p> 
<p>&nbsp;&nbsp;&nbsp;<strong>在python中，但凡内部含有__iter__方法的对象，都是可迭代对象</strong></p> 
<h3><strong>2、&nbsp;查看对象内部方法</strong></h3> 
<p>该对象内部含有什么方法除了看源码还有什么其他的解决方式么？当然有了， 可以通过dir() 去判断一个对象具有什么方法</p> 
<pre><code class="language-python">s1 = 'heian'
print(dir(s1))</code></pre> 
<p>dir()会返回一个列表，这个列表中含有该对象的以字符串的形式所有方法名。这样我们就可以判断python中的一个对象是不是可迭代对象了：</p> 
<pre><code class="language-python">s1 = 'heian'
i = 100
print('__iter__' in dir(i))  # False
print('__iter__' in dir(s1))  # True</code></pre> 
<h3><strong>3、判断一个对象是否可以迭代</strong></h3> 
<pre><code class="language-python">name = [1,2,3,4]
print(dir(name))
print('__iter__' in dir(name))</code></pre> 
<h3><strong>4、小结</strong>：</h3> 
<blockquote> 
 <p>字面意思：循环更新的一个实实在在的值<br> 内部意思：内部含有“__iter__()”方法的对象，可迭代对象<br> 判断方法：'__iter__' in dir(对象)<br> str list tuple dict set range</p> 
</blockquote> 
<h3>5、迭代对象优缺点</h3> 
<blockquote> 
 <p><br> 优点：<br> &nbsp;&nbsp;&nbsp; 1.存储的数据直接能显示，比较直观<br> &nbsp;&nbsp;&nbsp; 2.拥有的方法比较多，操作方便<br> 缺点：<br> &nbsp;&nbsp;&nbsp; 1.占用内存<br> &nbsp;&nbsp;&nbsp; 2.不能直接通过for循环，不能直接取值（索引和key除外）</p> 
</blockquote> 
<p>for循环在底层做了一个小小的转化，就是先将可迭代对象转化成迭代器，然后在进行取值的。</p> 
<h2><strong>&nbsp;2、迭代器</strong></h2> 
<h3><strong>1、迭代器的定义</strong></h3> 
<p>从字面意思来说迭代器，是一个可以迭代取值的工具，器：在这里当做工具比较合适。</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;从专业角度来说：迭代器是这样的对象：实现了无参数的__next__方法，返回序列中的下一个元素，如果没有元素了，那么抛出StopIteration异常.python中的迭代器还实现了__iter__方法，因此迭代器也可以迭代。 出自《流畅的python》</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;那么对于上面的解释有一些超前，和难以理解，不用过于纠结，我们简单来说：<strong>在python中，内部含有'__Iter__'方法并且含有'__next__'方法的对象就是迭代器。</strong></p> 
<h3>2、<strong>如何判断该对象是否是迭代器</strong></h3> 
<pre><code class="language-python">with open('heian',mode='w',encoding='utf-8') as f:
    print('__iter__' in dir(f) and '__next__' in dir(f))</code></pre> 
<h3>3、<strong>可迭代对象如何转化成迭代器</strong></h3> 
<pre><code class="language-python">l1 = [1, 2, 3, 4, 5, 6]
obj = l1.__iter__() 
# 或者 iter(l1)print(obj) 
# &lt;list_iterator object at 0x000002057FE1A3C8&gt;</code></pre> 
<h3><strong>　4、&nbsp;迭代器取值：</strong></h3> 
<p>&nbsp;可迭代对象是不可以一直迭代取值的（除去用索引，切片以及Key），但是转化成迭代器就可以了，迭代器是利用__next__()进行取值：</p> 
<pre><code class="language-python">l1 = [1, 2, 3,]
obj = l1.__iter__()  # 或者 iter(l1)
# print(obj)  # &lt;list_iterator object at 0x000002057FE1A3C8&gt;
ret = obj.__next__()
print(ret)
ret = obj.__next__()
print(ret)
ret = obj.__next__()
print(ret)
ret = obj.__next__()  # StopIteration
print(ret)
# 迭代器利用next取值：一个next取对应的一个值，如果迭代器里面的值取完了，还要next，
# 那么就报StopIteration的错误。</code></pre> 
<h3>5、<strong>while模拟for的内部循环机制</strong></h3> 
<pre><code class="language-python">l1 = [1, 2, 3, 4, 5, 6]
# 1 将可迭代对象转化成迭代器
obj = iter(l1)
# 2,利用while循环，next进行取值
while 1:
    # 3,利用异常处理终止循环
    try:
        print(next(obj))
    except StopIteration:
        break</code></pre> 
<h3>6、迭代器的优缺点</h3> 
<blockquote> 
 <p>优点：<br> &nbsp;&nbsp;&nbsp; 1.节省内存<br> &nbsp;&nbsp;&nbsp; 2.惰性机制。 next一次，取一个值，绝不过多取值。​<br> 缺点：<br> &nbsp;&nbsp;&nbsp; 1.速度慢<br> &nbsp;&nbsp;&nbsp; 2.不走回头路</p> 
</blockquote> 
<pre><code class="language-python">l1 = [1, 2, 3, 4, 5, 6]
obj = iter(l1)

for i in range(2):
    print(next(obj))

for i in range(2):
    print(next(obj))</code></pre> 
<h2>3、<strong>可迭代对象与迭代器对比</strong></h2> 
<p><strong>可迭代对象：</strong></p> 
<blockquote> 
 <p>&nbsp;&nbsp;&nbsp;&nbsp;是一个私有的方法比较多，操作灵活（比如列表，字典的增删改查，字符串的常用操作方法等）,比较直观，但是占用内存，而且不能直接通过循环迭代取值的这么一个数据集。</p> 
 <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;应用</strong>：当你侧重于对于数据可以灵活处理，并且内存空间足够，将数据集设置为可迭代对象是明确的选择。</p> 
</blockquote> 
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;迭代器：</strong></p> 
<blockquote> 
 <p>&nbsp;&nbsp;&nbsp;&nbsp;是一个非常节省内存，可以记录取值位置，可以直接通过循环+next方法取值，但是不直观，操作方法比较单一的数据集。</p> 
 <p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>应用</strong>：当你的数据量过大，大到足以撑爆你的内存或者你以节省内存为首选因素时，将数据集设置为迭代器是一个不错的选择。（可参考为什么python把文件句柄设置成迭代器）。</p> 
</blockquote> 
<p>&nbsp;</p>
                ]]></description></item><item><title>Zabbix配置企业微信群(机器人)警告</title><link>http://www.cnblogs.com/heian99/archive/2020/10/30/14124799.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 30 Oct 2020 10:22:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/10/30/14124799.html</guid><description><![CDATA[
                    <h2 id="企业微信机器人告警">企业微信机器人告警</h2> 
<p>企业微信群聊里面增加机器人，机器人会提供发送信息的URL</p> 
<p>&nbsp;python 脚本进行实现的</p> 
<h3 id="1-创建企业微信机器人">1、创建企业微信机器人</h3> 
<p><img alt="" height="446" src="https://img-blog.csdnimg.cn/20201030181237742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="368"></p> 
<p>没有企业微信的可以自己在企业微信官网申请注册个企业，创建企业微信群至少 3 个人以上</p> 
<p><img alt="" height="382" src="https://img-blog.csdnimg.cn/20201030181333913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="400"></p> 
<p><strong>这个 webhook 后面需要使用到</strong></p> 
<h3 id="2-配置zabbix-server">2、配置 zabbix server</h3> 
<p>2.1：配置脚本执行目录</p> 
<p>定义脚本目录，我这里就选择了默认的目录</p> 
<pre><code class="language-bash">[root@zabbix-master ~]#  grep -Ev '^$|#' /etc/zabbix/zabbix_server.conf | grep ^A
AlertScriptsPath=/usr/lib/zabbix/alertscripts
</code></pre> 
<p><img alt="" height="98" src="https://img-blog.csdnimg.cn/20201030181408876.png" width="719"></p> 
<p>2.2：创建脚本</p> 
<p>进入该定义的脚本存放路径下创建用来推送告警消息的脚本</p> 
<pre><code class="language-bash">[root@zabbix-master ~]# 
[root@zabbix-master ~]# cd /usr/lib/zabbix/alertscripts

[root@zabbix-master alertscripts]# vim wechat.py 

#!/usr/bin/python
# -*- coding: utf-8 -*-
import requests
import json
import sys
import os

headers = {'Content-Type': 'application/json;charset=utf-8'}
api_url = "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=36d51b45-162f6c9d13909" #这就是先前的webhook地址
def msg(text):
    json_text= {
     "msgtype": "text",
        "text": {
            "content": text
        },
    }
    print requests.post(api_url,json.dumps(json_text),headers=headers).content

if __name__ == '__main__':
    text = sys.argv[1]
    msg(text)
~            </code></pre> 
<p>2.3：赋予脚本执行权限</p> 
<pre><code class="language-bash">[root@zabbix-master alertscripts]# chmod +x wechat.py
[root@zabbix-master alertscripts]# python wechat.py 你好
{"errcode":0,"errmsg":"ok"}
[root@zabbix-master alertscripts]# 
</code></pre> 
<p><img alt="" height="203" src="https://img-blog.csdnimg.cn/20201030181751655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="553"></p> 
<h3 id="3-zabbix-web页面配置">3、zabbix Web 页面配置</h3> 
<p>3.1：创建报警媒介</p> 
<p>管理--&gt; 报警媒介类型--&gt; 创建媒介类型<br> 新建一个企业微信的报警，脚本名称就是我们脚本名 wechat.py</p> 
<p><img alt="" height="387" src="https://img-blog.csdnimg.cn/20201030181818737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="789"></p> 
<p><img alt="" height="239" src="https://img-blog.csdnimg.cn/20201030181827294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="813"></p> 
<p><img alt="" height="435" src="https://img-blog.csdnimg.cn/20201030181834972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="738"></p> 
<p>3.2：创建动作</p> 
<p><img alt="" height="523" src="https://img-blog.csdnimg.cn/20201030181905798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p><img alt="" height="398" src="https://img-blog.csdnimg.cn/2020103018191314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="957"></p> 
<p><img alt="" height="498" src="https://img-blog.csdnimg.cn/2020103018192468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1037"></p> 
<p><strong>默认标题：</strong></p> 
<pre><code class="language-bash">故障{TRIGGER.STATUS},服务器:{HOSTNAME1}发生: {TRIGGER.NAME}故障!

故障{TRIGGER.STATUS},服务器:{HOSTNAME1}发生: {TRIGGER.NAME}故障!
告警主机:{HOSTNAME1}
告警地址：{HOST.IP}
告警时间:{EVENT.DATE} {EVENT.TIME}
告警等级:{TRIGGER.SEVERITY}
告警信息: {TRIGGER.NAME}
告警项目:{TRIGGER.KEY1}
问题详情:{ITEM.NAME}:{ITEM.VALUE}
当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}
事件ID:{EVENT.ID}</code></pre> 
<p><strong>恢复操作</strong></p> 
<pre><code>恢复{TRIGGER.STATUS}, 服务器:{HOSTNAME1}: {TRIGGER.NAME}已恢复!


恢复{TRIGGER.STATUS}, 服务器:{HOSTNAME1}: {TRIGGER.NAME}已恢复!
告警主机:{HOSTNAME1}
告警地址：{HOST.IP}
告警时间:{EVENT.DATE} {EVENT.TIME}
告警等级:{TRIGGER.SEVERITY}
告警信息: {TRIGGER.NAME}
告警项目:{TRIGGER.KEY1}
问题详情:{ITEM.NAME}:{ITEM.VALUE}
当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}
事件ID:{EVENT.ID}</code></pre> 
<h3 id="4-测试发送告警">4、测试发送告警</h3> 
<p><img alt="" height="603" src="https://img-blog.csdnimg.cn/2020103018211323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>&nbsp;</p> 
<p><img alt="" height="822" src="https://img-blog.csdnimg.cn/20201030182132120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="741"></p>
                ]]></description></item><item><title>Linux 安装后基本优化操作</title><link>http://www.cnblogs.com/heian99/archive/2020/09/19/14124800.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 19 Sep 2020 13:55:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/09/19/14124800.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E9%85%8D%E7%BD%AE%20yum%20%E6%BA%90-toc" style="margin-left:40px;">&nbsp; &nbsp; &nbsp; &nbsp;<a href="#1.%E9%85%8D%E7%BD%AE%20yum%20%E6%BA%90">1.配置 yum 源</a></p> 
<p id="2.%E8%AE%BE%E5%AE%9A%20runlevel%203-toc" style="margin-left:80px;"><a href="#2.%E8%AE%BE%E5%AE%9A%20runlevel%203">2.设定 runlevel 3</a></p> 
<p id="3.%E7%B2%BE%E7%AE%80%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#3.%E7%B2%BE%E7%AE%80%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">3.精简开机启动服务</a></p> 
<p id="4.%E9%85%8D%E7%BD%AE%20sudo%20%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#4.%E9%85%8D%E7%BD%AE%20sudo%20%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86">4.配置 sudo 授权管理</a></p> 
<p id="5.ssh%20%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#5.ssh%20%E6%9C%8D%E5%8A%A1">5.ssh 服务</a></p> 
<p id="6.%E4%BF%AE%E6%94%B9%20linux%20%E9%BB%98%E8%AE%A4%E5%AD%97%E7%AC%A6%E9%9B%86-toc" style="margin-left:80px;"><a href="#6.%E4%BF%AE%E6%94%B9%20linux%20%E9%BB%98%E8%AE%A4%E5%AD%97%E7%AC%A6%E9%9B%86">6.修改 linux 默认字符集</a></p> 
<p id="7.%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5-toc" style="margin-left:80px;"><a href="#7.%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5">7.服务器时间同步</a></p> 
<p id="8.%E5%8A%A0%E5%A4%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-toc" style="margin-left:80px;"><a href="#8.%E5%8A%A0%E5%A4%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">8.加大服务器文件描述符</a></p> 
<p id="9.%E6%B8%85%E7%90%86%20clientmqueue%20%E5%9E%83%E5%9C%BE%E6%96%87%E4%BB%B6%E9%98%B2%E6%AD%A2%20inode%20%E8%A2%AB%E5%8D%A0%E6%BB%A1-toc" style="margin-left:80px;"><a href="#9.%E6%B8%85%E7%90%86%20clientmqueue%20%E5%9E%83%E5%9C%BE%E6%96%87%E4%BB%B6%E9%98%B2%E6%AD%A2%20inode%20%E8%A2%AB%E5%8D%A0%E6%BB%A1">9.清理 clientmqueue 垃圾文件防止 inode 被占满</a></p> 
<p id="10.%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#10.%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96">10.调整内核优化</a></p> 
<p id="11.grep%20%E8%AE%BE%E7%BD%AE%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA-toc" style="margin-left:80px;"><a href="#11.grep%20%E8%AE%BE%E7%BD%AE%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA">11.grep 设置高亮显示</a></p> 
<p id="Ulimit%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;"><a href="#Ulimit%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90">Ulimit管理系统资源</a></p> 
<p id="linux%20%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%B0%8F%E5%B7%A5%E5%85%B7-toc" style="margin-left:80px;"><a href="#linux%20%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%B0%8F%E5%B7%A5%E5%85%B7">linux 上传下载小工具</a></p> 
<p id="tcp%2Fip%20%E8%B0%83%E4%BC%98-toc" style="margin-left:80px;"><a href="#tcp%2Fip%20%E8%B0%83%E4%BC%98">tcp/ip 调优</a></p> 
<p id="%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93">优化总结</a></p> 
<hr id="hr-toc">
<h2>&nbsp;</h2> 
<h2 id="1.%E9%85%8D%E7%BD%AE%20yum%20%E6%BA%90">1.配置 yum 源</h2> 
<p><strong>1、添加普通用户，使用普通用户 su - root 登陆到 root<br> 2、设置更新源</strong><br> Linux 下方便安装软件的优秀工具叫做 yum 工具，linux 的二进制软件包一般是 rpm 包，类似windows 下的 exe 程序。<br> 通过 yum 工具安装软件，默认获取 rpm 包的软件配置是从国外 centos 官方源下载。<br> 因此，我们 yum 安装软件速度会比较慢，因此需要把默认获取 rpm 包的配置从国外官方源改为国内。</p> 
<pre><code class="language-bash">centos 5.8 64 位 yum 源
http://mirrors.sohu.com/help/CentOS-Base-sohu.repo
centos 6.4 64 位 yum 源
http://mirrors.163.com/.help/CentOS6-Base-163.repo
cd /etc/yum.repos.d/ //进入 yum 源7 
/bin/mv CentOS-Base.repo CentOS-Base.repo.ori //备份 yum 源
wget http://mirrors.sohu.com/help/CentOS-Base-sohu.repo //下载 soho 源
/bin/mv CentOS-Base-sohu.repo CentOS-Base.repo</code></pre> 
<p><br> 说明：我们现在使用的是互联网上的门户网站提供的 yum 源，将来我们也可以把 iso 镜像或光盘配<br> 置成 yum 源，你还可以自己配置一个像门户网站提供的这种 yum 源<br> 配置公网 yum 源及制作 rpm 包。</p> 
<p><br><strong>3、使用 yum upgrade 相当于 windows 下的打补丁，这个功能就用到了 yum 源，速度会比较快</strong></p> 
<p><br><strong>4、安装必要的软件包</strong><br> &nbsp;</p> 
<pre><code class="language-bash">yum -y install lrzsz</code></pre> 
<p><br><strong>一、关闭 selinux</strong></p> 
<p>由于安装服务、软件中，经常和 selinux 冲突，在国内生产环境中，都是关掉 selinux。</p> 
<pre><code class="language-bash">vi /etc/selinux/config //配置文件
默认是 enforcing 启用状态
disabled 是完全关闭状态
permissive 是打印警告，selinu 不生效
这种修改只能重启生效
gentenforce 0 临时关闭 selinux，使用 gentenforce 查看当前 selinux 状态</code></pre> 
<h3 id="2.%E8%AE%BE%E5%AE%9A%20runlevel%203"><br><strong>2.设定 runlevel 3</strong></h3> 
<pre><code class="language-bash">runlevel 查看当前系统运行级别
vi /etc/inittab //运行级别配置文件</code></pre> 
<h3 id="3.%E7%B2%BE%E7%AE%80%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><br><strong>3.精简开机启动服务</strong></h3> 
<p>1、可以使用 setup-system services 里面调整，这样调整起来效率低<br> 2、或者 ntsysv 调出来<br> 3、使用脚本一件关闭</p> 
<pre><code class="language-bash">#LANG=en
#显示出所有服务的所有运行级别的启动状态 8
chkconfig --list
#停止所有在运行级别 3 上开机启动的服务
for oldboy in `chkconfig --list|grep3:on |awk '{print $1}'`;do chkconfig --level 3
$oldboyoff;done
#在开启常用的服务，crond,network,rsyslog,sshd
for oldboy in crond network rsyslogsshd;do chkconfig --level 3 $oldboy on;done
#显示出所有 3 运行级别下的所有服务(根据需求决定哪个服务启动)
chkconfig --list |grep3:on</code></pre> 
<p><br> 刚装完的操作系统，只需要开启几个服务，剩下的以后用到再开，这样安全，遵循最小化原则，没<br> 用的不启动。</p> 
<ul><li>crond 定时任务</li><li>network 网络服务</li><li>sshd 远程服务</li><li>syslog 日志服务</li></ul>
<h3 id="4.%E9%85%8D%E7%BD%AE%20sudo%20%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86"><strong>4.配置 sudo 授权管理</strong></h3> 
<p><br> 为什么使用 sudo，如果普通用户使用 su - root 切换到管理员。进行非法操作，比如 passwd root<br> 修改 root 密码。那么系统其他用户将无法访问系统。这个普通管理员说白了，已经”功高盖主“<br><strong>1、在 root 权限下执行 visudo 在 98 行修改。命令使用逗号隔开，使用全路径。</strong></p> 
<pre><code class="language-bash"># user MACHINE= COMMANDS
root ALL =（ALL） ALL
用户 机器=（授权哪个角色的权限） /usr/sbin/useradd,/usr/sbin/passwd
如果不授权，默认是不能执行 useradd 命令的
#su - liuyalei //切换到普通用户 liuyalei$sudo /usr/sbin/useradd test //创建 test 用户</code></pre> 
<p>注意，<br> 前面要加上 sudo，打个比方就是一把钥匙开一把锁。第一次执行 sudo 需要输入普通用户密码，防<br> 止被非法利用。下次 5 分钟内不需要输入密码<br> 如果你是运维经理，带一个小弟，不会吧整个 root 的权限都给他，只给他一些普通权限。目的：既<br> 能让菜的运维干活，又不能威胁系统安全<br> 如果你是小弟，你的运维经历要把自己的账户提升成 root，那么直接复制，把 root 改成经理账号<br> 即可。下次经理直接使用 sudo su - root 就能切到 root 权限下<br> boss ALL =（ALL） ALL<br> 这样做，boss 既有了 root 权限还不知道 root 的密码，但是每次切到 root，都要输入 boss 普通用<br> 户密码，太繁琐了，可以在 visudo 中改成如下，这样就不用输入密码了，但是不安全。</p> 
<pre><code class="language-bash">boss ALL =（ALL） NOPASSWD： ALL</code></pre> 
<p><strong>su 命令总结</strong><br> 普通用户切换到 root，使用 su - 或者 su - root 需要输入 root 密码<br> 超级用户切换到普通用户不需要密码。但是 centos5.8 会有环境变量问题，需要给普通用户修改环<br> 境变量<br> su 优点是给管理服务器带来方便，但是他的缺点就是大家都知道 root 的密码，而且还能改掉 root<br> 的密码。在一定程度上，对服务器带来了很大的安全隐患。在工作用几乎有一半的问题来自于内部</p> 
<h3 id="5.ssh%20%E6%9C%8D%E5%8A%A1">5.ssh 服务</h3> 
<p>linux 默认管理员 root，port 端口号是 22，为了安全，我们要改掉默认的管理员和端口<br> 配置文件/etc/ssh/sshd_config</p> 
<pre><code class="language-bash">[root@oldboy ~]# vi /etc/ssh/sshd_config 添加如下内容保存。

52113#→ssh 连接默认的端口，谁都知道，必须要改。
PermitRootLogin no#→root 用户黑客都知道的，禁止它远程登陆。
PermitEmptyPasswords no #→禁止空密码登陆
UseDNSno#→不使用 DNS
GSSAPIAuthentication no

重启 sshd 服务 #
/etc/init.d/sshd restart</code></pre> 
<p>注意：yum，rpm 安装的软件，启动程序一般都在/etc/init.d</p> 
<h3 id="6.%E4%BF%AE%E6%94%B9%20linux%20%E9%BB%98%E8%AE%A4%E5%AD%97%E7%AC%A6%E9%9B%86">6.修改 linux 默认字符集</h3> 
<pre><code class="language-bash">[root@eric6 ~]# cat /etc/sysconfig/i18n //查看 linux 默认的字符集，默认是 UTF-8
LANG="zh_CN.UTF-8"
cp /etc/sysconfig/i18n /etc/sysconfig/i18n.ori //备份默认字符集
echo 'LANG="ZH_CN.GB18030"' &gt;/etc/sysconfig/i18n //修改字符集为 GB18030</code></pre> 
<p>什么是字符集？<br> 简单的说就是一套文字符号及其编码。常用的字符集有：<br> GBK 定长 双字节 不是国际标准，支持的系统不少<br> UTF-8 非定长 1-4 字节 广泛支持，MYSQL 也使用 UTF-8<br> 这个不一定要修改，有的公司使用的就是 UTF-8，因为 linux 对中文支持不好</p> 
<h3 id="7.%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5">7.服务器时间同步</h3> 
<p>如果时间不同步，经常带来业务不正常。如果公司规模小，可以使用联网手动同步，如果服务器多，<br> 可以在公司内部搭建 ntp server。还有一种可能是公司服务器不出外网，比如内部数据库服务器。<br> 可以在内网搭建两台时间服务器，因为一台可能 down 掉，搭建两台可以做到冗余的目的（50 台-100<br> 台以上在用）。</p> 
<p><img alt="" height="396" src="https://img-blog.csdnimg.cn/20200919214559317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="846"></p> 
<p>手动同步方法：</p> 
<pre><code class="language-bash">/sbin/ntpdate time.nist.gov //必须要联网
/usr/sbin/ntpdate time.nist.gov //6.4 在/usr/sbin 下
自动同步方法（每五分钟同步一次）：
echo '#time sync by oldboy at 2010-2-1' &gt;&gt;/var/spool/cron/root
echo '*/5 * * * * /usr/sbin/ntpdate time.nist.gov &gt;/dev/null  2&gt;&amp;1' &gt;&gt;/var/spool/cron/root</code></pre> 
<h3 id="8.%E5%8A%A0%E5%A4%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">8.加大服务器文件描述符</h3> 
<p>最简单的说，在 unix/liux 里面，你的服务只要开启一个进程，就要占用文件描述符的。liunx 默认是 1024，如果描述符少了，你的访问量多了，你的服务器支撑不了，所以要把描述符加大。</p> 
<pre><code class="language-bash">#echo '* - nofile 65535 ' &gt;&gt;/etc/security/limits.conf
#ulimit -n //查看当前文件描述符数量</code></pre> 
<p>有的时候，你的服务器硬盘/内存没那么大，如果文件描述符过大，访问量过来，有可能把服务器搞垮。但是网友们通常都改成 65535</p> 
<h3 id="9.%E6%B8%85%E7%90%86%20clientmqueue%20%E5%9E%83%E5%9C%BE%E6%96%87%E4%BB%B6%E9%98%B2%E6%AD%A2%20inode%20%E8%A2%AB%E5%8D%A0%E6%BB%A1">9.清理 clientmqueue 垃圾文件防止 inode 被占满</h3> 
<pre><code class="language-bash">#find /var/spool/clientmqueue/ -type -f |xargs rm -f</code></pre> 
<h3 id="10.%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96">10.调整内核优化</h3> 
<p>所谓内核优化，主要是在 linux 中针对业务服务应用而进行的系统内核参数优化，优化并无特殊的标准，下面以常见生产环境 linux 的内核优化为例讲解，仅供大家参考：<br><strong>内核调优</strong></p> 
<pre><code class="language-bash">#vi /etc/sysctl.cof
net.ipv4.tcp_fin_timeout = 2
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_keepalive_time = 600
net.ipv4.ip_local_port_range = 4000 65000
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.tcp_max_tw_buckets = 36000
net.ipv4.route.gc_timeout = 100
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_synack_retries = 1
net.core.somaxconn = 16384 12
net.core.netdev_max_backlog = 16384
net.ipv4.tcp_max_orphans = 16384</code></pre> 
<p>#以下参数是对 iptables 防火墙的优化，防火墙不开会提示，可以忽略不理</p> 
<pre><code class="language-bash">net.ipv4.ip_conntrack_max = 25000000
net.ipv4.netfilter.ip_conntrack_max=25000000
net.ipv4.netfilter.ip_conntrack_tcp_timeout_established=180
net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait=120
net.ipv4.netfilter.ip_conntrack_tcp_timeout_close_wait=60
net.ipv4.netfilter.ip_conntrack_tcp_timeout_fin_wait=120</code></pre> 
<pre><code class="language-bash">[root@eric6 ~]# sysctl -p //使配置文件生效
net.ipv4.ip_forward = 0
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.default.accept_source_route = 0
kernel.sysrq = 0
kernel.core_uses_pid = 1
net.ipv4.tcp_syncookies = 1
error: "net.bridge.bridge-nf-call-ip6tables" is an unknown key
error: "net.bridge.bridge-nf-call-iptables" is an unknown key
error: "net.bridge.bridge-nf-call-arptables" is an unknown key
kernel.msgmnb = 65536
kernel.msgmax = 65536
kernel.shmmax = 68719476736
kernel.shmall = 4294967296
net.ipv4.tcp_fin_timeout = 2
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1 13
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_keepalive_time = 600
net.ipv4.ip_local_port_range = 4000 65000
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.tcp_max_tw_buckets = 36000
net.ipv4.route.gc_timeout = 100
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_synack_retries = 1
net.core.somaxconn = 16384
net.core.netdev_max_backlog = 16384
net.ipv4.tcp_max_orphans = 16384
error: "net.ipv4.ip_conntrack_max" is an unknown key
error: "net.ipv4.netfilter.ip_conntrack_max" is an unknown key
error: "net.ipv4.netfilter.ip_conntrack_tcp_timeout_established" is an unknown key
error: "net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait" is an unknown key
error: "net.ipv4.netfilter.ip_conntrack_tcp_timeout_close_wait" is an unknown key
error: "net.ipv4.netfilter.ip_conntrack_tcp_timeout_fin_wait" is an unknown key </code></pre> 
<p>防火墙未开启报错，不用管,5.8 的话，不会报错</p> 
<h3 id="11.grep%20%E8%AE%BE%E7%BD%AE%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA">11.grep 设置高亮显示</h3> 
<pre><code class="language-bash">[root@eric ~]# vi /etc/profile
alias grep='grep --color=auto'
[root@eric ~]# source /etc/profile</code></pre> 
<h3>&nbsp;</h3> 
<h3 id="Ulimit%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90">Ulimit管理系统资源</h3> 
<p>具体的 options 含义以及简单示例可以参考以下表格。</p> 
<p><img alt="" height="102" src="https://img-blog.csdnimg.cn/20200919215234278.png" width="970"></p> 
<p><img alt="" height="637" src="https://img-blog.csdnimg.cn/20200919215248854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="974"></p> 
<h3 id="linux%20%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%B0%8F%E5%B7%A5%E5%85%B7">linux 上传下载小工具</h3> 
<pre><code class="language-bash">yum install lrzsz -y</code></pre> 
<h3 id="tcp%2Fip%20%E8%B0%83%E4%BC%98">tcp/ip 调优</h3> 
<p>sysctl 变量修改方法：sysctl –a<br> 使用 sysctl 命令修改系统变量，和通过编辑 sysctl.conf 文件来修改系统变量两种。但并不是所有的<br> 变量都可以在这个模式下设定。<br> 注：sysctl 变量的设置通常是字符串、数字或者布尔型。 (布尔型用 1 来表示'yes'，用 0 来表示'no')。</p> 
<pre><code class="language-bash">[root@localhost ~]#sysctl -w net.ipv4.tcp_keepalive_time=30
[root@localhost ~]#sysctl -w net.ipv4.tcp_keepalive_probes=2
[root@localhost ~]#sysctl -w net.ipv4.tcp_keepalive_intvl=2
[root@localhost~]# sysctl -a | grep keepalive
net.ipv4.tcp_keepalive_time= 30
net.ipv4.tcp_keepalive_probes= 2
net.ipv4.tcp_keepalive_intvl= 2

执行以下命令使变动立即生效： 
[root@localhost ~]# sysctl</code></pre> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>centos 6.4 安装软件包：<br> 软件自定义-基本<br> 性能工具<br> 调试工具兼容程序库&nbsp;<br> 开发工具<br> 服务器----系统管理工具<br> 系统管理---snmp/系统管理</p> 
<h3 id="%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93"><br><strong>优化总结</strong></h3> 
<ul><li>01）添加普通用户，通过 sudo 授权管理</li><li>02）定时自动更新服务器时间</li><li>03）配置 yum 更新源</li><li>04）关闭 selinux 和 iptables</li><li>05）调整文件描述符数量</li><li>06）定时自动清理/var/spool/clientmquene/目录垃圾文件，防止 inodes 节点被占满</li><li>07）精简开机自动启动服务（sshd，crond，network，syslog）</li><li>08）内核参数优化/etc/sysctl.config，sysctl -p 生效</li><li>09）更改默认 ssh 服务端口，及禁止 root 用户远程登陆</li><li>10）更改字符集，支持中文</li><li>11）锁定关键系统文件</li></ul>
<pre><code class="language-bash">chattr +i /etc/passwd
chattr +i /etc/inittab
chattr +i /etc/group
chattr +i /etc/shadow
chattr +i /etc/gshadow</code></pre> 
<ul><li>12）清空/etc/issue，去除系统及内核版本登陆前的屏幕显示</li><li>13）更改系统登录后的信息 /etc/motd</li></ul>
                ]]></description></item><item><title>手误【删库】 == 跑路，不存在的    Linux回收站</title><link>http://www.cnblogs.com/heian99/archive/2020/07/27/14124801.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 27 Jul 2020 15:15:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/07/27/14124801.html</guid><description><![CDATA[
                    <p><strong>上一章节，讲了自己悲剧的删库事件。</strong></p> 
<p><strong>原因总结：</strong></p> 
<p><span style="color:#f33b45;"><strong>（1）手贱</strong></span></p> 
<p><span style="color:#f33b45;"><strong>（2）还是手贱</strong></span></p> 
<p><span style="color:#f33b45;"><strong>（3）不过大脑</strong></span></p> 
<p><span style="color:#f33b45;"><strong>（4）Linux没有回收站功能</strong></span></p> 
<p><img alt="" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOC8wOC8wNC8yMDE4MDgwNDM0OTA5M192SWphd2cuZ2lm"><img alt="" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8xMC8zMS8yMDE5MTAzMTQ4OTEzN19YanpTUWEuanBn?x-oss-process=image/format,png"></p> 
<p><strong>俗话说，吃一堑长一智。接下来就是我的解决方案。</strong></p> 
<p><strong>给Linux添加一个回收站的功能，这是不是很高大上啊</strong></p> 
<p><strong>这下就不怕手贱删库了</strong></p> 
<h1 id="articleContentId"><a href="https://blog.csdn.net/heian_99/article/details/105689982">手误【删库】 == 跑路，不存在的 ——删瓦辛格</a></h1> 
<p>&nbsp;</p> 
<p><img alt="" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOC8wNC8xNC8yMDE4MDQxNDY2NTIyNl95c3JSbksuZ2lm"></p> 
<p>&nbsp;</p> 
<p><br><strong>删除是危险系数很高的操作，一旦误删可能会造成难以估计的损失。</strong></p> 
<p><strong>在 Linux 系统中这种危险尤为明显，一条简单的语句：rm –rf /* 就会把整个系统全部删除，而 Linux 并不会因为这条语句的不合理而拒绝执行。</strong></p> 
<p><img alt="" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxNy8wNy8wOS8yMDE3MDcwOTYwODcyMF9WSUxqQlUuZ2lm"></p> 
<p><strong>这时，有个像Windows的那样的回收站是多么的重要啊。下面可以使用代码实现</strong></p> 
<p>&nbsp;</p> 
<p><img alt="" height="364" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8wMy8yNC8yMDE5MDMyNDQwMjYxMF9ERnJCUXQuanBn?x-oss-process=image/format,png" width="518"></p> 
<p>&nbsp;</p> 
<h2>rm命令修改</h2> 
<pre><code class="language-bash">vim /etc/bashrc  

alias rm=delete  #命令别名，通过delete来实现rm改为mv
alias r=delete
alias rl='ls /trash' #rl 命令显示回收站中的文件
alias ur=undelfile #ur 命令找回回收站的文件
undelfile()
{
    mv /trash/$@ ./
}
delete()
{
if [ ! -d "/trash/" ];then
         mkdir /trash
fi
\mv --backup=numbered $@ /trash/
}
cleartrash()
{
    read -p "clear sure?[n]" confirm
    [ $confirm == 'y' ] || [ $confirm == 'Y' ]  &amp;&amp; /bin/rm -rf /trash/*
}</code></pre> 
<p>&nbsp;</p> 
<p>添加完毕后保存，执行source命令生效</p> 
<pre><code class="language-bash">source /etc/bashrc </code></pre> 
<p><img alt="" height="304" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOC8wOC8xOC8yMDE4MDgxODU1MTYyNF9pQ2NyakUucG5n?x-oss-process=image/format,png" width="351"></p> 
<p>&nbsp;</p> 
<h2>使用方法</h2> 
<p><br><strong>以使用<span style="color:#f33b45;">rm（删除），ur（撤销），rl（列出回收站），cleartrash（清空回收站）</span>命令了。</strong></p> 
<p>&nbsp;</p> 
<p><strong>删除一个文件夹，hellworld下面的文件均被移到回收站中</strong></p> 
<pre><code class="language-bash"> rm helloworld/  或者 r helloworld/ 或者 delete helloworld/</code></pre> 
<p><strong>删除一个文件</strong></p> 
<pre><code class="language-bash">rm 123.txt 或者 r  123.txt 或者 delete  123.txt</code></pre> 
<p><img alt="" height="194" src="https://img-blog.csdnimg.cn/20200727223701681.png" width="764"></p> 
<p><strong>列出回收站信息</strong></p> 
<p><img alt="" height="315" src="https://img-blog.csdnimg.cn/20200727223753250.png" width="826"></p> 
<p><strong>要查看回收站内容详细信息，只要加个参数就好</strong></p> 
<p><img alt="" height="246" src="https://img-blog.csdnimg.cn/20200727223822796.png" width="500"></p> 
<p><strong>撤销123.txt</strong></p> 
<pre><code class="language-bash">ur 123.txt 或者 undelfile  123.txt</code></pre> 
<p><strong>撤销helloworld文件夹</strong></p> 
<pre><code class="language-bash">ur helloworld  或者 undelfile helloworld </code></pre> 
<p><img alt="" height="329" src="https://img-blog.csdnimg.cn/20200727224026135.png" width="799"></p> 
<p><strong>清空回收站</strong></p> 
<pre><code class="language-bash">[root@Master ~]# cleartrash     #会弹出是否清空
clear sure?[n]y
[root@Master ~]# 
</code></pre> 
<h2><strong>删库，我害怕删库吗</strong></h2> 
<p>&nbsp;</p> 
<p><img alt="" height="385" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAyMC8wNC8xMS8yMDIwMDQxMTU4OTQzMF9Ca3RuZUQuZ2lm" width="385"></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>大规模集群全网数据备份解决方案</title><link>http://www.cnblogs.com/heian99/archive/2020/07/25/14124802.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 25 Jul 2020 09:59:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/07/25/14124802.html</guid><description><![CDATA[
                    <p>&nbsp; &nbsp; &nbsp; 数据备份是<a href="https://baike.baidu.com/item/%E5%AE%B9%E7%81%BE/6515934">容灾</a>的基础，是指为防止系统出现操作失误或系统故障导致数据丢失，而将全部或部分数据集合从应用主机的硬盘或阵列复制到其它的存储介质的过程。传统的数据备份主要是采用内置或外置的<a href="https://baike.baidu.com/item/%E7%A3%81%E5%B8%A6%E6%9C%BA/3991487">磁带机</a>进行<a href="https://baike.baidu.com/item/%E5%86%B7%E5%A4%87%E4%BB%BD">冷备份</a>。但是这种方式只能防止操作失误等人为故障，而且其恢复时间也很长。随着技术的不断发展，数据的海量增加，不少的企业开始采用<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%A4%87%E4%BB%BD/10847964">网络备份</a>。<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%A4%87%E4%BB%BD/10847964">网络备份</a>一般通过专业的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/9827490">数据存储</a><a href="https://baike.baidu.com/item/%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/810791">管理软件</a>结合相应的硬件和存储设备来实现。</p> 
<p><span style="color:#f33b45;"><strong>实现基础架构图</strong></span></p> 
<p><img alt="" height="559" src="https://img-blog.csdnimg.cn/20200725144809552.png" width="906"></p> 
<h2>1、基本备份要求</h2> 
<p>已知3台服务器主机名分别为web01，backup、nfs01，主机信息见下表：</p> 
<p><img alt="" height="170" src="https://img-blog.csdnimg.cn/20200725143647266.png" width="596"></p> 
<p><strong><span style="color:#f33b45;">要求</span>：</strong></p> 
<p><strong>每天晚上00点整在Web服务器上打包备份系统配置文件、网站程序目录及访问日志，</strong></p> 
<p><strong>通过rsync命令推送备份服务器backup上备份保留</strong></p> 
<p><strong>（备份思路可以是先在本地按日期打包，然后再推到备份服务器backup上）</strong></p> 
<p><span style="color:#f33b45;"><strong>具体要求如下：</strong></span></p> 
<blockquote> 
 <p>&nbsp;1）Web服务器和备份服务器的备份目录必须都为/backup<br> 2）要备份的系统配置文件包括但不限于：</p> 
 <p>a.定时任务服务的配置文件（var/spool/cron/root）。.<br> b.开机自启动的配置文件（/etc/rc.local）<br> c.日常脚本的目录（/server/scripts）<br> d.防火墙iptables的配置文件（/etc/sysconfig/iptables）。.<br> e.自己思考下还有什么需要备份呢？</p> 
 <p>3）Web服务器站点目录假定为（var/htm/www）.<br> 4）Web服务器A访问日志路径假定为（/app/logs）.<br> 5）Web服务器保留打包后的7天的备份数据即可（本地留存不能多于7天，因为太多硬盘会满）</p> 
 <p>6）备份服务器上，保留最近7天的备份数据，同时保留6个月内每周一的所有数据副本。<br> 7）备份服务器上要按照备份数据服务器的内网IP为目录保存备份，备份的文件按照时间名字保存。<br> 8）需要确保备份的数据尽量完整性，在备份服务器上对备份的数据进行检查，把备份的成功及失败结果信息发给系统管理员邮箱中</p> 
</blockquote> 
<p><img alt="" height="559" src="https://img-blog.csdnimg.cn/20200725144805899.png" width="906"></p> 
<p>&nbsp;</p> 
<p><strong>数据备份项目实战：</strong></p> 
<p><strong>解题思路</strong></p> 
<blockquote> 
 <p><strong><span style="color:#f33b45;">1、搭建backup服务器</span></strong></p> 
 <p>a、resync服务器</p> 
</blockquote> 
<blockquote> 
 <p><strong><span style="color:#f33b45;">2、搭建web01服务器</span></strong></p> 
 <p>a、验证rsync服务器能否推送成功</p> 
 <p>b、开发脚本实现打包，备份，推送，校检，删除</p> 
 <p>c、配置定时任务每天0点定时推送</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#f33b45;"><strong>3、backup服务器</strong></span></p> 
 <p>a、开发脚本实现校检，删除、报警</p> 
 <p>b、配置定时任务每天6点定时执行</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#f33b45;"><strong>4、同理搭建存储nfs01服务器</strong></span></p> 
</blockquote> 
<h2>2、项目实施</h2> 
<p>&nbsp;</p> 
<h3>配置所有hosts服务器</h3> 
<pre><code class="language-bash">cat &gt;&gt; /etc/hosts &lt;&lt;EOF
192.168.116.129 web
192.168.116.130 backup
192.168.116.131 nfs
EOF</code></pre> 
<h3>backup服务器安装rsync</h3> 
<pre><code> yum install -y rsync
</code></pre> 
<pre><code class="language-bash">[root@backup ~]# useradd -s /sbin/nologin -M rsync
[root@backup ~]# id rsync
uid=1001(rsync) gid=1001(rsync) 组=1001(rsync)

[root@backup ~]# vim /etc/rsyncd.conf 
port=873
uid = rsync
gid = rsync
use chroot = no
max connections = 200
timeout = 300
motd file = /var/rsyncd/rsync.motd
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
log file = /var/log/rsyncd.log
dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2
[backup]
path = /backup/
ignore errorsread only = false
write only = false
list = falsehosts allow = 192.168.116.0/24
hosts deny = 0.0.0.0/32
auth users = rsync_backup
secrets file = /etc/rsyncd.passwd</code></pre> 
<pre><code class="language-bash">######### 全局配置参数 ##########
port=888    # 指定rsync端口。默认873
uid = rsync # rsync服务的运行用户，默认是nobody，文件传输成功后属主将是这个uid
gid = rsync # rsync服务的运行组，默认是nobody，文件传输成功后属组将是这个gid
use chroot = no # rsync daemon在传输前是否切换到指定的path目录下，并将其监禁在内
max connections = 200 # 指定最大连接数量，0表示没有限制
timeout = 300         # 确保rsync服务器不会永远等待一个崩溃的客户端，0表示永远等待
motd file = /var/rsyncd/rsync.motd   # 客户端连接过来显示的消息
pid file = /var/run/rsyncd.pid       # 指定rsync daemon的pid文件
lock file = /var/run/rsync.lock      # 指定锁文件
log file = /var/log/rsyncd.log       # 指定rsync的日志文件，而不把日志发送给syslog
dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2  # 指定哪些文件不用进行压缩传输
 
###########下面指定模块，并设定模块配置参数，可以创建多个模块###########
[longshuai]        # 模块ID
path = /longshuai/ # 指定该模块的路径，该参数必须指定。启动rsync服务前该目录必须存在。rsync请求访问模块本质就是访问该路径。
ignore errors      # 忽略某些IO错误信息
read only = false  # 指定该模块是否可读写，即能否上传文件，false表示可读写，true表示可读不可写。所有模块默认不可上传
write only = false # 指定该模式是否支持下载，设置为true表示客户端不能下载。所有模块默认可下载
list = false       # 客户端请求显示模块列表时，该模块是否显示出来，设置为false则该模块为隐藏模块。默认true
hosts allow = 10.0.0.0/24 # 指定允许连接到该模块的机器，多个ip用空格隔开或者设置区间
hosts deny = 0.0.0.0/32   # 指定不允许连接到该模块的机器
auth users = rsync_backup # 指定连接到该模块的用户列表，只有列表里的用户才能连接到模块，用户名和对应密码保存在secrts file中，
                          # 这里使用的不是系统用户，而是虚拟用户。不设置时，默认所有用户都能连接，但使用的是匿名连接
secrets file = /etc/rsyncd.passwd # 保存auth users用户列表的用户名和密码，每行包含一个username:passwd。由于"strict modes"
                                  # 默认为true，所以此文件要求非rsync daemon用户不可读写。只有启用了auth users该选项才有效。
[xiaofang]    # 以下定义的是第二个模块
path=/xiaofang/
read only = false
ignore errors
comment = anyone can access</code></pre> 
<p>授权</p> 
<pre><code class="language-bash">[root@backup ~]# mkdir -p /backup
[root@backup ~]# chown -R rsync.rsync /backup/
[root@backup ~]# ls -ld /backup/
drwxr-xr-x 2 rsync rsync 6 6月  17 10:39 /backup/
</code></pre> 
<p>配置密码</p> 
<pre><code class="language-bash">​
[root@backup ~]# touch /etc/rsyncd.passwd
[root@backup ~]# echo "rsync_backup:root" &gt; /etc/rsyncd.passwd
[root@backup ~]# chmod 600 /etc/rsyncd.passwd
[root@backup ~]# ls -ld /etc/rsyncd.passwd
-rw------- 1 root root 18 6月  17 10:42 /etc/rsyncd.passwd

​</code></pre> 
<p>重启看是否成功</p> 
<pre><code class="language-bash">[root@backup ~]# rsync --daemon
[root@backup ~]# ss -lntup | grep rsync
tcp    LISTEN     0      5         *:873                   *:*                   users:(("rsync",pid=2280,fd=4))
tcp    LISTEN     0      5        :::873                  :::*                   users:(("rsync",pid=2280,fd=5))
</code></pre> 
<p>开机自启动</p> 
<pre><code class="language-bash">[root@backup ~]# which rsync
/usr/bin/rsync
[root@backup ~]# echo "/usr/bin/rsync --daemon" &gt;&gt; /etc/rc.local 
[root@backup ~]# tail -1 /etc/rc.local
/usr/bin/rsync --daemon
</code></pre> 
<h3>web服务器测试</h3> 
<p><span style="color:#f33b45;"><strong>rsync服务器接收客户端的请求</strong></span></p> 
<p><strong>下面测试，显示成功</strong></p> 
<pre><code class="language-bash">[root@web backup]# echo "root" &gt;&gt; /etc/rsync.password
[root@web backup]# chmod 600 /etc/rsync.password
[root@web backup]# rsync -avz /backup/ rsync://rsync_backup@192.168.116.130/backup --password-file=/etc/rsy
nc.password 

sending incremental file list
rsync: chgrp "." (in backup) failed: Operation not permitted (1)
./
mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz
</code></pre> 
<p>另一种传输方法&nbsp;</p> 
<pre><code class="language-bash"> rsync -avz /backup/ rsync_backup@192.168.116.130::backup --password-file=/etc/rsync.password </code></pre> 
<p>web服务器，创建模拟数据</p> 
<pre><code class="language-bash">[root@web backup]# 
[root@web backup]# mkdir /var/html/www -p
[root@web backup]# cd /var/html/www/
[root@web www]# touch {1..10}
[root@web www]# mkdir -p /app/logs
[root@web www]# touch /app/logs/{a..g}
</code></pre> 
<p>备份脚本存放目录</p> 
<pre><code class="language-bash">[root@web www]# mkdir -p /server/scripts

vim  /server/scripts/bak.sh
#!/bin/sh
export PATH=/sbin:/bin:/usr/sbin:/usr/bin
IP=$(ifconfig ens33|awk -F "[ :]+" 'NR==2{print $3}')
BakPath=/backup
mkdir $BakPath/$IP -p
if [ $(date +%w) -eq 2 ];then
 date="$(date +%F -d "-1day")_week1"
else
 date="$(date +%F -d "-1day")"
fi

cd / &amp;&amp;\
tar zcfh $BakPath/$IP/sys_config_${date}.tar.gz var/spool/cron etc/rc.local server/scripts &amp;&amp;\
tar zcfh $BakPath/$IP/webdata_${date}.tar.gz var/html/www/ &amp;&amp;\
tar zcf $BakPath/$IP/access_log_${date}.tar.gz app/logs &amp;&amp;\
find $BakPath -type f -name "*.tar.gz"|xargs md5sum &gt;$BakPath/$IP/flag_${date}
###bak data 
rsync -az $BakPath/ rsync_backup@192.168.116.130::backup --password-file=/etc/rsync.password 
###del data 7 days ago.
find $BakPath -type f  -mtime +7|xargs rm -f

</code></pre> 
<p><img alt="" height="268" src="https://img-blog.csdnimg.cn/20200725164710720.png" width="804"></p> 
<p>&nbsp;</p> 
<p>数据校检MD5sum</p> 
<p><img alt="" height="161" src="https://img-blog.csdnimg.cn/20200725162532994.png" width="807"></p> 
<p>定时任务</p> 
<pre><code>#backup
 00 00 * * * /bin/sh /server/scripts/bak.sh &gt;/dev/null 2&gt;&amp;1
</code></pre> 
<p>&nbsp;</p> 
<h3>Backup服务器校检，删除，报警</h3> 
<p>backup备份推送类容</p> 
<h3><img alt="" height="205" src="https://img-blog.csdnimg.cn/20200725165728648.png" width="441"></h3> 
<p><strong>邮件</strong></p> 
<pre><code class="language-bash">yum install mailx -y

vim /etc/mail.rc

#设置发件人名称
set from=32915245@qq.com
#设置邮件服务器
set smtp=smtp.qq.com
#填写自己邮箱地址
set smtp-auth-user=3291245@qq.com
#输入邮箱验证码
set smtp-auth-password=wrgcmeapjw
#smtp的认证方式，默认是login
set smtp-auth=login
</code></pre> 
<p><img alt="" height="360" src="https://img-blog.csdnimg.cn/20200725170404618.png" width="582"></p> 
<p><strong>测试【已经完成】</strong></p> 
<pre><code class="language-bash"> echo "admin ,文件内容" | mail -s "标题" 你的qq@qq.com
</code></pre> 
<p><img alt="" height="447" src="https://img-blog.csdnimg.cn/20200725170658944.png" width="813"></p> 
<p>&nbsp;</p> 
<p><strong>检验文件</strong></p> 
<pre><code class="language-bash">vim /server/scripts/checkbak.sh

#!/bin/sh
export LANG=en
find /backup/ -name "flag_$(date +%F -d "-1day")*"|xargs md5sum -c &amp;&gt;&gt;/tmp/mail_$(date +%F).log
if [ $(date +%w) -eq 2 ];then
 date="$(date +%F -d "-1day")_week1"
else
 date="$(date +%F -d "-1day")"
fi

find /backup/ -type f -name "*.tar.gz" -a ! -name "*week1*" -mtime +1|xargs rm -f
mail -s "backup `date`" 1794748404@qq.com &lt;/tmp/mail_$(date +%F).log
\cp /tmp/mail_$(date +%F).log /tmp/mail_$(date +%F).log.ori
&gt;/tmp/mail_$(date +%F).log
</code></pre> 
<p>定时任务</p> 
<pre><code class="language-bash">#backup
 00 06 * * * /bin/sh /server/scripts/checkbak.sh &gt;/dev/null 2&gt;&amp;1
</code></pre> 
<p>正确</p> 
<p><img alt="" height="347" src="https://img-blog.csdnimg.cn/20200725173944833.png" width="638"></p> 
<p>错误</p> 
<p><img alt="" height="175" src="https://img-blog.csdnimg.cn/20200725174730684.png" width="587"></p> 
<p>然后可以把脚本使用ansible批量发布各个主机，然后就可以大规模集群备份</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>宝塔Nginx配置防盗链</title><link>http://www.cnblogs.com/heian99/archive/2020/07/13/14124803.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 13 Jul 2020 02:34:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/07/13/14124803.html</guid><description><![CDATA[
                    <h1>Nginx配置防盗链</h1> 
<h2><strong>1.什么是资源盗链</strong></h2> 
<p>简单地说，就是某些不法网站未经许可，通过在其自身网站程序里非法调用其他网站的资源，然后在自己的网站上显示这些调用的资源，达到填充自身网站的效果。这一举动不仅浪费了调用资源网站的网络流量，还造成其他网站的带宽及服务压力吃紧，甚至宕机。</p> 
<p><img alt="" height="727" src="https://img-blog.csdnimg.cn/20200712001931869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h2><strong>&nbsp;2.网站资源被盗链带来的问题</strong></h2> 
<p>若网站图片及相关资源被盗链，最直接的影响就是网络带宽占用加大了，带宽费用多了，网络流量也可能忽高忽低，Nagios/Zabbix等报警服务频繁报警</p> 
<p><img alt="" height="702" src="https://img-blog.csdnimg.cn/20200712002043920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>最严重的情况就是网站的资源被非法使用，使网站带宽成本加大和服务器压力加大，这有可能导致数万元的损失，且网站的正常用户访问也会受到影响</p> 
<h2>3.企业真实案例：网站资源被盗链，出现严重问题</h2> 
<p>某日，接到从事运维工作的朋友的紧急求助，其公司的CDN源站，源站的流量没有变动，但CDN加速那边的流量无故超了好几个GB，不知道怎么处理。</p> 
<p>该故障的影响：由于是购买的CDN网站加速服务，因此虽然流量多了几个GB，但是业务未受影响。只是，这么大的异常流量，持续下去可直接导致公司无故损失数万元。解决这个问题可体现运维的价值。</p> 
<h2>4.常见防盗链解决方案的基本原理</h2> 
<h3>（1）根据HTTP referer实现防盗链</h3> 
<p>在HTTP协议中，有一个表头字段叫referer，使用URL格式来表示是哪里的链接用了当前网页的资源。通过referer可以检测访问的来源网页，如果是资源文件，可以跟踪到显示它的网页地址，一旦检测出来源不是本站，马上进行阻止或返回指定的页面。</p> 
<p>HTTP referer是header的一部分，当浏览器向Web服务器发送请求时，一般会带上referer，告诉服务器我是从哪个页面链接过来的，服务器借此获得一些信息用于处理。Apache、Nginx、Lighttpd三者都支持根据HTTP referer实现防盗链，referer是目前网站图片、附件、html等最常用的防盗链手段</p> 
<p><img alt="" height="920" src="https://img-blog.csdnimg.cn/20200712002247128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<h3>（2）根据cookie防盗链</h3> 
<p>对于一些特殊的业务数据，例如流媒体应用通过ActiveX显示的内容（例如，Flash、Windows Media视频、流媒体的RTSP协议等），因为它们不向服务器提供referer header，所以若采用上述的referer的防盗链手段，就达不到想要的效果。</p> 
<p>对于Flash、Windows Media视频这种占用流量较大的业务数据，防盗链是比较困难的，此时可以采用Cookie技术，解决Flash、Windows Media视频等的防盗链问题。</p> 
<p>例如：ActiveX插件不传递referer，但会传递Cookie，可以在显示ActiveX的页面的&lt;head&gt;&lt;/head&gt;标签内嵌入一段JavaScript代码，设置“Cookie：Cache=av”如下：</p> 
<pre><code class="language-javascript">&lt;script&gt; document.cookie="Cache=av；

domain=domain.com；

path=/"；

 &lt;/script&gt;</code></pre> 
<p>然后就可以通过各种手段来判断这个Cookie的存在，以及验证其值的操作了。</p> 
<p>根据Cookie来防盗链的技术非本书的内容，读者了解即可，如果企业确实有需要，可以阅读其他书籍或进入交流群获取这部分的知识。</p> 
<h2>（3）通过加密变换访问路径实现防盗链</h2> 
<p>此种方法比较适合视频及下载类业务数据的网站。例如：Lighttpd有类似的插件mod_secdownload来实现此功能。先在服务器端配置此模块，设置一个固定用于加密的字符串，比如oldboy，然后设置一个url前缀，比如/mp4/，再设置一个过期时间，比如1小时，然后写一段PHP代码，利用加密字符串和系统时间等通过md5算法生成一个加密字符串。最终获取到的文件的URL链接中会带有一个时间戳和一个加密字符的md5数值，在访问时系统会对这两个数据进行验证。如果时间不在预期的时间段内（如1小时内）则失效；如果时间戳符合条件，但是加密的字符串不符合条件也会失效，从而达到防盗链的效果。</p> 
<pre><code class="language-php">&lt;php
$secret = "oldboy"；
     // 加密字符串，必须和
lighttpd.conf里的保持一致
$uri_prefix = "/mp4/"；
     // 虚拟的路径、前缀，必须和
lighttpd.conf里的保持一致
$file = "/test.mp4"；
     // 实际文件名，必须加
"/"斜杠
$timestamp = time（）；
     // current timestamp
$t_hex = sprintf（
"%08x"，
 $timestamp）；
$m = md5（
$secret.$file.$t_hex）；
printf（
'%s'，
 $uri_prefix，
 $m，
 $t_hex，
 $file，
 $file）；
     //生成
url地址串
&gt;</code></pre> 
<h2>Nginx Web服务实现防盗链实战</h2> 
<p>在默认情况下，只需要进行简单的配置，即可实现防盗链处理</p> 
<p>利用referer，并且针对扩展名rewrite重定向</p> 
<p>第一步</p> 
<p><img alt="" height="494" src="https://img-blog.csdnimg.cn/20200713102729988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p> 
<p>第二步</p> 
<p><img alt="" height="693" src="https://img-blog.csdnimg.cn/20200713102916129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="689"></p> 
<p>第三步</p> 
<p><img alt="" height="589" src="https://img-blog.csdnimg.cn/20200713103058257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="680"></p> 
<p>相关配置</p> 
<pre><code class="language-bash">配置前


    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
    {
        expires      30d;
        error_log off;
        access_log /dev/null;
    }



配置后


	location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
{
 valid_referers *.heian99.top heian99.top;
 if ($invalid_referer) {
  rewrite ^/ https://ftp.bmp.ovh/imgs/2020/06/75d45131a596abbd.jpg;
  #return 404;
 }
 expires  30d;
}


</code></pre> 
<p>效果图</p> 
<p>打开这个图片，放到别的浏览器查看</p> 
<p><img alt="" height="199" src="https://img-blog.csdnimg.cn/20200713103143191.png" width="1115"></p> 
<p>就会变成下面这个图片了</p> 
<p><img alt="" height="939" src="https://img-blog.csdnimg.cn/20200713103259330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1117"></p>
                ]]></description></item><item><title>MHA架构实施（一主一从）学不会，你来打我？加油！奥利给</title><link>http://www.cnblogs.com/heian99/archive/2020/06/24/13203453.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 24 Jun 2020 03:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/06/24/13203453.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="1%E3%80%81%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82" rel="nofollow">1、环境要求</a></p>

<p id="2%E3%80%81%E6%9E%B6%E6%9E%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E6%9E%B6%E6%9E%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">2、架构工作原理</a></p>

<p id="2.1%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%3A-toc" style="margin-left:40px;"><a href="#2.1%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%3A" rel="nofollow">2.1架构介绍:</a></p>

<p id="2.2%20MHA%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%88%90-toc" style="margin-left:40px;"><a href="#2.2%20MHA%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%88%90" rel="nofollow">2.2 MHA软件构成</a></p>

<p id="3%E3%80%81Mysql%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-toc" style="margin-left:0px;"><a href="#3%E3%80%81Mysql%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" rel="nofollow">3、Mysql环境搭建</a></p>

<p id="3.1%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%EF%BC%88%E4%B8%BB%E4%BB%8E%E9%83%BD%E9%9C%80%E8%A6%81%E4%B8%8B%E9%9D%A2%E6%AD%A5%E9%AA%A4%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.1%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%EF%BC%88%E4%B8%BB%E4%BB%8E%E9%83%BD%E9%9C%80%E8%A6%81%E4%B8%8B%E9%9D%A2%E6%AD%A5%E9%AA%A4%EF%BC%89" rel="nofollow">3.1环境准备（主从都需要下面步骤）</a></p>

<p id="3.2%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%A4%84%E7%90%86%E5%8E%9F%E5%A7%8B%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#3.2%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%A4%84%E7%90%86%E5%8E%9F%E5%A7%8B%E7%8E%AF%E5%A2%83" rel="nofollow">3.2用户的创建处理原始环境</a></p>

<p id="3.3%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-toc" style="margin-left:40px;"><a href="#3.3%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95" rel="nofollow">3.3解压文件，更改文件目录</a></p>

<p id="3.4%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#3.4%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" rel="nofollow">3.4设置环境变量</a></p>

<p id="3.5%E7%8E%AF%E5%A2%83%E7%9B%AE%E5%BD%95%E8%A7%84%E5%88%92-toc" style="margin-left:40px;"><a href="#3.5%E7%8E%AF%E5%A2%83%E7%9B%AE%E5%BD%95%E8%A7%84%E5%88%92" rel="nofollow">3.5环境目录规划</a></p>

<p id="3.6my.cnf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#3.6my.cnf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">3.6my.cnf配置文件</a></p>

<p id="3.7mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#3.7mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">3.7mysql数据库初始化</a></p>

<p id="3.8%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%932%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#3.8%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%932%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">3.8启动数据库2种方式</a></p>

<p id="1.%20sys-v-toc" style="margin-left:80px;"><a href="#1.%20sys-v" rel="nofollow">1. sys-v</a></p>

<p id="2.%20systemd-toc" style="margin-left:80px;"><a href="#2.%20systemd" rel="nofollow">2. systemd</a></p>

<p id="3.9%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%86%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.9%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%86%E7%A0%81" rel="nofollow">3.9修改数据库的密码</a></p>

<p id="4%E3%80%81mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#4%E3%80%81mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE" rel="nofollow">4、mysql主从配置</a></p>

<p id="1%E3%80%81%E4%B8%BB%E5%BA%93%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%88db01%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%B8%BB%E5%BA%93%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%88db01%EF%BC%89" rel="nofollow">1、主库创建用户（db01）</a></p>

<p id="2%E3%80%81%E4%BB%8E%E5%BA%93%E5%BC%80%E5%90%AF%E8%BF%9E%E6%8E%A5%EF%BC%88db02%EF%BC%89-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%BB%8E%E5%BA%93%E5%BC%80%E5%90%AF%E8%BF%9E%E6%8E%A5%EF%BC%88db02%EF%BC%89" rel="nofollow">2、从库开启连接（db02）</a></p>

<p id="5%E3%80%81MHA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-toc" style="margin-left:0px;"><a href="#5%E3%80%81MHA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" rel="nofollow">5、MHA环境搭建</a></p>

<p id="5.1%E9%85%8D%E7%BD%AE%E5%85%B3%E9%94%AE%E7%A8%8B%E5%BA%8F%E8%BD%AF%E8%BF%9E%E6%8E%A5-toc" style="margin-left:40px;"><a href="#5.1%E9%85%8D%E7%BD%AE%E5%85%B3%E9%94%AE%E7%A8%8B%E5%BA%8F%E8%BD%AF%E8%BF%9E%E6%8E%A5" rel="nofollow">5.1配置关键程序软连接</a></p>

<p id="5.2%E9%85%8D%E7%BD%AE%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E4%BA%92%E4%BF%A1-toc" style="margin-left:40px;"><a href="#5.2%E9%85%8D%E7%BD%AE%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E4%BA%92%E4%BF%A1" rel="nofollow">5.2配置各个节点互信</a></p>

<p id="5.3%E5%AE%89%E8%A3%85MHA%E8%BD%AF%E4%BB%B6-toc" style="margin-left:40px;"><a href="#5.3%E5%AE%89%E8%A3%85MHA%E8%BD%AF%E4%BB%B6" rel="nofollow">5.3安装MHA软件</a></p>

<p id="1%E3%80%81%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85Node%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8C%85-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85Node%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8C%85" rel="nofollow">1、所有节点安装Node软件依赖包</a></p>

<p id="2%E3%80%81%E5%9C%A8db01%E4%B8%BB%E5%BA%93%E4%B8%AD%E5%88%9B%E5%BB%BAmha%E9%9C%80%E8%A6%81%E7%9A%84%E7%94%A8%E6%88%B7-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%9C%A8db01%E4%B8%BB%E5%BA%93%E4%B8%AD%E5%88%9B%E5%BB%BAmha%E9%9C%80%E8%A6%81%E7%9A%84%E7%94%A8%E6%88%B7" rel="nofollow">2、在db01主库中创建mha需要的用户</a></p>

<p id="3%E3%80%81Manager%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%88db02%EF%BC%89-toc" style="margin-left:80px;"><a href="#3%E3%80%81Manager%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%88db02%EF%BC%89" rel="nofollow">3、Manager软件安装（db02）</a></p>

<p id="5.4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%87%86%E5%A4%87%EF%BC%88db02%EF%BC%89-toc" style="margin-left:40px;"><a href="#5.4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%87%86%E5%A4%87%EF%BC%88db02%EF%BC%89" rel="nofollow">5.4配置文件准备（db02）</a></p>

<p id="5.5%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5-toc" style="margin-left:40px;"><a href="#5.5%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5" rel="nofollow">5.5状态检查</a></p>

<p id="%E4%BA%92%E4%BF%A1%E6%A3%80%E6%9F%A5-toc" style="margin-left:80px;"><a href="#%E4%BA%92%E4%BF%A1%E6%A3%80%E6%9F%A5" rel="nofollow">互信检查</a></p>

<p id="%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5-toc" style="margin-left:80px;"><a href="#%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5" rel="nofollow">主从状态检查</a></p>

<p id="5.6%E5%BC%80%E5%90%AFHMA%EF%BC%88db02%EF%BC%89-toc" style="margin-left:40px;"><a href="#5.6%E5%BC%80%E5%90%AFHMA%EF%BC%88db02%EF%BC%89" rel="nofollow">5.6开启HMA（db02）</a></p>

<p id="%E5%BC%80%E5%90%AF-toc" style="margin-left:80px;"><a href="#%E5%BC%80%E5%90%AF" rel="nofollow">开启</a></p>

<p id="%E6%A3%80%E6%B5%8BMHA%E7%8A%B6%E6%80%81-toc" style="margin-left:80px;"><a href="#%E6%A3%80%E6%B5%8BMHA%E7%8A%B6%E6%80%81" rel="nofollow">检测MHA状态</a></p>

<p id="6%E3%80%81MHA%20%E7%9A%84vip%E5%8A%9F%E8%83%BD-toc" style="margin-left:0px;"><a href="#6%E3%80%81MHA%20%E7%9A%84vip%E5%8A%9F%E8%83%BD" rel="nofollow">6、MHA 的vip功能</a></p>

<p id="%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%8F%82%E6%95%B0" rel="nofollow">参数</a></p>

<p id="%E4%BF%AE%E6%94%B9%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#%E4%BF%AE%E6%94%B9%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9" rel="nofollow">修改脚本内容</a></p>

<p id="%E6%9B%B4%E6%94%B9manager%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%9B%B4%E6%94%B9manager%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A" rel="nofollow">更改manager配置文件：</a></p>

<p id="%E4%B8%BB%E5%BA%93%E4%B8%8A%EF%BC%8C%E6%89%8B%E5%B7%A5%E7%94%9F%E6%88%90%E7%AC%AC%E4%B8%80%E4%B8%AAvip%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#%E4%B8%BB%E5%BA%93%E4%B8%8A%EF%BC%8C%E6%89%8B%E5%B7%A5%E7%94%9F%E6%88%90%E7%AC%AC%E4%B8%80%E4%B8%AAvip%E5%9C%B0%E5%9D%80" rel="nofollow">主库上，手工生成第一个vip地址</a></p>

<p id="%E9%87%8D%E5%90%AFmha-toc" style="margin-left:40px;"><a href="#%E9%87%8D%E5%90%AFmha" rel="nofollow">重启mha</a></p>

<p id="7%E3%80%81%C2%A0binlog%20server%EF%BC%88db02%EF%BC%89-toc" style="margin-left:0px;"><a href="#7%E3%80%81%C2%A0binlog%20server%EF%BC%88db02%EF%BC%89" rel="nofollow">7、&nbsp;binlog server（db02）</a></p>

<p id="%E5%8F%82%E6%95%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%8F%82%E6%95%B0%EF%BC%9A" rel="nofollow">参数：</a></p>

<p id="%E5%88%9B%E5%BB%BA%E5%BF%85%E8%A6%81%E7%9B%AE%E5%BD%95-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%E5%BF%85%E8%A6%81%E7%9B%AE%E5%BD%95" rel="nofollow">创建必要目录</a></p>

<p id="%E6%8B%89%E5%8F%96%E4%B8%BB%E5%BA%93binlog%E6%97%A5%E5%BF%97-toc" style="margin-left:40px;"><a href="#%E6%8B%89%E5%8F%96%E4%B8%BB%E5%BA%93binlog%E6%97%A5%E5%BF%97" rel="nofollow">拉取主库binlog日志</a></p>

<p id="%E9%87%8D%E5%90%AFMHA-toc" style="margin-left:40px;"><a href="#%E9%87%8D%E5%90%AFMHA" rel="nofollow">重启MHA</a></p>

<p id="8%E3%80%81%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92-toc" style="margin-left:0px;"><a href="#8%E3%80%81%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92" rel="nofollow">8、邮件提醒</a></p>

<p id="1.%20%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.%20%E5%8F%82%E6%95%B0" rel="nofollow">1. 参数</a></p>

<p id="2.%20%E5%87%86%E5%A4%87%E9%82%AE%E4%BB%B6%E8%84%9A%E6%9C%AC-toc" style="margin-left:40px;"><a href="#2.%20%E5%87%86%E5%A4%87%E9%82%AE%E4%BB%B6%E8%84%9A%E6%9C%AC" rel="nofollow">2. 准备邮件脚本</a></p>

<p id="3.%20%E4%BF%AE%E6%94%B9manager%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E8%B0%83%E7%94%A8%E9%82%AE%E4%BB%B6%E8%84%9A%E6%9C%AC-toc" style="margin-left:40px;"><a href="#3.%20%E4%BF%AE%E6%94%B9manager%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E8%B0%83%E7%94%A8%E9%82%AE%E4%BB%B6%E8%84%9A%E6%9C%AC" rel="nofollow">3. 修改manager配置文件，调用邮件脚本</a></p>

<p style="margin-left:40px;"><a href="#%E9%87%8D%E5%90%AFMHA" rel="nofollow">重启MHA</a></p>

<p id="9%E3%80%81%E6%B5%8B%E8%AF%95MHA-toc" style="margin-left:0px;"><a href="#9%E3%80%81%E6%B5%8B%E8%AF%95MHA" rel="nofollow">9、测试MHA</a></p>

<p id="%E5%85%B3%E9%97%AD%E4%B8%BB%E5%BA%93%2C%E7%9C%8B%E8%AD%A6%E5%91%8A%E9%82%AE%E4%BB%B6%20%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%85%B3%E9%97%AD%E4%B8%BB%E5%BA%93%2C%E7%9C%8B%E8%AD%A6%E5%91%8A%E9%82%AE%E4%BB%B6%20%C2%A0" rel="nofollow">关闭主库,看警告邮件 &nbsp;</a></p>

<hr id="hr-toc"><h1 id="1%E3%80%81%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82"><strong><strong><strong>1、环境要求</strong></strong></strong></h1>

<p>&nbsp;</p>

<p>MHA实施文档：&nbsp;<a href="https://download.csdn.net/download/heian_99/12548469">https://download.csdn.net/download/heian_99/12548469</a></p>

<p><img alt="" height="132" src="https://img-blog.csdnimg.cn/20200624114048584.png" width="124"></p>

<p>MHA实施软件集合：&nbsp;<a href="https://download.csdn.net/download/heian_99/12548494">https://download.csdn.net/download/heian_99/12548494</a>（包含所用到的软件）</p>

<p><img alt="" height="157" src="https://img-blog.csdnimg.cn/2020062411421623.png" width="807"></p>

<p><img alt="" height="648" src="https://img-blog.csdnimg.cn/20200624114140888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="425"></p>

<p style="margin-left:0pt;"><strong><strong>系统：</strong></strong><strong><strong>CentOS Linux release 7.4.1708 (Core)</strong></strong></p>

<p style="margin-left:0pt;"><strong><strong>Myssql：5</strong></strong><strong><strong>.7.20</strong></strong></p>

<p style="margin-left:0pt;"><strong><strong>MHA：</strong></strong><strong><strong>mha4mysql-manager-0.56-0.el6.noarch</strong></strong></p>

<p style="margin-left:0pt;"><strong><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mha4mysql-node-0.56-0.el6.noarch</strong></strong></p>

<p style="margin-left:0pt;">&nbsp;</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:138.25pt;">
			<p style="margin-left:0pt;"><strong><strong>主机</strong></strong></p>
			</td>
			<td style="vertical-align:top;width:138.25pt;">
			<p style="margin-left:0pt;"><strong><strong>IP</strong></strong></p>
			</td>
			<td style="vertical-align:top;width:138.3pt;">
			<p style="margin-left:0pt;"><strong><strong>端口</strong></strong></p>
			</td>
		</tr><tr><td style="vertical-align:top;width:138.25pt;">
			<p style="margin-left:0pt;"><strong><strong>主库（db</strong></strong><strong><strong>01</strong></strong><strong><strong>）</strong></strong></p>
			</td>
			<td style="vertical-align:top;width:138.25pt;">
			<p style="margin-left:0pt;"><strong><strong>172.17.1.145</strong></strong></p>
			</td>
			<td style="vertical-align:top;width:138.3pt;">
			<p style="margin-left:0pt;"><strong><strong>3</strong></strong><strong><strong>306</strong></strong></p>
			</td>
		</tr><tr><td style="vertical-align:top;width:138.25pt;">
			<p style="margin-left:0pt;"><strong><strong>从库（db</strong></strong><strong><strong>02</strong></strong><strong><strong>）</strong></strong></p>
			</td>
			<td style="vertical-align:top;width:138.25pt;">
			<p style="margin-left:0pt;"><strong><strong>172.17.1.146</strong></strong></p>
			</td>
			<td style="vertical-align:top;width:138.3pt;">
			<p style="margin-left:0pt;"><strong><strong>3</strong></strong><strong><strong>306</strong></strong></p>
			</td>
		</tr><tr><td style="vertical-align:top;width:138.25pt;">
			<p style="margin-left:0pt;"><strong><strong>虚拟ip（vrrp漂移）</strong></strong></p>
			</td>
			<td style="vertical-align:top;width:138.25pt;">
			<p style="margin-left:0pt;"><strong><strong>172.17.1.100</strong></strong></p>
			</td>
			<td style="vertical-align:top;width:138.3pt;">
			<p style="margin-left:0pt;">&nbsp;</p>
			</td>
		</tr></tbody></table><p><img alt="" height="344" src="https://img-blog.csdnimg.cn/2020062411072764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h1 id="2%E3%80%81%E6%9E%B6%E6%9E%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><strong><strong><strong>2、架构工作原理</strong></strong></strong></h1>

<p style="margin-left:0pt;"><strong>主库宕机处理过程</strong></p>

<p style="margin-left:0pt;"><strong>1. 监控节点 (通过配置文件获取所有节点信息)</strong></p>

<blockquote>
<p style="margin-left:0pt;">&nbsp;&nbsp;&nbsp;系统,网络,SSH连接性</p>

<p style="margin-left:0pt;">&nbsp;&nbsp;&nbsp;主从状态,重点是主库</p>
</blockquote>

<p style="margin-left:0pt;">&nbsp;</p>

<p style="margin-left:0pt;"><strong>2. 选主</strong></p>

<p style="margin-left:0pt;">(1) 如果判断从库(position或者GTID),数据有差异,最接近于Master的slave,成为备选主</p>

<p style="margin-left:0pt;">(2) 如果判断从库(position或者GTID),数据一致,按照配置文件顺序,选主.</p>

<p style="margin-left:0pt;">(3) 如果设定有权重(candidate_master=1),按照权重强制指定备选主.</p>

<blockquote>
<p style="margin-left:0pt;">&nbsp;&nbsp;&nbsp;&nbsp;1. 默认情况下如果一个slave落后master 100M的relay logs的话，即使有权重,也会失效.</p>

<p style="margin-left:0pt;">&nbsp;&nbsp;&nbsp;&nbsp;2. 如果check_repl_delay=0的化,即使落后很多日志,也强制选择其为备选主</p>
</blockquote>

<p style="margin-left:0pt;"><strong>3. 数据补偿</strong></p>

<blockquote>
<p style="margin-left:0pt;">(1) 当SSH能连接,从库对比主库GTID 或者position号,立即将二进制日志保存至各个从节点并且应用(save_binary_logs )</p>

<p style="margin-left:0pt;">(2) 当SSH不能连接, 对比从库之间的relaylog的差异(apply_diff_relay_logs)</p>
</blockquote>

<p style="margin-left:0pt;"><strong>4. Failover</strong></p>

<p style="margin-left:0pt;">将备选主进行身份切换,对外提供服务</p>

<p style="margin-left:0pt;">其余从库和新主库确认新的主从关系</p>

<p style="margin-left:0pt;"><strong>5. 应用透明(VIP)</strong></p>

<p style="margin-left:0pt;"><strong>6. 故障切换通知(send_reprt)</strong></p>

<p style="margin-left:0pt;"><strong>7. 二次数据补偿(binlog_server)</strong></p>

<h2 id="2.1%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%3A"><strong><strong><strong>2</strong></strong><strong><strong>.</strong></strong><strong><strong>1</strong></strong><strong><span style="color:#404040;"><strong>架构介绍:</strong></span></strong></strong></h2>

<blockquote>
<p style="margin-left:0pt;">1主1从，master：db01 &nbsp;&nbsp;slave：db02 ）：</p>

<p style="margin-left:0pt;">MHA 高可用方案软件构成</p>

<p style="margin-left:0pt;">Manager软件：选择一个从节点安装</p>

<p style="margin-left:0pt;">Node软件：所有节点都要安装</p>
</blockquote>

<h2 id="2.2%20MHA%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%88%90"><strong><strong><strong>2</strong></strong><strong><strong>.2 MHA软件构成</strong></strong></strong></h2>

<p style="margin-left:0pt;"><strong>anager工具包主要包括以下几个工具：</strong></p>

<blockquote>
<p style="margin-left:0pt;">masterha_manger &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动MHA</p>

<p style="margin-left:0pt;">masterha_check_ssh &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查MHA的SSH配置状况</p>

<p style="margin-left:0pt;">masterha_check_repl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查MySQL复制状况</p>

<p style="margin-left:0pt;">masterha_master_monitor &nbsp;&nbsp;&nbsp;&nbsp;检测master是否宕机</p>

<p style="margin-left:0pt;">masterha_check_status &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检测当前MHA运行状态</p>

<p style="margin-left:0pt;">masterha_master_switch &nbsp;控制故障转移（自动或者手动）</p>

<p style="margin-left:0pt;">masterha_conf_host &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加或删除配置的server信息</p>
</blockquote>

<p style="margin-left:0pt;">&nbsp;</p>

<p style="margin-left:0pt;"><strong>Node工具包主要包括以下几个工具：</strong></p>

<p style="margin-left:0pt;"><strong>这些工具通常由MHA Manager的脚本触发，无需人为操作</strong></p>

<blockquote>
<p style="margin-left:0pt;">save_binary_logs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保存和复制master的二进制日志</p>

<p style="margin-left:0pt;">apply_diff_relay_logs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;识别差异的中继日志事件并将其差异的事件应用于其他的</p>

<p style="margin-left:0pt;">purge_relay_logs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清除中继日志（不会阻塞SQL线程）</p>
</blockquote>

<h1 id="3%E3%80%81Mysql%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><strong><strong><strong>3、</strong></strong><strong><span style="color:#404040;"><strong>Mysql</strong></span></strong><strong><span style="color:#404040;"><strong>环境搭建</strong></span></strong></strong></h1>

<p>&nbsp;</p>

<h2 id="3.1%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%EF%BC%88%E4%B8%BB%E4%BB%8E%E9%83%BD%E9%9C%80%E8%A6%81%E4%B8%8B%E9%9D%A2%E6%AD%A5%E9%AA%A4%EF%BC%89"><strong><strong><strong>3</strong></strong><strong><strong>.</strong></strong><strong><strong>1环境准备（主从都需要下面步骤）</strong></strong></strong></h2>

<p style="margin-left:0pt;">创建目录，上传所需要的文件（主从都需要上传）</p>

<pre><code class="language-bash">[root@db01 ~]# mkdir -p /tools/mysql
[root@db01 ~]# cd  /tools/mysql
[root@db01 mysql]# scp * root@172.17.1.146:/tools/mysql/</code></pre>

<p><img alt="" height="117" src="https://img-blog.csdnimg.cn/20200624111039951.png" width="554"></p>

<h2 id="3.2%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%A4%84%E7%90%86%E5%8E%9F%E5%A7%8B%E7%8E%AF%E5%A2%83"><strong><strong><strong>3</strong></strong><strong><strong>.2用户的创建处理原始环境</strong></strong></strong></h2>

<pre><code class="language-bash">[root@db01 ~]# rpm -qa |grep mariadb
[root@db01 ~]# yum remove mariadb-libs-5.5.56-2.el7.x86_64 -y
添加mysql用户
 [root@db01 ~]# useradd -s /sbin/nologin mysql</code></pre>

<h2 id="3.3%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><strong><strong><strong>3.3</strong></strong><strong><strong>解压文件，更改文件目录</strong></strong></strong></h2>

<pre><code class="language-bash">存放mysql程序目录
[root@db01 mysql]# mkdir -p /app
解压
[root@db01 mysql]# tar xf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz 
移动
[root@db01 mysql]# mv mysql-5.7.20-linux-glibc2.12-x86_64 /app/mysql</code></pre>

<h3 id="3.4%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><strong><strong><strong>3</strong></strong><strong><strong>.4设置环境变量</strong></strong></strong></h3>

<pre><code class="language-bash">
vim /etc/profile

export PATH=/app/mysql/bin:$PATH

[root@db01 ~]# source /etc/profile

[root@db01 ~]# mysql -V

mysql &nbsp;Ver 14.14 Distrib 5.7.20, for linux-glibc2.12 (x86_64) using &nbsp;EditLine wrapper</code></pre>

<p><img alt="" height="87" src="https://img-blog.csdnimg.cn/20200624111140925.png" width="554"></p>

<h2 id="3.5%E7%8E%AF%E5%A2%83%E7%9B%AE%E5%BD%95%E8%A7%84%E5%88%92"><strong><strong><strong>3</strong></strong><strong><strong>.5</strong></strong><strong><strong>环境目录规划</strong></strong></strong></h2>

<p><img alt="" height="170" src="https://img-blog.csdnimg.cn/20200624111147115.png" width="554"></p>

<p style="margin-left:0pt;">创建文件，并授权</p>

<pre><code class="language-bash">[root@db01 mysql]# 
[root@db01 mysql]# mkdir -p /data/{mysql,binlog}
[root@db01 mysql]# mkdir -p /data/mysql/data
[root@db01 mysql]# chown -R mysql.mysql /app/mysql/*
[root@db01 mysql]# chown -R mysql.mysql /data/*</code></pre>

<p style="margin-left:0pt;">错误日志存放</p>

<pre><code class="language-bash">[root@db01 ~]# touch /var/log/mysql.log
[root@db01 ~]# chown mysql.mysql /var/log/mysql.log
[root@db01 ~]# ll /var/log/mysql.log
-rw-r--r-- 1 mysql mysql 0 6月  21 20:38 /var/log/mysql.log</code></pre>

<p style="margin-left:0pt;">Sock环境配置</p>

<pre><code class="language-bash">[root@db01 data]# touch /tmp/mysql.sock
[root@db01 data]# chown mysql.mysql /tmp/mysql.sock</code></pre>

<p style="margin-left:0pt;">慢日志（有需要可以加下面参数）</p>

<pre><code class="language-bash">开关:
slow_query_log=1 
文件位置及名字 
slow_query_log_file=/data/mysql/slow.log
设定慢查询时间:
long_query_time=0.1
没走索引的语句也记录:
log_queries_not_using_indexes</code></pre>

<h2 id="3.6my.cnf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><strong><strong><strong>3</strong></strong><strong><strong>.6</strong></strong><strong><strong>my.</strong></strong><strong><strong>cnf</strong></strong><strong><strong>配置文件</strong></strong></strong></h2>

<p style="margin-left:0pt;">主库server_id=145</p>

<p style="margin-left:0pt;">从库server_id=146</p>

<pre><code class="language-bash">[mysqld]
basedir=/data/mysql
datadir=/data/mysql/data
socket=/tmp/mysql.sock
#错误日志
log_error=/var/log/mysql.log
log_timestamps=system
#server_id
server_id=145
port=3306
secure-file-priv=/tmp
autocommit=0
log_bin=/data/binlog/mysql-bin
binlog_format=row
#GTID
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1
# 允许最大连接数
max_connections=200
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
[mysql]
socket=/tmp/mysql.sock
prompt=db01 [\d]&gt;</code></pre>

<h2 id="3.7mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96"><strong><strong><strong>3</strong></strong><strong><strong>.7</strong></strong><strong><strong>mysql数据库初始化</strong></strong></strong></h2>

<pre><code class="language-bash">[root@db01 ~]# mysqld --initialize-insecure --user=mysql --basedir=/app/mysql --datadir=/data/mysql/data</code></pre>

<h2 id="3.8%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%932%E7%A7%8D%E6%96%B9%E5%BC%8F"><strong><strong><strong>3.8</strong></strong><strong><strong>启动数据库2种方式</strong></strong></strong></h2>

<h3 id="1.%20sys-v"><strong><strong><strong>1. sys-v </strong></strong></strong></h3>

<pre><code class="language-bash">[root@db01 data]# cp /app/mysql/support-files/mysql.server  /etc/init.d/mysqld 
[root@db01 data]# vim /etc/init.d/mysqld 
[root@db01 data]# grep -Ev "^(#|$)" /etc/init.d/mysqld
 
basedir=/app/mysql
datadir=/data/mysql/data
………………………………………..</code></pre>

<pre><code class="language-bash">[root@db02 mysql]# service mysqld restart
[root@db02 mysql]# service mysqld stop
[root@db02 mysql]# service mysqld start</code></pre>

<pre><code class="language-bash">[root@db02 mysql]# /etc/init.d/mysqld restart
[root@db02 mysql]# /etc/init.d/mysqld stop
[root@db02 mysql]# /etc/init.d/mysqld start</code></pre>

<h3 id="2.%20systemd"><strong><strong><strong>2. systemd </strong></strong></strong></h3>

<p style="margin-left:0pt;">注意： sysv方式启动过的话，需要先提前关闭，才能以下方式登录</p>

<pre><code class="language-bash">cat &gt;/etc/systemd/system/mysqld.service &lt;&lt;EOF
[Unit]
Description=MySQL Server
Documentation=man:mysqld(8)
Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html
After=network.target
After=syslog.target
[Install]
WantedBy=multi-user.target
[Service]
User=mysql
Group=mysql
ExecStart=/app/mysql/bin/mysqld --defaults-file=/etc/my.cnf
LimitNOFILE = 5000
EOF</code></pre>

<pre><code class="language-bash">[root@db02 mysql]# systemctl restart mysqld
[root@db02 mysql]# systemctl stop mysqld
[root@db02 mysql]# systemctl start mysqld</code></pre>

<p><img alt="" height="262" src="https://img-blog.csdnimg.cn/20200624111355255.png" width="907"></p>

<h2 id="3.9%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%86%E7%A0%81"><strong><strong><strong>3</strong></strong><strong><strong>.9</strong></strong><strong><strong>修改数据库的密码</strong></strong></strong></h2>

<p style="margin-left:0pt;"><strong><strong>注意：</strong></strong><span style="color:#ff0000;">5.8</span><span style="color:#ff0000;">以上数据库，需要先创用户，授权</span></p>

<p style="margin-left:0pt;">&nbsp;<span style="color:#ff0000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.7</span><span style="color:#ff0000;">的数据库，你授权时，就行给你创建用户</span></p>

<p style="margin-left:0pt;"><span style="color:#ff0000;">（坑：在更改密码时，要注意空格，防止密码里有空格，而自己没注意</span></p>

<pre><code class="language-bash">use mysql;
本地连接密码
grant all on *.* to root@'localhost' identified by 'xdzh@2020';
同一网段可连接的root权限
grant all on *.* to root@'172.17.1.%' identified by 'xdzh@2020';
刷新权限表
flush privileges;</code></pre>

<p><img alt="" height="254" src="https://img-blog.csdnimg.cn/20200624111429928.png" width="245"></p>

<p style="margin-left:0pt;">本地登录测试</p>

<p><img alt="" height="220" src="https://img-blog.csdnimg.cn/20200624111436287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h1 id="4%E3%80%81mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE"><strong><strong><strong>4、mysql主从配置</strong></strong></strong></h1>

<h2 id="1%E3%80%81%E4%B8%BB%E5%BA%93%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%88db01%EF%BC%89"><strong>1、主库创建用户（db01<strong><strong>）</strong></strong></strong></h2>

<p style="margin-left:0pt;"><strong><span style="color:#ff0000;"><strong>账号密码可以自己定义</strong></span></strong></p>

<pre><code class="language-bash">grant replication slave  on *.* to repl@'172.17.1.%' identified by '123';
flush privileges;</code></pre>

<p><img alt="" height="317" src="https://img-blog.csdnimg.cn/20200624111504279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h2 id="2%E3%80%81%E4%BB%8E%E5%BA%93%E5%BC%80%E5%90%AF%E8%BF%9E%E6%8E%A5%EF%BC%88db02%EF%BC%89"><strong><strong><strong>2、从库开启连接（db</strong></strong><strong><strong>02</strong></strong><strong><strong>）</strong></strong></strong></h2>

<p style="margin-left:0pt;">执行语句，连接主库，同步数据</p>

<pre><code class="language-bash">change master to 
master_host='172.17.1.145',
master_user='repl',
master_password='123' ,
MASTER_AUTO_POSITION=1;</code></pre>

<p style="margin-left:0pt;">开启从库</p>

<pre><code class="language-bash">start slave;</code></pre>

<p><img alt="" height="907" src="https://img-blog.csdnimg.cn/20200624111547326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<p style="margin-left:0pt;">查看用户</p>

<p><img alt="" height="256" src="https://img-blog.csdnimg.cn/20200624111554968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h1 id="5%E3%80%81MHA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><strong><strong><strong>5、</strong></strong><strong><span style="color:#404040;"><strong>MHA环境搭建</strong></span></strong></strong></h1>

<p style="margin-left:0pt;">规划</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:207.4pt;">
			<p style="margin-left:0pt;">主机</p>
			</td>
			<td style="vertical-align:top;width:207.4pt;">
			<p style="margin-left:0pt;">MHA软件</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:207.4pt;">
			<p style="margin-left:0pt;">主库（db01）</p>
			</td>
			<td style="vertical-align:top;width:207.4pt;">
			<p style="margin-left:0pt;">Node</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:207.4pt;">
			<p style="margin-left:0pt;">从库（db02）</p>
			</td>
			<td style="vertical-align:top;width:207.4pt;">
			<p style="margin-left:0pt;">Node，Master</p>
			</td>
		</tr></tbody></table><h2 id="5.1%E9%85%8D%E7%BD%AE%E5%85%B3%E9%94%AE%E7%A8%8B%E5%BA%8F%E8%BD%AF%E8%BF%9E%E6%8E%A5" style="margin-left:0pt;"><strong><strong><strong>5</strong></strong><strong><strong>.1</strong></strong><strong><span style="color:#404040;"><strong>配置关键程序软连接</strong></span></strong></strong></h2>

<p style="margin-left:0pt;"><span style="color:#ff0000;">注意：一定要配置，不然后面数据库切换会出现问题（主从都配置）</span></p>

<pre><code class="language-bash">ln -s /app/mysql/bin/mysqlbinlog    /usr/bin/mysqlbinlog
ln -s /app/mysql/bin/mysql          /usr/bin/mysql</code></pre>

<p><img alt="" height="118" src="https://img-blog.csdnimg.cn/20200624111621692.png" width="554"></p>

<h2 id="5.2%E9%85%8D%E7%BD%AE%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E4%BA%92%E4%BF%A1"><strong><strong><strong>5</strong></strong><strong><strong>.2</strong></strong><strong><strong>配置各个节点互信</strong></strong></strong></h2>

<p style="margin-left:0pt;">配置SSH</p>

<pre><code class="language-bash">db01：
rm -rf /root/.ssh 
ssh-keygen
cd /root/.ssh 
mv id_rsa.pub authorized_keys
scp  -r  /root/.ssh  172.17.1.146:/root</code></pre>

<p style="margin-left:0pt;">各节点验证：</p>

<pre><code class="language-bash">db01:
ssh 172.17.1.145 date
ssh 172.17.1.146 date

db02:
ssh 172.17.1.145 date
ssh 172.17.1.146 date</code></pre>

<p style="margin-left:0pt;">主库</p>

<p>&nbsp;</p>

<p><img alt="" height="253" src="https://img-blog.csdnimg.cn/20200624111711489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="406"></p>

<p style="margin-left:0pt;">从库</p>

<p><img alt="" height="157" src="https://img-blog.csdnimg.cn/20200624111716381.png" width="329"></p>

<h2 id="5.3%E5%AE%89%E8%A3%85MHA%E8%BD%AF%E4%BB%B6"><strong><strong><strong>5</strong></strong><strong><strong>.3</strong></strong><strong><strong>安装MHA软件</strong></strong></strong></h2>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">mha官网：https://code.google.com/archive/p/mysql-master-ha/</p>

			<p style="margin-left:0pt;">github下载地址：https://github.com/yoshinorim/mha4mysql-manager/wiki/Downloads</p>
			</td>
		</tr></tbody></table><h3 id="1%E3%80%81%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85Node%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8C%85"><strong><strong><strong>1、</strong></strong><strong><strong>所有节点安装Node软件依赖包</strong></strong></strong></h3>

<pre><code class="language-bash">yum install perl-DBD-MySQL -y
rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm</code></pre>

<p><img alt="" height="305" src="https://img-blog.csdnimg.cn/20200624111748709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h3 id="2%E3%80%81%E5%9C%A8db01%E4%B8%BB%E5%BA%93%E4%B8%AD%E5%88%9B%E5%BB%BAmha%E9%9C%80%E8%A6%81%E7%9A%84%E7%94%A8%E6%88%B7"><strong><strong><strong>2、</strong></strong><strong><strong>在db01主库中创建mha需要的用户</strong></strong></strong></h3>

<p style="margin-left:0pt;">账号密码可以自己定义</p>

<pre><code class="language-bash">grant all privileges on *.* to mha@'172.17.1.%' identified by 'mha';</code></pre>

<p><img alt="" height="458" src="https://img-blog.csdnimg.cn/20200624111806606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h3 id="3%E3%80%81Manager%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%88db02%EF%BC%89"><strong><strong><strong>3、Manager软件安装（db02）</strong></strong></strong></h3>

<p style="margin-left:0pt;">注意：这边如果yum安装缺少依赖，换成阿里云的源和epel</p>

<pre><code class="language-bash">yum install -y perl-Config-Tiny epel-release perl-Log-Dispatch perl-Parallel-ForkManager perl-Time-HiRes
rpm -ivh mha4mysql-manager-0.56-0.el6.noarch.rpm</code></pre>

<p><img alt="" height="135" src="https://img-blog.csdnimg.cn/20200624111836755.png" width="554"></p>

<h2 id="5.4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%87%86%E5%A4%87%EF%BC%88db02%EF%BC%89"><strong><strong><strong>5</strong></strong><strong><strong>.4</strong></strong><strong><strong>配置文件准备（db</strong></strong><strong><strong>02</strong></strong><strong><strong>）</strong></strong></strong></h2>

<pre><code class="language-bash">创建配置文件目录
 mkdir -p /etc/mha
创建日志目录
 mkdir -p /var/log/mha/app1</code></pre>

<p style="margin-left:0pt;">编辑mha配置文件</p>

<pre><code class="language-bash">vim /etc/mha/app1.cnf

[server default]
manager_log=/var/log/mha/app1/manager        
manager_workdir=/var/log/mha/app1            
master_binlog_dir=/data/binlog       
user=mha                                   
password=mha                               
ping_interval=2
repl_password=123
repl_user=repl
ssh_user=root                               
[server1]                                   
hostname=172.17.1.145
port=3306                                  
[server2]            
hostname=172.17.1.146
port=3306
</code></pre>

<p>&nbsp;</p>

<p><img alt="" height="467" src="https://img-blog.csdnimg.cn/20200624111906941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h2 id="5.5%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5"><strong><strong><strong>5</strong></strong><strong><strong>.5状态检查</strong></strong></strong></h2>

<pre><code class="language-bash">检测repl状态
masterha_check_repl  --conf=/etc/mha/app1.cnf 
检测ssh状态
masterha_check_ssh  --conf=/etc/mha/app1.cnf

检测运行状态
 masterha_check_status --conf=/etc/mha/app1.cnf</code></pre>

<h3 id="%E4%BA%92%E4%BF%A1%E6%A3%80%E6%9F%A5"><strong><strong><strong>互信检查</strong></strong></strong></h3>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">masterha_check_ssh &nbsp;--conf=/etc/mha/app1.cnf</p>
			</td>
		</tr></tbody></table><p><img alt="" height="221" src="https://img-blog.csdnimg.cn/20200624111932247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h3 id="%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5"><strong><strong><strong>主从状态检查</strong></strong></strong></h3>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">masterha_check_repl &nbsp;--conf=/etc/mha/app1.cnf</p>
			</td>
		</tr></tbody></table><p><img alt="" height="289" src="https://img-blog.csdnimg.cn/20200624111948633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h2 id="5.6%E5%BC%80%E5%90%AFHMA%EF%BC%88db02%EF%BC%89"><strong><strong><strong>5</strong></strong><strong><strong>.6</strong></strong><strong><strong>开启HMA（db</strong></strong><strong><strong>02</strong></strong><strong><strong>）</strong></strong></strong></h2>

<h3 id="%E5%BC%80%E5%90%AF"><strong><strong><strong>开启</strong></strong></strong></h3>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">nohup masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover &nbsp;&lt; /dev/null&gt; /var/log/mha/app1/manager.log 2&gt;&amp;1 &amp;</p>
			</td>
		</tr></tbody></table><h3 id="%E6%A3%80%E6%B5%8BMHA%E7%8A%B6%E6%80%81"><strong><strong><strong>检测MHA状态</strong></strong></strong></h3>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">masterha_check_status --conf=/etc/mha/app1.cnf</p>

			<p style="margin-left:0pt;">&nbsp;</p>

			<p style="margin-left:0pt;">[root@db02 mysql]# masterha_check_status --conf=/etc/mha/app1.cnf</p>

			<p style="margin-left:0pt;">app1 (pid:17248) is running(0:PING_OK), master:172.17.1.145</p>

			<p style="margin-left:0pt;">[root@db02 mysql]# mysql -umha -pmha -h172.17.1.145 -e "show variables like 'server_id'"</p>

			<p style="margin-left:0pt;">mysql: [Warning] Using a password on the command line interface can be insecure.</p>

			<p style="margin-left:0pt;">+---------------+-------+</p>

			<p style="margin-left:0pt;">| Variable_name | Value |</p>

			<p style="margin-left:0pt;">+---------------+-------+</p>

			<p style="margin-left:0pt;">| server_id &nbsp;&nbsp;&nbsp;&nbsp;| 145 &nbsp;&nbsp;|</p>

			<p style="margin-left:0pt;">+---------------+-------+</p>

			<p style="margin-left:0pt;">[root@db02 mysql]# mysql -umha -pmha -h172.17.1.146 -e "show variables like 'server_id'"</p>

			<p style="margin-left:0pt;">mysql: [Warning] Using a password on the command line interface can be insecure.</p>

			<p style="margin-left:0pt;">+---------------+-------+</p>

			<p style="margin-left:0pt;">| Variable_name | Value |</p>

			<p style="margin-left:0pt;">+---------------+-------+</p>

			<p style="margin-left:0pt;">| server_id &nbsp;&nbsp;&nbsp;&nbsp;| 146 &nbsp;&nbsp;|</p>

			<p style="margin-left:0pt;">+---------------+-------+</p>
			</td>
		</tr></tbody></table><p><img alt="" height="200" src="https://img-blog.csdnimg.cn/20200624112112881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1179"></p>

<p><img alt="" height="454" src="https://img-blog.csdnimg.cn/20200624112119304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1067"></p>

<h1 id="6%E3%80%81MHA%20%E7%9A%84vip%E5%8A%9F%E8%83%BD"><strong><strong><strong>6</strong></strong><strong><strong>、</strong></strong><strong><strong>MHA 的vip功能</strong></strong></strong></h1>

<h2 id="%E5%8F%82%E6%95%B0"><strong><strong><span style="color:#404040;"><strong>参数</strong></span></strong></strong></h2>

<p><span style="color:#ff0000;">注意：</span><span style="color:#ff0000;">/usr/local/bin/master_ip_failover，必须事先准备好</span></p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">master_ip_failover_script=/usr/local/bin/master_ip_failover</p>
			</td>
		</tr></tbody></table><h2 id="%E4%BF%AE%E6%94%B9%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9"><strong><strong><span style="color:#404040;"><strong>修改脚本内容</strong></span></strong></strong></h2>

<pre><code class="language-bash">vi  /usr/local/bin/master_ip_failover
my $vip = '172.17.1.100/24';
my $key = '1';
my $ssh_start_vip = "/sbin/ifconfig eth0:$key $vip";
my $ssh_stop_vip = "/sbin/ifconfig eth0:$key down";</code></pre>

<h2 id="%E6%9B%B4%E6%94%B9manager%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A"><strong><strong><span style="color:#404040;"><strong>更改manager配置文件：</strong></span></strong></strong></h2>

<pre><code class="language-bash">vi /etc/mha/app1.cnf
添加：
master_ip_failover_script=/usr/local/bin/master_ip_failover
注意：
[root@db03 ~]# dos2unix /usr/local/bin/master_ip_failover 
dos2unix: converting file /usr/local/bin/master_ip_failover to Unix format ...
[root@db03 ~]# chmod +x /usr/local/bin/master_ip_failover</code></pre>

<h2 id="%E4%B8%BB%E5%BA%93%E4%B8%8A%EF%BC%8C%E6%89%8B%E5%B7%A5%E7%94%9F%E6%88%90%E7%AC%AC%E4%B8%80%E4%B8%AAvip%E5%9C%B0%E5%9D%80"><strong><strong><span style="color:#404040;"><strong>主库上，手工生成第一个vip地址</strong></span></strong></strong></h2>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">手工在主库上绑定vip，注意一定要和配置文件中的ethN一致，我的是eth0:1(1是key指定的值)</p>

			<p style="margin-left:0pt;">ifconfig ens33:1 172.17.1.100/24</p>
			</td>
		</tr></tbody></table><p><img alt="" height="768" src="https://img-blog.csdnimg.cn/20200624112235903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1190"></p>

<h2 id="%E9%87%8D%E5%90%AFmha"><strong><strong><span style="color:#404040;"><strong>重启mha</strong></span></strong></strong></h2>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">masterha_stop --conf=/etc/mha/app1.cnf</p>

			<p style="margin-left:0pt;">nohup masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover &lt; /dev/null &gt; /var/log/mha/app1/manager.log 2&gt;&amp;1 &amp;</p>
			</td>
		</tr></tbody></table><h1 id="7%E3%80%81%C2%A0binlog%20server%EF%BC%88db02%EF%BC%89"><strong><strong><strong>7、</strong></strong><strong><strong>&nbsp;binlog server（db02）</strong></strong></strong></h1>

<h2 id="%E5%8F%82%E6%95%B0%EF%BC%9A"><strong><strong><span style="color:#404040;"><strong>参数：</strong></span></strong></strong></h2>

<p style="margin-left:0pt;">binlogserver配置：</p>

<p style="margin-left:0pt;">找一台额外的机器，必须要有5.6以上的版本，支持gtid并开启，我们直接用slave（db02）</p>

<p style="margin-left:0pt;">vim /etc/mha/app1.cnf</p>

<pre><code class="language-bash">[binlog1]
no_master=1
hostname= 172.17.1.146
master_binlog_dir=/data/mysql/binlog</code></pre>

<p><img alt="" height="809" src="https://img-blog.csdnimg.cn/20200624112324531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="868"></p>

<p>&nbsp;</p>

<h2 id="%E5%88%9B%E5%BB%BA%E5%BF%85%E8%A6%81%E7%9B%AE%E5%BD%95"><strong><strong><span style="color:#404040;"><strong>创建必要目录</strong></span></strong></strong></h2>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">mkdir -p /data/mysql/binlog</p>

			<p style="margin-left:0pt;">chown -R mysql.mysql /data/*</p>

			<p style="margin-left:0pt;">修改完成后，将主库binlog拉过来（从000001开始拉，之后的binlog会自动按顺序过来）</p>
			</td>
		</tr></tbody></table><h2 id="%E6%8B%89%E5%8F%96%E4%B8%BB%E5%BA%93binlog%E6%97%A5%E5%BF%97"><strong><strong><span style="color:#404040;"><strong>拉取主库binlog日志</strong></span></strong></strong></h2>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">cd /data/mysql/binlog &nbsp;&nbsp;&nbsp;&nbsp;-----》必须进入到自己创建好的目录</p>

			<p style="margin-left:0pt;">mysqlbinlog &nbsp;-R --host=172.17.1.145 --user=mha --password=mha --raw &nbsp;--stop-never mysql-bin.000001 &amp;</p>

			<p style="margin-left:0pt;">注意：</p>

			<p style="margin-left:0pt;">拉取日志的起点,需要按照目前从库的已经获取到的二进制日志点为起点</p>
			</td>
		</tr></tbody></table><p><img alt="" height="456" src="https://img-blog.csdnimg.cn/20200624112351686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1113"></p>

<p>&nbsp;</p>

<h2 id="%E9%87%8D%E5%90%AFMHA"><strong><strong><span style="color:#404040;"><strong>重启MHA</strong></span></strong></strong></h2>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">masterha_stop --conf=/etc/mha/app1.cnf</p>

			<p style="margin-left:0pt;">nohup masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover &lt; /dev/null &gt; /var/log/mha/app1/manager.log 2&gt;&amp;1 &amp;</p>
			</td>
		</tr></tbody></table><h1 id="8%E3%80%81%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92"><strong><strong><strong>8、邮件提醒</strong></strong></strong></h1>

<h2 id="1.%20%E5%8F%82%E6%95%B0"><strong><strong><strong>1. 参数</strong></strong></strong></h2>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">report_script=/usr/local/bin/send</p>
			</td>
		</tr></tbody></table><h2 id="2.%20%E5%87%86%E5%A4%87%E9%82%AE%E4%BB%B6%E8%84%9A%E6%9C%AC"><strong><strong><strong>2. 准备邮件脚本</strong></strong></strong></h2>

<p><strong><strong>send_report</strong></strong></p>

<blockquote>
<p style="margin-left:0pt;">(1)准备发邮件的脚本(上传 email_2019-最新.zip中的脚本，到/usr/local/bin/中)</p>

<p style="margin-left:0pt;">(2)将准备好的脚本添加到mha配置文件中,让其调用</p>
</blockquote>

<p><img alt="" height="351" src="https://img-blog.csdnimg.cn/20200624112448507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="764"></p>

<h2 id="3.%20%E4%BF%AE%E6%94%B9manager%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E8%B0%83%E7%94%A8%E9%82%AE%E4%BB%B6%E8%84%9A%E6%9C%AC"><strong><strong><strong>3. 修改manager配置文件，调用邮件脚本</strong></strong></strong></h2>

<pre><code class="language-bash">vi /etc/mha/app1.cnf
report_script=/usr/local/bin/send</code></pre>

<h2><strong><strong><span style="color:#404040;"><strong>重启MHA</strong></span></strong></strong></h2>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:414.8pt;">
			<p style="margin-left:0pt;">masterha_stop --conf=/etc/mha/app1.cnf</p>

			<p style="margin-left:0pt;">nohup masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover &lt; /dev/null &gt; /var/log/mha/app1/manager.log 2&gt;&amp;1 &amp;</p>
			</td>
		</tr></tbody></table><h1 id="9%E3%80%81%E6%B5%8B%E8%AF%95MHA"><strong><strong><strong>9</strong></strong><strong><strong>、测试MHA</strong></strong></strong></h1>

<h2 id="%E5%85%B3%E9%97%AD%E4%B8%BB%E5%BA%93%2C%E7%9C%8B%E8%AD%A6%E5%91%8A%E9%82%AE%E4%BB%B6%20%C2%A0"><strong><strong><strong>关闭主库</strong></strong><strong><strong>,看警告邮件 &nbsp;</strong></strong></strong></h2>

<p>&nbsp;</p>

<p><img alt="" height="543" src="https://img-blog.csdnimg.cn/2020062411255410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1098"></p>

<p style="margin-left:0pt;">切换完后，HMA会退出，还有binlogserver</p>

<p style="margin-left:0pt;"><img alt="" height="226" src="https://img-blog.csdnimg.cn/20200624112607581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1127"></p>

<p><img alt="" height="709" src="https://img-blog.csdnimg.cn/20200624112627559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1085"></p>

<p><strong>&nbsp;145数据库挂掉后，MHA自动切换IP到146上，无需人为修改。</strong></p>

<p><img alt="" height="707" src="https://img-blog.csdnimg.cn/2020062411264552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1140"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>什么，你还不会Mysql主从复制？？？快来看</title><link>http://www.cnblogs.com/heian99/archive/2020/06/09/13203454.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 09 Jun 2020 09:35:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/06/09/13203454.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9F-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9F" rel="nofollow">1、为什么需要主从复制？</a></p>

<p id="2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFmysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFmysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6" rel="nofollow">2、什么是mysql主从复制</a></p>

<p id="3%E3%80%81Mysql%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#3%E3%80%81Mysql%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86" rel="nofollow">3、Mysql复制原理</a></p>

<p id="4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%AE%80%E4%BB%8B" rel="nofollow">4、主从复制简介</a></p>

<p id="5%E3%80%81%C2%A0%E5%BB%B6%E6%97%B6%E4%BB%8E%E5%BA%93-toc" style="margin-left:80px;"><a href="#5%E3%80%81%C2%A0%E5%BB%B6%E6%97%B6%E4%BB%8E%E5%BA%93" rel="nofollow">5、&nbsp;延时从库</a></p>

<p id="6%E3%80%81%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6" rel="nofollow">6、半同步复制</a></p>

<p id="7%E3%80%81%E8%BF%87%E6%BB%A4%E5%A4%8D%E5%88%B6-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E8%BF%87%E6%BB%A4%E5%A4%8D%E5%88%B6" rel="nofollow">7、过滤复制</a></p>

<p id="8%E3%80%81GTID%E5%A4%8D%E5%88%B6-toc" style="margin-left:80px;"><a href="#8%E3%80%81GTID%E5%A4%8D%E5%88%B6" rel="nofollow">8、GTID复制</a></p>

<p id="9.%20%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E7%9B%91%E6%8E%A7%5C%E5%88%86%E6%9E%90%5C%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#9.%20%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E7%9B%91%E6%8E%A7%5C%E5%88%86%E6%9E%90%5C%E5%A4%84%E7%90%86" rel="nofollow">9. 主从故障监控\分析\处理</a></p>

<p id="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90" rel="nofollow">主从复制故障分析</a></p>

<hr id="hr-toc"><h3 id="%E2%80%8B"><img alt="" height="590" src="https://img-blog.csdnimg.cn/20200609163414418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1054"></h3>

<h3 id="1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9F">1、<strong>为什么需要主从复制？</strong></h3>

<p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p>

<p>2、做数据的热备</p>

<p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p>

<h3 id="2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFmysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">2、什么是mysql主从复制</h3>

<p>Mysql主从复制是指数据可以从一个mysql数据库服务器节点复制到另一个或者多个节点。</p>

<p>Mysql默认采用异步复制方式，这样从节点不用一直访问主服务器来跟新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>

<h3 id="3%E3%80%81Mysql%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86">3、Mysql复制原理</h3>

<p><span style="color:#f33b45;"><strong>原理：</strong></span></p>

<p><span style="color:#f33b45;"><strong>（1）master服务器将数据的改变记录二进制binlog日志，当master的数据发生改变是，这将改变写入二进制日志中；</strong></span></p>

<p><span style="color:#f33b45;"><strong>（2）slave服务器会在一定时间间隔内对master二进制日志进行探测是否发生改变，如果发生该百年，则开始一个IO线程请求master二进制时间</strong></span></p>

<p><span style="color:#f33b45;"><strong>（3）同时主节点为每个IO线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动sql线程从中继日志读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后IO线程和sql线程进入睡眠状态，等待下一次唤醒</strong></span></p>

<blockquote>
<ul><li><strong>从库会生成两个线程,一个I/O线程,一个SQL线程;</strong></li>
	<li><strong>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</strong></li>
	<li><strong>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</strong></li>
	<li><strong>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</strong></li>
</ul></blockquote>

<p><strong>注意：</strong></p>

<p>1、master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</p>

<p>2、slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。</p>

<p>3、Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</p>

<p>4、Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</p>

<p>5、master和slave两节点间时间需同步</p>

<h3 id="4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%AE%80%E4%BB%8B">4、主从复制简介</h3>

<blockquote>
<p>1.1. 基于二进制日志复制的<br>
1.2. 主库的修改操作会记录二进制日志<br>
1.3. 从库会请求新的二进制日志并回放,最终达到主从数据同步<br>
1.4. 主从复制核心功能:<br>
辅助备份,处理物理损坏 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
扩展新型的架构:高可用,高性能,分布式架构等</p>
</blockquote>

<p><strong>前提</strong></p>

<ul><li>2.1 两台以上mysql实例 ,server_id,server_uuid不同</li>
	<li>2.2 主库开启二进制日志</li>
	<li>&nbsp;2.3 专用的复制用户</li>
	<li>2.4 保证主从开启之前的某个时间点,从库数据是和主库一致(补课)</li>
	<li>2.5 告知从库,复制user,passwd,IP port,以及复制起点(change master to)</li>
	<li>2.6 线程(三个):Dump thread &nbsp;IO thread &nbsp;SQL thread 开启(start slave)</li>
</ul><p><strong>主从复制搭建过程</strong></p>

<p><strong>清理主库数据</strong></p>

<pre><code class="language-bash">rm -rf /data/3307/data/*</code></pre>

<p><strong>重新初始化3307</strong></p>

<pre><code class="language-bash">mysqld --initialize-insecure --user=mysql --basedir=/app/mysql --datadir=/data/3307/data</code></pre>

<p><strong>修改my.cnf ,开启二进制日志功能</strong></p>

<pre><code class="language-bash">[root@db01 3307]# vim /data/3307/my.cnf 
log_bin=/data/3307/data/mysql-bin</code></pre>

<p><strong>启动所有节点</strong></p>

<pre><code class="language-bash">[root@db01 3307]# systemctl start mysqld3307
[root@db01 3307]# systemctl start mysqld3308
[root@db01 3307]# systemctl start mysqld3309
[root@db01 3307]# ps -ef |grep mysqld
mysql      3684      1  4 09:59 ?        00:00:00 /app/mysql/bin/mysqld --defaults-file=/data/3307/my.cnf
mysql      3719      1  7 09:59 ?        00:00:00 /app/mysql/bin/mysqld --defaults-file=/data/3308/my.cnf
mysql      3754      1  8 09:59 ?        00:00:00 /app/mysql/bin/mysqld --defaults-file=/data/3309/my.cnf
[root@db01 3307]# mysql -S /data/3307/mysql.sock -e "select @@server_id"
[root@db01 3307]# mysql -S /data/3308/mysql.sock -e "select @@server_id"
[root@db01 3307]# mysql -S /data/3309/mysql.sock -e "select @@server_id"</code></pre>

<p><strong>主库中创建复制用户</strong></p>

<pre><code class="language-bash">[root@db01 3307]# mysql -S /data/3307/mysql.sock 
db01 [(none)]&gt;grant replication slave on *.* to repl@'10.0.0.%' identified by '123';
db01 [(none)]&gt;select user,host from mysql.user;</code></pre>

<p><strong>备份主库并恢复到从库</strong></p>

<pre><code class="language-bash">[root@db01 3307]# mysqldump -S /data/3307/mysql.sock -A --master-data=2 --single-transaction  -R --triggers &gt;/backup/full.sql
-- CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=653;
[root@db01 3307]# mysql -S /data/3308/mysql.sock
db01 [(none)]&gt;source /backup/full.sql</code></pre>

<p><strong>告知从库关键复制信息</strong></p>

<pre><code>ip port user  password  binlog position 
[root@db01 3307]# mysql -S /data/3308/mysql.sock
db01 [mysql]&gt;help change master to

CHANGE MASTER TO
  MASTER_HOST='10.0.0.51',   #主库ip地址
  MASTER_USER='repl',        #复制用户
  MASTER_PASSWORD='123',     #密码
  MASTER_PORT=3307,          #端口
  MASTER_LOG_FILE='mysql-bin.000001', #复制binlog的起始位置
  MASTER_LOG_POS=653,        #起始位置的pos好
  MASTER_CONNECT_RETRY=10;   #尝试连接次数</code></pre>

<p><strong>开启主从专用线程</strong></p>

<pre><code>start slave ;</code></pre>

<p><strong>检查复制状态</strong></p>

<pre><code>db01 [mysql]&gt;show slave  status \G
Slave_IO_Running: Yes
Slave_SQL_Running: Yes</code></pre>

<p><strong>主从复制原理描述：</strong></p>

<ul><li>1.change master to 时，ip pot user password binlog position写入到master.info进行记录</li>
	<li>2. start slave 时，从库会启动IO线程和SQL线程</li>
	<li>3.IO_T，读取master.info信息，获取主库信息连接主库</li>
	<li>4. 主库会生成一个准备binlog DUMP线程，来响应从库</li>
	<li>5. IO_T根据master.info记录的binlog文件名和position号，请求主库DUMP最新日志</li>
	<li>6. DUMP线程检查主库的binlog日志，如果有新的，TP(传送)给从从库的IO_T</li>
	<li>7. IO_T将收到的日志存储到了TCP/IP 缓存，立即返回ACK给主库 ，主库工作完成</li>
	<li>8.IO_T将缓存中的数据，存储到relay-log日志文件,更新master.info文件binlog 文件名和postion，IO_T工作完成</li>
	<li>9.SQL_T读取relay-log.info文件，获取到上次执行到的relay-log的位置，作为起点，回放relay-log</li>
	<li>10.SQL_T回放完成之后，会更新relay-log.info文件。</li>
	<li>11. relay-log会有自动清理的功能。</li>
	<li>细节：</li>
	<li>1.主库一旦有新的日志生成，会发送“信号”给binlog dump ，IO线程再请求</li>
</ul><h3 id="5%E3%80%81%C2%A0%E5%BB%B6%E6%97%B6%E4%BB%8E%E5%BA%93">5、&nbsp;延时从库</h3>

<p>是我们认为配置的一种特殊从库.人为配置从库和主库延时N小时.</p>

<p><strong>为什么要有延时从？</strong></p>

<pre><code>数据库故障?
物理损坏
主从复制非常擅长解决物理损坏.
逻辑损坏
普通主从复制没办法解决逻辑损坏</code></pre>

<p>配置延时从库</p>

<pre><code>SQL线程延时:数据已经写入relaylog中了,SQL线程"慢点"运行
一般企业建议3-6小时,具体看公司运维人员对于故障的反应时间

mysql&gt;stop slave;
mysql&gt;CHANGE MASTER TO MASTER_DELAY = 300;
mysql&gt;start slave;
mysql&gt; show slave status \G
SQL_Delay: 300
SQL_Remaining_Delay: NULL</code></pre>

<p><strong>延时从库应用</strong></p>

<blockquote>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1主1从,从库延时5分钟,主库误删除1个库<br>
1. 5分钟之内 侦测到误删除操作<br>
2. 停从库SQL线程<br>
3. 截取relaylog<br>
起点 :停止SQL线程时,relay最后应用位置<br>
终点:误删除之前的position(GTID)<br>
4. 恢复截取的日志到从库<br>
5. 从库身份解除,替代主库工作</p>
</blockquote>

<p><strong>故障模拟及恢复</strong></p>

<pre><code>1.主库数据操作
db01 [(none)]&gt;create database relay charset utf8;
db01 [(none)]&gt;use relay
db01 [relay]&gt;create table t1 (id int);
db01 [relay]&gt;insert into t1 values(1);
db01 [relay]&gt;drop database relay;</code></pre>

<pre><code>2. 停止从库SQL线程
stop slave sql_thread;</code></pre>

<pre><code>3. 找relaylog的截取起点和终点
起点:
Relay_Log_File: db01-relay-bin.000002
Relay_Log_Pos: 482
终点:
show relaylog events in 'db01-relay-bin.000002'
| db01-relay-bin.000002 | 1046 | Xid            |         7 |        2489 | COMMIT /* xid=144 */                  |
| db01-relay-bin.000002 | 1077 | Anonymous_Gtid |         7 |        2554 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS'  |
mysqlbinlog --start-position=482 --stop-position=1077  /data/3308/data/db01-relay-bin.000002&gt;/tmp/relay.sql</code></pre>

<pre><code class="language-bash">4.从库恢复relaylog
source /tmp/relay.sql</code></pre>

<pre><code class="language-bash">5.从库身份解除
db01 [relay]&gt;stop slave;
db01 [relay]&gt;reset slave all
</code></pre>

<h3 id="6%E3%80%81%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6">6、半同步复制</h3>

<p><span style="color:#f33b45;"><strong>解决主从数据一致性问题</strong></span></p>

<p><strong>&nbsp;半同步复制工作原理的变化</strong></p>

<ul><li>1. 主库执行新的事务,commit时,更新 show master &nbsp;status\G ,触发一个信号给</li>
	<li>2. binlog dump 接收到主库的 show master status\G信息,通知从库日志更新了</li>
	<li>3. 从库IO线程请求新的二进制日志事件</li>
	<li>4. 主库会通过dump线程传送新的日志事件,给从库IO线程</li>
	<li>5. 从库IO线程接收到binlog日志,当日志写入到磁盘上的relaylog文件时,给主库ACK_receiver线程</li>
	<li>6. ACK_receiver线程触发一个事件,告诉主库commit可以成功了</li>
	<li>7. 如果ACK达到了我们预设值的超时时间,半同步复制会切换为原始的异步复制.</li>
</ul><p><strong>配置半同步复制</strong></p>

<pre><code>加载插件
主:
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
从:
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
查看是否加载成功:
show plugins;
启动:
主:
SET GLOBAL rpl_semi_sync_master_enabled = 1;
从:
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
重启从库上的IO线程
STOP SLAVE IO_THREAD;
START SLAVE IO_THREAD;
查看是否在运行
主:
show status like 'Rpl_semi_sync_master_status';
从:
show status like 'Rpl_semi_sync_slave_status';</code></pre>

<h3 id="7%E3%80%81%E8%BF%87%E6%BB%A4%E5%A4%8D%E5%88%B6">7、过滤复制</h3>

<p>主库：</p>

<pre><code>show master status;
Binlog_Do_DB
Binlog_Ignore_DB </code></pre>

<p>从库：</p>

<pre><code>show slave status\G
Replicate_Do_DB: 
Replicate_Ignore_DB: </code></pre>

<p><strong>实现过程</strong></p>

<pre><code>mysqldump -S /data/3307/mysql.sock -A --master-data=2 --single-transaction  -R --triggers &gt;/backup/full.sql

vim  /backup/full.sql
-- CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000002', MASTER_LOG_POS=154;

[root@db01 ~]# mysql -S /data/3309/mysql.sock 
source /backup/full.sql

CHANGE MASTER TO
MASTER_HOST='10.0.0.51',
MASTER_USER='repl',
MASTER_PASSWORD='123',
MASTER_PORT=3307,
MASTER_LOG_FILE='mysql-bin.000002',
MASTER_LOG_POS=154,
MASTER_CONNECT_RETRY=10;
start  slave;
[root@db01 ~]# vim /data/3309/my.cnf 
replicate_do_db=ppt
replicate_do_db=word
[root@db01 ~]# systemctl restart mysqld3309

主库：
Master [(none)]&gt;create database word;
Query OK, 1 row affected (0.00 sec)
Master [(none)]&gt;create database ppt;
Query OK, 1 row affected (0.00 sec)
Master [(none)]&gt;create database excel;
Query OK, 1 row affected (0.01 sec)</code></pre>

<h3 id="8%E3%80%81GTID%E5%A4%8D%E5%88%B6">8、GTID复制</h3>

<p>GTID介绍</p>

<pre><code>GTID(Global Transaction ID)是对于一个已提交事务的唯一编号，并且是一个全局(主从复制)唯一的编号。
它的官方定义如下：
GTID = source_id ：transaction_id
7E11FA47-31CA-19E1-9E56-C43AA21293967:29
什么是sever_uuid，和Server-id 区别？
核心特性: 全局唯一,具备幂等性</code></pre>

<p>GTID核心参数</p>

<pre><code>gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1

gtid-mode=on                        --启用gtid类型，否则就是普通的复制架构
enforce-gtid-consistency=true               --强制GTID的一致性
log-slave-updates=1                 --slave更新是否记入日志</code></pre>

<p><strong>GTID复制配置过程：</strong></p>

<pre><code>主库db01：
cat &gt; /etc/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/data/mysql/
datadir=/data/mysql/data
socket=/tmp/mysql.sock
server_id=51
port=3306
secure-file-priv=/tmp
autocommit=0
log_bin=/data/binlog/mysql-bin
binlog_format=row
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1
[mysql]
prompt=db01 [\\d]&gt;
EOF

slave1(db02)：
cat &gt; /etc/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/data/mysql
datadir=/data/mysql/data
socket=/tmp/mysql.sock
server_id=52
port=3306
secure-file-priv=/tmp
autocommit=0
log_bin=/data/binlog/mysql-bin
binlog_format=row
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1
[mysql]
prompt=db02 [\\d]&gt;
EOF

slave2(db03)：
cat &gt; /etc/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/data/mysql
datadir=/data/mysql/data
socket=/tmp/mysql.sock
server_id=53
port=3306
secure-file-priv=/tmp
autocommit=0
log_bin=/data/binlog/mysql-bin
binlog_format=row
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1
[mysql]
prompt=db03 [\\d]&gt;
EOF</code></pre>

<p>初始化数据</p>

<pre><code>mysqld --initialize-insecure --user=mysql --basedir=/data/mysql  --datadir=/data/mysql/data </code></pre>

<p>启动数据库</p>

<pre><code>/etc/init.d/mysqld start</code></pre>

<p>构建主从</p>

<pre><code>master:51
slave:52,53

51:
grant replication slave  on *.* to repl@'10.0.0.%' identified by '123';

52\53:
change master to 
master_host='10.0.0.51',
master_user='repl',
master_password='123' ,
MASTER_AUTO_POSITION=1;

start slave;
</code></pre>

<p>GTID 从库误写入操作处理</p>

<pre><code>查看监控信息:
Last_SQL_Error: Error 'Can't create database 'oldboy'; database exists' on query. Default database: 'oldboy'. Query: 'create database oldboy'

Retrieved_Gtid_Set: 71bfa52e-4aae-11e9-ab8c-000c293b577e:1-3
Executed_Gtid_Set:  71bfa52e-4aae-11e9-ab8c-000c293b577e:1-2,
7ca4a2b7-4aae-11e9-859d-000c298720f6:1

注入空事物的方法：

stop slave;
set gtid_next='99279e1e-61b7-11e9-a9fc-000c2928f5dd:3';
begin;commit;
set gtid_next='AUTOMATIC';
    
这里的xxxxx:N 也就是你的slave sql thread报错的GTID，或者说是你想要跳过的GTID。
最好的解决方案：重新构建主从环境</code></pre>

<p>GTID 复制和普通复制的区别</p>

<pre><code>CHANGE MASTER TO
MASTER_HOST='10.0.0.51',
MASTER_USER='repl',
MASTER_PASSWORD='123',
MASTER_PORT=3307,
MASTER_LOG_FILE='mysql-bin.000001',
MASTER_LOG_POS=444,
MASTER_CONNECT_RETRY=10;

change master to 
master_host='10.0.0.51',
master_user='repl',
master_password='123' ,
MASTER_AUTO_POSITION=1;
start slave;

（0）在主从复制环境中，主库发生过的事务，在全局都是由唯一GTID记录的，更方便Failover
（1）额外功能参数（3个）
（2）change master to 的时候不再需要binlog 文件名和position号,MASTER_AUTO_POSITION=1;
（3）在复制过程中，从库不再依赖master.info文件，而是直接读取最后一个relaylog的 GTID号
（4） mysqldump备份时，默认会将备份中包含的事务操作，以以下方式
    SET @@GLOBAL.GTID_PURGED='8c49d7ec-7e78-11e8-9638-000c29ca725d:1';
    告诉从库，我的备份中已经有以上事务，你就不用运行了，直接从下一个GTID开始请求binlog就行。</code></pre>

<p>&nbsp;</p>

<h3 id="9.%20%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E7%9B%91%E6%8E%A7%5C%E5%88%86%E6%9E%90%5C%E5%A4%84%E7%90%86">9. 主从故障监控\分析\处理</h3>

<p>主库:</p>

<pre><code class="language-bash">show full processlist;
每个从库都会有一行dump相关的信息
HOSTS: 
db01:47176
State:
Master has sent all binlog to slave; waiting for more updates
如果现实非以上信息,说明主从之间的关系出现了问题    </code></pre>

<p>从库:</p>

<pre><code>db01 [(none)]&gt;show slave status \G
*************************** 1. row ***************************</code></pre>

<p>主库相关信息监控</p>

<pre><code>Master_Host: 10.0.0.51
Master_User: repl
Master_Port: 3307
Master_Log_File: mysql-bin.000005
Read_Master_Log_Pos: 444</code></pre>

<p>从库中继日志的应用状态</p>

<pre><code>Relay_Log_File: db01-relay-bin.000002
Relay_Log_Pos: 485</code></pre>

<p>从库复制线程有关的状态</p>

<pre><code>Slave_IO_Running: Yes
Slave_SQL_Running: Yes
Last_IO_Errno: 0
Last_IO_Error: 
Last_SQL_Errno: 0
Last_SQL_Error: </code></pre>

<p>过滤复制有关的状态</p>

<pre><code>Replicate_Do_DB: 
Replicate_Ignore_DB: 
Replicate_Do_Table: 
Replicate_Ignore_Table: 
Replicate_Wild_Do_Table: 
Replicate_Wild_Ignore_Table: </code></pre>

<p>主从延时相关状态(非人为)</p>

<pre><code>Seconds_Behind_Master: 0</code></pre>

<p>延时从库有关的状态(人为)</p>

<pre><code>SQL_Delay: 0
SQL_Remaining_Delay: NULL</code></pre>

<p>GTID 复制有关的状态</p>

<pre><code>Retrieved_Gtid_Set: 
Executed_Gtid_Set: 
Auto_Position: 0</code></pre>

<h3 id="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90">主从复制故障分析</h3>

<pre><code>(1) 用户 密码  IP  port
Last_IO_Error: error reconnecting to master 'repl@10.0.0.51:3307' - retry-time: 10  retries: 7
[root@db01 ~]# mysql -urepl  -p123333  -h 10.0.0.51 -P 3307
ERROR 1045 (28000): Access denied for user 'repl'@'db01' (using password: YES)

原因:
密码错误 
用户错误 
skip_name_resolve
地址错误
端口</code></pre>

<p>处理方法</p>

<pre><code>stop  slave  
reset slave all 
change master to 
start slave</code></pre>

<p><strong>主库连接数上线,或者是主库太繁忙</strong></p>

<pre><code>show slave  staus \G 
Last_IO_Errno: 1040
Last_IO_Error: error reconnecting to master 'repl@10.0.0.51:3307' - retry-time: 10  retries: 7
处理思路:
拿复制用户,手工连接一下

[root@db01 ~]# mysql -urepl -p123 -h 10.0.0.51 -P 3307 
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 1040 (HY000): Too many connections
处理方法:
db01 [(none)]&gt;set global max_connections=300;

(3) 防火墙,网络不通</code></pre>

<p><strong>请求二进制日志</strong></p>

<pre><code>主库缺失日志
从库方面,二进制日志位置点不对
Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: 'could not find next log; the first event 'mysql-bin.000001' at 154, the last event read from '/data/3307/data/mysql-bin.000002' at 154, the last byte read from '/data/3307/data/mysql-bin.000002' at 154.'</code></pre>

<pre><code>注意: 在主从复制环境中,严令禁止主库中reset master; 可以选择expire 进行定期清理主库二进制日志
解决方案:
重新构建主从</code></pre>

<p><strong>&nbsp;SQL 线程故障</strong></p>

<p>SQL线程功能：</p>

<pre><code>(1)读写relay-log.info 
(2)relay-log损坏,断节,找不到
(3)接收到的SQL无法执行</code></pre>

<p><strong>导致SQL线程故障原因分析：</strong></p>

<pre><code>1. 版本差异，参数设定不同，比如：数据类型的差异，SQL_MODE影响
2.要创建的数据库对象,已经存在
3.要删除或修改的对象不存在  
4.DML语句不符合表定义及约束时.  
归根揭底的原因都是由于从库发生了写入操作.
Last_SQL_Error: Error 'Can't create database 'db'; database exists' on query. Default database: 'db'. Query: 'create database db'</code></pre>

<p>处理方法(以从库为核心的处理方案)：</p>

<pre><code>方法一：
stop slave; 
set global sql_slave_skip_counter = 1;
#将同步指针向下移动一个，如果多次不同步，可以重复操作。
start slave;
方法二：
/etc/my.cnf
slave-skip-errors = 1032,1062,1007
常见错误代码:
1007:对象已存在
1032:无法执行DML
1062:主键冲突,或约束冲突

但是，以上操作有时是有风险的，最安全的做法就是重新构建主从。把握一个原则,一切以主库为主.</code></pre>

<p>一劳永逸的方法:</p>

<pre><code>(1) 可以设置从库只读.
db01 [(none)]&gt;show variables like '%read_only%';
注意：
只会影响到普通用户，对管理员用户无效。
(2)加中间件
读写分离。</code></pre>

<p>主从延时监控及原因&nbsp;</p>

<pre><code>主库做了修改操作,从库比较长时间才能追上.</code></pre>

<p>外在因素</p>

<pre><code>网络 
主从硬件差异较大
版本差异
参数因素</code></pre>

<p>主库</p>

<pre><code>(1) 二进制日志写入不及时
[rep]&gt;select @@sync_binlog;
(2) CR的主从复制中,binlog_dump线程,事件为单元,串行传送二进制日志(5.6 5.5)

1. 主库并发事务量大,主库可以并行,传送时是串行
2. 主库发生了大事务,由于是串行传送,会产生阻塞后续的事务.

解决方案:
1. 5.6 开始,开启GTID,实现了GC(group commit)机制,可以并行传输日志给从库IO
2. 5.7 开始,不开启GTID,会自动维护匿名的GTID,也能实现GC,我们建议还是认为开启GTID
3. 大事务拆成多个小事务,可以有效的减少主从延时.</code></pre>

<p>&nbsp;从库</p>

<pre><code>SQL线程导致的主从延时
在CR复制情况下: 从库默认情况下只有一个SQL,只能串行回放事务SQL
1. 主库如果并发事务量较大,从库只能串行回放
2. 主库发生了大事务,会阻塞后续的所有的事务的运行

解决方案:
1. 5.6 版本开启GTID之后,加入了SQL多线程的特性,但是只能针对不同库(database)下的事务进行并发回放.
2. 5.7 版本开始GTID之后,在SQL方面,提供了基于逻辑时钟(logical_clock),binlog加入了seq_no机制,
真正实现了基于事务级别的并发回放,这种技术我们把它称之为MTS(enhanced multi-threaded slave).
3. 大事务拆成多个小事务,可以有效的减少主从延时.
[https://dev.mysql.com/worklog/task/?id=6314]</code></pre>

<p><img alt="" src="https://img-blog.csdnimg.cn/20200609173050827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><img alt="" src="https://img-blog.csdnimg.cn/20200609173240393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL二进制安装（版本：5.7.26）</title><link>http://www.cnblogs.com/heian99/archive/2020/06/09/13203456.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 09 Jun 2020 08:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/06/09/13203456.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<p id="main-toc"><strong>目录</strong></p>

<p id="1%E3%80%81%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%A4%84%E7%90%86%E5%8E%9F%E5%A7%8B%E7%8E%AF%E5%A2%83-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%A4%84%E7%90%86%E5%8E%9F%E5%A7%8B%E7%8E%AF%E5%A2%83" rel="nofollow">1、用户的创建处理原始环境</a></p>

<p id="2%E3%80%81%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6" rel="nofollow">2、下载，上传文件</a></p>

<p id="3%E3%80%81%E8%A7%A3%E5%8E%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E8%A7%A3%E5%8E%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85" rel="nofollow">3、解压二进制包</a></p>

<p id="4%E3%80%81%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%A3%81%E7%9B%98%EF%BC%8C%E6%8C%82%E8%BD%BD%2Fdata%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%A3%81%E7%9B%98%EF%BC%8C%E6%8C%82%E8%BD%BD%2Fdata%E6%95%B0%E6%8D%AE" rel="nofollow">4、添加一个磁盘，挂载/data数据</a></p>

<p id="5%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E5%B9%B6%E6%8E%88%E6%9D%83-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E5%B9%B6%E6%8E%88%E6%9D%83" rel="nofollow">5、创建数据路径并授权</a></p>

<p id="6%E3%80%81%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" rel="nofollow">6、设置环境变量</a></p>

<p id="7%E3%80%81Mysql%E8%B4%A6%E5%8F%B7%E6%8E%88%E6%9D%83%E7%9B%B8%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#7%E3%80%81Mysql%E8%B4%A6%E5%8F%B7%E6%8E%88%E6%9D%83%E7%9B%B8%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6" rel="nofollow">7、Mysql账号授权相应的文件</a></p>

<p id="8%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0" rel="nofollow">8、数据库初始化&nbsp;</a></p>

<p id="9%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%86%E5%A4%87-toc" style="margin-left:80px;"><a href="#9%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%86%E5%A4%87" rel="nofollow">9、配置文件的准备</a></p>

<p id="10%E3%80%81%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:80px;"><a href="#10%E3%80%81%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">10、启动数据库</a></p>

<p id="11%E3%80%81%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-toc" style="margin-left:80px;"><a href="#11%E3%80%81%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8" rel="nofollow">11、如何分析处理MySQL数据库无法启动</a></p>

<p id="12%E3%80%81%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81%E7%9A%84%E8%AE%BE%E5%AE%9A%EF%BC%88root%40localhost%EF%BC%89-toc" style="margin-left:80px;"><a href="#12%E3%80%81%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81%E7%9A%84%E8%AE%BE%E5%AE%9A%EF%BC%88root%40localhost%EF%BC%89" rel="nofollow">12、管理员密码的设定（root@localhost）</a></p>

<p id="13%E3%80%81%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E4%BA%86%EF%BC%9F-toc" style="margin-left:80px;"><a href="#13%E3%80%81%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E4%BA%86%EF%BC%9F" rel="nofollow">13、管理员用户密码忘记了？</a></p>

<p id="14%E3%80%81%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E7%BB%B4%E6%8A%A4%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#14%E3%80%81%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E7%BB%B4%E6%8A%A4%E6%A8%A1%E5%BC%8F" rel="nofollow">14、启动数据库到维护模式</a></p>

<hr id="hr-toc"><blockquote>
<p>RDBMS : 关系型数据库 管理系统</p>

<p>NoSQL : 非关系型的</p>

<p>NewSQL : 新型的分布式解决方案</p>
</blockquote>

<p></p>

<h3 id="1%E3%80%81%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%A4%84%E7%90%86%E5%8E%9F%E5%A7%8B%E7%8E%AF%E5%A2%83">1、用户的创建处理原始环境</h3>

<p></p>

<pre><code class="language-bash">[root@db01 ~]# yum remove mariadb-libs-5.5.60-1.el7_5.x86_64 -y
[root@db01 ~]# rpm -qa |grep mariadb
[root@db01 ~]# useradd -s /sbin/nologin mysql</code></pre>

<p>MySQL 5.7.26 二进制版本安装</p>

<p><a href="https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz" rel="nofollow">https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</a></p>

<p></p>

<h3 id="2%E3%80%81%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6">2、下载，上传文件</h3>

<pre><code class="language-bash">[root@db01 ~]# mkdir -p /server/tools
[root@db01 ~]# cd /server/tools/
[root@db01 /server/tools]# yum install -y lrzsz
[root@db01 /server/tools]# ls
mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</code></pre>

<p><img alt="" height="419" src="https://img-blog.csdnimg.cn/20200609161515666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="431"></p>

<p></p>

<h3 id="3%E3%80%81%E8%A7%A3%E5%8E%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85">3、解压二进制包</h3>

<pre><code class="language-bash">[root@db01 /server/tools]# tar xf mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz 
[root@db01 ~]# mkdir /application
[root@db01 /server/tools]# mv mysql-5.7.26-linux-glibc2.12-x86_64  /application/mysql</code></pre>

<p>&nbsp;</p>

<p><strong>基本思路</strong>：把<span style="color:#f33b45;">软件存放位置</span>和<span style="color:#7c79e5;">数据存放位置</span>分开，确保数据安全</p>

<p><img alt="" height="494" src="https://img-blog.csdnimg.cn/20200609161557901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="537"></p>

<h3 id="4%E3%80%81%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%A3%81%E7%9B%98%EF%BC%8C%E6%8C%82%E8%BD%BD%2Fdata%E6%95%B0%E6%8D%AE">4、添加一个磁盘，挂载/data数据</h3>

<p></p>

<p><img alt="" height="97" src="https://img-blog.csdnimg.cn/20200609161751738.png" width="487"></p>

<p><img alt="" height="330" src="https://img-blog.csdnimg.cn/20200609161809689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="607"></p>

<h3 id="5%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E5%B9%B6%E6%8E%88%E6%9D%83">5、创建数据路径并授权</h3>

<pre><code class="language-bash">[root@db01 ~]# mkfs.xfs /dev/sdc
[root@db01 ~]# mkdir /mysql
[root@db01 ~]# blkid
[root@db01 ~]# vim /etc/fstab 
[root@db01 ~]# UUID="7d7814c3-1ad2-4622-a435-7086d05d6c55" /mysql xfs defaults 0 0
[root@db01 ~]# mount -a
[root@db01 ~]# df -h</code></pre>

<p><img alt="" height="159" src="https://img-blog.csdnimg.cn/20200609161923453.png" width="606"></p>

<p><img alt="" height="117" src="https://img-blog.csdnimg.cn/20200609161932212.png" width="623"></p>

<p><img alt="" height="258" src="https://img-blog.csdnimg.cn/20200609161940465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="616"></p>

<h3></h3>

<h3 id="6%E3%80%81%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">6、设置环境变量</h3>

<p></p>

<pre><code class="language-bash">vim /etc/profile
export PATH=/application/mysql/bin:$PATH
[root@db01 ~]# source /etc/profile
[root@db01 ~]# mysql -V
mysql  Ver 14.14 Distrib 5.7.26, for linux-glibc2.12 (x86_64) using  EditLine wrapper</code></pre>

<p><img alt="" height="90" src="https://img-blog.csdnimg.cn/20200609161839500.png" width="623"></p>

<h3 id="7%E3%80%81Mysql%E8%B4%A6%E5%8F%B7%E6%8E%88%E6%9D%83%E7%9B%B8%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6">7、Mysql账号授权相应的文件</h3>

<pre><code class="language-bash">授权 
 chown -R mysql.mysql /application/*
 chown -R mysql.mysql /mysql</code></pre>

<h3 id="8%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0">8、数据库初始化&nbsp;</h3>

<pre><code class="language-bash">5.6 版本 初始化命令  /application/mysql/scripts/mysql_install_db 
# 5.7 版本
[root@db01 ~]# mkdir /mysql/mysql/data -p 
[root@db01 ~]# chown -R mysql.mysql /mysql
[root@db01 ~]# mysqld --initialize --user=mysql --basedir=/application/mysql --datadir=/mysql/mysql/data </code></pre>

<p><img alt="" height="228" src="https://img-blog.csdnimg.cn/20200609162239455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1087"></p>

<p>&nbsp;</p>

<p><strong>说明：</strong></p>

<p></p>

<p><span style="color:#f33b45;"><strong>--initialize 参数：</strong></span></p>

<ul><li>1. 对于密码复杂度进行定制：12位，4种</li>
	<li>2. 密码过期时间：180</li>
	<li>3. 给root@localhost用户设置临时密码</li>
</ul><p><span style="color:#f33b45;"><strong>--initialize-insecure 参数：</strong></span></p>

<p>无限制，无临时密码</p>

<p></p>

<pre><code class="language-bash">[root@db01 /data/mysql/data]# \rm -rf /data/mysql/data/*
[root@db01 ~]# mysqld --initialize-insecure --user=mysql --basedir=/application/mysql --datadir=/mysql/mysql/data</code></pre>

<p>没有密码</p>

<p><img alt="" height="181" src="https://img-blog.csdnimg.cn/20200609162224248.png" width="927"></p>

<h3 id="9%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%86%E5%A4%87">9、配置文件的准备</h3>

<p></p>

<pre><code class="language-bash">cat &gt;/etc/my.cnf &lt;&lt;EOF
[mysqld]
user=mysql
basedir=/application/mysql
datadir=/mysql/mysql/data
socket=/tmp/mysql.sock
server_id=6
port=3306
[mysql]
socket=/tmp/mysql.sock
EOF</code></pre>

<h3 id="10%E3%80%81%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93">10、启动数据库</h3>

<p></p>

<p><strong>1. sys-v</strong></p>

<pre><code class="language-bash">[root@db01 /etc/init.d]# cp /application/mysql/support-files/mysql.server  /etc/init.d/mysqld 
[root@db01 /etc/init.d]# service mysqld restart</code></pre>

<p><img alt="" height="160" src="https://img-blog.csdnimg.cn/20200609162358130.png" width="625"></p>

<p><strong>2. systemd</strong></p>

<p></p>

<p>注意： sysv方式启动过的话，需要先提前关闭，才能以下方式登录</p>

<pre><code class="language-bash">cat &gt;/etc/systemd/system/mysqld.service &lt;&lt;EOF
[Unit]
Description=MySQL Server
Documentation=man:mysqld(8)
Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html
After=network.target
After=syslog.target
[Install]
WantedBy=multi-user.target
[Service]
User=mysql
Group=mysql
ExecStart=/application/mysql/bin/mysqld --defaults-file=/etc/my.cnf
LimitNOFILE = 5000
EOF</code></pre>

<p><img alt="" height="519" src="https://img-blog.csdnimg.cn/20200609162443134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="749"></p>

<h3 id="11%E3%80%81%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8">11、如何分析处理MySQL数据库无法启动</h3>

<p></p>

<p>without updating PID 类似错误</p>

<p><strong>查看日志：</strong></p>

<blockquote>
<p>在哪？</p>

<p>/data/mysql/data/主机名.err</p>

<p>[ERROR] 上下文</p>
</blockquote>

<p><strong>可能情况：</strong></p>

<blockquote>
<p>/etc/my.cnf 路径不对等</p>

<p>/tmp/mysql.sock文件修改过 或 删除过</p>

<p>数据目录权限不是mysql</p>

<p>参数改错了</p>
</blockquote>

<p></p>

<h3 id="12%E3%80%81%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81%E7%9A%84%E8%AE%BE%E5%AE%9A%EF%BC%88root%40localhost%EF%BC%89">12、管理员密码的设定（root@localhost）</h3>

<p></p>

<pre><code class="language-bash">[root@db01 ~]# mysqladmin -uroot -p password oldboy123
Enter password: </code></pre>

<h3 id="13%E3%80%81%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E4%BA%86%EF%BC%9F">13、管理员用户密码忘记了？</h3>

<p></p>

<pre><code class="language-bash">--skip-grant-tables  #跳过授权表
--skip-networking    #跳过远程登录</code></pre>

<h3 id="14%E3%80%81%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E7%BB%B4%E6%8A%A4%E6%A8%A1%E5%BC%8F">14、启动数据库到维护模式</h3>

<p></p>

<pre><code class="language-bash">[root@db01 ~]# mysqld_safe --skip-grant-tables --skip-networking &amp;</code></pre>

<p>登录并修改密码</p>

<p></p>

<pre><code class="language-bash">mysql&gt; alter user root@'localhost' identified by '1';
ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement
mysql&gt; flush privileges;
mysql&gt; alter user root@'localhost' identified by '1';
Query OK, 0 rows affected (0.01 sec)</code></pre>

<p><img alt="" height="195" src="https://img-blog.csdnimg.cn/20200609162657818.png" width="620"></p>

<p>关闭数据库，正常启动验证</p>

<p></p>

<p>&nbsp;</p>

<p></p>
                                    ]]></description></item><item><title>MySQL--备份恢复【Mysqdump+xtrabackup（XBK）】</title><link>http://www.cnblogs.com/heian99/archive/2020/05/28/13203457.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 28 May 2020 09:19:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/05/28/13203457.html</guid><description><![CDATA[
                                            <h2>1.运维在数据库备份恢复方面的职责</h2>

<p><strong>1.设计备份策略</strong></p>

<blockquote>
<p>全备 、增量、时间、自动</p>
</blockquote>

<p><strong>2.日常备份检查</strong></p>

<blockquote>
<ol><li>备份存在性</li>
	<li>备份空间够用否</li>
</ol></blockquote>

<p><strong>&nbsp;3.定期恢复演练(测试库)</strong></p>

<blockquote>
<p>一季度 或者 半年</p>
</blockquote>

<p><strong>4.故障恢复</strong></p>

<blockquote>
<p>通过现有备份,能够将数据库恢复到故障之前的时间点. &nbsp;</p>
</blockquote>

<p><strong>5.迁移</strong></p>

<blockquote>
<p>1. 停机时间<br>
2. 回退方案</p>
</blockquote>

<h2><strong>2.Mysql数据损坏类型</strong></h2>

<p><strong>1.物理损坏</strong></p>

<blockquote>
<p>磁盘损坏：硬件，磁道坏，dd，格式化</p>

<p>文件损坏：数据文件损坏，redo损坏</p>
</blockquote>

<p><strong>2.逻辑损坏</strong></p>

<pre><code class="language-bash">drop
delete
truncate
update</code></pre>

<h2>3. 备份类型</h2>

<p><strong>1.热备</strong></p>

<blockquote>
<p>在数据库正常业务时,备份数据,并且能够一致性恢复（只能是innodb）</p>

<p>对业务影响非常小</p>
</blockquote>

<p><strong>2.温备</strong></p>

<blockquote>
<p>锁表备份,只能查询不能修改（myisam）<br>
影响到写入操作</p>
</blockquote>

<p><strong>3.冷备</strong></p>

<blockquote>
<p>关闭数据库业务,数据库没有任何变更的情况下,进行备份数据.<br>
业务停止</p>
</blockquote>

<h2>4. 备份方式及工具介绍</h2>

<p><strong>1.逻辑备份工具</strong></p>

<pre><code class="language-bash">基于SQL语句进行备份
mysqldump       *****
mysqlbinlog     *****</code></pre>

<p><strong>2. 物理备份工具</strong></p>

<pre><code class="language-bash">基于磁盘数据文件备份
xtrabackup(XBK) ：percona 第三方   *****
MySQL Enterprise Backup（MEB）</code></pre>

<h2>5. 逻辑备份和物理备份的比较</h2>

<p>&nbsp;mysqldump (MDP)</p>

<p><span style="color:#f33b45;"><strong>优点：</strong></span></p>

<ul><li>1.不需要下载安装</li>
	<li>2.备份出来的是SQL，文本格式，可读性高,便于备份处理</li>
	<li>3.压缩比较高，节省备份的磁盘空间</li>
</ul><p><span style="color:#f33b45;"><strong>缺点：</strong></span></p>

<ul><li>依赖于数据库引擎，需要从磁盘把数据读出，然后转换成SQL进行转储，比较耗费资源，数据量大的话效率较低</li>
</ul><p><span style="color:#f33b45;"><strong>建议：</strong></span></p>

<ul><li>100G以内的数据量级，可以使用mysqldump</li>
	<li>超过TB以上，我们也可能选择的是mysqldump，配合分布式的系统</li>
	<li>1EB &nbsp;=1024 PB =1000000 TB</li>
</ul><h2>6.备份策略</h2>

<p><strong>备份方式：</strong></p>

<ul><li>全备:全库备份，备份所有数据</li>
	<li>增量:备份变化的数据</li>
</ul><p><strong>备份工具</strong></p>

<ul><li>逻辑备份=mysqldump+mysqlbinlog</li>
	<li>物理备份=xtrabackup_full+xtrabackup_incr+binlog或者xtrabackup_full+binlog</li>
</ul><p><strong>备份周期:</strong></p>

<ul><li>根据数据量设计备份周期</li>
	<li>比如：周日全备，周1-周6增量</li>
</ul><p><strong>备份监控</strong></p>

<ul><li>备份空间</li>
	<li>备份日志</li>
</ul><h2>7.容灾策略</h2>

<p><strong>备份</strong></p>

<p><strong>架构</strong></p>

<ul><li>高可用&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;负载均衡</li>
	<li>演示从库&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主从同步</li>
	<li>灾备库&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;异地备份</li>
</ul><p><strong>定期的故障恢复演练</strong></p>

<h2>8.mysqldump应用</h2>

<p><strong>介绍：逻辑备份工具。备份的是sql语句</strong></p>

<p><strong>备份方式</strong></p>

<p>InnoDB</p>

<blockquote>
<ul><li>可以采取快照备份的方式</li>
	<li>开启一个独立的事务，获取当前最新的一致性快照，将快照数据，放在临时表中，转换成SQL（Create database，create table，insert），保存到sql文件中</li>
</ul></blockquote>

<p>非InnoDB</p>

<blockquote>
<ul><li>需要锁表备份。触发FTWRL，全局锁表。</li>
	<li>将快照数据，放在临时表中，转换成SQL（Create database，create table，insert），保存到sql文件中</li>
</ul></blockquote>

<p><strong>核心参数</strong></p>

<p>建立备份目录，授权</p>

<pre><code class="language-bash">mkdir -p /data/backup
chown -R mysql.mysql /data/backup/</code></pre>

<h3><strong>连接参数</strong></h3>

<ul><li>-u &nbsp;#用户</li>
	<li>-p &nbsp;#密码</li>
	<li>-h &nbsp; #主机地址</li>
	<li>-P &nbsp; #端口</li>
	<li>-S &nbsp;#socket连接</li>
	<li>-A &nbsp; #全备</li>
</ul><pre><code class="language-bash"> mysqldump -uroot -proot -A &gt;/data/backup/full.sql</code></pre>

<ul><li>-B &nbsp;#备份一个或者多个</li>
</ul><pre><code class="language-bash">mysqldump -uroot -proot -B gtid gtid2  &gt;/data/backup/db.sql</code></pre>

<p><strong>备份库下的多个表（不加参数）</strong></p>

<pre><code class="language-bash"> mysqldump -uroot -proot gtid t1 t1 &gt;/data/backup/db.sql</code></pre>

<h3><strong>备份高级参数</strong></h3>

<pre><code class="language-bash">--master-data=2</code></pre>

<pre><code class="language-bash">以注释的形式,保存备份开始时间点的binlog的状态信息

mysqldump -uroot -p  -A  -R --triggers --master-data=2   &gt;/back/world.sql
[root@db01 ~]# grep 'CHANGE' /backup/world.sql 
-- CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000035', MASTER_LOG_POS=194;

功能：
（1）在备份时，会自动记录，二进制日志文件名和位置号
0 默认值
1  以change master to命令形式，可以用作主从复制
2  以注释的形式记录，备份时刻的文件名+postion号
（2） 自动锁表
（3）如果配合--single-transaction，只对非InnoDB表进行锁表备份，InnoDB表进行“热“”备，实际上是实现快照备份。</code></pre>

<pre><code class="language-bash">--single-transaction</code></pre>

<pre><code class="language-bash">innodb 存储引擎开启热备(快照备份)功能       
master-data可以自动加锁
（1）在不加--single-transaction ，启动所有表的温备份，所有表都锁定
（1）加上--single-transaction ,对innodb进行快照备份,对非innodb表可以实现自动锁表功能
例子6: 备份必加参数
mysqldump -uroot -p -A -R -E --triggers --master-data=2  --single-transaction --set-gtid-purged=OFF &gt;/data/backup/full.sql
</code></pre>

<pre><code class="language-bash">--set-gtid-purged=auto</code></pre>

<pre><code class="language-bash">auto , on
off 
使用场景:
1. --set-gtid-purged=OFF,可以使用在日常备份参数中.
mysqldump -uroot -p -A -R -E --triggers --master-data=2  --single-transaction --set-gtid-purged=OFF &gt;/data/backup/full.sql
2. auto , on:在构建主从复制环境时需要的参数配置
mysqldump -uroot -p -A -R -E --triggers --master-data=2  --single-transaction --set-gtid-purged=ON &gt;/data/backup/full.sql</code></pre>

<pre><code>--max-allowed-packet=#</code></pre>

<pre><code class="language-bash">mysqldump -uroot -p -A -R -E --triggers --master-data=2  --single-transaction --set-gtid-purged=OFF --max-allowed-packet=256M &gt;/data/backup/full.sql

 --max-allowed-packet=# 
The maximum packet length to send to or receive from server.
</code></pre>

<ul><li>-R &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;备份存储过程及函数</li>
	<li>--triggers &nbsp;备份触发器</li>
	<li>-E &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 备份事件</li>
</ul><p>&nbsp;</p>

<h3>生产备份语句（只是建议，根据自己需求来改）</h3>

<pre><code class="language-bash">mysqldump -uroot -p -A -R -E --triggers --master-data=2  --single-transaction --set-gtid-purged=OFF --max-allowed-packet=256M &gt;/data/backup/full.sql</code></pre>

<h3>练习&nbsp; &nbsp;实现所有表的单独备份</h3>

<pre><code class="language-bash">提示：
information_schema.tables
mysqldump -uroot -p123 world city &gt;/backup/world_city.sql

select concat("mysqldump -uroot -p123 ",table_schema," ",table_name," --master-data=2 --single-transaction --set-gtid-purged=0  -R -E --triggers&gt;/backup/",table_schema,"_",table_name,".sql") from information_schema.tables where table_schema not in ('sys','information_schema','performance_schema');</code></pre>

<h2>9. 备份时优化参数:</h2>

<pre><code>(1) max_allowed_packet   最大的数据包大小

mysqldump -uroot -p123 -A  -R  --triggers --set-gtid-purged=OFF --master-data=2 max_allowed_packet=128M  --single-transaction|gzip &gt; /backup/full_$(date +%F).sql.gz

(2) 增加key_buffer_size    (临时表有关)
(3) 分库分表并发备份       (作业)
(4) 架构分离,分别备份      (架构拆分,分布式备份)</code></pre>

<h2>10. MySQL物理备份工具-xtrabackup(XBK、Xbackup)</h2>

<p>安装并安装</p>

<pre><code class="language-bash">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.12/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm

https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/redhat/6/x86_64/percona-xtrabackup-24-2.4.4-1.el6.x86_64.rpm

yum -y install percona-xtrabackup-24-2.4.4-1.el7.x86_64.rpm</code></pre>

<p><strong>备份命令介绍:</strong></p>

<pre><code class="language-bash">xtrabackup
innobackupex    ******</code></pre>

<p><strong>备份方式——物理备份</strong></p>

<pre><code class="language-bash">（1）对于非Innodb表（比如 myisam）是，锁表cp数据文件，属于一种温备份。
（2）对于Innodb的表（支持事务的），不锁表，拷贝数据页，最终以数据文件的方式保存下来，把一部分redo和undo一并备走，属于热备方式。</code></pre>

<h3>xbk 在innodb表备份恢复的流程</h3>

<pre><code>  0、xbk备份执行的瞬间,立即触发ckpt,已提交的数据脏页,从内存刷写到磁盘,并记录此时的LSN号
  1、备份时，拷贝磁盘数据页，并且记录备份过程中产生的redo和undo一起拷贝走,也就是checkpoint LSN之后的日志
  2、在恢复之前，模拟Innodb“自动故障恢复”的过程，将redo（前滚）与undo（回滚）进行应用
  3、恢复过程是cp 备份到原来数据目录下</code></pre>

<h3>innobackupex使用</h3>

<p><strong>全备</strong></p>

<pre><code class="language-bash">innobackupex --user=root --password=123  /data/backup</code></pre>

<p><strong>自主定制备份路径名</strong></p>

<pre><code class="language-bash"> innobackupex --user=root --password=123 --no-timestamp /data/backup/full</code></pre>

<p><strong>备份集中多出来的文件：</strong></p>

<pre><code class="language-bash">-rw-r----- 1 root root       24 Jun 29 09:59 xtrabackup_binlog_info
-rw-r----- 1 root root      119 Jun 29 09:59 xtrabackup_checkpoints
-rw-r----- 1 root root      489 Jun 29 09:59 xtrabackup_info
-rw-r----- 1 root root     2560 Jun 29 09:59 xtrabackup_logfile

xtrabackup_binlog_info ：（备份时刻的binlog位置）
[root@db01 full]# cat xtrabackup_binlog_info 
mysql-bin.000003    536749
79de40d3-5ff3-11e9-804a-000c2928f5dd:1-7
记录的是备份时刻，binlog的文件名字和当时的结束的position，可以用来作为截取binlog时的起点。

xtrabackup_checkpoints ：
backup_type = full-backuped
from_lsn = 0            上次所到达的LSN号(对于全备就是从0开始,对于增量有别的显示方法)
to_lsn = 160683027      备份开始时间(ckpt)点数据页的LSN    
last_lsn = 160683036    备份结束后，redo日志最终的LSN
compact = 0
recover_binlog_info = 0
（1）备份时刻，立即将已经commit过的，内存中的数据页刷新到磁盘(CKPT).开始备份数据，数据文件的LSN会停留在to_lsn位置。
（2）备份时刻有可能会有其他的数据写入，已备走的数据文件就不会再发生变化了。
（3）在备份过程中，备份软件会一直监控着redo的undo，如果一旦有变化会将日志也一并备走，并记录LSN到last_lsn。
从to_lsn  ----》last_lsn 就是，备份过程中产生的数据变化.</code></pre>

<h2>&nbsp;innobackupex 增量备份(incremental)</h2>

<ul><li>（1）增量备份的方式，是基于上一次备份进行增量。</li>
	<li>（2）增量备份无法单独恢复。必须基于全备进行恢复。</li>
	<li>（3）所有增量必须要按顺序合并到全备中。</li>
</ul><h3><img alt="" height="470" src="https://img-blog.csdnimg.cn/20200528171555177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></h3>

<h3><img alt="" height="532" src="https://img-blog.csdnimg.cn/2020052817161814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></h3>

<h3>增量备份命令</h3>

<pre><code class="language-bash">（1）删掉原来备份
略.
（2）全备（周日）
[root@db01 backup]# innobackupex --user=root --password --no-timestamp /backup/full &gt;&amp;/tmp/xbk_full.log
（3）模拟周一数据变化
db01 [(none)]&gt;create database cs charset utf8;
db01 [(none)]&gt;use cs
db01 [cs]&gt;create table t1 (id int);
db01 [cs]&gt;insert into t1 values(1),(2),(3);
db01 [cs]&gt;commit;

（4）第一次增量备份（周一）
innobackupex --user=root --password=123 --no-timestamp --incremental --incremental-basedir=/backup/full  /backup/inc1 &amp;&gt;/tmp/inc1.log
（5）模拟周二数据
db01 [cs]&gt;create table t2 (id int);
db01 [cs]&gt;insert into t2 values(1),(2),(3);
db01 [cs]&gt;commit;
（6）周二增量
 innobackupex --user=root --password=123 --no-timestamp --incremental --incremental-basedir=/backup/inc1  /backup/inc2  &amp;&gt;/tmp/inc2.log
（7）模拟周三数据变化
db01 [cs]&gt;create table t3 (id int);
db01 [cs]&gt;insert into t3 values(1),(2),(3);
db01 [cs]&gt;commit;
db01 [cs]&gt;drop database cs;</code></pre>

<p>恢复到周三误drop之前的数据状态</p>

<pre><code class="language-bash">恢复思路：
1.  挂出维护页，停止当天的自动备份脚本
2.  检查备份：周日full+周一inc1+周二inc2，周三的完整二进制日志
3. 进行备份整理（细节），截取关键的二进制日志（从备份——误删除之前）
4. 测试库进行备份恢复及日志恢复
5. 应用进行测试无误，开启业务
6. 此次工作的总结</code></pre>

<p>恢复过程</p>

<pre><code class="language-bash">1. 检查备份
1afe8136-601d-11e9-9022-000c2928f5dd:7-9
2. 备份整理（apply-log）+合并备份（full+inc1+inc2）
(1) 全备的整理
[root@db01 one]# innobackupex --apply-log --redo-only /data/backup/full
(2) 合并inc1到full中
[root@db01 one]# innobackupex --apply-log --redo-only --incremental-dir=/data/backup/inc1 /data/backup/full
(3) 合并inc2到full中
[root@db01 one]# innobackupex --apply-log  --incremental-dir=/data/backup/inc2 /data/backup/full
(4) 最后一次整理全备
[root@db01 backup]#  innobackupex --apply-log  /data/backup/full
3. 截取周二 23:00 到drop 之前的 binlog 
[root@db01 inc2]# mysqlbinlog --skip-gtids --include-gtids='1afe8136-601d-11e9-9022-000c2928f5dd:7-9' /data/binlog/mysql-bin.000009 &gt;/data/backup/binlog.sql
4. 进行恢复
[root@db01 backup]# mkdir /data/mysql/data2 -p
[root@db01 full]# cp -a * /data/mysql/data2
[root@db01 backup]# chown -R mysql.  /data/*
[root@db01 backup]# systemctl stop mysqld
vim /etc/my.cnf
datadir=/data/mysql/data2
systemctl start mysqld
Master [(none)]&gt;set sql_log_bin=0;
Master [(none)]&gt;source /data/backup/binlog.sql</code></pre>

<p>下面是我画的思维导图，可以很快加强记忆。</p>

<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/2020052817175226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Mysql日志分析（错误日志，Binlog日志，慢日志），有惊喜哦</title><link>http://www.cnblogs.com/heian99/archive/2020/05/27/13203458.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 27 May 2020 09:52:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/05/27/13203458.html</guid><description><![CDATA[
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h1><a id="Mysql_0"></a>Mysql日志</h1>
<h2><a id="1_2"></a>1.错误日志</h2>
<h3><a id="1_4"></a>1.作用</h3>
<p><strong>- 排查MySQL运行过程的故障.</strong></p>
<h3><a id="2_8"></a>2.默认配置</h3>
<ul>
<li>
<pre><code>1.默认就开启了
</code></pre>
</li>
<li>
<pre><code>2.默认路径和名字: datadir/hostname.err
</code></pre>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020052717320827.png" alt="在这里插入图片描述"></p>
<h3><a id="3_15"></a>3.人为定制位置</h3>
<pre><code class="prism language-bash">- log_error<span class="token operator">=</span>/tmp/mysql.log
</code></pre>
<p>重启生效</p>
<pre><code class="prism language-bash">show variables like <span class="token string">'log_error'</span><span class="token punctuation">;</span>
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200527173404582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><a id="binlog_28"></a>二进制日志(binlog)</h2>
<h3><a id="1_30"></a>1.作用</h3>
<p><strong>- (1)备份恢复必须依赖二进制日志</strong><br>
<strong>- (2)主从环境必须依赖二进制日志</strong></p>
<h3><a id="2_binlog_57server_id_35"></a>2. binlog配置 (5.7必须加server_id)</h3>
<pre><code>    1.默认：8.0版本以前，没有开启（注意：MySQL默认是没有开启二进制日志的
	说明：和数据盘分开，防止数据盘损坏，导致binlong无法恢复
	2.默认配置方法

	server_id=6   # 主机编号。主从使用，    5.7以后开启binlog要加此参数                        
	log_bin=/data/binlog/mysql-bin #日志存放目录+日志名前缀，例如：mysql-bin.000001
	sync_binlog=1   #binlog日志刷盘策略，双一的第二个1。每次事务提交立即刷写binlog到磁盘
	binlog_format=row  #binlog的记录格式为row模式
	重启完成
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200527173938813.png" alt="在这里插入图片描述"></p>
<p><strong>- 基础参数查看</strong></p>
<pre><code>- 开关（1：表示开启）

	- select @@log_bin;

- 日志路径及名字

	- select @@log_bin_basename;

- 服务ID号

	- select @@server_id;

- 二进制日志格式

	- select @@binlog_format;

- 双一标准之二

	- select @@sync_binlog;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200527173958351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/2020052717400897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3><a id="3_72"></a>3.二进制内置查看命令</h3>
<ul>
<li>查看一目前有几个日志binlog</li>
</ul>
<pre><code class="prism language-bash"> show binary logs<span class="token punctuation">;</span>
</code></pre>
<ul>
<li>查看当前在使用的binlog</li>
</ul>
<pre><code class="prism language-bash"> show master status<span class="token punctuation">;</span>
</code></pre>
<ul>
<li>查看二进制事件</li>
</ul>
<pre><code class="prism language-bash"> show binlog events <span class="token keyword">in</span> <span class="token string">'mysql-bin.000001 '</span><span class="token punctuation">;</span>
</code></pre>
<h3><a id="binlog_93"></a>binlog文件内容详细查看</h3>
<pre><code class="prism language-bash">- mysql  -uroot  -proot  -e  <span class="token string">"show binlog events in 'mysql-bin.000001'"</span>
- 普通查看  mysqlbinlog 

	- mysqlbinlog   /mysql/mysql/data/binlog/mysql-bin.000001 <span class="token operator">&gt;</span> a.sql   <span class="token comment">#把binlog到成sql文件</span>

- 翻译查看

	- mysqlbinlog  --base64-output<span class="token operator">=</span>decode-rows  -vvv /data/binlog/mysql-bin.000003

- 基于时间查看

	- mysqlbinlog  --start-datetime<span class="token operator">=</span><span class="token string">'2019-05-06 17:00:00'</span>   --stop-datetime<span class="token operator">=</span><span class="token string">'2019-05-06 17:01:00'</span>    /data/binlog/mysql-bin.000004 

- 基于Position号进行日志截取

	- mysqlbinlog  --start-position<span class="token operator">=</span>219  --stop-position<span class="token operator">=</span>1347  /data/binlog/mysql-bin.000003 <span class="token operator">&gt;</span>/tmp/bin.sql

- 数据恢复

-   <span class="token keyword">set</span> sql_log_bin<span class="token operator">=</span>0<span class="token punctuation">;</span>
	<span class="token function">source</span> /tmp/bin.sql
</code></pre>
<h3><a id="binlog_119"></a>binlog维护操作</h3>
<p><strong>- 1.日志滚动</strong></p>
<pre><code>- flush logs；
- mysqladmin -uroot -proot flush-logs
- 自动滚动，默认1G滚动一次，可以设置参数
- select @@max_binlog_size;
- mysqldump -F
- 重启数据自动滚动
</code></pre>
<p><strong>- 2.日志的删除</strong></p>
<pre><code>- 注意：不要使用rm命令删除日志
- 自动删除（默认：0 永不删除，单位是天）

- select @@expire_logs_days; 

- 问题：到底设置多少天合适？    一个全备周期（7+1）天，一般生产一遍建议2个全备周期+1

- show variables like '%expire%';


expire_logs_days  0   
自动清理时间,是要按照全备周期+1
set global expire_logs_days=8;
永久生效:
my.cnf
expire_logs_days=15;
企业建议,至少保留两个全备周期+1的binlog
</code></pre>
<pre><code class="prism language-bash">- 手工删除

		- PURGE BINARY LOGS TO <span class="token string">'mysql-bin.010'</span><span class="token punctuation">;</span>
		- PURGE BINARY LOGS BEFORE <span class="token string">'2008-04-02 22:46:26'</span><span class="token punctuation">;</span>

	- 全部清空

		-  reset master<span class="token punctuation">;</span>

			- 比较危险，在主从执行此操作，主从必宕机
</code></pre>
<h2><a id="binlogGTID_165"></a>binlog日志的GTID新特性</h2>
<h3><a id="1GTID__167"></a>1.GTID 介绍</h3>
<pre><code>- 5.6 版本新加的特性,5.7中做了加强
5.6 中不开启,没有这个功能.
5.7 中的GTID,即使不开也会有自动生成
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'

- 对于一个已提交事务的编号，并且是一个全局唯一的编号。
它的官方定义如下：

GTID = source_id ：transaction_id
7E11FA47-31CA-19E1-9E56-C43AA21293967:29
</code></pre>
<h3><a id="2_180"></a>2.开启参数</h3>
<pre><code>开启的参数
    gtid-mode=on
	enforce-gtid-consistency=true
查看
- select @@gtid_mode;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200527174329550.png" alt="在这里插入图片描述"></p>
<h3><a id="3GTID_188"></a>3.具备GTID后,截取查看某些事务日志</h3>
<pre><code> --include-gtids
 --exclude-gtids
 --skip-gtids
</code></pre>
<h3><a id="4_194"></a>4.数据截取</h3>
<ul>
<li><code>mysqlbinlog --skip-gtids --include-gtids='3ca79ab5-3e4d-11e9-a709-000c293b577e:1-9' mysql-bin.000002 mysql-bin.000003 &gt; /tmp/gtid.sql</code></li>
</ul>
<h3><a id="5_198"></a>5.数据恢复</h3>
<pre><code class="prism language-bash"><span class="token keyword">set</span> sql_log_bin<span class="token operator">=</span>0<span class="token punctuation">;</span>
<span class="token function">source</span> /tmp/bin.sql
</code></pre>
<h2><a id="slowlog_207"></a>慢日志(slow-log)</h2>
<h3><a id="1__209"></a>1 作用：记录运行较慢的语句,优化过程中常用的工具日志.</h3>
<h3><a id="2_211"></a>2.配置方法（默认没开启）</h3>
<pre><code>select @@slow_query_log;      #0表示关闭

select @@slow_query_log_file;     #文件存放文字
</code></pre>
<p>** 开关:**</p>
<pre><code class="prism language-bash">slow_query_log<span class="token operator">=</span>1 
</code></pre>
<p><strong>文件位置及名字</strong></p>
<pre><code class="prism language-bash">slow_query_log_file<span class="token operator">=</span>/data/mysql/slow.log
</code></pre>
<p><strong>设定慢查询时间:</strong></p>
<pre><code class="prism language-bash">long_query_time<span class="token operator">=</span>0.1
</code></pre>
<p><strong>没走索引的语句也记录:</strong></p>
<pre><code class="prism language-c">log_queries_not_using_indexes
</code></pre>
<pre><code class="prism language-bash">vim /etc/my.cnf
slow_query_log<span class="token operator">=</span>1 
slow_query_log_file<span class="token operator">=</span>/data/mysql/slow.log
long_query_time<span class="token operator">=</span>0.1
log_queries_not_using_indexes
systemctl restart mysqld
</code></pre>
<h3><a id="3mysqldumpslow__250"></a>3.mysqldumpslow 分析慢日志</h3>
<ul>
<li><code>mysqldumpslow -s c -t 10 /data/mysql/slow.log</code></li>
<li>
<h1><a id="_253"></a>第三方工具(自己扩展)</h1>
</li>
</ul>
<pre><code class="prism language-bash">https://www.percona.com/downloads/percona-toolkit/LATEST/
yum <span class="token function">install</span> perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl-Digest-MD5
</code></pre>
<pre><code>- toolkit工具包中的命令:
</code></pre>
<pre><code class="prism language-bash">./pt-query-diagest  /data/mysql/slow.log
Anemometer基于pt-query-digest将MySQL慢查询可视化
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200527175023286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

                                    ]]></description></item><item><title>Mysql多实例启动</title><link>http://www.cnblogs.com/heian99/archive/2020/05/19/13203459.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 19 May 2020 09:56:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/05/19/13203459.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E5%A4%9A%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">多实例的应用</a></p>

<p id="1%E3%80%81%E5%87%86%E5%A4%87%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%87%86%E5%A4%87%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95" rel="nofollow">1、准备多个目录</a></p>

<p id="2%E3%80%81%E5%87%86%E5%A4%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%87%86%E5%A4%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">2、准备配置文件</a></p>

<p id="3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%89%E5%A5%97%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%89%E5%A5%97%E6%95%B0%E6%8D%AE" rel="nofollow">3、初始化三套数据</a></p>

<p id="4%E3%80%81systemd%E7%AE%A1%E7%90%86%E5%A4%9A%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#4%E3%80%81systemd%E7%AE%A1%E7%90%86%E5%A4%9A%E5%AE%9E%E4%BE%8B" rel="nofollow">4、systemd管理多实例</a></p>

<p id="5%E3%80%81%E6%8E%88%E6%9D%83-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E6%8E%88%E6%9D%83" rel="nofollow">5、授权</a></p>

<p id="6%E3%80%81%E5%90%AF%E5%8A%A8-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E5%90%AF%E5%8A%A8" rel="nofollow">6、启动</a></p>

<p id="7%E3%80%81%E9%AA%8C%E8%AF%81%E5%A4%9A%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E9%AA%8C%E8%AF%81%E5%A4%9A%E5%AE%9E%E4%BE%8B" rel="nofollow">7、验证多实例</a></p>

<hr id="hr-toc"><p>Mysql下载</p>

<p><a href="https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz" rel="nofollow">https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</a></p>

<p>&nbsp;</p>

<p>Mysql版本：5.7.26</p>

<p>Mysql安装方式：二进制</p>

<p>&nbsp;</p>

<h2 id="%E5%A4%9A%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%BA%94%E7%94%A8">多实例的应用</h2>

<h3 id="1%E3%80%81%E5%87%86%E5%A4%87%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95">1、准备多个目录</h3>

<pre><code>mkdir -p /mysql/330{7,8,9}/data</code></pre>

<p>&nbsp;</p>

<h3 id="2%E3%80%81%E5%87%86%E5%A4%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">2、准备配置文件</h3>

<pre><code class="language-bash">cat &gt; /mysql/3307/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/application/mysql   #mysql安装路径
datadir=/mysql/3307/data     #mysql数据存放目录
socket=/mysql/3307/mysql.sock  #mysql的socket
log_error=/mysql/3307/mysql.log
port=3307
server_id=7
log_bin=/mysql/3307/mysql-bin
EOF

cat &gt; /mysql/3308/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/application/mysql
datadir=/mysql/3308/data
socket=/mysql/3308/mysql.sock
log_error=/mysql/3308/mysql.log
port=3308
server_id=8
log_bin=/mysql/3308/mysql-bin
EOF

cat &gt; /mysql/3309/my.cnf &lt;&lt;EOF
[mysqld]
basedir=/application/mysql
datadir=/mysql/3309/data
socket=/mysql/3309/mysql.sock
log_error=/mysql/3309/mysql.log
port=3309
server_id=9
log_bin=/mysql/3309/mysql-bin
EOF</code></pre>

<h3 id="3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%89%E5%A5%97%E6%95%B0%E6%8D%AE">3、初始化三套数据</h3>

<pre><code class="language-bash">mysqld --initialize-insecure  --user=mysql --datadir=/mysql/3307/data --basedir=/application/mysql
mysqld --initialize-insecure  --user=mysql --datadir=/mysql/3308/data --basedir=/application/mysql
mysqld --initialize-insecure  --user=mysql --datadir=/mysql/3309/data --basedir=/application/mysql</code></pre>

<h3 id="4%E3%80%81systemd%E7%AE%A1%E7%90%86%E5%A4%9A%E5%AE%9E%E4%BE%8B">4、systemd管理多实例</h3>

<pre><code class="language-bash">cd /etc/systemd/system
cp mysqld.service mysqld3307.service
cp mysqld.service mysqld3308.service
cp mysqld.service mysqld3309.service

vim mysqld3307.service
ExecStart=/app/mysql/bin/mysqld  --defaults-file=/mysql/3307/my.cnf
vim mysqld3308.service
ExecStart=/app/mysql/bin/mysqld  --defaults-file=/mysql/3308/my.cnf
vim mysqld3309.service
ExecStart=/app/mysql/bin/mysqld  --defaults-file=/mysql/3309/my.cnf</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h3 id="5%E3%80%81%E6%8E%88%E6%9D%83">5、授权</h3>

<pre><code class="language-bash">chown -R mysql.mysql /mysql/*</code></pre>

<p>&nbsp;</p>

<h3 id="6%E3%80%81%E5%90%AF%E5%8A%A8">6、启动</h3>

<pre><code class="language-bash">systemctl start mysqld3307.service
systemctl start mysqld3308.service
systemctl start mysqld3309.service</code></pre>

<h3 id="7%E3%80%81%E9%AA%8C%E8%AF%81%E5%A4%9A%E5%AE%9E%E4%BE%8B">7、验证多实例</h3>

<pre><code>netstat -lnp|grep 330
mysql -S /mysql/3307/mysql.sock -e "select @@server_id"
mysql -S /mysql/3308/mysql.sock -e "select @@server_id"
mysql -S /mysql/3309/mysql.sock -e "select @@server_id"</code></pre>

<p><img alt="" height="445" src="https://img-blog.csdnimg.cn/20200520102625482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="893"></p>
                                    ]]></description></item><item><title>Zabbix服务自定义监控和模板</title><link>http://www.cnblogs.com/heian99/archive/2020/05/13/13203460.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 13 May 2020 09:22:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/05/13/13203460.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:40px;">&nbsp;</p>

<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p>

<p id="%E5%A6%82%E4%BD%95%E5%85%A5%E6%89%8B%E7%9B%91%E6%8E%A7-toc" style="margin-left:40px;"><a href="#%E5%A6%82%E4%BD%95%E5%85%A5%E6%89%8B%E7%9B%91%E6%8E%A7" rel="nofollow">如何入手监控</a></p>

<p id="%E4%B8%80%E3%80%81zabbix%20%E5%BF%AB%E9%80%9F%E7%9B%91%E6%8E%A7%E4%B8%BB%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81zabbix%20%E5%BF%AB%E9%80%9F%E7%9B%91%E6%8E%A7%E4%B8%BB%E6%9C%BA" rel="nofollow">一、zabbix 快速监控主机</a></p>

<p id="1.%E5%AE%89%E8%A3%85zabbix-agent-toc" style="margin-left:80px;"><a href="#1.%E5%AE%89%E8%A3%85zabbix-agent" rel="nofollow">1.安装zabbix-agent</a></p>

<p id="2.%E9%85%8D%E7%BD%AEzabbix-agent(%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE)-toc" style="margin-left:80px;"><a href="#2.%E9%85%8D%E7%BD%AEzabbix-agent(%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE)" rel="nofollow">2.配置zabbix-agent(修改配置)</a></p>

<p id="3.%E5%90%AF%E5%8A%A8zabbix-agent%E5%B9%B6%E6%A3%80%E6%9F%A5-toc" style="margin-left:80px;"><a href="#3.%E5%90%AF%E5%8A%A8zabbix-agent%E5%B9%B6%E6%A3%80%E6%9F%A5" rel="nofollow">3.启动zabbix-agent并检查</a></p>

<p id="4.zabbix-web%E7%95%8C%E9%9D%A2%EF%BC%8C%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA-toc" style="margin-left:80px;"><a href="#4.zabbix-web%E7%95%8C%E9%9D%A2%EF%BC%8C%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA" rel="nofollow">4.zabbix-web界面，添加主机</a></p>

<p id="%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E4%B8%BB%E6%9C%BA%E5%B0%8F%E8%AF%95%E8%BA%AB%E6%89%8B-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E4%B8%BB%E6%9C%BA%E5%B0%8F%E8%AF%95%E8%BA%AB%E6%89%8B" rel="nofollow">二、自定义监控主机小试身手</a></p>

<p id="1.%E7%9B%91%E6%8E%A7%E9%9C%80%E6%B1%82-toc" style="margin-left:80px;"><a href="#1.%E7%9B%91%E6%8E%A7%E9%9C%80%E6%B1%82" rel="nofollow">1.监控需求</a></p>

<p id="2.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0" rel="nofollow">2.命令行实现</a></p>

<p id="3.%E7%BC%96%E5%86%99zabbix%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6(%E4%BC%A0%E5%8F%82%E5%BD%A2%E5%BC%8F)-toc" style="margin-left:80px;"><a href="#3.%E7%BC%96%E5%86%99zabbix%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6(%E4%BC%A0%E5%8F%82%E5%BD%A2%E5%BC%8F)" rel="nofollow">3.编写zabbix监控文件(传参形式)</a></p>

<p id="4.server%E7%AB%AF%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#4.server%E7%AB%AF%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">4.server端进行测试</a></p>

<p id="5.web%E7%AB%AF%E6%B7%BB%E5%8A%A0-toc" style="margin-left:40px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="#5.web%E7%AB%AF%E6%B7%BB%E5%8A%A0" rel="nofollow">5.web端添加</a></p>

<hr id="hr-toc"><h2 id="%E5%89%8D%E8%A8%80">前言</h2>

<p><strong><a href="https://blog.csdn.net/heian_99/article/details/106023595">Centos7安装Zabbix服务端、Zabbix客户端和Win客户端配置（源码编译安装）</a></strong></p>

<p>前面介绍怎么源码编译安装Zabbix和主机添加。下面要介绍怎么添加模板和自定义监控</p>

<h2 id="%E5%A6%82%E4%BD%95%E5%85%A5%E6%89%8B%E7%9B%91%E6%8E%A7">如何入手监控</h2>

<blockquote>
<p>1.硬件监控 路由器、交换机、防火墙<br>
2.系统监控 CPU、内存、磁盘、网络、进程、 TCP<br>
3.服务监控 nginx、 php、 tomcat、 redis、 memcache、 mysql<br>
4.WEB 监控 请求时间、响应时间、加载时间、<br>
5.日志监控 ELk（收集、存储、分析、展示） 日志易<br>
6.安全监控 Firewalld、 WAF(Nginx+lua)、安全宝、牛盾云、安全狗<br>
7.网络监控 smokeping 多机房<br>
8.业务监控 活动引入多少流量、产生多少注册量、带来多大价值</p>
</blockquote>

<h2 id="%E4%B8%80%E3%80%81zabbix%20%E5%BF%AB%E9%80%9F%E7%9B%91%E6%8E%A7%E4%B8%BB%E6%9C%BA">一、zabbix 快速监控主机</h2>

<h3 id="1.%E5%AE%89%E8%A3%85zabbix-agent"><strong>1.安装zabbix-agent</strong></h3>

<pre><code class="language-bash">rpm -ivh https://mirror.tuna.tsinghua.edu.cn/zabbix/zabbix/4.0/rhel/7/x86_64/zabbix-agent-4.0.4-1.el7.x86_64.rpm</code></pre>

<h3 id="2.%E9%85%8D%E7%BD%AEzabbix-agent(%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE)"><strong>2.配置zabbix-agent(<span style="color:#f33b45;">修改配置</span>)</strong></h3>

<pre><code class="language-bash">[root@kvm zabbix]# grep "^[a-Z]" /etc/zabbix/zabbix_agentd.conf
PidFile=/var/run/zabbix/zabbix_agentd.pid
LogFile=/var/log/zabbix/zabbix_agentd.log
LogFileSize=0
Server=192.168.1.10
ServerActive=192.168.1.10
Hostname=Zabbix_kvm
Include=/etc/zabbix/zabbix_agentd.d/*.conf
</code></pre>

<h3 id="3.%E5%90%AF%E5%8A%A8zabbix-agent%E5%B9%B6%E6%A3%80%E6%9F%A5"><strong>3.启动zabbix-agent并检查</strong></h3>

<p><img alt="" height="458" src="https://img-blog.csdnimg.cn/20200513165443770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="883"></p>

<h3 id="4.zabbix-web%E7%95%8C%E9%9D%A2%EF%BC%8C%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA"><strong>4.zabbix-web界面，添加主机</strong></h3>

<p><img alt="" height="596" src="https://img-blog.csdnimg.cn/20200513165608707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" height="839" src="https://img-blog.csdnimg.cn/20200513165718476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="978"></p>

<p><img alt="" height="239" src="https://img-blog.csdnimg.cn/2020051316595198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>这边配置自动发现和自动注册（可以自动发现和添加主机和模板）</strong></p>

<p><img alt="" height="252" src="https://img-blog.csdnimg.cn/20200513170035522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E4%B8%BB%E6%9C%BA%E5%B0%8F%E8%AF%95%E8%BA%AB%E6%89%8B">二、自定义监控主机小试身手</h2>

<h3 id="1.%E7%9B%91%E6%8E%A7%E9%9C%80%E6%B1%82">1.监控需求</h3>

<p>监控TCP3种状态集</p>

<h3 id="2.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0">2.命令行实现</h3>

<pre><code class="language-bash">[root@kvm zabbix]#  netstat -ant|grep -c TIME_WAIT
1
[root@kvm zabbix]#  netstat -ant|grep -c LISTEN
13
</code></pre>

<h3 id="3.%E7%BC%96%E5%86%99zabbix%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6(%E4%BC%A0%E5%8F%82%E5%BD%A2%E5%BC%8F)">3.编写zabbix监控文件(传参形式)</h3>

<pre><code class="language-bash">[root@kvm zabbix]# cat /etc/zabbix/zabbix_agentd.d/tcp_status.conf
UserParameter=tcp_state[*],netstat -ant|grep -c $1
[root@kvm zabbix]# systemctl restart zabbix-agent.service 
</code></pre>

<h3 id="4.server%E7%AB%AF%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95">4.server端进行测试</h3>

<pre><code class="language-bash">[root@master zabbix]# /data/zabbix/bin/zabbix_get -s 192.168.1.100  -k tcp_state[TIME_WAIT]
6
[root@master zabbix]# /data/zabbix/bin/zabbix_get -s 192.168.1.100  -k tcp_state[LISTEN]
13
</code></pre>

<h3 id="5.web%E7%AB%AF%E6%B7%BB%E5%8A%A0">5.web端添加</h3>

<p><img alt="" height="886" src="https://img-blog.csdnimg.cn/20200513171340178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="940"></p>

<p><img alt="" height="220" src="https://img-blog.csdnimg.cn/20200513171350962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" height="77" src="https://img-blog.csdnimg.cn/20200513171406244.png" width="1200"></p>

<p><img alt="" height="34" src="https://img-blog.csdnimg.cn/20200513171440577.png" width="1200"></p>

<p>数据出来了</p>

<p><img alt="" height="360" src="https://img-blog.csdnimg.cn/20200513171552382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" height="424" src="https://img-blog.csdnimg.cn/20200513171924500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1162"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Centos7安装Zabbix服务端、Zabbix客户端和Win客户端配置（源码编译安装）</title><link>http://www.cnblogs.com/heian99/archive/2020/05/09/12865375.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 09 May 2020 10:03:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/05/09/12865375.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="1%E3%80%81%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83" rel="nofollow">1、宝塔安装和配置环境</a></p>

<p id="2%E3%80%81%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%92%8C%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%92%8C%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85" rel="nofollow">2、安装依赖和编译安装</a></p>

<p id="3%E3%80%81%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">3、配置数据库</a></p>

<p id="4%E3%80%81%E9%85%8D%E7%BD%AEZabbix%E6%9C%8D%E5%8A%A1%E7%AB%AF-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E9%85%8D%E7%BD%AEZabbix%E6%9C%8D%E5%8A%A1%E7%AB%AF" rel="nofollow">4、配置Zabbix服务端</a></p>

<p style="margin-left:0px;"><a href="#5%E3%80%81%E9%85%8D%E7%BD%AEZabbix%E7%9A%84Web%E7%AB%AF" rel="nofollow">5、配置Zabbix的Web端</a></p>

<p id="6%E3%80%81%E9%85%8D%E7%BD%AELinux%E5%AE%A2%E6%88%B7%E7%AB%AF-toc" style="margin-left:0px;"><a href="#6%E3%80%81%E9%85%8D%E7%BD%AELinux%E5%AE%A2%E6%88%B7%E7%AB%AF" rel="nofollow">6、配置Linux客户端</a></p>

<p id="7%E3%80%81%E9%85%8D%E7%BD%AEWindows%E5%AE%A2%E6%88%B7%E7%AB%AF-toc" style="margin-left:0px;"><a href="#7%E3%80%81%E9%85%8D%E7%BD%AEWindows%E5%AE%A2%E6%88%B7%E7%AB%AF" rel="nofollow">7、配置Windows客户端</a></p>

<p style="margin-left:0px;"><a href="#%E4%B8%89%E5%9C%A8zabbix%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA" rel="nofollow">8、在zabbix服务器添加主机</a></p>

<hr id="hr-toc"><hr><p>Centos7上使用宝塔面板配置LNMP环境安装zabbix4.2</p>

<h1 id="1%E3%80%81%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83">1、宝塔安装和配置环境</h1>

<p><strong><a href="https://blog.csdn.net/heian_99/article/details/101266165">Centos7安装宝塔控制面板</a></strong></p>

<p><strong><a href="https://download.csdn.net/download/heian_99/12403970">Zabbix4.2.2的源码包（包括Win）</a></strong></p>

<p><strong>L：Linux</strong></p>

<p><strong>N：Nginx</strong></p>

<p><strong>M：Mysql</strong></p>

<p><strong>P：PHP</strong></p>

<p><img alt="" height="169" src="https://img-blog.csdnimg.cn/20200509171022419.png" width="1200"></p>

<p><img alt="" height="630" src="https://img-blog.csdnimg.cn/202005091712413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="939">/2‘’</p>

<h1 id="2%E3%80%81%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%92%8C%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85">2、安装依赖和编译安装</h1>

<pre><code class="language-bash">yum install -y wget telnet net-tools python-paramiko gcc gcc-c++ dejavu-sans-fonts python-setuptools python-devel sendmail mailx net-snmp net-snmp-devel net-snmp-utils freetype-devel libpng-devel perl unbound libtasn1-devel p11-kit-devel OpenIPMI unixODBC  libevent-devel 
</code></pre>

<p>首先添加zabbix用户和zabbix组</p>

<pre><code class="language-bash">groupadd zabbix
useradd -g zabbix -s /sbin/nologin zabbix</code></pre>

<p>然后下载zabbix4.2编译安装包</p>

<p>执行</p>

<pre><code class="language-bash">wget https://jaist.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/4.2.4/zabbix-4.2.4.tar.gz
tar -zxvf zabbix-4.2.4.tar.gz 
cd zabbix-4.2.4</code></pre>

<p>执行帮助查看编译安装选项</p>

<pre><code class="language-bash">./configure --help</code></pre>

<p><img alt="" height="569" src="https://img-blog.csdnimg.cn/20200509172136180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="527"></p>

<p>我采取的是尽量多安装模块</p>

<pre><code class="language-bash">./configure --prefix=/data/zabbix --enable-server --enable-proxy --enable-agent --enable-ipv6  --with-mysql --with-net-snmp --with-libcurl --with-openipmi --with-openssl --with-libcurl --with-libxml2 </code></pre>

<p>说明：<br>
1、对于虚拟机监视--with-libcurl和--with-libxml2配置选项是必需的<br>
2、enable proxy,agent是启用代理<br>
3、with-net-snmp with-mysql是配置snmp和mysql支持<br>
4、在编译过程中，如果提示错误，则是某些扩展包没有安装，进行yum安装即可</p>

<p><img alt="" height="708" src="https://img-blog.csdnimg.cn/20200509172251298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="695"></p>

<p>在检查配置无误后，执行安装</p>

<pre><code>make install</code></pre>

<h1 id="3%E3%80%81%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93">3、配置数据库</h1>

<p>然后配置数据库。在宝塔面板中可以查看和修改数据库root密码</p>

<p><img alt="" height="664" src="https://img-blog.csdnimg.cn/20200509172339296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" height="724" src="https://img-blog.csdnimg.cn/20200509172349206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>完成数据创建后，导入数据库</p>

<pre><code class="language-bash">mysql -uzabbix -pzabbix -hlocalhost zabbix &lt; database/mysql/schema.sql
mysql -uzabbix -pzabbix -hlocalhost zabbix &lt; database/mysql/images.sql
mysql -uzabbix -pzabbix -hlocalhost zabbix &lt; database/mysql/data.sql</code></pre>

<p>导入完毕后，可以在宝塔面板的phpMyadmin中查看数据库详细</p>

<p><img alt="" height="691" src="https://img-blog.csdnimg.cn/20200509172420290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h1 id="4%E3%80%81%E9%85%8D%E7%BD%AEZabbix%E6%9C%8D%E5%8A%A1%E7%AB%AF">4、配置Zabbix服务端</h1>

<p>然后进入zabbix安装目录/usr/local/zabbix配置zabbix.conf配置文件</p>

<pre><code>vim /data/zabbix/etc/zabbix_server.conf</code></pre>

<p><img alt="" height="582" src="https://img-blog.csdnimg.cn/20200509172717309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="642"></p>

<p>然后关闭centos上防火墙，selinux等</p>

<pre><code class="language-bash">systemctl stop firewalld
systemctl disable firewalld</code></pre>

<p>Zabbix前端是用PHP编写的，因此要运行它需要PHP支持的Web服务器。只需将PHP文件从frontends / php复制到webserver HTML文档目录即可完成安装。</p>

<p>在使用宝塔面板安装LNMP环境后，会自动配置nginx，同时会在跟目录下创建WWW目录，存放WEB服务器等信息。</p>

<p><img alt="" height="460" src="https://img-blog.csdnimg.cn/20200509173006151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="466"></p>

<h3 id="5%E3%80%81%E9%85%8D%E7%BD%AEZabbix%E7%9A%84Web%E7%AB%AF">5、配置Zabbix的Web端</h3>

<p>再宝塔面板网站中，添加新的站点</p>

<p>说明<br>
1、域名一般使用公网域名<br>
2、没有公网域名，内网中使用.lcoal或者其他不冲突的域名格式代替即可<br>
3、使用ip地址业务可以</p>

<p><img alt="" height="168" src="https://img-blog.csdnimg.cn/20200509173107841.png" width="1200"></p>

<p>完成域名配置后，将zabbix-4.2.4目录中的frontends / php/下的文件复制到站点目录</p>

<pre><code>cd zabbix-4.2.4
cp -r frontends/php/* /www/wwwroot/zabbix/  #此文件就是之前创建的站点</code></pre>

<p>完成之后，再软件商店中调整以下php设置</p>

<p><img alt="" height="587" src="https://img-blog.csdnimg.cn/20200509173136849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>根据zabbix要求，调整max_input_time 由60改为300,同时调整时区date.timezone为.Asia/Shanghai,然后保存设置</p>

<p><img alt="" height="653" src="https://img-blog.csdnimg.cn/20200509173153451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="831"></p>

<p><strong>然后启动zabbix和zabbix-agent</strong></p>

<pre><code class="language-bash">/data/zabbix/sbin/zabbix_server
/data/zabbix/sbin/zabbix_agentd </code></pre>

<p>然后再浏览器中输入ip/setup.php(服务器IP地址），进行配置zabbix</p>

<p><img alt="" height="668" src="https://img-blog.csdnimg.cn/20200509173401552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>提示缺少php ldap的警告</p>

<p><img alt="" height="618" src="https://img-blog.csdnimg.cn/20200509173421500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1025"></p>

<p>无视，点击下一步<br>
配置mysql</p>

<p><img alt="" height="591" src="https://img-blog.csdnimg.cn/20200509173433478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="996"></p>

<p>然后这里提示报错。我们需要按照提将文件下载保存为/www/wwwroot/zabbix/conf/zabbix.conf.php"</p>

<p><img alt="" height="522" src="https://img-blog.csdnimg.cn/20200509173501258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="959"></p>

<p>完成后，zabbix配置完成</p>

<p><img alt="" height="784" src="https://img-blog.csdnimg.cn/20200509173545188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>以后对 zabbix的维护，包括安全加固，数据备份，新能调优等等，都可以通过宝塔面板进行</p>

<h1 id="6%E3%80%81%E9%85%8D%E7%BD%AELinux%E5%AE%A2%E6%88%B7%E7%AB%AF">6、配置Linux客户端</h1>

<p>1.添加zabbix用户和组。</p>

<pre><code class="language-bash">groupadd   zabbix
useradd zabbix -g  zabbix -s /sbin/nologin</code></pre>

<p>2.安装zabbix客户端。</p>

<pre><code class="language-bash">tar xvf  zabbix-4.2.4.tar.gz
cd zabbix-4.2.4
./configure --prefix=/data/zabbix_agent --enable-agent</code></pre>

<pre><code class="language-bash">make &amp;&amp; make install</code></pre>

<p>3.添加服务端口和修改启动脚本。</p>

<pre><code>echo 'zabbix-agent 10050/tcp #Zabbix Agent' &gt;&gt; /etc/services
echo 'zabbix-agent 10050/udp #Zabbix Agent' &gt;&gt; /etc/services
cp zabbix-4.2.2/misc/init.d/Fedora/core/zabbix_agentd /etc/init.d/
sed -i 's/BASEDIR=\/usr\/local/BASEDIR=\/data\/zabbix/g' /etc/init.d/zabbix_agentd
</code></pre>

<p>Zabbix agentd使用 chkconfig 将其加入 init 的启动服务</p>

<pre><code class="language-bash">chkconfig --add zabbix_agentd
chkconfig --level 345 zabbix_agentd on</code></pre>

<p>使用 chkconfig --list 检查一下</p>

<pre><code class="language-bash">chkconfig --list | grep zabbix</code></pre>

<p>4.修改zabbix_agent配置文件。</p>

<pre><code>vim /data/zabbix/etc/zabbix_agentd.conf</code></pre>

<pre><code class="language-bash">Server=192.168.1.83 //配置zabbix_server服务端服务器的IP地址
ServerActive=192.168.1.83
Hostname=linux_server1 //配置主机名
PidFile=/var/tmp/zabbix_agentd.pid //指定pid路径
LogFile=/var/log/zabbix/zabbix_agentd.log //指定日志文件
</code></pre>

<p>保存退出</p>

<pre><code class="language-bash">mkdir /var/log/zabbix
touch /var/log/zabbix/zabbix_agentd.log
chown -R zabbix.zabbix /var/log/zabbix</code></pre>

<p>5.启动客户端服务并进程测试。</p>

<pre><code class="language-bash">/etc/init.d/zabbix_agentd start</code></pre>

<pre><code class="language-bash">ps aux| grep zabbix</code></pre>

<p><img alt="" height="227" src="https://img-blog.csdnimg.cn/20200509175243775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="975"></p>

<p>在zabbix的服务端执行下面的命令测试与客户端是否联通</p>

<pre><code>/data/zabbix/bin/zabbix_get -s 192.168.1.160 -p10050 -k”net.if.in[eth0,bytes]”</code></pre>

<p>可以得到网卡信息说明客户端与服务端可以正常通信。</p>

<h1 id="7%E3%80%81%E9%85%8D%E7%BD%AEWindows%E5%AE%A2%E6%88%B7%E7%AB%AF">7、配置Windows客户端</h1>

<p>1.从官方下载Zabbix Agent后，压缩包里面有2个目录</p>

<p><img alt="" src="https://img-blog.csdn.net/20160425113839169"></p>

<p>在C盘下创建一个为zabbix的目录，在bin文件夹下有一个为win32和win64两个目录，每个目录下应该有3个.exe程序，分别为：zabbix_agentd.exe zabbix_get.exe zabbix_sender.exe</p>

<p>2.根据自己的操作系统复制相应的win32/win64里边的数据到刚创建好的c:\zabbix目录下</p>

<p><img alt="" src="https://img-blog.csdn.net/20160425141815069"></p>

<p>3.复制解压后zabbix_agents_2.4.4.win文件夹conf里的在C盘的zabbix目录下的conf文件夹下有个zabbix_agentd.win.conf修改一下内容重命名zabbix_agentd.conf到c:\zabbix下</p>

<blockquote>
<p>LogFile=c:\zabbix\zabbix_agentd.log<br>
Server=&lt;服务端IP地址&gt;<br>
Hostname=win_server1</p>
</blockquote>

<p>4.安装zabbix客户端。依次执行 开始–&gt;运行–&gt;cmd(也可以使用win+R快捷键直接打开)，在打开的命令提示符下执行下面的命令</p>

<blockquote>
<p>cd c:\zabbix<br>
zabbix_agentd.exe –c c:\zabbix\zabbix_agentd.conf -i</p>
</blockquote>

<p><img alt="" src="https://img-blog.csdn.net/20160425142439655"></p>

<p>看到上面的信息说明agent已经安装成功了。<br>
5.启动客户端</p>

<blockquote>
<p>zabbix_agentd.exe –s<br>
如果在启动的时候报错，说cannot open config file[C:\zabbix_agentd.conf]: [2] No such file or directory，把配置文件复制到c:\一份即可<br>
zabbix_agentd.exe可用参数介绍：<br>
-c 指定配置文件所在位置<br>
-i 安装客户端<br>
-s 启动客户端<br>
-x 停止客户端<br>
-d 卸载/删除客户端<br><img alt="" src="https://img-blog.csdn.net/20160425143053240"></p>
</blockquote>

<p>可以看到客户端已经监听在了10050端口上。打开windows管理工具—&gt;服务，查看一下</p>

<p><img alt="" src="https://img-blog.csdn.net/20160425143209555"></p>

<h2 id="三在zabbix服务器添加主机">8、在zabbix服务器添加主机</h2>

<p><img alt="" height="632" src="https://img-blog.csdnimg.cn/20200509180034899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" height="799" src="https://img-blog.csdnimg.cn/20200509180112477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1137"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>运维工作经验汇总---------高级运维工程师</title><link>http://www.cnblogs.com/heian99/archive/2020/04/29/12865372.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 29 Apr 2020 09:21:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/04/29/12865372.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%88%9D%E5%85%A5%E5%85%AC%E5%8F%B8-toc" style="margin-left:40px;"><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%88%9D%E5%85%A5%E5%85%AC%E5%8F%B8" rel="nofollow">第一章 初入公司</a></p>

<p id="-toc" style="margin-left:40px;"><a href="#" rel="nofollow">第2章 第一阶段：解决物理服务器单电问题</a></p>

<p style="margin-left:40px;"><a href="#" rel="nofollow">第3章 第二阶段：解决服务器虚拟化问题</a></p>

<p style="margin-left:40px;"><a href="#" rel="nofollow">第4章 第三阶段：数据库备份</a></p>

<p id="%E7%AC%AC5%E7%AB%A0%20%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%AC%AC5%E7%AB%A0%20%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E7%82%B9" rel="nofollow">第5章 第四阶段：解决数据库单点</a></p>

<p id="%E7%AC%AC6%E7%AB%A0%20%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%AE%8C%E5%96%84%E7%9B%91%E6%8E%A7%E9%A1%B9-toc" style="margin-left:40px;"><a href="#%E7%AC%AC6%E7%AB%A0%20%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%AE%8C%E5%96%84%E7%9B%91%E6%8E%A7%E9%A1%B9" rel="nofollow">第6章 第五阶段：完善监控项</a></p>

<p id="%E7%AC%AC7%E7%AB%A0%20%E7%AC%AC%E5%85%AD%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%BB%9F%E4%B8%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E7%AC%AC7%E7%AB%A0%20%E7%AC%AC%E5%85%AD%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%BB%9F%E4%B8%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F" rel="nofollow">第7章 第六阶段：统一服务的安装方式</a></p>

<p id="%E7%AC%AC8%E7%AB%A0%20%E7%AC%AC%E4%B8%83%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%85%B3%E9%94%AE%E6%9C%8D%E5%8A%A1%20NFS%20%E8%BF%81%E7%A7%BB%E5%A4%87%E4%BB%BD-toc" style="margin-left:40px;"><a href="#%E7%AC%AC8%E7%AB%A0%20%E7%AC%AC%E4%B8%83%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%85%B3%E9%94%AE%E6%9C%8D%E5%8A%A1%20NFS%20%E8%BF%81%E7%A7%BB%E5%A4%87%E4%BB%BD" rel="nofollow">第8章 第七阶段：关键服务 NFS 迁移备份</a></p>

<p id="%E7%AC%AC9%E7%AB%A0%20%E7%AC%AC%E5%85%AB%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86-%E7%94%A8%E6%88%B7%E5%92%8C%E7%88%AC%E8%99%AB%E6%B5%81%E9%87%8F%E5%88%86%E7%A6%BB-ELK%20%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86-toc" style="margin-left:40px;"><a href="#%E7%AC%AC9%E7%AB%A0%20%E7%AC%AC%E5%85%AB%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86-%E7%94%A8%E6%88%B7%E5%92%8C%E7%88%AC%E8%99%AB%E6%B5%81%E9%87%8F%E5%88%86%E7%A6%BB-ELK%20%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86" rel="nofollow">第9章 第八阶段：服务拆分-用户和爬虫流量分离-ELK 日志收集</a></p>

<p id="%E7%AC%AC10%E7%AB%A0%20%E7%AC%AC%E4%B9%9D%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%AC%AC%E4%BA%8C%E6%9C%BA%E6%88%BF-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1-toc" style="margin-left:40px;"><a href="#%E7%AC%AC10%E7%AB%A0%20%E7%AC%AC%E4%B9%9D%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%AC%AC%E4%BA%8C%E6%9C%BA%E6%88%BF-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1" rel="nofollow">第10章 第九阶段：增加第二机房-大数据服务</a></p>

<p id="%E5%AE%8C%E6%95%B4%E6%9E%B6%E6%9E%84%E5%9B%BE-toc" style="margin-left:40px;"><a href="#%E5%AE%8C%E6%95%B4%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">完整架构图</a></p>

<p id="%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E6%BC%94%E5%8F%98-toc" style="margin-left:40px;"><a href="#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E6%BC%94%E5%8F%98" rel="nofollow">整体结构演变</a></p>

<hr id="hr-toc"><h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%88%9D%E5%85%A5%E5%85%AC%E5%8F%B8">第一章 初入公司</h2>

<h3 id="1.1%20%E6%9E%B6%E6%9E%84%E6%8B%93%E6%89%91%E5%9B%BE">1.1 <strong>架构拓扑图</strong></h3>

<p><img alt="" height="534" src="https://img-blog.csdnimg.cn/2020042915240892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="952"></p>

<h3 id="1.2%20%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB">1.2 存在的问题汇总</h3>

<blockquote>
<ul><li>1.物理服务器电源单电，机房电力切割时需要关闭所有服务器，导致服务中断 4-6 小时</li>
	<li>2.物理服务器配置不当，有的服务器系统盘用 SSD，数据盘反而用机械盘</li>
	<li>3.服务器虚拟化 ESXi 上的虚拟机经常无故变成系统只读导致服务不可用</li>
	<li>4.操作系统不统一，有 debian，有 FreeBSD</li>
	<li>5.数据库单点，且没有备份以及恢复计划</li>
	<li>6.keepalived 配置错误导致 HA 高可用没有生效</li>
	<li>7.重要的 NFS 服务器 5T 的数据没有备份，且操作系统为 FreeBSD</li>
	<li>8.zabbix 监控项过多，报警内容太多，关键报警被淹没</li>
	<li>9.软件部署方式不统一，有编译/脚本/tar 包/deb 包多种安装方式</li>
	<li>10.脚本不统一，脚本随处存放，命名混乱，很多不知道有没有用</li>
	<li>11.没有批量操作工具，依靠纯手工或脚本操作</li>
</ul></blockquote>

<p>&nbsp;</p>

<h2>第2章 第一阶段：解决物理服务器单电问题</h2>

<h3 id="2.1%20%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">2.1 问题现象</h3>

<blockquote>
<p>1.物理服务器电源单模块，如果机房进行电力切割，必须关闭所有服务器，等机房电力切割结束再把所有服务器开机</p>
</blockquote>

<h3 id="2.2%20%E5%AF%BC%E8%87%B4%E5%90%8E%E6%9E%9C">2.2 导致后果</h3>

<blockquote>
<p>1.电力切割期间所有的业务完全中断，用户在此期间无法访问<br>
2.服务没有做开机自启动，重新开机之后需要手动起服务<br>
3.因为服务器老旧，关机之后可能起不来<br>
4.因为关机时暴力 kill 了服务，导致服务器重启后数据损坏</p>
</blockquote>

<h3 id="2.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">2.3 解决方案</h3>

<blockquote>
<p>1.因为服务器型号老旧，厂商已经停产，买不到新电源<br>
2.退而求次，淘宝联系卖二手服务器的卖家，购买服务器相同型号的电源<br>
3.服务器电源属于热插拔，可以直接插上测试<br>
4.验收方法为：<br>
- 两个电源模块都插上电，然后拔掉第一个电源模块，查看服务器有没有重启。<br>
- 如果服务器没有重启，再全部插上电源，然后再拔掉另一个电源，查看有没有重启<br>
- 如果都没有重启，就证明服务器双电模块运行正常</p>
</blockquote>

<h3 id="2.4%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">2.4 价值体现</h3>

<blockquote>
<p>1.由原来业务需要中断 4-6 小时缩短为 0 中断<br>
2.给公司减少了由于业务中断导致的经济损失<br>
3.运维再也不用在机房通宵熬夜等待电力切割了</p>
</blockquote>

<p>&nbsp;</p>

<h2>第3章 第二阶段：解决服务器虚拟化问题</h2>

<h3 id="3.1%20%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">3.1 问题现象</h3>

<blockquote>
<p>1.服务器虚拟化采用的是 VMware ESXi 虚拟化平台，运行的虚拟机经常无故的系统变成只读，导致服务中断</p>
</blockquote>

<h3 id="3.2%20%E5%AF%BC%E8%87%B4%E5%90%8E%E6%9E%9C">3.2 导致后果</h3>

<blockquote>
<p>1.虚拟机运行的服务不可用，导致业务中断，影响用户体验</p>
</blockquote>

<h3 id="3.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">3.3 解决方案</h3>

<blockquote>
<p>1.找台新服务器安装部署新版本的 ESXi,安装 VCenter 管理中心<br>
2.迁移旧服务到新服务器<br>
3.持续观察检验</p>
</blockquote>

<h3 id="3.4%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">3.4 价值体现</h3>

<blockquote>
<p>1.新版本虚拟机运行稳定，业务不会中断<br>
2.服务器虚拟化充分利用了硬件资源，为公司节省了购买 3 台物理服务器的价格</p>
</blockquote>

<p>&nbsp;</p>

<h2>第4章 第三阶段：数据库备份</h2>

<h3 id="4.1%20%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">4.1 问题现象</h3>

<blockquote>
<p>1.mysql 数据库只有一台主从，没有备份<br>
2.redis 和 mongo 单点，且没有备份<br>
3.数据库服务器数据盘均为单块 SSD 固态硬盘，一旦损坏没有修复的希望</p>
</blockquote>

<h3 id="4.2%20%E5%AF%BC%E8%87%B4%E5%90%8E%E6%9E%9C">4.2 导致后果</h3>

<blockquote>
<p>1.如果数据库服务器硬件或者硬盘损坏，没有数据可以提供恢复，后果不堪设想</p>
</blockquote>

<h3 id="4.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">4.3 解决方案</h3>

<blockquote>
<p>1.这个阶段重点是先备份数据<br>
2.新增加一个 mysql 从库，使用 xtrabackup 在从库上每天定时备份数据<br>
3.新增加一个 redis 从库，每天物理备份 redis 持久化的 RDB 文件<br>
4.新增加一个 mongo 从库，每天使用 mongodump 导出数据</p>
</blockquote>

<h3 id="4.4%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">4.4 价值体现</h3>

<blockquote>
<p>1.在服务器有限和时间有限的情况下，按照紧急度优先解决数据库备份<br>
2.降低了因为物理服务器损坏或者人为操作失误导致的数据灾难性丢失情况<br>
3.为下一步数据库服务集群化提供了基础保障</p>
</blockquote>

<h3 id="4.5%20%E6%8B%93%E6%89%91%E5%9B%BE">4.5 拓扑图</h3>

<p><img alt="" height="502" src="https://img-blog.csdnimg.cn/20200429153536306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="952"></p>

<p>&nbsp;</p>

<h2 id="%E7%AC%AC5%E7%AB%A0%20%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E7%82%B9">第5章 第四阶段：解决数据库单点</h2>

<h3 id="5.1%20%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">5.1 问题现象</h3>

<blockquote>
<p>1.数据库故障到完全修复过程中，业务会中断，用户不能访问</p>
</blockquote>

<h3 id="5.2%20%E5%AF%BC%E8%87%B4%E5%90%8E%E6%9E%9C">5.2 导致后果</h3>

<blockquote>
<p>1.虽然已经做了数据库备份，但是一旦数据库损坏，恢复起来依然需要很多时间<br>
2.由于业务代码写死了 IP 地址，一旦数据库损坏，在其他机器上恢复了，业务代码也需要变更 IP 地<br>
址，重新发布，耗时太长</p>
</blockquote>

<h3 id="5.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">5.3 解决方案</h3>

<blockquote>
<p>1.对目前单点数据库升级到集群架构<br>
2.新增加 mysql 从库。<br>
3.redis 由单节点升级为 redis cluster 集群<br>
4.mongo 由主从复制升级为 3 节点副本集<br>
5.新部署 elasticsearch 服务集群</p>
</blockquote>

<h3 id="5.4%20%E5%AE%9E%E6%96%BD%E9%9A%BE%E7%82%B9">5.4 实施难点</h3>

<blockquote>
<p>1.对于运维来说，安装部署不复杂，但是难题在于由于数据库架构升级，从而导致业务代码连接方<br>
式发生改变<br>
2.因为现在的业务代码都是采用框架开发，所以很多数据库插件需要升级，比如 redis 和 mongo 都需<br>
要升级插件才能支持集群化连接<br>
3.需要提前在开发环境搭建部署好。然后开发测试没有问题之后，再采用轮训升级的方式逐步升级<br>
升级数据库以及代码框架</p>
</blockquote>

<h3 id="5.5%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">5.5 价值体现</h3>

<blockquote>
<p>1.对数据库的稳定性以及安全性有了质的改变<br>
2.由于数据库集群化，性能得到了大大的提升，用户打开网站访问速度更好，体验更好<br>
3.由于数据库集群化，提供了冗余，所以即使服务器损坏或者维护也不会影响架构改变，用户访问<br>
也不会中断<br>
4.减少了因为数据库宕机或恢复导致的经济损失</p>
</blockquote>

<h3 id="5.6%20%E6%8B%93%E6%89%91%E5%9B%BE">5.6 拓扑图</h3>

<p><img alt="" height="453" src="https://img-blog.csdnimg.cn/20200429153904667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1022"></p>

<p>&nbsp;</p>

<h2 id="%E7%AC%AC6%E7%AB%A0%20%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%AE%8C%E5%96%84%E7%9B%91%E6%8E%A7%E9%A1%B9">第6章 第五阶段：完善监控项</h2>

<p>&nbsp;</p>

<h3 id="6.1%20%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">6.1 问题现象</h3>

<blockquote>
<p>1.监控项报警内容太多，有时候几分钟上百条</p>
</blockquote>

<h3 id="6.2%20%E5%AF%BC%E8%87%B4%E5%90%8E%E6%9E%9C">6.2 导致后果</h3>

<blockquote>
<p>1.关键的报警信息被不重要的报警淹没，以至于不能第一时间发现关键问题<br>
2.由于报警监控项配置不当，导致连锁反应，牵动很多不需要的警告<br>
3.由于短时间大量的报警产生，对 zabbix 服务器造成很大压力，甚至导致 zabbix 服务宕机<br>
4.如果配置了短信报警，那么大量的非关键报警导致消耗很多短信条目，很花钱！</p>
</blockquote>

<h3 id="6.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">6.3 解决方案</h3>

<blockquote>
<p>1.优化报警内容，只监控必须要监控的，模版自带的一些不需要的监控项停掉<br>
2.报警分级，将报警信息按紧急度拆分，所有报警都发邮件，紧急的报警追加发送到微信<br>
3.取消短信报警，改为邮件和微信报警<br>
4.报警内容优化，尽量看标题就能知道报警内容是什么</p>
</blockquote>

<h3 id="6.4%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">6.4 价值体现</h3>

<blockquote>
<p>1.接受的报警量大大减少，运维的注意力可以更集中在关键的问题处理上<br>
2.通过不同的发送介质第一时间了解问题的紧急度，比如发送到微信上的都是需要立刻处理的<br>
3.取消短信报警为公司节省开销</p>
</blockquote>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2 id="%E7%AC%AC7%E7%AB%A0%20%E7%AC%AC%E5%85%AD%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%BB%9F%E4%B8%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F">第7章 第六阶段：统一服务的安装方式</h2>

<h3 id="7.1%20%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">7.1 问题现象</h3>

<blockquote>
<p>1.服务安装混乱，有脚本安装，有 tar 包安装，有 deb 包安装，有编译安装<br>
2.软件存放目录不统一，数据存放目录不统一，脚本存放目录不统一<br>
3.防火墙规则不统一，有一些不用的规则没有清理</p>
</blockquote>

<h3 id="7.2%20%E5%AF%BC%E8%87%B4%E5%90%8E%E6%9E%9C">7.2 导致后果</h3>

<blockquote>
<p>1.一些操作无法进行批量执行<br>
2.安装服务基本需要手动操作<br>
3.文档缺失，不知道以前怎么装的，不知道以前配了什么参数<br>
4.防火墙规则混乱，有一些已经不用的服务，但是规则没有删除，看起来很乱</p>
</blockquote>

<h3 id="7.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">7.3 解决方案</h3>

<blockquote>
<p>1.引入 ansible 批量管理工具，统一服务安装方式，新服务统一使用 playbook 安装<br>
2.统一服务安装目录，数据目录，日志目录<br>
3.清理防火墙不用的规则，只保留必须的规则<br>
4.编写运维文档，制定运维规范</p>
</blockquote>

<h3 id="7.4%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">7.4 价值体现</h3>

<blockquote>
<p>1.新服务安装部署由原来的按小时缩短为分钟级别，提高了运维效率<br>
2.避免了因为手动操作敲错命令导致的不可预料后果，实现了一次编写重复运行<br>
3.编写运维文档，为部门同事和公司留下可持续的价值输出</p>
</blockquote>

<p>&nbsp;</p>

<h2 id="%E7%AC%AC8%E7%AB%A0%20%E7%AC%AC%E4%B8%83%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%85%B3%E9%94%AE%E6%9C%8D%E5%8A%A1%20NFS%20%E8%BF%81%E7%A7%BB%E5%A4%87%E4%BB%BD">第8章 第七阶段：关键服务 NFS 迁移备份</h2>

<h3 id="8.1%20%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">8.1 问题现象</h3>

<blockquote>
<p>1.公司成立以来所有的图片数据都保存在一台安装 FreeBSD 操作系统的老旧服务器上且没有备份</p>
</blockquote>

<h3 id="8.2%20%E5%AF%BC%E8%87%B4%E5%90%8E%E6%9E%9C">8.2 导致后果</h3>

<blockquote>
<p>1.NFS 服务器的数据高达 5T，且没有备份，一旦服务器或硬盘损坏，后果不堪设想<br>
2.由于 FreeBSD 操作系统的原因，没有办法使用 sersync 来进行实时同步备份<br>
3.一旦服务器发生损坏，所有业务网站的图片服务都将失效，短时间没有替代方案</p>
</blockquote>

<h3 id="8.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">8.3 解决方案</h3>

<blockquote>
<p>1.虽然 FreeBSD 系统不能使用 sersync，但是可以使用 rsync<br>
2.找一台性能足够服务器，使用四块 6T 磁盘制作 RAID10，安装部署 rsync 服务端和 NFS 服务端<br>
3.分目录进行同步，总目录数据量太大，同步起来时间按天算，拆分成一个个小目录分批进行同步<br>
4.统计记录每次同步的时间，最高在半夜业务低峰期进行同步<br>
5.和开发沟通切换方案，开发修改代码，用户上传数据同时往 2 台服务器上写入，保证数据一致性<br>
6.业务低峰期进行切换，在前端代理轮流更新 WEB 服务器的卸载旧 NFS，然后重新挂载新 NFS<br>
7.修改个别权限不对的目录。测试所有上传业务是否可以正常的写入<br>
8.为了防止意料不到的意外情况，旧服务器数据继续保留 1 个月。确定一切正常之后重做旧服务器<br>
9.然后使用 sersync 同步数据到新服务器，持续观察，保证同步正常工作</p>
</blockquote>

<h3 id="8.4%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">8.4 价值体现</h3>

<blockquote>
<p>1.在业务不中断，数据不丢失的情况下为公司的宝贵资产提供了可靠的备份方案<br>
2.烫手的山芋在运维手里得到了解决，荣誉感，成就感大增<br>
3.在公司领导和同事心中留下了可靠可信赖的印象</p>
</blockquote>

<h3 id="8.5%20%E6%8B%93%E6%89%91%E5%9B%BE">8.5 拓扑图</h3>

<p><img alt="" height="489" src="https://img-blog.csdnimg.cn/20200429164751753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1052"></p>

<p><img alt="" height="570" src="https://img-blog.csdnimg.cn/20200429154635701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="966"></p>

<p>&nbsp;</p>

<h2 id="%E7%AC%AC9%E7%AB%A0%20%E7%AC%AC%E5%85%AB%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86-%E7%94%A8%E6%88%B7%E5%92%8C%E7%88%AC%E8%99%AB%E6%B5%81%E9%87%8F%E5%88%86%E7%A6%BB-ELK%20%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86">第9章 第八阶段：服务拆分-用户和爬虫流量分离-ELK 日志收集</h2>

<h3 id="9.1%20%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1">9.1 问题现象</h3>

<blockquote>
<p>1.因为公司有论坛，需要爬虫来爬取<br>
2.但是爬虫的流量和用户的流量混合在了一起，且没有统一的日志管理平台查看过滤</p>
</blockquote>

<h3 id="9.2%20%E5%AF%BC%E8%87%B4%E5%90%8E%E6%9E%9C">9.2 导致后果</h3>

<blockquote>
<p>1.由于流量没有分离，导致当有大量的爬虫访问的时候，对服务器和数据库造成非常大的压力<br>
2.当爬虫访问频次过高时，会导致数据库连接数变多，系统负载变高，影响用户正常服务<br>
3.同样，由于爬虫流量和用户流量混在了一起，没有很好的办法分析压力高的原因<br>
4.开发或者运营想看一些日志数据只能找运维解决，每次分析都要花很久，分析脚本没有办法复用</p>
</blockquote>

<h3 id="9.3%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">9.3 解决方案</h3>

<blockquote>
<p>1.新增加一台 WEB 服务器专门给爬虫使用，页面做静态化，优化爬虫抓去效率<br>
2.数据库读写分离，爬虫抓取如果需要查询数据库，把流量指向没有业务访问的从库<br>
3.前端代理根据访问的请求报文里的 user-agent 来分离爬虫和用户的访问流量，如果是爬虫就把流量引到给爬虫抓取的 WEB 服务器上，用户正常的流量还是正常访问 WEB 集群。<br>
4.搭建部署 ELK 日志收集平台，集中收集所有 Nginx 访问日志，使用 kibana 作为过滤搜索和展示，<br>
制作好用户展示数据的图表，培训部门同事 ELK 的使用和查询方法</p>
</blockquote>

<h3 id="9.4%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">9.4 价值体现</h3>

<blockquote>
<p>1.将用户和爬虫流量分离，当爬虫大量访问时候正常用户访问也不会受到影响，用户体验大大提升<br>
2.搭建部署了 ELK 日志分析平台，方便部门同事查询数据，定位故障时间大大地缩减，大大提高了工作效率</p>
</blockquote>

<h3 id="9.5%20%E6%8B%93%E6%89%91%E5%9B%BE">9.5 拓扑图</h3>

<p><img alt="" height="717" src="https://img-blog.csdnimg.cn/20200429154905136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<h2 id="%E7%AC%AC10%E7%AB%A0%20%E7%AC%AC%E4%B9%9D%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%AC%AC%E4%BA%8C%E6%9C%BA%E6%88%BF-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1">第10章 第九阶段：增加第二机房-大数据服务</h2>

<p>&nbsp;</p>

<h3 id="10.1%20%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82">10.1 项目需求</h3>

<blockquote>
<p>1.业务发展，需要部署 Hadoop 平台和 kafka+zookeeper 服务<br>
2.由于 IDC 机房只有一个机架，所以需要在第二机房部署</p>
</blockquote>

<h3 id="10.2%20%E4%BB%B7%E5%80%BC%E4%BD%93%E7%8E%B0">10.2 价值体现</h3>

<blockquote>
<p>1.测试环境测试没问题后使用 ansible 批量部署到新的大数据服务器，节省了部署时间<br>
2.大数据服务可以更好的分析用户访问行为，根据分析结果可以更精确的给用户推送推荐内容</p>
</blockquote>

<h3 id="10.3%20%E6%8B%93%E6%89%91%E5%9B%BE">10.3 拓扑图</h3>

<p><img alt="" height="680" src="https://img-blog.csdnimg.cn/2020042915530829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="%E5%AE%8C%E6%95%B4%E6%9E%B6%E6%9E%84%E5%9B%BE">完整架构图</h2>

<p><img alt="" src="https://img-blog.csdnimg.cn/20200429162352895.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<h2 id="%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E6%BC%94%E5%8F%98">整体结构演变</h2>

<p><img alt="" src="https://img-blog.csdnimg.cn/20200429165223813.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>手误【删库】 ==  跑路，不存在的  ——删瓦辛格</title><link>http://www.cnblogs.com/heian99/archive/2020/04/22/12865373.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 22 Apr 2020 10:43:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/04/22/12865373.html</guid><description><![CDATA[
                                            <h1><strong>手误【删库】 == &nbsp;跑路，不存在的 &nbsp;——删瓦辛格</strong></h1>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="462" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOC8wNC8xNC8yMDE4MDQxNDY2NTIyNl95c3JSbksuZ2lm" width="447"></p>

<p>&nbsp;</p>

<h1>前言</h1>

<p><strong>今天公司服务器的宝塔打不开，让我去修（ps：<span style="color:#f33b45;">宝宝委屈</span>）</strong></p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="332" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOC8wOC8wNC8yMDE4MDgwNDM0OTA5M192SWphd2cuZ2lm" width="332"><img alt="" height="300" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8xMC8zMS8yMDE5MTAzMTQ4OTEzN19YanpTUWEuanBn?x-oss-process=image/format,png" width="299"></p>

<p><strong>打开找一下问题所在</strong></p>

<p><img alt="" height="567" src="https://img-blog.csdnimg.cn/20200422165352610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h3>问题：</h3>

<p><strong>发现是宝塔官方的cdn好像挂掉了</strong></p>

<h3>解决思路：</h3>

<ul><li>（1）本地重新搞个服务器装宝塔，发现没问题</li>
	<li>（2）比较一下，发现线上的确实cdn有问题</li>
	<li>（3）把本地的可以用的cdn，放到线上就行。</li>
</ul><h3>解决：</h3>

<p>卧槽，我发下，我根本不了解宝塔的目录结构【<strong>ps</strong>：<span style="color:#f33b45;"><strong>解决毛线，下班走人</strong></span>】</p>

<p>&nbsp;</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="236" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxNy8xMS8wOS8yMDE3MTEwOTI0MDk5MF95VUpLcncuanBn?x-oss-process=image/format,png" width="205"><strong>&nbsp;&nbsp;</strong><img alt="" height="229" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxNi8xMC8xNi8yMDE2MTAxNjU5ODUyMl9GSlJOcWkuanBn?x-oss-process=image/format,png" width="229"></p>

<h1>正文</h1>

<p><strong>别眨眼，接下的我sb的操作，真的亮瞎我狗眼【ps：别害怕，也会亮瞎你的狗眼的，嘿嘿。。。】</strong></p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8xMS8xNy8yMDE5MTExNzkzODYzMF9sdGRCVWIuanBn?x-oss-process=image/format,png">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>

<h3>常规操作：</h3>

<p>（1）备份要修改的文件，这是职业本能，OK，没毛病，我喜欢。</p>

<p>（2）删除那个没用的文件&nbsp; &nbsp; &nbsp; &nbsp; 【<strong>文件</strong><span style="color:#7c79e5;">：你才没用，看老子的移魂大法</span>】</p>

<p><img alt="" height="134" src="https://img-blog.csdnimg.cn/20200422170347674.png" width="960"></p>

<h1>重点：</h1>

<p><strong>备份一切over，删除时，我手贱多打了个<span style="color:#f33b45;">&nbsp; *&nbsp;&nbsp;</span>。</strong></p>

<p><strong>然后没思考，一个回车，那感觉爽啊&nbsp; &nbsp; </strong></p>

<h1>求德玛得...........................................................................................................雅蠛蝶...............................................................................................................</h1>

<h1><span style="color:#f33b45;"><strong>对，ctrl +c 你已经看出我的绝望了</strong></span></h1>

<p>&nbsp;</p>

<h1><strong>说时迟那时快，掏出手机，抢票一张去往非洲的机票</strong></h1>

<p><img alt="" height="226" src="https://img-blog.csdnimg.cn/20200422171348108.gif" width="239">&nbsp; &nbsp; &nbsp; <img alt="" height="187" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOC8wNi8wMS8yMDE4MDYwMTc4MjU5Nl9yRmJSSlEuanBn?x-oss-process=image/format,png" width="251">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="205" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxNi8wMi8xMS8yMDE2MDIxMTE0NTUyMV9weG13YVguZ2lm" width="205"></p>

<p>&nbsp;</p>

<p><img alt="" height="134" src="https://img-blog.csdnimg.cn/20200422170347674.png" width="960"></p>

<p><strong>我多打一个 *&nbsp; ，导致把线上环境的&nbsp;&nbsp;<span style="color:#f33b45;">nginx服务，php环境，redis缓存，mysql数据库</span>，全部删掉了</strong></p>

<p>&nbsp;</p>

<h1><strong>不多说，赶紧跑路了..........................................................................</strong></h1>

<h1>&nbsp;</h1>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="318" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOC8wOS8yOS8yMDE4MDkyOTE3NzE1MV9JYnVwbksuZ2lm" width="318"></p>

<p>&nbsp;</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="243" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8xMC8wMy8yMDE5MTAwMzA2MzMzMV9rQ2FuUEEuanBn?x-oss-process=image/format,png" width="257"></p>

<p>&nbsp;</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="427" src="https://img-blog.csdnimg.cn/20200422172023538.jpg" width="427">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;</p>

<h1>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="383" src="https://img-blog.csdnimg.cn/20200422172113218.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="326">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</h1>

<h1>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 飞机延时，公司发现</h1>

<h1>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;跑路失败，当场被捕</h1>

<p>&nbsp;</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8wNS8yOC8yMDE5MDUyODk4NzYzMF9WZ0JuV3oucG5n?x-oss-process=image/format,png">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" height="216" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8wOC8yOC8yMDE5MDgyODk0NTcyOV9qcWNIbk4uanBn?x-oss-process=image/format,png" width="216"></p>

<h1>&nbsp;</h1>

<h1>数据恢复</h1>

<ul><li><strong>（1）停止对服务器进行一切的写入操作，卸载挂载</strong></li>
	<li><strong>（2）安装extundelete，进行扫描</strong></li>
	<li><strong>（3）恢复数据，环境再次重新工作</strong></li>
</ul><p><span style="color:#f33b45;"><strong>PS：因为这个服务器没有搞本地备份和异地本地，所以才有下面这些破事，再不是，直接备份恢复就行了</strong></span></p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" height="311" src="https://img-blog.csdnimg.cn/20200422173118382.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="316"></p>

<p>&nbsp;</p>

<p><strong>（1）停止对服务器进行一切的写入操作，卸载挂载</strong></p>

<p>当发现误删除文件时，为了尽可能的恢复数据，先要关掉所有的正在进行的服务，不要再进行数据的写入，要不然恢复的概率那就低了。我们可以直接</p>

<pre><code># killall 进程名</code></pre>

<p>或者</p>

<pre><code># kill -9 pid</code></pre>

<p>然后把误删除的文件所在分区，重新挂载成只读的</p>

<pre><code>#&nbsp;mount&nbsp;-o ro&nbsp;/dev/sdb&nbsp;&nbsp;/data/&nbsp;</code></pre>

<p><strong>（2）安装extundelete</strong></p>

<pre><code>yum install bzip2 gcc-c++ e2fsprogs* -y
wget http://nchc.dl.sourceforge.net/project/extundelete/extundelete/0.2.4/extundelete-0.2.4.tar.bz2</code></pre>

<p><img alt="" height="334" src="https://img-blog.csdnimg.cn/20200422173821480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1004"></p>

<pre><code>tar jxvf extundelete-0.2.4.tar.bz2
cd extundelte-0.2.4
</code></pre>

<p><img alt="" height="469" src="https://img-blog.csdnimg.cn/20200422173919712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="474"></p>

<pre><code>./configure
make &amp;&amp;  make install</code></pre>

<p><img alt="" height="275" src="https://img-blog.csdnimg.cn/20200422174332816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="929"></p>

<p>验证安装结果</p>

<pre><code> extundelete -v</code></pre>

<p><img alt="" height="135" src="https://img-blog.csdnimg.cn/20200422174349766.png" width="615"></p>

<p><strong>（3）进行扫描，恢复数据</strong></p>

<p><strong>恢复指定文件：</strong></p>

<p><strong>原理：</strong>从根节点(inode=2)开始找到被删除文件的i节点，然后recover i节点。</p>

<p><strong>删除目录：/www/server</strong></p>

<p><img alt="" height="296" src="https://img-blog.csdnimg.cn/2020042217503887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="645"></p>

<p><strong>先检测被删除的文件有哪些：</strong></p>

<pre><code class="language-bash">extundelete /dev/mapper/centos-root --inode 2</code></pre>

<p><img alt="" height="546" src="https://img-blog.csdnimg.cn/20200422175226509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="624"></p>

<pre><code>extundelete /dev/mapper/centos-root --inode 1703938</code></pre>

<p><img alt="" height="511" src="https://img-blog.csdnimg.cn/20200422175304352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="570"></p>

<pre><code>extundelete /dev/mapper/centos-root --inode 1703940</code></pre>

<p><img alt="" height="537" src="https://img-blog.csdnimg.cn/2020042217550244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="665"></p>

<pre><code>extundelete /dev/mapper/centos-root --restore-directory /www/server
</code></pre>

<p><img alt="" height="301" src="https://img-blog.csdnimg.cn/20200422181709739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="766"></p>

<pre><code>#查看能恢复的数据：
[root@localhost ~]# extundelete /dev/sdc1 --inode 2
#恢复单个文件
[root@localhost ~]# extundelete /dev/sdc1 --restore-file somefile
#恢复目录
[root@localhost ~]# extundelete /dev/sdc1 --restore-directory /somedir
#恢复所有文件
[root@localhost ~]# extundelete /dev/sdb1 --restore-all</code></pre>

<h1><strong>能恢复多少，就靠运气</strong></h1>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" height="397" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxNi8wOS8xNi8yMDE2MDkxNjAwMjcyMl9oUWFqR2cuanBn?x-oss-process=image/format,png" width="397"></p>

<p>&nbsp;</p>

<h1>后记：</h1>

<p><strong>运气较好，恢复了数据</strong></p>

<p><strong>把生成环境搭建出来，跑上面完全没有问题</strong></p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="314" src="https://img-blog.csdnimg.cn/20200422183730193.png" width="314"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8xMi8yMy8yMDE5MTIyMzA5MDk1Ml9WTVF3eE4ucG5n?x-oss-process=image/format,png">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5kb3V0dWxhLmNvbS9wcm9kdWN0aW9uL3VwbG9hZHMvaW1hZ2UvMjAxOS8xMi8yMy8yMDE5MTIyMzA5MDk1Ml9WTVF3eE4ucG5n?x-oss-process=image/format,png"></p>

<h1>切记</h1>

<ul><li><strong>（1）记得备份</strong></li>
	<li><strong>（2）不要用rm</strong></li>
	<li><strong>（3）干啥要三思</strong></li>
</ul><h1><strong>下次更新</strong>，“<span style="color:#f33b45;"><strong>垃圾rm，毁我青春，我直接把你删掉</strong></span>”</h1>

<h1>预知后事，且听下回分解【<span style="color:#f33b45;">关注我，期待下次分享</span>】</h1>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" height="665" src="https://img-blog.csdnimg.cn/20200422184020681.gif" width="665"></p>

<p>&nbsp;&nbsp;</p>
                                    ]]></description></item><item><title>Centos7集群时间同步（Chrony）</title><link>http://www.cnblogs.com/heian99/archive/2020/04/20/12865376.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 20 Apr 2020 03:51:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/04/20/12865376.html</guid><description><![CDATA[
                                            <h3>概述</h3>

<p>集群对时间同步要求高，实际使用环境中必须确保集群中所有系统时间保持一致</p>

<p>Chrony是一个开源的自由软件，像CentOS&nbsp;7或基于RHEL 7操作系统，已经是默认服务，默认配置文件在 /etc/chrony.conf 它能保持系统时间与时间服务器（NTP）同步，让时间始终保持同步。相对于NTP时间同步软件，占据很大优势。</p>

<p><img alt="" height="156" src="https://img-blog.csdnimg.cn/20200420111940887.png" width="505"></p>

<p>需要注意的是，配置完/etc/chrony.conf后，需重启chrony服务，否则可能会不生效</p>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>主机名称</td>
			<td>IP地址</td>
		</tr><tr><td>Master</td>
			<td>192.168.1.10</td>
		</tr><tr><td>Node1</td>
			<td>192.168.1.20</td>
		</tr><tr><td>Node2</td>
			<td>192.168.1.30</td>
		</tr></tbody></table><p><img alt="" height="155" src="https://img-blog.csdnimg.cn/20200420112112851.png" width="349"></p>

<h3 id="0x01-%E5%AE%89%E8%A3%85chrony">1、安装chrony</h3>

<p>CentOS7中已经默认安装了chrony，其配置文件路径在</p>

<pre><code class="language-bash">/etc/chrony.conf</code></pre>

<p>如果系统内没有chrony，请按照如下进行安装，启动并检查相关状态</p>

<pre><code class="language-bash"> yum install chrony -y

systemctl enable chronyd.service
systemctl restart chronyd.service
systemctl status chronyd.service</code></pre>

<p>在防火墙内放行，因NTP使用123/UDP端口协议，所以允许NTP服务即可。（如果已关闭防火墙请无视）</p>

<pre><code class="language-bash">firewall-cmd --add-service=ntp --permanent
firewall-cmd --reload</code></pre>

<h3>2、检查设置时区</h3>

<p><img alt="" height="261" src="https://img-blog.csdnimg.cn/20200420112313217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="476"></p>

<pre><code class="language-bash"># timedatectl
      Local time: Fri 2018-2-29 13:31:04 CST
  Universal time: Fri 2018-2-29 05:31:04 UTC
        RTC time: Fri 2018-2-29 08:17:20
       Time zone: Asia/Shanghai (CST, +0800)
     NTP enabled: yes
NTP synchronized: yes
 RTC in local TZ: no
      DST active: n/a

#如果你当前的时区不正确，请按照以下操作设置。

#查看所有可用的时区：

# timedatectl list-timezones

#筛选式查看在亚洲S开的上海可用时区：

# timedatectl list-timezones |  grep  -E "Asia/S.*"

Asia/Sakhalin
Asia/Samarkand
Asia/Seoul
Asia/Shanghai
Asia/Singapore
Asia/Srednekolymsk

#设置当前系统为Asia/Shanghai上海时区：

# timedatectl set-timezone Asia/Shanghai

#设置完时区后，强制同步下系统时钟：

# chronyc -a makestep
200 OK</code></pre>

<h3>3、Master节点配置chrony</h3>

<p>此处选用的是阿里云的ntp服务server，地址为</p>

<pre><code>ntp1.aliyun.com</code></pre>

<p>当前是Master，ip地址为<strong>192.168.1.10</strong>，网段是<strong>192.168.1.0/24</strong>，配置详情如下，红色为更改部分</p>

<pre><code class="language-bash">vim /etc/chrony.conf


server ntp1.aliyun.com iburst

# Record the rate at which the system clock gains/losses time.
driftfile /var/lib/chrony/drift

# Allow the system clock to be stepped in the first three updates
# if its offset is larger than 1 second.
makestep 1.0 3

# Enable kernel synchronization of the real-time clock (RTC).
rtcsync

# Enable hardware timestamping on all interfaces that support it.
#hwtimestamp *

# Increase the minimum number of selectable sources required to adjust
# the system clock.
#minsources 2

# Allow NTP client access from local network.
#allow 192.168.0.0/16
allow 192.168.1.0/24

# Serve time even if not synchronized to a time source.
local stratum 10

# Specify file containing keys for NTP authentication.
#keyfile /etc/chrony.keys

# Specify directory for log files.
logdir /var/log/chrony

# Select which information is logged.
#log measurements statistics tracking
</code></pre>

<p><strong>重启</strong></p>

<pre><code># systemctl restart chronyd.service
# systemctl status chronyd.service</code></pre>

<p><img alt="" height="363" src="https://img-blog.csdnimg.cn/20200420112830302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="998"></p>

<pre><code>强制同步下系统时钟：
# chronyc -a makestep

查看时间同步源状态：
# chronyc sourcestats

查看时间同步源：
# chronyc sources -v</code></pre>

<p><img alt="" height="442" src="https://img-blog.csdnimg.cn/20200420113129524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="848"></p>

<h3>4、Node节点配置chrony</h3>

<p><strong>node节点</strong>(192.168.26.136)只需要注释掉原来的ip，新增Master主机的IP地址即可（记得<strong>重启</strong>chrony服务）</p>

<p><img alt="" height="431" src="https://img-blog.csdnimg.cn/20200420113245814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="617"></p>

<pre><code># systemctl restart chronyd.service
# systemctl status chronyd.service</code></pre>

<p><img alt="" height="364" src="https://img-blog.csdnimg.cn/20200420113321607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="984"></p>

<pre><code>强制同步下系统时钟：
# chronyc -a makestep

查看时间同步源状态：
# chronyc sourcestats

查看时间同步源：
# chronyc sources -v</code></pre>

<p><img alt="" height="419" src="https://img-blog.csdnimg.cn/2020042011341518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="769"></p>

<p><strong>Node2也是以上步骤</strong></p>

<p>&nbsp;</p>

<h3 id="0x05-chrony.conf%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">5、 chrony.conf文件详解</h3>

<p><strong>以下是系统默认配置文件的说明(CentOS7)，了解一下各个配置是做什么。</strong></p>

<pre><code class="language-bash"># 使用pool.ntp.org项目中的公共服务器。以server开，理论上你想添加多少时间服务器都可以。
# Please consider joining the pool (http://www.pool.ntp.org/join.html).
server 0.centos.pool.ntp.org iburst
server 1.centos.pool.ntp.org iburst
server 2.centos.pool.ntp.org iburst
server 3.centos.pool.ntp.org iburst

# 根据实际时间计算出服务器增减时间的比率，然后记录到一个文件中，在系统重启后为系统做出最佳时间补偿调整。
driftfile /var/lib/chrony/drift

# chronyd根据需求减慢或加速时间调整，
# 在某些情况下系统时钟可能漂移过快，导致时间调整用时过长。
# 该指令强制chronyd调整时期，大于某个阀值时步进调整系统时钟。
# 只有在因chronyd启动时间超过指定的限制时（可使用负值来禁用限制）没有更多时钟更新时才生效。
makestep 1.0 3

# 将启用一个内核模式，在该模式中，系统时间每11分钟会拷贝到实时时钟（RTC）。
rtcsync

# Enable hardware timestamping on all interfaces that support it.
# 通过使用hwtimestamp指令启用硬件时间戳
#hwtimestamp eth0
#hwtimestamp eth1
#hwtimestamp *

# Increase the minimum number of selectable sources required to adjust
# the system clock.
#minsources 2

# 指定一台主机、子网，或者网络以允许或拒绝NTP连接到扮演时钟服务器的机器
#allow 192.168.0.0/16
#deny 192.168/16

# Serve time even if not synchronized to a time source.
local stratum 10

# 指定包含NTP验证密钥的文件。
#keyfile /etc/chrony.keys

# 指定日志文件的目录。
logdir /var/log/chrony

# Select which information is logged.
#log measurements statistics tracking</code></pre>

<p><img alt="" height="428" src="https://img-blog.csdnimg.cn/20200420114231122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="739"></p>

<p><img alt="" height="276" src="https://img-blog.csdnimg.cn/2020042011425943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="734"></p>

<h3 id="0x07-chrony%E7%9A%84%E4%BC%98%E5%8A%BF">6、chrony的优势</h3>

<p>chrony的优势更快的同步只需要数分钟而非数小时时间，从而最大程度减少了时间和频率误差，这对于并非全天 24 小时运行的台式计算机或系统而言非常有用。</p>

<p>能够更好地响应时钟频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率发生变化的节能技术而言非常有用。</p>

<p>在初始同步后，它不会停止时钟，以防对需要系统时间保持单调的应用程序造成影响。</p>

<p>在应对临时非对称延迟时（例如，在大规模下载造成链接饱和时）提供了更好的稳定性。</p>

<p>无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。</p>

<p><img alt="" height="699" src="https://img-blog.csdnimg.cn/20200420114950310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1057"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Python项目打包发布Linux线上</title><link>http://www.cnblogs.com/heian99/archive/2020/04/18/12865377.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Apr 2020 09:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/04/18/12865377.html</guid><description><![CDATA[
                                            <blockquote>
<p>近期写一个Python系统硬件监控，准备发布到Linux上。</p>
</blockquote>

<p>下面一起看看怎么把项目发布到Linux上吧。</p>

<h1>环境要求</h1>

<p><strong>Python版本：3.7</strong></p>

<p>&nbsp;</p>

<h1>Windows运行项目</h1>

<p><img alt="" height="394" src="https://img-blog.csdnimg.cn/20200418164919336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="811"></p>

<p><img alt="" height="989" src="https://img-blog.csdnimg.cn/20200418164935273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<h1>Centos7运行项目</h1>

<p>因为centos7的python环境是2.75的。</p>

<p>所以我们首先把Python环境换成3.7的才行。</p>

<p><strong><a href="https://blog.csdn.net/heian_99/article/details/105428325">Centos7升级Python3.7.3版本</a></strong></p>

<p>上面是教程。</p>

<h3>（1）打包Python项目的依赖（也就是本地安装的项目依赖）</h3>

<pre><code>pip3 freeze &gt; requirements.txt
</code></pre>

<p><img alt="" height="630" src="https://img-blog.csdnimg.cn/20200418165554759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1022"></p>

<h3>（2）压缩Python项目和上传到服务器，解压</h3>

<p><img alt="" height="173" src="https://img-blog.csdnimg.cn/20200418165656154.png" width="920"></p>

<p><strong>zip包的解压命令：unzip 包名</strong></p>

<p><img alt="" height="149" src="https://img-blog.csdnimg.cn/20200418165840505.png" width="821"></p>

<h3>（3）cd到项目里，安装依赖</h3>

<pre><code> pip3 install -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com -r requirements.txt</code></pre>

<p><img alt="" height="345" src="https://img-blog.csdnimg.cn/202004181701159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1042"></p>

<p>&nbsp;</p>

<h3>（4）运行项目启动文件</h3>

<pre><code>python3 manage.py 
</code></pre>

<p><img alt="" height="998" src="https://img-blog.csdnimg.cn/20200418170247801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" height="203" src="https://img-blog.csdnimg.cn/20200418170257165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1022"></p>

<p><strong>项目已经运行成功，还有最简便的方法就是运行在docker容器里，更加方便，后续会更新</strong></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Python购物车和学生管理系统</title><link>http://www.cnblogs.com/heian99/archive/2020/04/14/12865378.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 14 Apr 2020 07:53:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/04/14/12865378.html</guid><description><![CDATA[
                                            <h3>购物车练习程序</h3>

<p><strong>（1）可以显示商品列表</strong></p>

<p><strong>（2）根据商品id进行购买</strong></p>

<p><strong>（3）根据输入的工作来判断是否有足够的钱购买</strong></p>

<p><strong>（4）退出时，显示购买的商品和卡中的余额</strong></p>

<pre><code class="language-python"># 购物车练习程序

product_list = [
    ('iphone', 5000),
    ('Mac', 9000),
    ('Bike', 800),
    ('watch', 600),
    ('book', 600),
]
shopping_list = []
def shop():
    salay = input("请输入你的工资:")
    if salay.isdigit():
        salay = int(salay)
        while True:
            for index, itme in enumerate(product_list):
                #print(product_list.index(itme),itme)
                print(index,itme)

            user_choice = input("选择要买的商品？请选择购买的编号！")

            if user_choice.isdigit():
                user_choice = int(user_choice)
                if user_choice &lt; len(product_list) and user_choice &gt;-1:
                    p_itme = product_list[user_choice]
                    if p_itme[1] &lt;= salay:#买的起
                        shopping_list.append(p_itme)
                        salay-=p_itme[1]
                        print("Added %s into shopping cart ,you current balance is \033[31;1m%s\033[0m" %(p_itme,salay))
                    else:
                        print("\033[41;1m你的余额不足，只剩[%s]\033[0m" % salay)
                else:
                    print("请输入正确商品编号")

            elif user_choice == 'q':

                print('----------------------shopping list----------------------------')
                for p in shopping_list:
                    print(p)
                print("\033[41;1m你的余额[%s]\033[0m" % salay)
                exit()
            else:
                print("请输入正确的编号")
    else:
        print("你输入的工资格式不对，请输入正确的格式")
        shop()
shop()
</code></pre>

<h3>学生管理系统</h3>

<pre>欢迎使用[学生管理系统] V1.0
1.显示所有学生信息
2.新建学生信息
3.查询学生信息
4.修改学生信息
5.删除学生信息
0.退出系统</pre>

<pre><code class="language-python">"""
欢迎使用[学生管理系统] V1.0
1.显示所有学生信息
2.新建学生信息
3.查询学生信息
4.修改学生信息
5.删除学生信息
0.退出系统
"""
# 模拟学生数据
from datetime import datetime

student_data = [
    {
        'name': '南宫乘风',
        'sex': '男',
        'address': '西安',
        'birthday': '20000229'
    },
    {
        'name': '乘风',
        'sex': '男',
        'address': '洋县',
        'birthday': '20101229'
    }
]


# 学生类
class Student:
    # 学生初始化
    def __init__(self, name, sex, address, birthday):
        self.name = name
        self.sex = sex
        self.address = address
        self.birthday = birthday

    # 获取学生年龄
    def get_age(self):
        if self.birthday:
            age = datetime.now().year - int(self.birthday[:4])
            return age
        else:
            print("不知道")


# 学生管理系统类


class System:
    # 初始化
    def __init__(self, name):
        self.name = name
        self.data = []

    # 美化输出打印
    def beauty_print(self, data_list):
        for index, student in enumerate(data_list):
            print(f"序号：{index}", end='\t')
            print(f"姓名：{student.name}", end='\t')
            print(f"性别：{student.sex:2}", end='\t')
            print(f"地址：{student.address}", end='\t')
            print(f"年龄：{student.get_age()}")

    # 加载数据
    def load_data(self):
        for item in student_data:
            student = Student(item['name'], item['sex'], item['address'], item['birthday'])
            self.data.append(student)

    # 显示菜单
    def show_menu(self):
        # f-string
        print(f"""
        ******************************
            欢迎使用[{self.name}] V2.0
            1.显示所有学生信息
            2.新建学生信息
            3.查询学生信息
            4.修改学生信息
            5.删除学生信息
            0.退出系统
        ******************************    
        """)

    # 启动学生管理系统
    def start(self):
        # 加载数据
        self.load_data()
        while True:

            self.show_menu()
            op = input("选择操作")
            if op == '1':
                self.show_all_student()
            elif op == '2':
                self.create_student()
            elif op == '3':
                self.find_student()
            elif op == '4':
                self.modify_student()
            elif op == '5':
                self.remove_student()
            elif op == '6':
                print('退出程序')
                break
            else:
                print("请输入正常的操作")

    # 选择性别
    def choose_sex(self):
        sex = input("请选择性别：（1）:男|(2):女").strip()
        if sex == '1':
            return '男'
        elif sex == '2':
            return '女'
        else:
            return '未知'

    # 判断名字
    def input_name(self):
        while True:
            name = input("请输入名字：").strip()
            if name:
                return name
            else:
                continue

    # 根据名字查询
    def find_student_name(self):
        name = self.input_name()
        find_list = []
        for student in self.data:
            if name.lower() in student.name.lower():
                find_list.append(student)
        if find_list:
            return find_list
        else:
            print(f"没有找到学生：{name}")

    # 1.显示所有学生信息
    def show_all_student(self):
        self.beauty_print(self.data)

    # 2.新建学生信息
    def create_student(self):
        name = self.input_name()
        sex = self.choose_sex()
        address = input("请输入地址")
        birthday = input("请输入生日")
        student = Student(name, sex, address, birthday)
        self.data.append(student)

    # 3.查询学生信息
    def find_student(self):
        # name = self.input_name()
        # for student in self.data:
        #     if name.lower() in student.name.lower():
        #         self.beauty_print([student])

        find_list = self.find_student_name()
        self.beauty_print(find_list)

    # 4.修改学生信息
    def modify_student(self):
        find_list = self.find_student_name()
        if find_list:
            self.beauty_print(find_list)
            index = int(input("选择序号:"))
            student = find_list[index]
            print('当前修改的是：')
            self.beauty_print([student])
            student.name = input('输入新的名字：').strip()
            student.sex = self.choose_sex()
            student.address = input("请输入地址：")
            student.birthday = input("请输入生日：")
            print(f'{student.name}已经修改')
            return

    # 5.删除学生信息
    def remove_student(self):
        find_list = self.find_student_name()
        if find_list:
            self.beauty_print(find_list)
            index = int(input("选择序号:"))
            student = find_list[index]
            print('当前删除的是：')
            self.beauty_print([student])
            self.data.remove(student)
            return
        else:
            print(f'没有的人')

    # 0.退出系统


if __name__ == '__main__':
    student_sys = System('乘风系统')
    student_sys.start()
</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Centos7升级Python3.7.3版本</title><link>http://www.cnblogs.com/heian99/archive/2020/04/10/12865379.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 10 Apr 2020 02:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/04/10/12865379.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p>

<p id="%E6%AD%A3%E6%96%87%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%AD%A3%E6%96%87%EF%BC%9A" rel="nofollow">正文：</a></p>

<p id="1.%E4%B8%8B%E8%BD%BDPython3.7.3%E7%9A%84%E9%95%9C%E5%83%8F-toc" style="margin-left:80px;"><a href="#1.%E4%B8%8B%E8%BD%BDPython3.7.3%E7%9A%84%E9%95%9C%E5%83%8F" rel="nofollow">1.下载Python3.7.3的镜像</a></p>

<p id="2%E3%80%81%E8%A7%A3%E5%8E%8B%20tar%20-xzvf%20Python-3.7.3.tgz-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E8%A7%A3%E5%8E%8B%20tar%20-xzvf%20Python-3.7.3.tgz" rel="nofollow">2、解压 tar -xzvf Python-3.7.3.tgz</a></p>

<p id="3%E3%80%81cd%20Python-3.7.3-toc" style="margin-left:80px;"><a href="#3%E3%80%81cd%20Python-3.7.3" rel="nofollow">3、cd Python-3.7.3</a></p>

<p id="4%E3%80%81%E5%AE%89%E8%A3%85%E5%88%B0%2Fusr%2Flocal%E7%9B%AE%E5%BD%95%E4%B8%AD-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%AE%89%E8%A3%85%E5%88%B0%2Fusr%2Flocal%E7%9B%AE%E5%BD%95%E4%B8%AD" rel="nofollow">4、安装到/usr/local目录中</a></p>

<p id="5%E3%80%81make%20%26%26%20make%C2%A0altinstall-toc" style="margin-left:80px;"><a href="#5%E3%80%81make%20%26%26%20make%C2%A0altinstall" rel="nofollow">5、make &amp;&amp; make&nbsp;altinstall</a></p>

<p id="6%E3%80%81%E9%AA%8C%E8%AF%81-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E9%AA%8C%E8%AF%81" rel="nofollow">6、验证</a></p>

<p id="7%E3%80%81cd%20%2Fusr%2Fbin-toc" style="margin-left:80px;"><a href="#7%E3%80%81cd%20%2Fusr%2Fbin" rel="nofollow">7、cd /usr/bin</a></p>

<p id="8%E3%80%81%E5%A4%87%E4%BB%BD%E4%B9%8B%E5%89%8D%E7%9A%84python%C2%A0-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E5%A4%87%E4%BB%BD%E4%B9%8B%E5%89%8D%E7%9A%84python%C2%A0" rel="nofollow">8、备份之前的python&nbsp;</a></p>

<p id="9%E3%80%81%E5%88%9B%E5%BB%BA%E8%BD%AF%E8%BF%9E%E6%8E%A5%C2%A0-toc" style="margin-left:80px;"><a href="#9%E3%80%81%E5%88%9B%E5%BB%BA%E8%BD%AF%E8%BF%9E%E6%8E%A5%C2%A0" rel="nofollow">9、创建软连接&nbsp;</a></p>

<p id="%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E9%97%AE%E9%A2%98" rel="nofollow">问题</a></p>

<p id="1%E3%80%81%E6%9B%B4%E6%94%B9yum%E8%84%9A%E6%9C%AC%E7%9A%84python%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E6%9B%B4%E6%94%B9yum%E8%84%9A%E6%9C%AC%E7%9A%84python%E4%BE%9D%E8%B5%96" rel="nofollow">1、更改yum脚本的python依赖</a><a href="#%E2%80%8B" rel="nofollow">​</a></p>

<p id="2%E3%80%81%E4%BF%AE%E6%94%B9urlgrabber%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E4%BF%AE%E6%94%B9urlgrabber%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">2、修改urlgrabber配置文件</a></p>

<p id="%E5%A4%87%E6%B3%A8%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%A4%87%E6%B3%A8%EF%BC%9A" rel="nofollow">备注：</a></p>

<hr id="hr-toc"><h1 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h1>

<p>我们使用的centos7镜像，里面都内置的Python，但都是python2的版本，比较落后。</p>

<p><img alt="" height="316" src="https://img-blog.csdnimg.cn/20200410094932143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="702"></p>

<p>现在有的有Python3已经出来，有的程序运行需要Python3的环境支持。</p>

<p><span style="color:#f33b45;"><strong>安装下面操作，能够正确安装和替换Python2，如果操作有问题请下方留言</strong></span></p>

<p>&nbsp;</p>

<h1 id="%E6%AD%A3%E6%96%87%EF%BC%9A">正文：</h1>

<p>&nbsp;</p>

<h3 id="1.%E4%B8%8B%E8%BD%BDPython3.7.3%E7%9A%84%E9%95%9C%E5%83%8F">1.下载Python3.7.3的镜像</h3>

<pre><code class="language-bash">wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz</code></pre>

<h3 id="2%E3%80%81%E8%A7%A3%E5%8E%8B%20tar%20-xzvf%20Python-3.7.3.tgz">2、解压 tar -xzvf Python-3.7.3.tgz</h3>

<pre><code class="language-bash">tar -xzvf Python-3.7.3.tgz</code></pre>

<h3 id="3%E3%80%81cd%20Python-3.7.3">3、cd Python-3.7.3</h3>

<pre><code class="language-bash">cd Python-3.7.3</code></pre>

<p><img alt="" height="602" src="https://img-blog.csdnimg.cn/20200410095352308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="455"></p>

<h3 id="4%E3%80%81%E5%AE%89%E8%A3%85%E5%88%B0%2Fusr%2Flocal%E7%9B%AE%E5%BD%95%E4%B8%AD">4、安装到/usr/local目录中</h3>

<pre><code> ./configure --prefix=/usr/local/python3</code></pre>

<p><strong><span style="color:#f33b45;">执行这步后，会检测程序。等检测完毕，是否有报错或者依赖没安装。</span></strong></p>

<p><img alt="" height="558" src="https://img-blog.csdnimg.cn/20200410095527594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="619"></p>

<h3 id="5%E3%80%81make%20%26%26%20make%C2%A0altinstall">5、make &amp;&amp; make&nbsp;altinstall</h3>

<pre><code class="language-bash">make &amp;&amp; make altinstall</code></pre>

<p><span style="color:#f33b45;"><strong>执行这步后，会进行编译，然后安装程序到指定的目录</strong></span></p>

<h3 id="6%E3%80%81%E9%AA%8C%E8%AF%81">6、验证</h3>

<p>直接先运行python3，再确认一下版本信息：</p>

<p><img alt="" height="587" src="https://img-blog.csdnimg.cn/20200410103542694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1024"></p>

<h3 id="7%E3%80%81cd%20%2Fusr%2Fbin">7、cd /usr/bin</h3>

<h3 id="8%E3%80%81%E5%A4%87%E4%BB%BD%E4%B9%8B%E5%89%8D%E7%9A%84python%C2%A0">8、备份之前的python&nbsp;</h3>

<pre><code class="language-bash">mv python python.bak</code></pre>

<p><img alt="" height="467" src="https://img-blog.csdnimg.cn/2020041010390020.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="646"></p>

<h3 id="9%E3%80%81%E5%88%9B%E5%BB%BA%E8%BD%AF%E8%BF%9E%E6%8E%A5%C2%A0">9、创建软连接&nbsp;</h3>

<pre><code class="language-bash">ln -s /usr/local/python3/bin/python3.7 /usr/bin/python</code></pre>

<p><img alt="" height="198" src="https://img-blog.csdnimg.cn/20200410104048542.png" width="789"></p>

<p><img alt="" height="287" src="https://img-blog.csdnimg.cn/20200410104207453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="725"></p>

<h1 id="%E9%97%AE%E9%A2%98"><span style="color:#f33b45;">问题</span></h1>

<p><img alt="" height="166" src="https://img-blog.csdnimg.cn/20200410104254815.png" width="564"></p>

<h3 id="1%E3%80%81%E6%9B%B4%E6%94%B9yum%E8%84%9A%E6%9C%AC%E7%9A%84python%E4%BE%9D%E8%B5%96">1、更改yum脚本的python依赖</h3>

<pre><code class="language-bash">vi /usr/bin/yum</code></pre>

<p><strong>#!/usr/bin/python&nbsp;改为&nbsp;#!/usr/bin/python2</strong></p>

<p><img alt="" height="233" src="https://img-blog.csdnimg.cn/20200410104331995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="652"></p>

<h3 id="%E2%80%8B"><img alt="" height="350" src="https://img-blog.csdnimg.cn/20200410104455768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="995"></h3>

<h3 id="2%E3%80%81%E4%BF%AE%E6%94%B9urlgrabber%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">2、修改urlgrabber配置文件</h3>

<pre><code class="language-bash">vi /usr/libexec/urlgrabber-ext-down</code></pre>

<p><strong>#!/usr/bin/python&nbsp;改为&nbsp;#!/usr/bin/python2</strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h1 id="%E5%A4%87%E6%B3%A8%EF%BC%9A"><span style="color:#f33b45;"><strong>备注：</strong></span></h1>

<p>1、3.6的依赖 没有执行 报错了 后续有需要再逐步加上这些依赖吧</p>

<pre><code class="language-bash">yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel</code></pre>

<p>2、3.7的依赖包（一定要在安装前先install 否则安装会报错）</p>

<pre><code class="language-bash">yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel libffi-devel
</code></pre>

<p><strong>测试</strong>：输入python 查看最新的版本</p>

<p><img alt="" height="250" src="https://img-blog.csdnimg.cn/20200410104626467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="706"></p>

<p>&nbsp;</p>

<p>已经完成，可以正常使用python3了</p>
                                    ]]></description></item><item><title>Linux 服务器上有挖矿病毒处理【分析+解决】</title><link>http://www.cnblogs.com/heian99/archive/2020/04/01/12865374.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 01 Apr 2020 08:13:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/04/01/12865374.html</guid><description><![CDATA[
                                            <h1>Linux 服务器上有挖矿病毒处理</h1>

<h2>分析</h2>

<p><strong>今天遇到病毒挖矿，有点小兴奋。</strong></p>

<p><strong>来波分析：</strong></p>

<p><strong>看上面的症状是：攻击者通过docker入侵的【<span style="color:#f33b45;">后面了解，可能是redis账号密码简单的原因被爆破的</span>】</strong></p>

<p><strong>最奇诡的事，攻击者可能通过提权，获取到root的权限。然后一些列的挖矿病毒</strong></p>

<p><strong>大致流程图</strong></p>

<p><img alt="" height="324" src="https://img-blog.csdnimg.cn/2020040115423125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="648"></p>

<p><img alt="" height="472" src="https://img-blog.csdnimg.cn/20200401153640531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="806"></p>

<h3>症状表现</h3>

<p><strong>服务器CPU资源使用一直处于100%的状态，通过&nbsp;<code>top</code>&nbsp;命令查看，发现可疑进程&nbsp;</strong></p>

<h2><img alt="" height="559" src="https://img-blog.csdnimg.cn/20200401154407826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="800"></h2>

<h2>&nbsp;</h2>

<h2>解决</h2>

<h3>排查方法</h3>

<p><strong><code>首先</code>：查看 bbb进程，使用&nbsp;<code>ps -ef | grep bbb&nbsp;</code></strong></p>

<p><img alt="" height="212" src="https://img-blog.csdnimg.cn/20200401154526249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="782"></p>

<blockquote>
<p><strong>PS： 通过 ps -ef 命令查出 bbb进程号，直接 kill -9 进程号并删除 /tmp/bbb执行文件。但没有过1分钟进程又运行了，这时就能想到，bbbb有守护程序或者有计划任务。通过 crontab -l 查看是否有可疑的计划任务。</strong></p>
</blockquote>

<h3>定时任务</h3>

<p><strong>看来有猫腻，准备删除这些定时任务【<span style="color:#f33b45;">但是无法删除</span>】</strong></p>

<p><img alt="" height="86" src="https://img-blog.csdnimg.cn/20200401154814957.png" width="892"></p>

<p><img alt="" height="154" src="https://img-blog.csdnimg.cn/20200401155049914.png" width="365"></p>

<p><span style="color:#f33b45;"><strong>注意：无法删除，原因被chatter 上锁了</strong></span></p>

<p><strong>那我就开锁就行</strong></p>

<p><img alt="" height="240" src="https://img-blog.csdnimg.cn/20200401155117130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="376"></p>

<h3><span style="color:#f33b45;">重点</span></h3>

<p><u><strong>当你解开锁时时，但是你去删除这个文件，全是无法删除。再看看权限，又被锁住了。【<span style="color:#f33b45;">攻击者你很骚气啊</span>】</strong></u></p>

<p>咦，我发现了邮件服务，每当我运行权限脚本时，都会发送一个邮件到/var/spool/mail/root</p>

<pre><code class="language-bash">You have new mail in /var/spool/mail/root提示</code></pre>

<p>看到这个，我有点起疑心了。</p>

<p><strong>怀疑</strong>：为啥我们平常的服务器上没有出现这个，但现在为啥会出现邮件。【<span style="color:#f33b45;">突破点</span>】</p>

<p>我想想了，可能是通过mail的提示来检测我的服务器操作，从而重新执行脚本。</p>

<p>OK。那我就干掉你，看你怎么检测</p>

<h3>第一步：关闭提示</h3>

<pre><code class="language-bash">echo "unset MAILCHECK"&gt;&gt; /etc/profile
source /etc/profile</code></pre>

<h3>第二步：查看</h3>

<pre><code class="language-bash">ls -lth /var/spool/mail/</code></pre>

<h3>第三步：清空</h3>

<pre><code class="language-bash">cat /dev/null &gt; /var/spool/mail/root</code></pre>

<h2><span style="color:#f33b45;">定时任务清空【完成】</span></h2>

<p><span style="color:#7c79e5;"><strong>让你们了解一下chatter锁。想深入可以百度了解看一下</strong></span></p>

<p><strong>lsattr</strong>可用来查看文件的属性：</p>

<pre><code class="language-bash">lsattr filename</code></pre>

<p>如果文件属性中有i与a，或者有其中的一个</p>

<p>可以使用<strong>chattr</strong>去掉这属性：</p>

<pre><code class="language-bash">chattr -ia filename</code></pre>

<p>这次来试试，OK了，文件清空。</p>

<p><img alt="" height="264" src="https://img-blog.csdnimg.cn/20200401155816202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="578"></p>

<p>&nbsp;</p>

<h2>bbb程序删掉</h2>

<p><strong>top查看 </strong></p>

<p><img alt="" height="560" src="https://img-blog.csdnimg.cn/20200401155919235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="834"></p>

<h3>分析运行路径</h3>

<p><img alt="" height="311" src="https://img-blog.csdnimg.cn/20200401160005732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="819"></p>

<p><code>第三步</code>：kill 掉 bbb守护进程 <code>kill -9 25800</code>，最后删除 bbb执行程序 <code>rm -f /var/tmp/bbb</code>。</p>

<p>但是这个脚本也被chatter了，需要解锁才能删除。</p>

<p>解锁，删掉。</p>

<h2>curl程序删掉</h2>

<p>上面的病毒搞完了，但是还有curl后台程序运行。</p>

<p><img alt="" height="286" src="https://img-blog.csdnimg.cn/20200401160549250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="880"></p>

<p>开机自启，是什么位置</p>

<p><img alt="" height="439" src="https://img-blog.csdnimg.cn/20200401160813126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1040"></p>

<p>删掉这些程序，重启一下</p>

<p><img alt="" height="575" src="https://img-blog.csdnimg.cn/20200401160920480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="796"></p>

<p><img alt="" height="187" src="https://img-blog.csdnimg.cn/20200401160926984.png" width="744"></p>

<p>服务器稳定运行，没有病毒程序。</p>

<h2>SSH秘钥删除</h2>

<p>攻击者可能在/root/.ssh/里面留他们的秘钥，所以我们要清理掉。重新生成秘钥。</p>

<p>&nbsp;</p>

<h2>后期防护</h2>

<ul><li>启用ssh公钥登陆，禁用密码登陆。</li>
	<li>云主机：完善安全策略，入口流量，一般只开放 80 443 端口就行，出口流量默认可以不限制，如果有需要根据需求来限制。物理机：可以通过硬件防火墙或者机器上iptables 来开放出入口流量规则。</li>
	<li>本机不是直接需要对外提供服务，可以拒绝外网卡入口所有流量，通过 jumper 机器内网登陆业务机器。</li>
	<li>公司有能力可以搭建安全扫描服务，定期检查机器上漏洞并修复。</li>
</ul><p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Docker一键部署GitLab+Jenkins【本地持久化】</title><link>http://www.cnblogs.com/heian99/archive/2020/03/31/12865381.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 31 Mar 2020 07:35:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/31/12865381.html</guid><description><![CDATA[
                                            <h3>docker-compose安装配置</h3>

<p id="3748988653"><strong>二进制安装</strong></p>

<p>1、下载最新版的 docker-compose 二进制执行文件。</p>

<pre><code class="language-bash">sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</code></pre>

<p>2、配置可执行权限。</p>

<pre><code class="language-bash">sudo chmod +x /usr/local/bin/docker-compose</code></pre>

<p>3、测试是否安装成功。</p>

<pre><code class="language-bash">docker-compose --version </code></pre>

<p><img alt="" height="204" src="https://img-blog.csdnimg.cn/20200331153131369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="605"></p>

<p><strong>使用docker-compose启动yml，一键配置和启动容器</strong></p>

<p><strong>对于容器开机启动，本地数据持续化，保留数据</strong></p>

<p><strong>安装docker-compose</strong></p>

<p><strong>运行：</strong></p>

<pre><code class="language-bash">docker-compose up -d</code></pre>

<p><strong>但是这样运行的话，可能jenkins会运行，但是会报错，因为jenkins_home的权限不够，导致无法写入数据。</strong></p>

<p><strong>编写一个shell脚本，和这个docker-compose.yml放在一个目录下</strong></p>

<p><strong>直接运行这个脚本，就可以实现gitlab和jenkins的完美运行。</strong></p>

<p><strong>两个 开始消耗的内存和cpu过大，需要等待一会就可以了。</strong></p>

<p><strong>git.sh</strong></p>

<pre><code class="language-bash">#!/bin/bash
mkdir -p /usr/local/docker/jenkins/jenkins_home
chown -R 1000:1000 /usr/local/docker/jenkins/jenkins_home
docker-compose up -d</code></pre>

<p><strong>docker-compose.yml</strong></p>

<pre><code class="language-bash">version: '3'
services:
    gitlab:
      image: twang2218/gitlab-ce-zh:9.4
      restart: always
      hostname: 192.168.1.100
      environment:
        TZ: 'Asia/Shanghai'
        GITLAB_OMNIBUS_CONFIG: |
          external_url 'http://192.168.1.100:8080'
          gitlab_rails['gitlab_shell_ssh_port'] = 2222
          unicorn['port'] = 8888
          nginx['listen_port'] = 8080
      ports:
        - '8080:8080'
        - '8443:443'
        - '2222:22'
      volumes:
        - /usr/local/docker/gitlab/config:/etc/gitlab
        - /usr/local/docker/gitlab/repo:/var/opt/gitlab
        - /usr/local/docker/gitlab/logs:/var/log/gitlab

    jenkins:
      restart: always
      image: jenkins/jenkins
      container_name: docker_jenkins
      ports:
        - '8081:8080'
        - '50000:50000'
      volumes:
        - /usr/local/docker/jenkins/jenkins_home:/var/jenkins_home
      environment:
            JAVA_OPTS: '-Djava.util.logging.config.file=/var/jenkins_home/log.properties'</code></pre>

<p><img alt="" height="281" src="https://img-blog.csdnimg.cn/20200331153328896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1014"></p>

<p>&nbsp;</p>

<p><img alt="" height="592" src="https://img-blog.csdnimg.cn/20200331153406300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" height="975" src="https://img-blog.csdnimg.cn/20200331153421909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                                    ]]></description></item><item><title>Linux自动批量增加公钥</title><link>http://www.cnblogs.com/heian99/archive/2020/03/30/12865382.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 30 Mar 2020 05:41:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/30/12865382.html</guid><description><![CDATA[
                                            <h3>自动增加公钥</h3>

<p>需求：</p>

<p>提示要输入对方的ip和root密码，然后可以自动把本机的公钥增加到对方机器上，从而实现密钥认证。</p>

<p>1.在使用之前，先安装epel源，yum install expect -y</p>

<p>2.写分发脚本，后缀为exp</p>

<pre><code class="language-bash">#!/usr/bin/expect#!/bin/bash
#name:南宫乘风
#email：heian99@163.com
#自动添加公钥到指定的服务器
set host_ip [lindex $argv 0]
spawn ssh-copy-id -i /root/.ssh/id_rsa.pub $host_ip
expect {
        -timeout 60
        "(yes/no)?" { send "yes\n";exp_continue}
        "password:" { send "root\n"} #填写服务器的同一密码
        timeout {puts "Connect timeout!";return}
}
expect eof
exit -onexit {
        send_user "Job has finished!"
}</code></pre>

<p>注：set的作用是设置变量，spawn设置执行命令时，可以引用变量；变量的第一个参数为0</p>

<p>编写ip.txt,存放ip地址</p>

<p><img alt="" height="47" src="https://img-blog.csdnimg.cn/20200330133725664.png" width="260"></p>

<p>3.执行以下命令开始分发</p>

<pre><code class="language-bash">for ip in `cat /root/ip.txt`;do expect /root/ssh.exp $ip ;done</code></pre>

<p><img alt="" height="329" src="https://img-blog.csdnimg.cn/20200330134021584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="883"></p>

<p>如果密码不一样，也可以定义到ip.txt的文本里面，通过awk获取到。</p>

<p>然后传值给expect。可以实现不同ip和密码的自动批量秘钥传输。</p>
                                    ]]></description></item><item><title>主机存活监控</title><link>http://www.cnblogs.com/heian99/archive/2020/03/28/12865383.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 28 Mar 2020 09:59:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/28/12865383.html</guid><description><![CDATA[
                                            <h3>单个服务器监控</h3>

<p><strong>监控远程的一台机器(假设ip为192.168.1.100)的存活状态，当发现宕机时发一封邮件给你自己</strong></p>

<pre><code class="language-bash">#!/bin/bash
#name:南宫乘风
#email：heian99@163.com
ip="192.168.1.100"
while true ; do
    # 利用ping检查主机是否存活
    ping -c 4 $ip &gt; /dev/null 2&gt; /dev/null
    if [ $? != "0" ]; then
        # 失败提示，可以通过邮件发送信息（mailx）
        echo "$ip已经挂掉"
        #echo "服务器$ip坏掉，请及时处理" | mail -s "$ip服务器挂掉" 1794748404@qq.com
    else
        echo "$ip正常"
    fi
    sleep 3s
    
done</code></pre>

<h3>批量服务器监控</h3>

<p><strong>监控多台服务器，可以使用文本记录ip或者使用数组</strong></p>

<pre><code class="language-bash">#!/bin/bash
#name:南宫乘风
#email：heian99@163.com
#此处也可以使用文本，写入ip地址
#ip=$(cat /data/ip.txt)
ip="192.168.1.100 192.168.1.111 192.168.1.99"
while true ; do
    for i in $ip; do
    # 利用ping检查主机是否存活
    echo "$i"
    ping -c 4 $i &gt; /dev/null 2&gt; /dev/null
    if [ $? != "0" ]; then
        # 失败提示，可以通过邮件发送信息（mailx）
        echo "$i已经挂掉"
        #echo "服务器$i坏掉，请及时处理" | mail -s "$i服务器挂掉" 1794748404@qq.com
    else
        echo "$i正常"
    fi
    sleep 3s      
    done 
done</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>[Linux小技巧] 将 rm 命令删除的文件放在回收站</title><link>http://www.cnblogs.com/heian99/archive/2020/03/26/12585719.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 26 Mar 2020 09:22:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/26/12585719.html</guid><description><![CDATA[
                                            <h3>自定义rm命令</h3>

<p><strong>linux系统的rm命令太危险，一不小心就会删除掉系统文件。 写一个shell脚本来替换系统的rm命令，要求当删除一个文件或者目录时，都要做一个备份，然后再删除。下面分两种情况，做练习：</strong></p>

<h3><strong>1. 简单的实现：</strong></h3>

<p>假设有一个大的分区/data/，每次删除文件或者目录之前，都要先在/data/下面创建一个隐藏目录，以日期/时间命名，比如/data/.20170327/，然后把所有删除的文件同步到该目录下面，可以使用rsync -R 把文件路径一同同步，示例</p>

<pre><code class="language-bash">#!/bin/bash
#name:南宫乘风
#email：heian99@163.com
fileName=$1
now=`date +%Y%y%d`
dir=$(/data/$now)
read  -p "你确定删除这文件或者目录吗 $1 ? yes|no :" input
if [ $input == "yes" ] || [ $input == "y" ]; then
     # 判断目录是否存在
     if [ ! -d $dir ]; then
        mkdir /data/$now
    fi
    # rsync同步要删除的文件和目录
     rsync -aR $1/ /data/$now/$1/
     rm -rf $1
    
elif [ $input == "no" ] || [ $input == "n" ]; then
     # 选择no退出
     exit 0
else
     # 如果选择别的输入符，提示
     echo "只能输入yes或者no"
     exit 0
fi</code></pre>

<h3><strong>2.复杂的实现：</strong></h3>

<p>不知道哪个分区有剩余空间，在删除之前先计算要删除的文件或者目录大小，然后对比系统的磁盘空间，如果够则按照上面的规则创建隐藏目录，并备份，如果没有足够空间，要提醒用户没有足够的空间备份并提示是否放弃备份，如果用户输入yes，则直接删除文件或者目录，如果输入no，则提示未删除，然后退出脚本，示例：&nbsp;</p>

<pre><code class="language-bash">#!/bin/bash
#name:南宫乘风
#email：heian99@163.com
now=$(date +%Y%m%d)
#判断文件大写
f_size=$(du -sk $dir | awk '{print $1}')
#判断磁盘大小
disk_szie=$(df -k| grep -vi filesystem | awk '{print $4}'|sort -n|tail -n1)
#判断最大的目录在哪里
big_filesystem=$(df -k|grep -vi filesystem | sort -n -k4 | tail -n1 | awk '{print $NF}')
#判断文件大小和磁盘大小比较
if [ $f_size -lt $disk_szie ]; then
     # 输入选项，准备开始删除工作
     read  -p "你确定删除这文件或者目录吗 $1 ? yes|no :" input
    if [ $input == "yes" ] || [ $input == "y" ]; then
         # 判断存放目录是否存在
         if [ ! -d $big_filesystem/data/$now ]; then
             # 不存在新建目录
            mkdir -p $big_filesystem/data/$now
         fi
         rsync -aR $1 $big_filesystem/$now/
         rm -rf $1
    #判断输入no的情况
    elif [ $input == "no" ] || [ $input == "n"]; then
         exit 0
    else
       # 如果选择别的输入符，提示
        echo "只能输入yes或者no"  
    fi
    
else
     # 判断磁盘空间不足的情况
     echo "这磁盘没有足够的空间备份: $1."
     read -p "你还想删除"$1"吗？ yes|no ：" input
     if [ $input == "yes" ] || [ $input == "n" ]; then
          # body
          echo "$1将会在3秒后删除，将不会有备份"
          for i in `seq 1 5`; do echo -ne "."; sleep 1; done
          rm -rf $1

     elif [ $input == "no" ] || [ $input == "n" ]; then
          echo "将不会删除 $1."
          exit 0
     else
          # 如果选择别的输入符，提示
           echo "只能输入yes或者no"  
     fi
     
fi</code></pre>

<p>我的gitee：<a href="https://gitee.com/chengfeng99/Linux-DevOps" rel="nofollow">https://gitee.com/chengfeng99/Linux-DevOps</a></p>

<p>欢迎和我一起来讨论学习</p>

<p><img alt="" height="909" src="https://img-blog.csdnimg.cn/20200326172100697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h1>&nbsp;</h1>
                                    ]]></description></item><item><title>Linux常见问题及命令</title><link>http://www.cnblogs.com/heian99/archive/2020/03/25/12585720.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 25 Mar 2020 09:09:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/25/12585720.html</guid><description><![CDATA[
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h1><a id="Linux_0"></a>Linux常见问题及命令总结</h1>
<h2><a id="1Linux_2"></a>1.查询Linux系统相关的</h2>
<h3><a id="linux_4"></a>查看linux内核版本</h3>
<pre><code class="prism language-bash"><span class="token function">cat</span> /etc/version  
</code></pre>
<h3><a id="_10"></a>查看内核版本号</h3>
<pre><code class="prism language-bash"><span class="token function">uname</span> -r
</code></pre>
<h3><a id="_16"></a>查看内核/操作系统的信息</h3>
<pre><code class="prism language-bash"><span class="token function">uname</span> -a
</code></pre>
<h3><a id="_22"></a>查看系统版本号</h3>
<pre><code class="prism language-bash">lsb_release -a
</code></pre>
<h3><a id="cache_28"></a>手动释放cache缓存</h3>
<pre><code class="prism language-bash"><span class="token keyword">echo</span> 3 <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches 
</code></pre>
<h2><a id="2_34"></a>2.操作文件相关的</h2>
<h3><a id="_36"></a>查找目录下文件内字符串</h3>
<pre><code class="prism language-bash"><span class="token function">grep</span> -rn <span class="token string">"welcome"</span> *<span class="token punctuation">;</span>//查找当前目录下<span class="token string">"welcome"</span>字符串, *表示当前目录下所有文件,也可以是文件名
</code></pre>
<h3><a id="_43"></a>查找指定文件内字符串</h3>
<pre><code class="prism language-bash"><span class="token function">grep</span> -rn /usr/local/ -e <span class="token string">"20003"</span><span class="token punctuation">;</span>//查找在/usr/local目录下文件中包含20003关键字的文件
</code></pre>
<h3><a id="index_53"></a>搜索所有以index开头的文件</h3>
<pre><code class="prism language-bash"><span class="token function">find</span> /home/tom -name <span class="token string">'index*'</span>   <span class="token comment"># 搜索所有以index开头的文件</span>
</code></pre>
<h3><a id="home10000K_62"></a>在/home目录下搜索所有大小超过10000K的文件</h3>
<pre><code class="prism language-bash"><span class="token function">find</span> /home -size +10000k        <span class="token comment"># 在/home目录下搜索所有大小超过10000K的文件</span>

</code></pre>
<h3><a id="homesoftware__69"></a>在/home/software 下查找名字</h3>
<pre><code class="prism language-bash"><span class="token function">find</span> /home/software/ -type f -name <span class="token string">"splunk.tgz"</span><span class="token punctuation">;</span> //在/home/software 下查找名字为<span class="token string">"splunk.tgz"</span>的文件

</code></pre>
<h3><a id="redistargz_76"></a>解压redis.tar.gz的文件</h3>
<pre><code class="prism language-bash"><span class="token function">tar</span> -zxvf redis.tar.gz<span class="token punctuation">;</span>//解压redis.tar.gz的文件

</code></pre>
<h3><a id="C_83"></a>解压到指定目录（-C）</h3>
<pre><code class="prism language-bash"><span class="token function">tar</span> -zxvf jdk-8u72-linux-x64.tar.gz -C /usr/local<span class="token punctuation">;</span>//将jdk-8u72-linux-x64.tar.gz 解压到/usr/local目录中

</code></pre>
<h3><a id="d_90"></a>解压到指定目录（-d）</h3>
<pre><code class="prism language-bash">unzip gradle-3.3-bin.zip -d /usr/local/<span class="token punctuation">;</span> 将gradle-3.3-bin.zip解压到/usr/local目录

</code></pre>
<h3><a id="zip_97"></a>zip压缩文件</h3>
<pre><code class="prism language-bash"><span class="token function">zip</span>  -r test.zip  <span class="token function">test</span><span class="token punctuation">;</span>将test文件夹打包成test.zip

</code></pre>
<h3><a id="_104"></a>查看尾部内容</h3>
<pre><code class="prism language-bash"><span class="token function">tail</span> -f access.log<span class="token punctuation">;</span>//查看文件尾部内容

</code></pre>
<h3><a id="_111"></a>进程后台运行</h3>
<pre><code class="prism language-bash"><span class="token function">nohup</span> java -jar jenkins.war <span class="token operator">&amp;</span><span class="token punctuation">;</span>//进程后台程序

</code></pre>
<h3><a id="_118"></a>将文件权限分配用户</h3>
<pre><code class="prism language-bash"><span class="token function">chown</span> -R cdn:cdn common/<span class="token punctuation">;</span>//将common文件夹权限分给cdn

</code></pre>
<h3><a id="2017622_125"></a>查询2017年6月22日日志</h3>
<pre><code class="prism language-bash"><span class="token function">sed</span> -n <span class="token string">'/22\/Jun\/2017/'</span>p  access.log<span class="token operator">&gt;&gt;</span>20170622.log<span class="token punctuation">;</span>//查询2017年6月22日日志

</code></pre>
<h3><a id="_132"></a>截取某段时间的日志</h3>
<pre><code class="prism language-bash"><span class="token function">sed</span> -n <span class="token string">'/2017-06-15 00:00:00/,/2017-06-15 24:00:00/p'</span> catalina.out <span class="token operator">&gt;&gt;</span> 20170615.log<span class="token punctuation">;</span>//截取某个时间段的日志

</code></pre>
<pre><code class="prism language-bash"><span class="token function">sed</span> -n <span class="token string">'/2017-07-05 09:[0-9][0-9]:[0-9][0-9]/,/2017-07-05 16:[0-9][0-9]:[0-9][0-9]/p'</span>  catalina.out

</code></pre>
<h3><a id="_144"></a>创建文件软链接</h3>
<pre><code class="prism language-bash"><span class="token function">ln</span> -s /usr/mengqc/mub1 /usr/liu/abc<span class="token punctuation">;</span> 将/usr/mengqc/mub1代表的路径将存放在名为/usr/liu/abc的文件中。

</code></pre>
<h3><a id="_151"></a>删除软链接</h3>
<pre><code class="prism language-bash"><span class="token function">rm</span> -rf /usr/softlink <span class="token punctuation">;</span>删除软链接 注意后面不用加／

</code></pre>
<h3><a id="_158"></a>创建目录引向某个文件</h3>
<pre><code class="prism language-bash"><span class="token function">ln</span> –s  /var/www/test   /var/test <span class="token punctuation">;</span> 创建/var/test 引向/var/www/test 文件夹 

</code></pre>
<h2><a id="3_165"></a>3.查询进程相关的</h2>
<pre><code class="prism language-bash"><span class="token function">netstat</span> -lp<span class="token operator">|</span><span class="token function">grep</span> memcached<span class="token punctuation">;</span> //查看启动的memcache服务

<span class="token function">netstat</span> -nltp<span class="token operator">|</span><span class="token function">grep</span> 8080<span class="token punctuation">;</span>//查询8080端口是否监听

<span class="token function">ps</span> -aux<span class="token punctuation">;</span>//查看所有的进程

<span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> java<span class="token punctuation">;</span> //查看java的进程号

<span class="token function">history</span> 1000<span class="token operator">|</span><span class="token function">grep</span> pip<span class="token punctuation">;</span>//列出最近使用pip 命令的1000条记录

<span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> jetty<span class="token operator">|</span><span class="token function">grep</span> -v <span class="token function">grep</span><span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span><span class="token punctuation">;</span>//查看jetty进程号

<span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> -v <span class="token function">grep</span><span class="token operator">|</span><span class="token function">grep</span> jetty-avene<span class="token operator">|</span><span class="token function">grep</span> jetty<span class="token operator">|</span><span class="token function">grep</span> -v python<span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span><span class="token punctuation">;</span>//查询jetty项目名称为jetty－avene的进程号

<span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> -v <span class="token function">grep</span><span class="token operator">|</span><span class="token function">grep</span> jetty-avene<span class="token operator">|</span><span class="token function">grep</span> jetty<span class="token operator">|</span><span class="token function">grep</span> -v python<span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span>


</code></pre>
<h2><a id="4_187"></a>4.安装软件相关的</h2>
<pre><code class="prism language-bash">rpm --install couchbase-server-enterprise-3.0.3-centos6.x86_64.rpm<span class="token punctuation">;</span>//解压rpm文件

rpm -qa<span class="token punctuation">;</span>//查看所有安装的软件包

rpm -qa<span class="token operator">|</span><span class="token function">grep</span> kernel<span class="token punctuation">;</span>//查询系统所有内核

yum remove kernel-headers-3.10.0-327.el7.x86_64<span class="token punctuation">;</span>//删除内核kernel-headers-3.10.0-327.el7.x86_64

rpm -l pkgname.rpm；//安装rpm包

rpm -e pkgname<span class="token punctuation">;</span>//删除rmp包


从源码安装
./configure
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span>

</code></pre>
<h2><a id="5centos6_210"></a>5.防火墙相关的(centos6)</h2>
<pre><code class="prism language-bash"><span class="token function">chkconfig</span> --list<span class="token punctuation">;</span>//列出系统所有服务启动情况

<span class="token function">service</span> iptables status<span class="token punctuation">;</span>//查看防火墙状态

<span class="token function">service</span> iptables start<span class="token punctuation">;</span>//打开防火墙

<span class="token function">service</span> iptables stop<span class="token punctuation">;</span>//关闭防火墙


为防火墙添加访问端口和ip，在vi /etc/sysconfig/iptables目录下编辑:

iptables -A INPUT -p tcp --dport 10006 -j ACCEPT<span class="token punctuation">;</span> //允许端口10006访问

iptables -A INPUT -s 192.168.50.87 -p tcp -j ACCEPT；//允许192.168.50.87地址能访问

</code></pre>
<h2><a id="6_230"></a>6.操作磁盘相关的</h2>
<pre><code class="prism language-bash"><span class="token function">df</span> -h<span class="token punctuation">;</span>//查看磁盘的使用情况

<span class="token function">du</span> -h<span class="token punctuation">;</span>//查看目录的大小

<span class="token function">du</span> –sh *；//查看某个目录下所有文件及文件的大小：

<span class="token function">du</span> -sh *<span class="token operator">|</span><span class="token function">sort</span> -nr<span class="token punctuation">;</span>//定位那个目录最大

<span class="token function">du</span> –sh * <span class="token operator">|</span><span class="token function">sort</span> –n<span class="token punctuation">;</span>//按照文件大小排序

<span class="token function">fdisk</span> -l<span class="token punctuation">;</span>//可以查看到当前的所有分区，比如boot分区，该分区存档linux的grub以及内核源码

vim /etc/fstab <span class="token punctuation">;</span>//修改fstab内容

</code></pre>
<h2><a id="7_249"></a>7.网络相关的</h2>
<pre><code class="prism language-bash"><span class="token function">nslookup</span> www.baidu.com<span class="token punctuation">;</span>//查询域名对应的ip地址

<span class="token function">dig</span> www.baidu.com<span class="token punctuation">;</span>//查询域名对应的ip地址

<span class="token function">lsof</span> -i:4080<span class="token punctuation">;</span>//查看4080端口是否被占用

<span class="token function">curl</span> ifconfig.me<span class="token punctuation">;</span>//查出外网的ip地址

<span class="token function">netstat</span> -tnlp<span class="token operator">|</span><span class="token function">grep</span> redis<span class="token punctuation">;</span>

<span class="token function">ifconfig</span> -a<span class="token punctuation">;</span>      //列出所有网络端口和IP地址

iftop            //监控网络带宽

<span class="token function">ifconfig</span> eth0    //列出指定以太网端口对应的IP地址和详细信息

<span class="token function">ethtool</span> eth0     //查看以太网状态

<span class="token function">ping</span> host   

whois domain     //获取指定域名的信息

<span class="token function">dig</span> domain       //获取指定域名的DNS信息

<span class="token function">dig</span> -x host      //根据主机地址反向查找

host goole.com   //根据域名查找DNS IP地址

<span class="token function">wget</span> <span class="token function">file</span>        //下载文件

<span class="token function">netstat</span> -tupl    //列出系统的活跃连接

</code></pre>
<h2><a id="8_286"></a>8.文件传输相关的</h2>
<pre><code class="prism language-bash"><span class="token function">scp</span> file.txt server2:/tmp                 //安全拷贝file.txt到远程主机的/tmp目录下

<span class="token function">scp</span> noodle@server2:/www/*.html /www/tmp   //拷贝远程主机的/www/目录下的所有HTML文件到本地的/www/tmp目录

<span class="token function">scp</span> -r noodle@server2:/www /www/tmp       //递归拷贝远程主机/www目录下的所有文件和文件夹到本地/www/tmp目录

<span class="token function">scp</span> -P 2244 client.xml datasources.xml server.xml 

root@139.136.218.194:/data/appdatas/cat<span class="token punctuation">;</span>//远程机器访问端口为2244

<span class="token comment"># rsync</span>
<span class="token function">rsync</span> -a /home/apps /backup/              <span class="token comment"># 源目录和目标目录同步</span>
<span class="token function">rsync</span> -avz /home/apps noodle@192.168.10.1:/backup   //本地目录和远程主机目录同步，启用压缩

//模拟请求
<span class="token function">curl</span> -i -X POST -H <span class="token string">'Content-type'</span><span class="token keyword">:</span><span class="token string">'application/json'</span> -d <span class="token string">'{"customerId":3,"recNum":"18862285367"}'</span> http://10.105.31.109:10000/sms/sendCoupenCodeSms

</code></pre>
<h2><a id="9_308"></a>9.硬件相关的</h2>
<pre><code class="prism language-bash"><span class="token function">dmesg</span>                   //监测硬件和启动消息 

<span class="token function">cat</span> /proc/cpuinfo       //CPU信息 

<span class="token function">cat</span> /proc/meminfo       //硬件内存信息 

<span class="token function">free</span> -m                 //已使用的和可用内存，-m表示单位为M 

lspci -tv               //显示PCI设备信息 

lsusb -tv               //显示USB设备信息 

hdparm -l /dev/sda      //显示sda硬盘信息 

hdparm -tT /dev/sda     //对sda硬盘进行读取速度测试 

hdparm -s /dev/sda      //测试sda硬盘上不可读的块

</code></pre>
<h2><a id="10_331"></a>10.统计相关的</h2>
<pre><code class="prism language-bash"><span class="token function">top</span>                       //显示并不断更新最耗CPU的进程 
mpstat 1                  //显示CPU统计信息 
<span class="token function">vmstat</span> 2                  //显示虚拟内存统计信息 
iostat 2                  //显示IO统计信息（2s采样间隔） 
tcpdump -i eth1           //捕获eth1网络接口上的所有数据包 
tcpdump -i eth0 <span class="token string">'port 80'</span> //监控80端口的网络流量 
<span class="token function">lsof</span>                      //列出所有活跃进程打开的文件 
<span class="token function">lsof</span> -u testuser          //列出所有testuser用户打开的文件

<span class="token function">wc</span> -l filename<span class="token punctuation">;</span>//统计行数
<span class="token function">wc</span> -c filename<span class="token punctuation">;</span>//统计字节数
<span class="token function">wc</span> -m filename<span class="token punctuation">;</span>//统计字符数
<span class="token function">wc</span> -w filename<span class="token punctuation">;</span>//统计单词数
<span class="token function">ls</span> -l<span class="token operator">|</span><span class="token function">wc</span> -l 用来统计当前目录下的文件数

</code></pre>
<h2><a id="11nginx_351"></a>11.nginx统计相关的</h2>
<pre><code class="prism language-bash">1.根据访问IP统计UV

<span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span>}'</span>  access.log<span class="token operator">|</span><span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span><span class="token function">wc</span> -l

2.统计访问URL统计PV

<span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$7</span>}'</span> access.log<span class="token operator">|</span><span class="token function">wc</span> -l

3.查询访问最频繁的URL

<span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$7</span>}'</span> access.log<span class="token operator">|</span><span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span><span class="token function">sort</span> -n -k 1 -r<span class="token operator">|</span><span class="token function">more</span>

4.查询访问最频繁的IP

<span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span>}'</span> access.log<span class="token operator">|</span><span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span><span class="token function">sort</span> -n -k 1 -r<span class="token operator">|</span><span class="token function">more</span>

5.根据时间段统计查看日志

 <span class="token function">cat</span>  access.log<span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">'/14\/Mar\/2015:21/,/14\/Mar\/2015:22/p'</span><span class="token operator">|</span><span class="token function">more</span>

</code></pre>
<h2><a id="12nmap_376"></a>12.nmap相关的</h2>
<pre><code class="prism language-bash">nmap 192.168.102.10<span class="token punctuation">;</span> 侦测ip地址

nmap weixin.hao.cn<span class="token punctuation">;</span>侦测域名

nmap -sU -sS -F weixin.hao.cn<span class="token punctuation">;</span>//-F 快速扫描模式，扫描最可能开放的前100个端口

nmap -sV 192.168.102.10<span class="token punctuation">;</span>

nmap -A 192.168.102.10<span class="token punctuation">;</span>执行全网扫描

nmap -O weixin.hao.cn<span class="token punctuation">;</span>//侦测操作系统的信息

nmap -sP 192.168.102.*<span class="token punctuation">;</span>//找出网络中的在线主机

nmap -V<span class="token punctuation">;</span>//查询nmap版本

nmap -p 8080 weixin.hao.cn<span class="token punctuation">;</span>//扫描特定端口

</code></pre>
<h2><a id="13_399"></a>13.用户相关的</h2>
<pre><code class="prism language-bash">adduser newname // 新建用户newname

<span class="token function">passwd</span>  newname //设置用户名和密码

<span class="token function">userdel</span> newname //删除用户

deluser –remove-home newname //删除home目录的数据

<span class="token function">sudo</span> addgroup siatstudent  //创建组

<span class="token function">groupadd</span> testgroup

<span class="token function">groupmod</span> -n test2group testgroup //修改组

delgroup happy  //删除分组

<span class="token function">groups</span>  <span class="token comment">#查看当前登陆用户所在的组</span>

<span class="token function">groups</span> testnewuser <span class="token comment">#查看testnewuser 所在的组</span>

<span class="token function">cat</span> /etc/group  <span class="token comment">#查看所有组</span>

</code></pre>
<h2><a id="14Linux_426"></a>14.Linux内存清理命令</h2>
<pre><code class="prism language-bash"><span class="token function">free</span> -m<span class="token punctuation">;</span>//清理内存前 查看内存使用情况

<span class="token keyword">echo</span> 1 <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches<span class="token punctuation">;</span>//开始清理

<span class="token function">free</span> -m<span class="token punctuation">;</span>//清理之后查看内存使用情况

dmidecode <span class="token operator">|</span> <span class="token function">grep</span> -A16 <span class="token string">"Memory Device$"</span><span class="token punctuation">;</span>//查看内存条数

</code></pre>

                                    ]]></description></item><item><title>Docker测试一个静态网站</title><link>http://www.cnblogs.com/heian99/archive/2020/03/23/12585721.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 23 Mar 2020 03:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/23/12585721.html</guid><description><![CDATA[
                                            <h1>使用Docker测试静态网站</h1>

<p><strong>将Docker作为本地Web开发环境是Docker的一个最简单的应用场景。 这样的环境可以完全复制生产环境，并确保用户开发的东西在生产环境中也能运行。下面从将Nginx Web服务器安装到容器来架构一个简 单的网站开始。这个网站暂且命名为Sample。&nbsp;</strong></p>

<h2>Sample网站的初始Dockerfile</h2>

<p><strong>为了完成网站开发，从这个简单的Dockerfile开始。先来创建一个 目录，保存Dockerfile</strong></p>

<pre><code class="language-bash">$ mkdir sample 
$ cd sample 
$ touch Dockerfile
</code></pre>

<p>现在还需要一些Nginx配置文件，才能运行这个网站。首先在这个示例 所在的目录里创建一个名为nginx的目录，用来存放这些配置文件。 然后我们可以从GitHub上下载作者准备好的示例文件</p>

<pre><code class="language-bash">$ mkdir nginx &amp;&amp; cd nginx 
$ wget https://raw.githubusercontent.com/jamtur01/dockerbook-code/master/code/5/sample/nginx/global.conf 
$ wget https://raw.githubusercontent.com/jamtur01/dockerbook-code/master/code/5/sample/nginx/nginx.conf 
$ cd ..
</code></pre>

<p><strong>现在看一下我们将要为Sample网站创建的Dockerfile，如代码清单</strong></p>

<pre><code class="language-bash">FROM centos
MAINTAINER heian99 "heian99@163.com" 
ENV REFRESHED_AT 2014-06-01 
RUN yum -y update &amp;&amp; yum  -y install nginx 
RUN mkdir -p /var/www/html/website 
ADD nginx/global.conf /etc/nginx/conf.d/ 
ADD nginx/nginx.conf /etc/nginx/nginx.conf 
EXPOSE 80</code></pre>

<h3>这个简单的Dockerfile内容包括以下几项。</h3>

<ul><li>
	<p>安装Nginx。</p>
	</li>
	<li>
	<p>在容器中创建一个目录/var/www/html/website/。</p>
	</li>
	<li>
	<p>将来自我们下载的本地文件的Nginx配置文件添加到镜像中。</p>
	</li>
	<li>
	<p>公开镜像的80端口。</p>
	</li>
</ul><p><strong>这个Nginx配置文件是为了运行Sample网站而配置的。将文件 nginx/global.conf用ADD指令复制到/etc/nginx/conf.d/目 录中。配置文件</strong></p>

<h3><strong>global.conf</strong></h3>

<pre><code class="language-bash">server {
        listen          0.0.0.0:80;
        server_name     _;

        root            /var/www/html/website;
        index           index.html index.htm;

        access_log      /var/log/nginx/default_access.log;
        error_log       /var/log/nginx/default_error.log;
}
</code></pre>

<p>这个文件将Nginx设置为监听80端口，并将网络服务的根路径设置 为/var/www/ html/website，这个目录是我们用RUN指令创建 的。<br>
我们还需要将Nginx配置为非守护进程的模式，这样可以让Nginx在 Docker容器里工作。将文件nginx/nginx.conf复制 到/etc/nginx目录就可以达到这个目的</p>

<h3>nginx.conf的清单</h3>

<pre><code class="language-bash">user www-data;#把这个删除掉，不然后面docker里面的nginx无法启动
worker_processes 4;
pid /run/nginx.pid;
daemon off;

events {  }

http {
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;
  include /etc/nginx/mime.types;
  default_type application/octet-stream;
  access_log /var/log/nginx/access.log;
  error_log /var/log/nginx/error.log;
  gzip on;
  gzip_disable "msie6";
  include /etc/nginx/conf.d/*.conf;
}
</code></pre>

<p>在这个配置文件里，daemon off;选项阻止Nginx进入后台，强制其 在前台运行。这是因为要想保持Docker容器的活跃状态，需要其中运 行的进程不能中断。默认情况下，Nginx会以守护进程的方式启动，这 会导致容器只是短暂运行，在守护进程被fork启动后，发起守护进程 的原始进程就会退出，这时容器就停止运行了</p>

<p><strong>这个文件通过ADD指令复制到/etc/nginx/nginx.conf。</strong></p>

<p><span style="color:#f33b45;"><strong>第一个指令以 目录/etc/nginx/ conf.d/结束，而第二个指令指定了文 件/etc/nginx/nginx.conf。将文件复制到Docker镜像时，这两 种风格都是可以用的。</strong></span></p>

<h2>构建Sample网站和Nginx镜像</h2>

<p><strong>利用之前的Dockerfile，可以用docker build命令构建出新的镜 像，并将这个镜像命名为heian/nginx</strong></p>

<pre><code>docker build -t heian/nginx .</code></pre>

<p><img alt="" height="284" src="https://img-blog.csdnimg.cn/20200323104725505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="721"></p>

<p><strong>这将构建并命名一个新镜像。下面来看看构建的执行步骤。使用 docker history命令查看构建新镜像的步骤和层级</strong></p>

<p><img alt="" height="424" src="https://img-blog.csdnimg.cn/20200323105621292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="879"></p>

<h2>&nbsp;从Sample网站和Nginx镜像构建容器</h2>

<p>现在可以使用heian/nginx镜像，并开始从这个镜像构建可以用 来测试Sample网站的容器。为此，需要添加Sample网站的代码。现在<br>
注意提示下载这段代码到sample目录</p>

<pre><code class="language-bash">$ mkdir website &amp;&amp; cd website 
$ wget http://raw.githubusercontent.com/jamtur01/dockerbook-code/master/code/5/sample/website/index.html
$ cd..</code></pre>

<p>现在来看看如何使用docker run命令来运行一个容器</p>

<pre><code class="language-bash">docker run -d -p 80 --name website  -v $PWD/website:/var/www/html/website heian/nginx nginx
</code></pre>

<p>上面命令如果有问题，那就执行下面的命令</p>

<pre><code class="language-bash">docker run -d  -p 80 --name nginx -v $PWD/website:/var/www/html/website  heian/nginx /bin/bash -c "tail -f /dev/null;/usr/sbin/nginx"</code></pre>

<blockquote>
<p><span style="color:#f33b45;"><strong>可以看到，在执行docker run时传入了nginx作为容器的启动命令。一般情况下， 这个命令无法让Nginx以交互的方式运行。我们已经在提供给Docker的配置里加入了指令 daemon off，这个指令让Nginx启动后以交互的方式在前台运行</strong></span></p>
</blockquote>

<p><img alt="" height="213" src="https://img-blog.csdnimg.cn/20200323111606206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="484"></p>

<p>可以看到，我们使用docker run命令从heian/nginx镜像创建 了一个名为website的容器。读者已经见过了大部分选项，不过-v选 项是新的。-v这个选项允许我们将宿主机的目录作为卷，挂载到容器 里。<br><strong>回到刚才的例子。当我们因为某些原因不想把应用或者代码构建到镜 像中时，就体现出卷的价值了。例如：</strong></p>

<ul><li>希望同时对代码做开发和测试；</li>
	<li>代码改动很频繁，不想在开发过程中重构镜像；</li>
	<li>希望在多个容器间共享代码</li>
</ul><p><strong>-v选项通过指定一个目录或者登上与容器上与该目录分离的本地宿主 机来工作，这两个目录用:分隔。如果容器目录不存在，Docker会自 动创建一个。</strong><br>
&nbsp;</p>

<pre><code class="language-bash"> docker run -d -p 80 --name website \
 -v $PWD/website:/var/www/html/website:ro \ 
heian/nginx nginx
</code></pre>

<p><strong>这将使目的目录/var/www/html/website变成只读状态。</strong></p>

<p>在Nginx网站容器里，我们通过卷将$PWD/website挂载到容器 的/var/www/ html/website目录，顺利挂载了正在开发的本地网 站。在Nginx配置里（在配置文 件/etc/ngingx/conf.d/global.conf中），已经指定了这个目 录为Nginx服务器的工作目录。<br><strong>现在，如果使用docker ps命令查看正在运行的容器，可以看到名为 website的容器正处于活跃状态，容器的80端口被映射到宿主机的 49161端口</strong></p>

<p><img alt="" height="148" src="https://img-blog.csdnimg.cn/20200323112506809.png" width="968"></p>

<h3>修改网站</h3>

<p><img alt="" height="155" src="https://img-blog.csdnimg.cn/20200323112652112.png" width="482"></p>

<p>我们已经得到了一个可以工作的网站！现在，如果要修改网站，该怎 么办？可以直接打开本地宿主机的website目录下的index.html文 件并修改</p>

<p><img alt="" height="209" src="https://img-blog.csdnimg.cn/20200323112743234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="484"></p>

<p><img alt="" height="190" src="https://img-blog.csdnimg.cn/20200323112752462.png" width="434"></p>

<p><strong>可以看到，Sample网站已经更新了。显然这个修改太简单了，不过可 以看出，更复杂的修改也并不困难。更重要的是，正在测试网站的运 行环境，完全是生产环境里的真实状态。现在可以给每个用于生产的 网站服务环境（如Apache、Nginx）配置一个容器，给不同开发框架 的运行环境（如PHP或者Ruby on Rails）配置一个容器，或者给后端 数据库配置一个容器，等等。&nbsp;</strong></p>
                                    ]]></description></item><item><title>Docker容器访问外部世界</title><link>http://www.cnblogs.com/heian99/archive/2020/03/20/12585722.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 20 Mar 2020 08:38:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/20/12585722.html</guid><description><![CDATA[
                                            <h1><a href="https://blog.csdn.net/heian_99/article/details/104914945">Docker网络（host、bridge、none）详细介绍</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104944575">Docker容器间通信</a></h1>

<p>前面我们已经解决了容器间通信的问题，接下来讨论容器如何与外部世界通信。</p>

<p>这里涉及两个方向：</p>

<p>（1）容器访问外部世界。</p>

<p>（2）外部世界访问容器。</p>

<h2>容器访问外部世界</h2>

<p>在我们当前的实验环境下，docker host是可以访问外网的</p>

<p><img alt="" height="203" src="https://img-blog.csdnimg.cn/20200320161023549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="700"></p>

<p>我们看一下容器是否也能访问外网呢？</p>

<p><img alt="" height="500" src="https://img-blog.csdnimg.cn/20200320161151610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="693"></p>

<p><span style="color:#f33b45;"><strong>可见，容器默认就能访问外网。</strong></span><br><strong>请注意：这里外网指的是容器网络以外的网络环境，并非特指Internet.</strong></p>

<blockquote>
<p>现象很简单，但更重要的：我们应该理解现象下的本质。</p>

<p><br>
在上面的例子中，busybox位于dockero这个私有bridge网络中（172.17.0.0/16），当busybox从容器向外ping时，数据包是怎样到达bing.com的呢？</p>

<p><br><strong>这里的关键就是NAT，我们查看一下docker host上的iptables规则</strong></p>
</blockquote>

<p><img alt="" height="484" src="https://img-blog.csdnimg.cn/20200320161357178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="769"></p>

<h3>在NAT表中，有这么一条规则：</h3>

<pre><code class="language-bash">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
</code></pre>

<p><strong>其含义是：如果网桥docker0收到来自172.17.0.0/16网段的外出包，把它交给MASQUERADE处理。而且MASQUERADE的处理方式是将</strong></p>

<p><strong>包的原地址替换成host的地址发送出去，机 做了一次网络地址转换（NAT）</strong></p>

<hr><p><strong>下面我们通过tcpdump查看地址是如何转换的。先查看docker host的路由表</strong></p>

<p><img alt="" height="122" src="https://img-blog.csdnimg.cn/20200320161827561.png" width="717"></p>

<p>默认路由通过ens192发出去，所以我们同时要监控ens192和docker0上的icmp（ping）的数据包。</p>

<p>当busybox ping www.baidu.com时，tcpdumo输出如下</p>

<pre><code class="language-bash">tcpdump -i docker0 -n icmp</code></pre>

<p><img alt="" height="263" src="https://img-blog.csdnimg.cn/20200320162226557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="832"></p>

<p>docker0收到busybox的ping包，源地址为容器的IP：172.17.0.2，这没问题，交给MASQUERADE处理。这时，在看ens192的变化。</p>

<p><img alt="" height="269" src="https://img-blog.csdnimg.cn/2020032016253616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="826"></p>

<p>ping包的源地址变成ens192的192.168.1.100</p>

<p>这就是iptables的NAT规则的处理结果，从而保证数据包能够到达外网。</p>

<p>下面这张图来说明结果。</p>

<p><img alt="" height="292" src="https://img-blog.csdnimg.cn/20200320162712634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="733"></p>

<blockquote>
<ul><li>（1）busybox发送ping包：172.17.0.2 &gt; www.bing.com。</li>
	<li>（2）dockero收到包，发现是发送到外网的，交给NAT处理。</li>
	<li>（3）NAT将源地址换成ens192的IP：10.0.2.15 &gt;www.bing.com.</li>
	<li>（4）ping从 ens192出去，达www.bing.como</li>
</ul></blockquote>

<h2><span style="color:#f33b45;">通过NAT，docker实现了容器对外网的访问。</span></h2>

<p>&nbsp;</p>

<h2>外部世界访问容器</h2>

<p><strong>下面我们来讨论另一个方向：外网如何访问到容器？</strong><br><strong>答案是：<span style="color:#f33b45;">端口映射。</span></strong></p>

<p><br><strong>docker可将容器对外提供服务的端口映射到host的某个端口，外网通过该端口访问容器。容器启动时通过-p参数映射端口</strong></p>

<pre><code class="language-bash">[root@kvm ~]# docker run -d -p 80 httpd
6b89d7e3f47a425256af6934689c0009fbbad9099bf31c2e6148a6cb236a9655
[root@kvm ~]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES
6b89d7e3f47a        httpd               "httpd-foreground"   5 seconds ago       Up 2 seconds        0.0.0.0:32768-&gt;80/tcp   stoic_bartik
78de9710bce0        busybox             "sh"                 19 minutes ago      Up 19 minutes                               hei
[root@kvm ~]# docker port 6b89d7e3f47a
80/tcp -&gt; 0.0.0.0:32768
</code></pre>

<p><img alt="" height="536" src="https://img-blog.csdnimg.cn/20200320163142538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1028"></p>

<p><strong>容器启动后，可通过docker ps或者docker port查看到host映射的端口。在上面的例子中，httpd容器的80端口被映射到host 32768上，这样就可以通过&lt;host ip&gt;：&lt;32773&gt;访问容器的Web服务了</strong></p>

<p><img alt="" height="102" src="https://img-blog.csdnimg.cn/20200320163253965.png" width="522"></p>

<p><strong>除了映射动态端口，也可在-p中指定映射到host某个特定端口，例如可将80端口映射到host的8080端口</strong></p>

<pre><code class="language-bash">[root@kvm ~]# docker run -d -p 8080:80 httpd
8d7db7b2c7a6fc03cd219d6d3c07f15261d8a12efda3be25fdb60576c91c1a7e
[root@kvm ~]# curl 192.168.1.100:8080
&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
[root@kvm ~]# 
</code></pre>

<p><img alt="" height="177" src="https://img-blog.csdnimg.cn/20200320163433687.png" width="592"></p>

<p><strong>每一个映射的端口，host都会启动一个docker-proxy进程来处理访问容器的流量。</strong></p>

<p><img alt="" height="276" src="https://img-blog.csdnimg.cn/20200320163639265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1026"></p>

<h3>以0.0.0.0：32773-280/tcp为例分析整个过程</h3>

<p><img alt="" height="292" src="https://img-blog.csdnimg.cn/2020032016370255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="805"></p>

<blockquote>
<ul><li>（1）docker-proxy监听host的32773端口。</li>
	<li>（2）当curl访问10.0.2.15：32773时，docker-proxy转发给容器172.170.2：80。</li>
	<li>（3）httpd容器响应请求并返回结果。</li>
</ul></blockquote>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Docker容器间通信</title><link>http://www.cnblogs.com/heian99/archive/2020/03/18/12585723.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 18 Mar 2020 06:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/18/12585723.html</guid><description><![CDATA[
                                            <h2>IP通信</h2>

<p>从前面的例子可以得出这样一个结论：两个容器要能通信，必须要有属于同一个网络的网卡。满足这个条件后，容器就可以通过IP交互了。具体做法是在容器创建时通过-network指定相应的网络，或者通过docker network connect将现有容器加入到指定网络。可参考上一节</p>

<p><strong><a href="https://blog.csdn.net/heian_99/article/details/104914945">Docker网络（host、bridge、none）详细介绍</a></strong></p>

<h2>Docker DNS Server</h2>

<p>通过IP访问容器虽然满足了通信的需求，但还是不够灵活。因为在部署应用之前可能无法确定IP，部署之后再指定要访问的IP会比较麻烦。对于这个问题，可以通过docker自带的DNS服务解决。</p>

<p><strong>从Docker 1.10版本开始，docker daemon实现了一个内嵌的DNS server，使容器可以直接1通过“容器名”通信。方法很简单，只要在启动时用-name为容器命名就可以了。</strong></p>

<pre><code class="language-bash">docker run -it --network=my_net2 --name=bbox1 busybox 
docker run -it --network=my_net2 --name=bbox2 busybox</code></pre>

<p><strong>然后，bbox2就可以直接ping到bbox1了</strong></p>

<p><img alt="" height="145" src="https://img-blog.csdnimg.cn/20200318144200839.png" width="503"></p>

<p>使用docker DNS有个限制：只能在user-defined网络中使用。也就是说，默认的bridge网络是无法使用DNS的。</p>

<p>下面验证一下：<strong>创建bbox3和bbox4，均连接到bridge网络。</strong></p>

<pre><code class="language-bash">docker run -it --name=bbox3 busybox 
docker run -it --name=bbox4 busybox</code></pre>

<p><strong>bbox4无法ping到bbox3</strong></p>

<p><img alt="" height="101" src="https://img-blog.csdnimg.cn/20200318144318852.png" width="378"></p>

<p>&nbsp;</p>

<h2>Joined容器</h2>

<p>joined容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined容器之间可以通过127.0.01直接通信。</p>

<p>请看下面的例子：<strong>先创建一个httpd容器，名字为web1。</strong></p>

<pre><code class="language-bash">docker run -d -it --name=web1 =httpd</code></pre>

<p>然后创建busybox容器并通过-network-container:webl指定joined容器为webl，</p>

<pre><code class="language-bash">docker run -it --network=container:web1 busybox</code></pre>

<p><img alt="" height="254" src="https://img-blog.csdnimg.cn/20200318144541356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="482"></p>

<p>&nbsp;</p>

<p>请注意busybox器中网配置息，下面我们查看一下webl的网络，</p>

<p><img alt="" height="259" src="https://img-blog.csdnimg.cn/20200318144601257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="591"></p>

<p>看！busybox和webl的网卡mac地址与IP完全一样，它们共享了相同的网络栈。<br><strong>busybox可以直接用127.0.0.1访问webl的http服务</strong></p>

<p><img alt="" height="117" src="https://img-blog.csdnimg.cn/20200318144619828.png" width="366"></p>

<h3>joined容器非常适合以下场景：</h3>

<ol><li>不同容器中的程序希望通过loopback高效快速地通信，比如web Server与App Server.</li>
	<li>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</li>
</ol>                                    ]]></description></item><item><title>Docker网络（host、bridge、none）详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/03/17/12585724.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 17 Mar 2020 03:35:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/17/12585724.html</guid><description><![CDATA[
                                            <h1>Docker网络（host、bridge、none）</h1>

<p><strong>我们会首先学习Docker提供的几种原生网络，以及如何创建自定义网络；然后探讨容器之间如何通信，以及容器与外界如何交互。</strong></p>

<p>&nbsp;Docker网络从覆盖范围可分为单个host上的容器网络和跨多个host的网络，本章重点讨论前一种。对于更为复杂的多host容器网络，我们会在后面进阶技术章节单独讨论。</p>

<p><br>
Docker 安装时会自动在host 上创建三个网络，我们可用<span style="color:#f33b45;"><strong>docker network ls</strong></span>命令查看</p>

<pre><code class="language-bash">docker network ls</code></pre>

<p><img alt="" height="155" src="https://img-blog.csdnimg.cn/20200317094903719.png" width="604"></p>

<h2>none网络</h2>

<p><strong>顾名思义，none网络就是什么都没有的网络。挂在这个网络下的容器除了1o，没有其他任何网卡。容器创建时，可以通过-network=none指定使用none网络，如图</strong></p>

<pre><code class="language-bash">docker run -it --network=none busybox</code></pre>

<p><img alt="" height="292" src="https://img-blog.csdnimg.cn/20200317095403385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="617"></p>

<p><strong>我们不禁会问，这样一个封闭的网络有什么用呢？</strong></p>

<blockquote>
<p style="text-indent:0;"><br>
其实还真有应用场景。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用none网络。<br>
比如某个容器的唯一用途是生成随机密码，就可以放到none网络中避免密码被窃取。</p>

<p style="text-indent:0;"><br><strong>当然大部分容器是需要网络的，我们接着看host网络。</strong></p>
</blockquote>

<p>&nbsp;</p>

<h2>host网络</h2>

<p><strong>连接到host网络的容器共享Docker host的网络栈，容器的网络配置与host完全一样。</strong><br><strong>可以通过-network-host 指定使用host网络</strong></p>

<pre><code class="language-bash">docker run -it --network=host busybox</code></pre>

<p><img alt="" height="292" src="https://img-blog.csdnimg.cn/2020031709570833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="665"></p>

<p><img alt="" height="615" src="https://img-blog.csdnimg.cn/20200317100148893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="567"></p>

<h3><strong>在容器中可以看到host的所有网卡，并且连hostmame 也是host的。host网络的使用场景又是什么呢？</strong></h3>

<p>直接使用Docker host的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择host网络。当然不便之处就是牺牲一些灵活性，比如要<span style="color:#f33b45;"><strong>考虑端口冲突问题</strong></span>，Docker host 上<strong><span style="color:#f33b45;">已经使用的端口就不能再用</span></strong>了。<br><strong>Docker host的另一个用途是让容器可以直接配置host网路，比如某些跨host的网络解决方案，其本身也是以容器方式运行的，这些方案需要对网络进行配置，比如管理iptables</strong><br>
&nbsp;</p>

<h2>bridge网络</h2>

<p><strong>Docker安装时会创建一个命名为docker0的Linux bridge。如果不指定-network，创建的容器默认都会挂到docker0上</strong></p>

<pre><code class="language-bash">brctl show</code></pre>

<p><img alt="" height="177" src="https://img-blog.csdnimg.cn/20200317100442883.png" width="536"></p>

<p>当前docker0上没有任何其他网络设备，我们创建一个容器看看有什么变化</p>

<p><img alt="" height="243" src="https://img-blog.csdnimg.cn/20200317100641383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="715"></p>

<p><strong>一个新的网络接口vethb56e98c被挂到了docker0上，vethb56e98c就是新创建容器的虚拟网卡。</strong><br>
下面看一下容器的网络配置</p>

<p><img alt="" height="175" src="https://img-blog.csdnimg.cn/20200317102259644.png" width="750"></p>

<p><img alt="" height="571" src="https://img-blog.csdnimg.cn/20200317102355122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="691"></p>

<p><strong>容器有一个网卡eth0@if34，为什么不是vethb56e98c呢？</strong></p>

<p>实际上eth0@if34 和veth28c57df 是一对veth pair。 veth pair 是一种成对出现的特殊网络设备，可以把它们想象成由一根虚拟网线连接起来的一对网卡， 网卡的一头(eth0@if34) 在容器中，另一头(veth28c57df) 挂在网桥docker0 上，其效果就是将eth0@if34 也挂在了docker0上。<br>
我们还看到eth0@if34 已经配置了IP 172.17.0.2， 为什么是这个网段呢?让我们通过<span style="color:#f33b45;"><strong>docker network inspect bridge</strong></span>看- -下bridge 网络的配置信息</p>

<p><img alt="" height="337" src="https://img-blog.csdnimg.cn/20200317103035414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="636"></p>

<p>原来bridge 网络配置的subnet 就是172.17.0.0/16, 并且网关是172.17.0.1. 这个网关在哪儿呢?大概你已经猜出来了，就是docker0</p>

<p><img alt="" height="210" src="https://img-blog.csdnimg.cn/20200317103118420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="570"></p>

<p><strong>容器网络拓扑图</strong></p>

<p><img alt="" height="390" src="https://img-blog.csdnimg.cn/20200317103137881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="305"></p>

<p><strong>容器创建时，docker 会自动从172.17.0.0/16 中分配-个IP,这里16 位的掩码保证有足够多的IP可以供容器使用。</strong></p>

<h2>user-defined网络</h2>

<p>除了none、host、bridge这三个自动创建的网络，用户也可以根据业务需要创建user-defined网络。<br>
Docker提供三种user-defined 网络驱动：bridge、overlay 和macvlan。overlay 和macvlan用于创建跨主机的网络</p>

<p>我们可通过bridge 驱动创建类似前面默认的bridge 网络</p>

<pre><code class="language-bash">docker network create --driver bridge my_net</code></pre>

<pre><code class="language-bash">[root@kvm ~]# docker network create --driver bridge my_net
7428a4d14c67b44be3a7184a5a065303d3688b5b13883526989b7173af881170
[root@kvm ~]# brctl show
bridge name	bridge id		STP enabled	interfaces
br-7428a4d14c67		8000.024221339eb6	no		
docker0		8000.024280532eb0	no		veth6281a8d
virbr0		8000.52540015904b	yes		virbr0-nic
</code></pre>

<p><img alt="" height="185" src="https://img-blog.csdnimg.cn/20200317104818355.png" width="567"></p>

<p>新增了一个网桥br-7428a4d14c67，这里7428a4d14c67正好是新建bridge网络my_net的短id。执行<strong>docker network inspect</strong>查看一下my_net的配置信息，</p>

<p><img alt="" height="440" src="https://img-blog.csdnimg.cn/20200317104949890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="632"></p>

<p><strong>这里172.18.0.0/16是Docker自动分配的IP网段。<br><span style="color:#3399ea;">我们可以自己指定IP网段吗？<br>
答案是：可以。</span></strong></p>

<p><br><strong>只需在创建网段时指定--subnet和-gateway参数</strong></p>

<pre><code>docker network create --driver bridge --subnet 172.22.16.0/24 --gateway 172.22.16.1 my_net2</code></pre>

<p><img alt="" height="516" src="https://img-blog.csdnimg.cn/20200317105333121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="762"></p>

<p>这里我们创建了新的bridge网络my_net2，网段为172.22.16.0/24，网关为172.22.16.1与前面一样，网关在my net2对应的网桥br-5d863e9778b6上</p>

<p><img alt="" height="319" src="https://img-blog.csdnimg.cn/20200317105504416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="563"></p>

<p>&nbsp;</p>

<p><strong>容器要使用新的网络，需要在启动时通过--network指定</strong></p>

<pre><code class="language-bash">docker run -it --network=my_net2 busybox</code></pre>

<p><img alt="" height="323" src="https://img-blog.csdnimg.cn/20200317105622853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="633"></p>

<p>容器分配到的IP为172.22.16.20到目前为止，容器的IP都是docker自动从subnet中分配，我们能否指定一个静态IP呢？<br><strong>答案是：<span style="color:#f33b45;">可以，通过-p指定</span></strong></p>

<pre><code class="language-bash">docker run -it --network=my_net2 --ip 172.22.16.8 busybox
</code></pre>

<p><img alt="" height="322" src="https://img-blog.csdnimg.cn/20200317110228543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="619"></p>

<h3><strong>好了，我们来看看当前docker host的网络拓扑结构</strong></h3>

<p><img alt="" height="334" src="https://img-blog.csdnimg.cn/20200317110738979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="366"></p>

<p>两个busybox容器都挂在mynet2上，应该能够互通</p>

<p><img alt="" height="400" src="https://img-blog.csdnimg.cn/20200317111158421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="561"></p>

<p><img alt="" height="432" src="https://img-blog.csdnimg.cn/20200317111230330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="572"></p>

<p><span style="color:#f33b45;"><strong>可见同一网络中的容器、网关之间都是可以通信的。</strong></span><br>
my_net2与默认bridge网络能通信吗？<br>
从拓扑图可知，两个网络属于不同的网桥，应该不能通信，我们通过实验验证一下，让busybox容器ping 不同网段容器</p>

<p>&nbsp;</p>

<p><img alt="" height="349" src="https://img-blog.csdnimg.cn/20200317111500404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="537"></p>

<p>确实 ping不通，符合预期。<br>
“等等！不同的网络如果加上路由应该就可以通信了吧？”我已经听到有读者在建议了这是一个非常非常好的想法。</p>

<p>确实，如果host上对每个网络都有一条路由，同时操作系统上打开了ip forwarding，host就成了一个路由器，挂接在不同网桥上的网络就能够相互通信。下面我们来看看docker host是否满足这些条件呢？<br>
&nbsp;</p>

<p>ip r查看host上的路由表：</p>

<p><img alt="" height="159" src="https://img-blog.csdnimg.cn/20200317111807344.png" width="657"></p>

<p>172.17.0.0/16和172.22.16.0/24两个网络的路由都定义好了。再看看ip forwarding：</p>

<pre><code>[root@kvm ~]# sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 1
</code></pre>

<p>ip forwarding也已经启用了。条件都满足，为什么不能通行呢？<br>
我们还得看看iptables：</p>

<pre><code>iptavles-save

-A DOCKER-ISOLATION -i br-13ceb40bd8e8 -o docker0 -j DROP
-A DOCKER-ISOLATION -i docker0 -o br-13ceb40bd8e8 -j DROP
</code></pre>

<p>原因就在这里了：<span style="color:#f33b45;"><strong>iptables DROP掉了网桥dockero与br-13ceb40bd8e8之间双向的流量。</strong></span></p>

<p><span style="color:#e579b6;"><strong>从规则的命名DOCKER-ISOLATION可知docker在设计上就是要隔离不同的netwrok</strong></span></p>

<p>那么接下来的问题是：怎样才能让busybox与httpd 通信呢？</p>

<p><br><span style="color:#f33b45;"><strong>答案是：为httpd容器添加一块net_my2的网卡。这个可以通过docker network connect命令实现，</strong></span></p>

<p><img alt="" height="197" src="https://img-blog.csdnimg.cn/20200317112835177.png" width="1008"></p>

<pre><code class="language-bash">docker network connect my_net2 655643ea6894</code></pre>

<p>我们在docker0网段器中查看一下网络配置</p>

<p><img alt="" height="318" src="https://img-blog.csdnimg.cn/20200317113019172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="647"></p>

<p>容器中增加了一个网卡ethl，分配了my_net2的IP 172.22.16.3。现在busybox应该能够访问docker0网段了，验证一下</p>

<p><img alt="" height="495" src="https://img-blog.csdnimg.cn/20200317113317665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="623"></p>

<p>busybox能够ping到httpd，并且可以访问httpd的Web服务所示。</p>

<p>（因为这里我在docker0网段，用busybox代替的httpd）</p>

<p>&nbsp;</p>

<p><img alt="" height="539" src="https://img-blog.csdnimg.cn/20200317113409925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="469"></p>

<p>学习了Docker各种类型网络之后，接下来我们讨论容器与容器、容器与外界的连通问题</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Docker的资源限制（内存、CPU、IO）详细篇</title><link>http://www.cnblogs.com/heian99/archive/2020/03/16/12585725.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 16 Mar 2020 09:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/16/12585725.html</guid><description><![CDATA[
                                            <h3><strong>一个docker host. 上会运行若干容器，每个容器都需要CPU、内存和I0资源。对于KVM、VMware 等虚拟化技术，用户可以控制分配多少CPU、内存资源给每个虚拟机。对于容器，Docker 也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个host<br>
的性能。</strong><br>
&nbsp;</h3>

<h1>内存限额</h1>

<p>与操作系统类似，容器可以使用的内存包括两部分：物理内存和Swap。</p>

<p>Docker通过下面两组参数来控制容器内存的使用量</p>

<p>（1）-m 或 --memory ：设置内存的使用限额，例如100MB，2GB</p>

<p>（2）--memory-swap：设置内存+swawp的使用限额</p>

<p>&nbsp;</p>

<p>当我们执行如下的命令时</p>

<pre><code class="language-bash">docker run -m 200M --memory-swap=300M ubuntu</code></pre>

<p>其含义是允许该容器最多使用200MB的内存和100MB 的swap。默认情况下，上面两组参数为-1, 即对容器内存和swap的使用没有限制。</p>

<p>下面我们将使用progrium/stress 镜像来学习如何为容器分配内存。该镜像可用于对容器执行压力测试。执行如下命令:<br>
&nbsp;</p>

<pre><code class="language-bash">docker run -it -m 200M --memory-swap=300M progrium/stress --vm 1 --vm-bytes 208M</code></pre>

<ul><li>--vm1:启动1个内存工作线程。</li>
	<li>--vm-bytes 280M:每个线程分配280MB内存。</li>
</ul><p>&nbsp;</p>

<p><strong>运行如下图结果</strong></p>

<p><img alt="" height="393" src="https://img-blog.csdnimg.cn/2020031616300042.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="611"></p>

<p>因为280MB在可分配的范围(300MB) 内，所以工作线程能够正常工作，其过程是:<br>
(1)分配280MB内存。<br>
(2)释放280MB内存。<br>
(3)再分配280MB内存。<br>
(4)再释放280MB内存。<br>
(5)一-直循环.....<br>
如果让工作线程分配的内存超过300MB,结果如图</p>

<pre><code class="language-bash">docker run -it -m 200M --memory-swap=300M progrium/stress --vm 1 --vm-bytes 310M</code></pre>

<p><img alt="" height="211" src="https://img-blog.csdnimg.cn/20200316165917983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="846"></p>

<p>分配的内存超过限额，stress 线程报错，容器退出。<br>
如果在启动容器时只指定-m而不指定-memoryswap, 那么-memory-swap 默认为-m的两倍，比如:<br>
&nbsp;</p>

<pre><code>docker run -it -m 200M ubuntu
</code></pre>

<p>容器最多使用200M绒里内存和200swap</p>

<h2>CPU限额</h2>

<p><strong>默认设置下，所有容器可以平等地使用host CPU资源并且没有限制</strong>。</p>

<p><br><strong>Docker可以通过-c或-pu-shares设置容器使用CPU的权重。如果不指定，默认值为<span style="color:#f33b45;">1024</span>。</strong><br>
与内存限额不同，通过-c设置的cpu share 并不是CPU资源的绝对数量，而是一个相对的权重值。某个容器最终能分配到的CPU资源取决于它的cpu share占所有容器cpu share总和的比例。<br>
换句话说:通过cpu share可以设置容器使用CPU的优先级。</p>

<p>比如在host中启动了两个容器:</p>

<pre><code class="language-bash">docker run --name "cont_A" -c 1024 ubuntu docker run --name "cont_B" -c 512 ubuntu
</code></pre>

<p><strong>containerA的cpu share 1024， 是containerB 的两倍。当两个容器都需要CPU资源时，containerA可以得到的CPU是containerB 的两倍。<br>
需要特别注意的是，这种按权重分配CPU只会发生在CPU资源紧张的情况下。如果containerA处于空闲状态，这时，为了充分利用CPU资源，containerB 也可以分配到全部可用的CPU.</strong></p>

<p><br>
下面我们继续用progrium/stress 做实验。</p>

<h3><br>
(1)启动(container_ A, cpu share为1024<br>
&nbsp;</h3>

<pre><code class="language-bash">docker run --name "cont_A" -it -c 1024  progrium/stress --cpu 1</code></pre>

<p><img alt="" height="98" src="https://img-blog.csdnimg.cn/20200316170953506.png" width="655"></p>

<p>--cpu用来设置工作线程的数量。因为当前host 只有1颗CPU,所以一个工作线程就能将CPU压满。如果host有多颗CPU,则需要相应增加--cpu的数量。<br>
&nbsp;</p>

<h3>(2)启动(container_B, cpu share为512</h3>

<pre><code class="language-bash">docker run --name "cont_B" -it -c 512  progrium/stress --cpu 1</code></pre>

<p><img alt="" height="105" src="https://img-blog.csdnimg.cn/20200316171149233.png" width="852"></p>

<h3>(3)在host中执行top, 查看容器对CPU的使用情况，<br>
&nbsp;</h3>

<p><img alt="" height="238" src="https://img-blog.csdnimg.cn/20200316171249683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="786"></p>

<pre><code class="language-bash">ps aux|head -1;ps aux|sort -k3nr |head -4
</code></pre>

<p><img alt="" height="225" src="https://img-blog.csdnimg.cn/20200316171752731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1063"></p>

<h3><strong>containerA消耗的CPU是containerB 的两倍。</strong><br>
&nbsp;</h3>

<h3>(4)现在暂停container. A</h3>

<h3><img alt="" height="164" src="https://img-blog.csdnimg.cn/20200316172530957.png" width="1065"></h3>

<h3>(5) top 显示containerB在containerA空闲的情况下能够用满整颗CPU</h3>

<h3><img alt="" height="216" src="https://img-blog.csdnimg.cn/20200316172546902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="764"></h3>

<h1>Block IO 带宽限额</h1>

<p>Block 10是另一种可以限制容器使用的资源。Block I0指的是磁盘的读写，docker 可通过设置权重、限制bps和iops 的方式控制容器读写磁盘的带宽，下 面分别讨论。<br><strong>注:目前Block I0限额只对direct IO (不使用文件缓存)有效。</strong><br>
Block IO权重<br>
默认情况下，所有容器能平等地读写磁盘，可以通过设置<span style="color:#f33b45;"><strong>-blkio-weight</strong></span>参数来改变容器block Io的优先级。<br><span style="color:#f33b45;"><strong>-blkio-weight</strong></span>与--cpu-shares 类似，设置的是相对权重值，默认为500。 在下面的例子中，containerA 读写磁盘的带宽是containerB 的两倍。</p>

<pre><code class="language-bash">docker run -it --name cont_A --blkip-weight 600 ubuntu
docker run -it --name cont_B --blkip-weight 300 ubuntu</code></pre>

<h3>限制bps和iops</h3>

<p>bps是 byte per second ，每秒读写的数量</p>

<p>iops是 io per second ，每秒IO的次数</p>

<p>可以同过下面的参数控制容器的bps和iops；</p>

<ul><li>--device-read-bps:限制读某个设备的bps.</li>
	<li>--devce-write-bps:限制写某个设备的bps.</li>
	<li>--device- read-iops:限制读某个设备的iops.</li>
	<li>--device-write-iops: 限制写某个设备的iops。<br>
	&nbsp;</li>
</ul><p>下面这个例子限制容器写/dev/sda 的速率为30 MB/s:<br>
&nbsp;</p>

<pre><code class="language-bash">[root@kvm ~]# docker run -it --device-write-bps /dev/sda:30MB ubuntu
root@10845a98036e:/# time dd if=/dev/zero of=test.out bs=1M count=800 oflag=direct
800+0 records in
800+0 records out
838860800 bytes (839 MB, 800 MiB) copied, 26.6211 s, 31.5 MB/s

real	0m26.623s
user	0m0.000s
sys	0m0.106s
root@10845a98036e:/# </code></pre>

<pre><code class="language-bash">docker run -it --device-write-bps /dev/sda:30MB ubuntu</code></pre>

<p><strong>有限制</strong></p>

<p><img alt="" height="206" src="https://img-blog.csdnimg.cn/2020031617393618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="668"></p>

<p><strong>没有限制</strong></p>

<p><img alt="" height="266" src="https://img-blog.csdnimg.cn/20200316174047490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="710"></p>

<p>通过dd测试在容器中写磁盘的速度。因为容器的文件系统是在host /dev/sda. 上的，在容器中写文件相当于对host /dev/sda 进行写操作。另外，oflag= -direct指定用direct I0方式写文件，这样--device-write-bps才能生效。<br>
&nbsp;</p>

<p>看到，没有限速的话，速度很快，</p>

<p>其他参数，大家也可以试试</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>esxi中CentOS7不停机加磁盘并扩容现有分区</title><link>http://www.cnblogs.com/heian99/archive/2020/03/16/12585726.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 16 Mar 2020 03:53:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/16/12585726.html</guid><description><![CDATA[
                                            <p>linux的磁盘容量扩容，基于lvm，即逻辑卷管理。具体是什么请百度，这里不细述。</p>

<p>此次操作的目的是为了给已存在的linux主机的其中一个数据分区扩容。</p>

<p>环境：esxi6.5&nbsp; 虚拟机系统centos7</p>

<p><img alt="" height="417" src="https://img-blog.csdnimg.cn/20200316104601736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="610"></p>

<p>简单来说，扩容这件事分三步</p>

<p><strong>一、从esxi中为此虚拟机增加硬盘，并让centos系统识别出此硬盘</strong></p>

<p><strong>二、将此硬盘进行分区、格式化</strong>（重点是这里的分区不是类似于windows，分完就能用了，而它需要一个挂载的过程，要么单独挂载，要么加入lvm挂载，否则在linux中是无法访问的）</p>

<p><strong>三、卷组管理</strong></p>

<ul><li>&nbsp; &nbsp;1、将分好区的硬盘创建为物理卷</li>
	<li>&nbsp; &nbsp;2、将此物卷直接进行挂载到文件系统</li>
	<li>&nbsp; &nbsp;3、或将此物理卷加入到lvm卷组中</li>
	<li>&nbsp; &nbsp;4、对加入到卷组的空间进行逻辑卷扩容或是创建为逻辑卷再进行扩容等操作</li>
</ul><p>以下是本次操作的过程记录</p>

<h2>1、首先看一下未添加硬盘前的系统磁盘状态，</h2>

<p><img alt="" height="502" src="https://img-blog.csdnimg.cn/202003161047479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="784"></p>

<h2>2、在esxi中添加硬盘的过程就不说了，添加过硬盘，需要对scsi接口进行扫描，就相当于扫描新硬件</h2>

<p><img alt="" height="208" src="https://img-blog.csdnimg.cn/20200316110633353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1024"></p>

<h3>端口太多，一个个扫描太慢，我就写个简单脚本执行。</h3>

<pre><code class="language-bash">ls | sort &gt; /opt/host.txt</code></pre>

<p><img alt="" height="213" src="https://img-blog.csdnimg.cn/20200316110801653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="523"></p>

<h3><strong>批量扫描脚本</strong></h3>

<pre><code class="language-bash">
#!/bin/bash
DIR="/sys/class/scsi_host/"
for i in `cat host.txt`
do
        echo "- - -" &gt; $DIR$i/scan
        echo $DIR$i/scan
done
rm -rf /opt/host.txt
</code></pre>

<h3>运行脚本</h3>

<pre><code class="language-bash">[root@kvm opt]# ls
backup  host.sh  host.txt  rh
[root@kvm opt]# pwd
/opt
[root@kvm opt]# bash host.sh 
</code></pre>

<p><img alt="" height="220" src="https://img-blog.csdnimg.cn/20200316111014697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="460"></p>

<h2>3、可以看到新加的10G硬盘已经被识别为/dev/sdb</h2>

<p><img alt="" height="489" src="https://img-blog.csdnimg.cn/20200316111142626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="684"></p>

<h2>4、查看一下scsi的状态，以上都是准备工作，状态都对，后面操作就容易</h2>

<pre><code class="language-bash">cat /proc/scsi/scsi</code></pre>

<p><img alt="" height="258" src="https://img-blog.csdnimg.cn/20200316111612685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="621"></p>

<h3>5、对新硬盘进行分区，此处是新建了一个主分区，默认id为1，所以分好后就是sdb1</h3>

<p><img alt="" height="580" src="https://img-blog.csdnimg.cn/20200316112118387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="802"></p>

<h3>6、我们的目的是为了用lvm进行管理，所以在分完区后，要将分区属性标记为lvm的8e</h3>

<p><img alt="" height="565" src="https://img-blog.csdnimg.cn/20200316112253487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="674"></p>

<h3>7、分完后可以看到分区信息，/dev/sdb1的8e,然后重读一下分区表，刷新</h3>

<p><img alt="" height="158" src="https://img-blog.csdnimg.cn/20200316112354827.png" width="593"></p>

<p>已经分区成功了</p>

<p><img alt="" height="240" src="https://img-blog.csdnimg.cn/20200316112738878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="739"></p>

<p><img alt="" height="152" src="https://img-blog.csdnimg.cn/20200316113306596.png" width="381"></p>

<h2>8、上面分完区，下面当然就是加入卷了，先把sdb1做成一个新的物理卷</h2>

<p>&nbsp;</p>

<p><img alt="" height="527" src="https://img-blog.csdnimg.cn/20200316113804728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="716"></p>

<h3>9、用vgdisplay查看一下卷组的状态，可以看到原先centos组里面没有空余，那么我们要做的就是把刚加的磁盘，刚分好的区，然后刚创建成的物理卷加入到这个centos组里去，加进组才能在组里进行分配嘛。所以vgextend centos /dev/sdb1,加完再看vgdisplay，空余空间为10G，很明显，新加的磁盘已处理待分配状态</h3>

<p><img alt="" height="473" src="https://img-blog.csdnimg.cn/20200316114005356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="575"></p>

<pre><code class="language-bash">[root@kvm dev]# vgextend centos_kvm /dev/sdb1
  Volume group "centos_kvm" successfully extended</code></pre>

<p><img alt="" height="46" src="https://img-blog.csdnimg.cn/20200316114116853.png" width="472"></p>

<p><img alt="" height="354" src="https://img-blog.csdnimg.cn/20200316114222108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="545"></p>

<h3>10、最后就是剑指黄龙，我要给var进行扩容，lvresize -L +10G /dev/centos/var</h3>

<pre><code class="language-bash">[root@kvm centos_kvm]# lvresize -L +20G /dev/centos_kvm/root 
  Size of logical volume centos_kvm/root changed from &lt;26.00 GiB (6655 extents) to &lt;46.00 GiB (11775 extents).
  Logical volume centos_kvm/root successfully resized.
[root@kvm centos_kvm]# vgdisplay
  --- Volume group ---
  VG Name               centos_kvm
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  5
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                2
  Open LV               2
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               128.99 GiB
  PE Size               4.00 MiB
  Total PE              33022
  Alloc PE / Size       12543 / &lt;49.00 GiB
  Free  PE / Size       20479 / &lt;80.00 GiB
  VG UUID               K35BzQ-nhXT-zFsf-W1kp-T9iq-kcFx-hfTdTN
</code></pre>

<p><img alt="" height="497" src="https://img-blog.csdnimg.cn/20200316114711966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="839"></p>

<h3>11、上面那一步不算完，记得不，之前我虽然分区了，创建卷了，加入卷组，但实际上我没格式化。那么OK，这里用xfs_qrowfs /dev/centos/var重新识别一下新卷的容量，是扩容后的哦，扩容时加上的新磁盘也就同时被格式化了。</h3>

<p>xfs_qrowfs 是centos7的命令，在centos6.X中是resize2fs，其实还是6.x的命令好记。</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>此处讲的是直接将新加的磁盘扩容到已有分区，还可以做的是，在将新分区加入卷组后：</p>

<p>1、创建需要大小的独立逻辑卷，将它进行单独挂载使用。（别忘了改一下/etc/fstab，不然下次重启还要手动挂载）</p>

<pre><code class="language-bash">&nbsp; &nbsp;lvcreate&nbsp;-L&nbsp;4G&nbsp;-n&nbsp;newlv&nbsp;centos &nbsp;在centos卷组的空闲空间中划出4G的新逻辑卷，起名为newlv

&nbsp; &nbsp; mkfs.xfs /dev/centos/newlv &nbsp; &nbsp;将新的newlv格式化为xfs文件系统</code></pre>

<p>1、不创新需要大小的独立逻辑卷，将自由空间扩容到现有的分区挂载点</p>

<p>基本就这些了。lvm管理说实话真挺爽的。特别是在esxi主机上使用，无需停机，直接加装扩容。</p>

<p>有正就有反，能装就得能卸，能扩就得能减。</p>

<p>1、直接扩容原有逻辑卷大小的卸载新加容量</p>

<blockquote>
<p>&nbsp; lvreduce -L -10G /dev/centos/var &nbsp;先把扩容的容量减掉</p>
</blockquote>

<p>&nbsp; &nbsp;如果是创建成为一个独立的逻辑卷，则</p>

<blockquote>
<p>&nbsp; lvremove /dev/centos/newlv1</p>
</blockquote>

<p>2、从卷组中删掉加入的磁盘分区</p>

<blockquote>
<p>&nbsp; vgreduce centos /dev/sdb1</p>
</blockquote>

<p>3、从物理卷中卸掉sdb1</p>

<blockquote>
<ul><li>&nbsp; pvremove /dev/sdb1</li>
</ul></blockquote>

<p>最后就是在esxi中删硬件了。</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>ESXI6.5安装CentOS7教程</title><link>http://www.cnblogs.com/heian99/archive/2020/03/16/12585727.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 16 Mar 2020 01:59:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/16/12585727.html</guid><description><![CDATA[
                                            <p>VMware三个版本</p>

<p>workstation： 单机级，用在个人桌面系统中，需要操作系统支持</p>

<p>servier：工作组级，用于服务器，需要操作系统支持</p>

<p>esxi：企业级，用于服务器，不需要操作系统支持</p>

<p>Exsi 是一款虚拟化系统，与VMware，VirtualBox不同，它不需要安装在其他操作系统上，直接运行在裸机上；占用系统资源很小，易于管理，所以被大多数中小型公司所使用；</p>

<p><img alt="" src="https://img-blog.csdn.net/20180803092244598?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDI4MjAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<h3>安装图解：</h3>

<p>镜像已上传到服务器，CentOS7镜像包</p>

<p><img alt="" height="497" src="https://img-blog.csdnimg.cn/20200316094044629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="933"></p>

<p>新建虚拟机</p>

<p><img alt="" height="749" src="https://img-blog.csdnimg.cn/20200316094121259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" height="598" src="https://img-blog.csdnimg.cn/2020031609421728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="938"></p>

<p>选择存储</p>

<p><img alt="" height="598" src="https://img-blog.csdnimg.cn/20200316094300587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="943"></p>

<p>自定义设置</p>

<p><img alt="" height="591" src="https://img-blog.csdnimg.cn/20200316094537426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="943"></p>

<p><img alt="" height="964" src="https://img-blog.csdnimg.cn/20200316094607941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="937"></p>

<p>如果配置不够，可进行修改</p>

<p><img alt="" height="645" src="https://img-blog.csdnimg.cn/20200316094645722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>将镜像加载到新建的虚拟机里，CD/DVD驱动器选择数据存储ISO文件</p>

<p><img alt="" height="567" src="https://img-blog.csdnimg.cn/20200316094723876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="791"></p>

<p><img alt="" height="518" src="https://img-blog.csdnimg.cn/20200316094747276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="801"></p>

<p>现在开始运行，首先打开电源,打开控制台</p>

<p><img alt="" height="522" src="https://img-blog.csdnimg.cn/20200316094819324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="670"></p>

<p><img alt="" height="625" src="https://img-blog.csdnimg.cn/2020031609501224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="796"></p>

<p>下面步骤就可安装Centos7一样了。</p>

<p>选择自己需求的东西就行，然后开始安装。</p>
                                    ]]></description></item><item><title>Linux查看占用CPU和内存的 的程序</title><link>http://www.cnblogs.com/heian99/archive/2020/03/14/12585728.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 14 Mar 2020 13:27:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/03/14/12585728.html</guid><description><![CDATA[
                                            <p>占内存的程序命令</p>

<pre><code class="language-bash"> ps aux | head -1;ps aux|sort -k4nr|head -5</code></pre>

<p><img alt="" height="473" src="https://img-blog.csdnimg.cn/20200314212600566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>占CPU的程序命令</p>

<pre><code class="language-bash">ps aux | head -1;ps aux|sort -k3nr|head -5</code></pre>

<p><img alt="" height="398" src="https://img-blog.csdnimg.cn/20200314212429239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Centos7使用脚本搭建LVS的DR模式。</title><link>http://www.cnblogs.com/heian99/archive/2020/02/20/12585729.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 20 Feb 2020 15:23:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/20/12585729.html</guid><description><![CDATA[
                                            <p><img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85OTY3NTk1LTgxZDY1OGFjM2M3MTBlMGEucG5n?x-oss-process=image/format,png"></p>

<p><img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85OTY3NTk1LWIyNWJhNDE4MjliYTUzZDQucG5n?x-oss-process=image/format,png"></p>

<p>环境准备：三台虚拟机</p>

<p>1）此环境是针对内部服务的LVS架构，如数据库，缓存，共享存储等业务。</p>

<table border="1"><tbody><tr><td style="vertical-align:top;">虚拟机角色</td>
			<td style="vertical-align:top;">IP地址</td>
			<td style="vertical-align:top;">备注</td>
		</tr><tr><td style="vertical-align:top;">LVS负载均衡器</td>
			<td style="vertical-align:top;">192.168.116.129</td>
			<td style="vertical-align:top;">VIP地址：192.168.116.100</td>
		</tr><tr><td style="vertical-align:top;">http服务器RS1</td>
			<td style="vertical-align:top;">192.168.116.130</td>
			<td style="vertical-align:top;">&nbsp;</td>
		</tr><tr><td style="vertical-align:top;">http服务器RS2</td>
			<td style="vertical-align:top;">192.168.116.131</td>
			<td style="vertical-align:top;">&nbsp;</td>
		</tr></tbody></table><p>&nbsp;</p>

<h3><strong>LVS负载均衡器</strong></h3>

<pre><code class="language-bash"> vim /usr/local/sbin/lvs_dr.sh

#!/bin/bash   
 yum install -y net-tools ipvsadm                                                                          
 echo 1 &gt; /proc/sys/net/ipv4/ip_forward
 ipv=/usr/sbin/ipvsadm
 vip=192.168.116.100
 rs1=192.168.116.130
 rs2=192.168.116.131
 #注意这里的网卡名字
 ifconfig ens33:2 $vip broadcast $vip netmask 255.255.255.255 up
 route add -host $vip dev ens33:2
 $ipv -C
 $ipv -A -t $vip:80 -s wrr
 $ipv -a -t $vip:80 -r $rs1:80 -g -w 1
 $ipv -a -t $vip:80 -r $rs2:80 -g -w 1</code></pre>

<p>&nbsp;</p>

<h3><strong>http服务器RS1、http服务器RS2</strong></h3>

<pre><code class="language-bash"> vim /usr/local/sbin/lvs_dr.sh

#/bin/bash  
 yum install -y net-tools                                                                         
 vip=192.168.116.100
 #把vip绑定在lo上，是为了实现rs直接把结果返回给客户端
 ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up
 route add -host $vip lo:0
 #以下操作为更改arp内核参数，目的是为了让rs顺利发送mac地址给客户端
 echo "1" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
 echo "2" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
 echo "1" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
 echo "2" &gt;/proc/sys/net/ipv4/conf/all/arp_announce</code></pre>

<p>&nbsp;</p>

<h1><strong>运行脚本</strong></h1>

<pre><code class="language-bash">bash /usr/local/sbin/lvs_dr_rs.sh
</code></pre>

<p><strong>在httpd服务器创建文件测试</strong></p>

<pre><code class="language-bash">yum install -y httpd &amp;&amp; echo "this is one" &gt;&gt; /var/www/html/index.html &amp;&amp; systemctl restart httpd
</code></pre>

<p><img alt="" height="483" src="https://img-blog.csdnimg.cn/20200220231947152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="700"></p>

<p><img alt="" height="375" src="https://img-blog.csdnimg.cn/20200221105747161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="986"></p>
                                    ]]></description></item><item><title>Kubernetes（k8s）的调度器 - 调度亲和性详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/11/12328959.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 11 Feb 2020 08:02:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/11/12328959.html</guid><description><![CDATA[
                                            <h1>节点亲和性</h1>

<p><strong>pod.spec.nodeAﬃnity</strong></p>

<ul><li>preferredDuringSchedulingIgnoredDuringExecution：软策略</li>
	<li>requiredDuringSchedulingIgnoredDuringExecution：硬策略</li>
</ul><h3>requiredDuringSchedulingIgnoredDuringExecution</h3>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: affinity
  labels:
    app: node-affinity-pod
spec:
  containers:
  - name: with-node-affinity
    image: wangyanglinux/myapp:v1
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname
            operator: NotIn
            values:
            - node02
</code></pre>

<h1><img alt="" class="has" height="323" src="https://img-blog.csdnimg.cn/20200211145022940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></h1>

<h1><img alt="" class="has" height="311" src="https://img-blog.csdnimg.cn/20200211145132557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1127"></h1>

<h3>preferredDuringSchedulingIgnoredDuringExecution</h3>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: affinity
  labels:
    app: node-affinity-pod
spec:
  containers:
  - name: with-node-affinity
    image: wangyanglinux/myapp:v1
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        preference:
          matchExpressions:
          - key: kubernetes.io/hostname
            operator: In
            values:
            - node3</code></pre>

<p><img alt="" class="has" height="269" src="https://img-blog.csdnimg.cn/20200211150043932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1041"></p>

<h1>先硬后软</h1>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: affinity
  labels:
    app: node-affinity-pod
spec:
  containers:
  - name: with-node-affinity
    image: hub.atguigu.com/library/myapp:v1
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname
            operator: NotIn
            values:
            - k8s-node02
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        preference:
          matchExpressions:
          - key: source
            operator: In
            values:
            - qikqiak
</code></pre>

<h3><strong>键值运算关系</strong></h3>

<ul><li><strong>In：label 的值在某个列表中</strong></li>
	<li><strong>NotIn：label 的值不在某个列表中</strong></li>
	<li><strong>Gt：label 的值大于某个值</strong></li>
	<li><strong>Lt：label 的值小于某个值</strong></li>
	<li><strong>Exists：某个 label 存在</strong></li>
	<li><strong>DoesNotExist：某个 label 不存在</strong><br>
	&nbsp;</li>
</ul><h1>&nbsp;Pod &nbsp;亲和性</h1>

<p><strong>pod.spec.aﬃnity.podAﬃnity/podAntiAﬃnity</strong></p>

<ul><li><strong>preferredDuringSchedulingIgnoredDuringExecution：软策略</strong></li>
	<li><strong>requiredDuringSchedulingIgnoredDuringExecution：硬策略</strong></li>
</ul><pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: pod-3
  labels:
    app: pod-3
spec:
  containers:
  - name: pod-3
    image: wangyanglinux/myapp:v1
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app
            operator: In
            values:
            - pod-1
        topologyKey: kubernetes.io/hostname
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - pod-2
          topologyKey: kubernetes.io/hostname
</code></pre>

<p>亲和性/反亲和性调度策略比较如下：<br>
&nbsp;</p>

<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td>调度策略匹配 标签</td>
			<td>匹配 标签</td>
			<td>操作符</td>
			<td>拓扑域 支持</td>
			<td>调度目标</td>
		</tr><tr><td>nodeAﬃnity</td>
			<td>&nbsp;主机</td>
			<td>In, NotIn, Exists, DoesNotExist, Gt, Lt</td>
			<td>否</td>
			<td>指向主机</td>
		</tr><tr><td>podAﬃnity&nbsp;</td>
			<td>POD</td>
			<td>In, NotIn, Exists, DoesNotExist</td>
			<td>是</td>
			<td>POD与指定POD同一拓 扑域</td>
		</tr><tr><td>podAnitAﬃnity&nbsp;</td>
			<td>POD</td>
			<td>In, NotIn, Exists, DoesNotExist</td>
			<td>是</td>
			<td>POD与指定POD不在同 一拓扑域</td>
		</tr></tbody></table><p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）的调度器详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/11/12328960.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 11 Feb 2020 06:45:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/11/12328960.html</guid><description><![CDATA[
                                            <h1>简介&nbsp;</h1>

<p><strong>Scheduler 是 kubernetes 的调度器，主要的任务是把定义的 pod 分配到集群的节点上。听起来非常简单，但有 很多要考虑的问题：</strong></p>

<ul><li><strong>公平：如何保证每个节点都能被分配资源</strong></li>
	<li><strong>资源高效利用：集群所有资源最大化被使用</strong></li>
	<li><strong>效率：调度的性能要好，能够尽快地对大批量的 pod 完成调度工作</strong></li>
	<li><strong>灵活：允许用户根据自己的需求控制调度的逻辑</strong><br>
	&nbsp;</li>
</ul><p>Sheduler 是作为单独的程序运行的，启动之后会一直坚挺 API Server，获取 PodSpec.NodeName 为空的 pod， 对每个 pod 都会创建一个 binding，表明该 pod 应该放到哪个节点上&nbsp;</p>

<h1>调度过程&nbsp;</h1>

<p>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程称为&nbsp;&nbsp;predicate ；然后对通过的节点按照优先级 排序，这个是&nbsp;&nbsp;priority ；最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误&nbsp;</p>

<p><strong>Predicate 有一系列的算法可以使用：&nbsp;</strong></p>

<ul><li><strong>PodFitsResources ：节点上剩余的资源是否大于 pod 请求的资源</strong></li>
	<li><strong>PodFitsHost ：如果 pod 指定了 NodeName，检查节点名称是否和 NodeName 匹配</strong></li>
	<li><strong>PodFitsHostPorts ：节点上已经使用的 port 是否和 pod 申请的 port 冲突</strong></li>
	<li><strong>PodSelectorMatches ：过滤掉和 pod 指定的 label 不匹配的节点</strong></li>
	<li><strong>NoDiskConflict ：已经 mount 的 volume 和 pod 指定的 volume 不冲突，除非它们都是只读</strong><br>
	&nbsp;</li>
</ul><p>如果在 predicate 过程中没有合适的节点，pod 会一直在&nbsp;&nbsp;pending &nbsp;状态，不断重试调度，直到有节点满足条件。 经过这个步骤，如果有多个节点满足条件，就继续 priorities 过程： 按照优先级大小对节点排序<br><strong>优先级由一系列键值对组成，键是该优先级项的名称，值是它的权重（该项的重要性）。这些优先级选项包括：</strong></p>

<ul><li><strong>LeastRequestedPriority ：通过计算 CPU 和 Memory 的使用率来决定权重，使用率越低权重越高。换句话</strong><strong>说，这个优先级指标倾向于资源使用比例更低的节点</strong></li>
	<li><strong>BalancedResourceAllocation ：节点上 CPU 和 Memory 使用率越接近，权重越高。这个应该和上面的一起</strong><strong>使用，不应该单独使用</strong></li>
	<li><strong>ImageLocalityPriority &nbsp;：倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高</strong><br>
	&nbsp;</li>
</ul><p><strong>通过算法对所有的优先级项目和权重进行计算，得出最终的结果</strong></p>

<h1>自定义调度器&nbsp;</h1>

<p><strong>除了 kubernetes 自带的调度器，你也可以编写自己的调度器。通过 spec:schedulername 参数指定调度器的名 字，可以为 pod 选择某个调度器进行调度。比如下面的 pod 选择 my-scheduler 进行调度，而不是默认的 default-scheduler ：</strong></p>

<pre class="has"><code>apiVersion: v1
kind: Pod
metadata:
  name: annotation-second-scheduler
  labels:
    name: multischeduler-example
spec:
  schedulername: my-scheduler
  containers:
  - name: pod-with-second-annotation-container
    image: wangyanglinux/myapp:v1
</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）的存储PV-PVC详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/09/12328961.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 09 Feb 2020 13:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/09/12328961.html</guid><description><![CDATA[
                                            <h1>概念&nbsp;</h1>

<h2>PersistentVolume （PV）&nbsp;</h2>

<p>是由管理员设置的存储，它是群集的一部分。就像节点是集群中的资源一样，PV 也是集群中的资源。 PV 是 Volume 之类的卷插件，但具有独立于使用 PV 的 Pod 的生命周期。此 API 对象包含存储实现的细节，即 NFS、 iSCSI 或特定于云供应商的存储系统&nbsp;</p>

<h2>PersistentVolumeClaim （PVC）</h2>

<p>是用户存储的请求。它与 Pod 相似。Pod 消耗节点资源，PVC 消耗 PV 资源。Pod 可以请求特定级别的资源 （CPU 和内存）。声明可以请求特定的大小和访问模式（例如，可以以读/写一次或 只读多次模式挂载）</p>

<h2>静态 pv&nbsp;</h2>

<p>集群管理员创建一些 PV。它们带有可供群集用户使用的实际存储的细节。它们存在于 Kubernetes API 中，可用 于消费</p>

<h2>动态&nbsp;</h2>

<p>当管理员创建的静态 PV 都不匹配用户的 PersistentVolumeClaim 时，集群可能会尝试动态地为 PVC 创建卷。此 配置基于StorageClasses ：PVC 必须请求 [存储类]，并且管理员必须创建并配置该类才能进行动态创建。声明该 类为 "" 可以有效地禁用其动态配置</p>

<p>要启用基于存储级别的动态存储配置，集群管理员需要启用 API server 上的 DefaultStorageClass [准入控制器] 。例如，通过确保 DefaultStorageClass 位于 API server 组件的 --admission-control 标志，使用逗号分隔的 有序值列表中，可以完成此操作</p>

<h2>绑定&nbsp;</h2>

<p>master 中的控制环路监视新的 PVC，寻找匹配的 PV（如果可能），并将它们绑定在一起。如果为新的 PVC 动态 调配 PV，则该环路将始终将该 PV 绑定到 PVC。否则，用户总会得到他们所请求的存储，但是容量可能超出要求 的数量。一旦 PV 和 PVC 绑定后， PersistentVolumeClaim 绑定是排他性的，不管它们是如何绑定的。 PVC 跟 PV 绑定是一对一的映射&nbsp;</p>

<h2>持久化卷声明的保护&nbsp;</h2>

<p>PVC 保护的目的是确保由 pod 正在使用的 PVC 不会从系统中移除，因为如果被移除的话可能会导致数据丢失</p>

<p>当启用PVC 保护 alpha 功能时，如果用户删除了一个 pod 正在使用的 PVC，则该 PVC 不会被立即删除。PVC 的 删除将被推迟，直到 PVC 不再被任何 pod 使用<br>
&nbsp;</p>

<h2>持久化卷类型&nbsp;</h2>

<p><strong>PersistentVolume 类型以插件形式实现。Kubernetes 目前支持以下插件类型：&nbsp;</strong></p>

<ul><li>GCEPersistentDisk &nbsp; AWSElasticBlockStore &nbsp;AzureFile &nbsp;AzureDisk &nbsp;FC (Fibre Channel)</li>
	<li>FlexVolume &nbsp;Flocker &nbsp;NFS &nbsp;iSCSI &nbsp;RBD (Ceph Block Device) &nbsp;CephFS</li>
	<li>Cinder (OpenStack block storage) &nbsp;Glusterfs &nbsp;VsphereVolume &nbsp;Quobyte Volumes</li>
	<li>HostPath &nbsp; VMware Photon &nbsp;Portworx Volumes &nbsp;ScaleIO Volumes &nbsp;StorageOS</li>
</ul><h2><strong>持久卷演示代码</strong><br>
&nbsp;</h2>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0003
spec:
  capacity:
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: slow
  mountOptions:
    - hard
    - nfsvers=4.1
  nfs:
    path: /tmp
    server: 172.17.0.2
</code></pre>

<h1>PV 访问模式&nbsp;</h1>

<p>PersistentVolume 可以以资源提供者支持的任何方式挂载到主机上。如下表所示，供应商具有不同的功能，每个 PV 的访问模式都将被设置为该卷支持的特定模式。例如，NFS 可以支持多个读/写客户端，但特定的 NFS PV 可能 以只读方式导出到服务器上。每个 PV 都有一套自己的用来描述特定功能的访问模式&nbsp;</p>

<ul><li>ReadWriteOnce——该卷可以被单个节点以读/写模式挂载</li>
	<li>ReadOnlyMany——该卷可以被多个节点以只读模式挂载</li>
	<li>ReadWriteMany——该卷可以被多个节点以读/写模式挂载</li>
</ul><p><strong>在命令行中，访问模式缩写为：</strong></p>

<ul><li>RWO - ReadWriteOnce</li>
	<li>ROX - ReadOnlyMany</li>
	<li>RWX - ReadWriteMany</li>
</ul><p><img alt="" class="has" height="688" src="https://img-blog.csdnimg.cn/20200209203250815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="814"></p>

<h2>回收策略</h2>

<ul><li>Retain（保留）——手动回收</li>
	<li>Recycle（回收）——基本擦除（ rm -rf /thevolume/* &nbsp;）</li>
	<li>Delete（删除）——关联的存储资产（例如 AWS EBS、GCE PD、Azure Disk 和 OpenStack Cinder 卷）将被删除</li>
</ul><p>当前，只有 NFS 和 HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk 和 Cinder 卷支持删除策略</p>

<h2>状态</h2>

<p>卷可以处于以下的某种状态：</p>

<ul><li><strong>Available（可用）——一块空闲资源还没有被任何声明绑定</strong></li>
	<li><strong>Bound（已绑定）——卷已经被声明绑定</strong></li>
	<li><strong>Released（已释放）——声明被删除，但是资源还未被集群重新声明</strong></li>
</ul><p>&nbsp;Failed（失败）——该卷的自动回收失败<br>
命令行会显示绑定到 PV 的 PVC 的名称</p>

<h1>持久化演示说明 - NFS&nbsp;</h1>

<h2>Ⅰ、安装 NFS 服务器</h2>

<pre class="has"><code class="language-bash">yum install -y nfs-common nfs-utils  rpcbind
mkdir /nfsdata
chmod 666 /nfsdata
chown nfsnobody /nfsdata
cat /etc/exports
    /nfsdata *(rw,no_root_squash,no_all_squash,sync)
systemctl start rpcbind
systemctl start nfs
</code></pre>

<p><img alt="" class="has" height="273" src="https://img-blog.csdnimg.cn/20200209204222455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="595"></p>

<p>NFS已经成功了</p>

<h2>Ⅱ、部署 PV&nbsp;</h2>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: PersistentVolume
metadata:
  name: nfspv1
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: nfs
  nfs:
    path: /nfsdata
    server: 192.168.116.131
</code></pre>

<p><img alt="" class="has" height="318" src="https://img-blog.csdnimg.cn/20200209211106596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1091"></p>

<h2>Ⅲ、创建服务并使用 PVC&nbsp;</h2>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None
  selector:
    app: nginx
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  selector:
    matchLabels:
      app: nginx
  serviceName: "nginx"
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: wangyanglinux/myapp:v1
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: "nfs"
      resources:
        requests:
          storage: 10Gi
</code></pre>

<p><img alt="" class="has" height="483" src="https://img-blog.csdnimg.cn/20200209212349469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1183"></p>

<p><img alt="" class="has" height="299" src="https://img-blog.csdnimg.cn/20200209212806114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="594"></p>

<p><img alt="" class="has" height="173" src="https://img-blog.csdnimg.cn/20200209212904233.png" width="803"></p>

<p>&nbsp;</p>

<h1>关于 StatefulSet&nbsp;</h1>

<p>匹配 Pod name ( 网络标识 ) 的模式为：$(statefulset名称)-$(序号)，比如上面的示例：web-0，web-1，web-2</p>

<ul><li><strong>StatefulSet 为每个 Pod 副本创建了一个 DNS 域名，这个域名的格式为： $(podname).(headless server&nbsp;name)，也就意味着服务间是通过Pod域名来通信而非 Pod IP，因为当Pod所在Node发生故障时， Pod 会被飘移到其它 Node 上，Pod IP 会发生变化，但是 Pod 域名不会有变化</strong></li>
	<li><strong>StatefulSet 使用 Headless 服务来控制 Pod 的域名，这个域名的 FQDN 为：$(service&nbsp;name).$(namespace).svc.cluster.local，其中，“cluster.local” 指的是集群的域名</strong></li>
	<li><strong>根据 volumeClaimTemplates，为每个 Pod 创建一个 pvc，pvc 的命名规则匹配模式：(volumeClaimTemplates.name)-(pod_name)，比如上面的 volumeMounts.name=www， Pod&nbsp;name=web-[0-2]，因此创建出来的 PVC 是 www-web-0、www-web-1、www-web-2</strong></li>
	<li><strong>删除 Pod 不会删除其 pvc，手动删除 pvc 将自动释放 pv</strong></li>
</ul><h2>Statefulset的启停顺序：</h2>

<ul><li>有序部署：部署StatefulSet时，如果有多个Pod副本，它们会被顺序地创建（从0到N-1）并且，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态。</li>
	<li>有序删除：当Pod被删除时，它们被终止的顺序是从N-1到0。</li>
	<li>有序扩展：当对Pod执行扩展操作时，与部署一样，它前面的Pod必须都处于Running和Ready状态。</li>
</ul><h2>StatefulSet使用场景：</h2>

<ul><li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现。</li>
	<li>稳定的网络标识符，即 Pod 重新调度后其 PodName 和 HostName 不变。</li>
	<li>有序部署，有序扩展，基于 init containers 来实现。</li>
	<li>有序收缩。</li>
</ul>                                    ]]></description></item><item><title>Kubernetes（k8s）的存储Volume 详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/08/12285692.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 08 Feb 2020 13:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/08/12285692.html</guid><description><![CDATA[
                                            <p><strong>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃 时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在 Pod 中同时运行多个容器时，这些容器之间通常需要共享文件。<span style="color:#f33b45;">Kubernetes </span>中的 <span style="color:#f33b45;">Volume </span>抽象就很好的解决了 这些问题</strong></p>

<h1>背景&nbsp;</h1>

<p>Kubernetes 中的卷有明确的寿命 —— 与封装它的 Pod 相同。所f以，卷的生命比 Pod 中的所有容器都长，当这 个容器重启时数据仍然得以保存。当然，当 Pod 不再存在时，卷也将不复存在。也许更重要的是，Kubernetes 支持多种类型的卷，Pod 可以同时使用任意数量的卷</p>

<h2><img alt="" class="has" height="450" src="https://img-blog.csdnimg.cn/20200208201700623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="762"><br><strong>卷的类型&nbsp;</strong></h2>

<p><strong>Kubernetes 支持以下类型的卷：</strong></p>

<ul><li>awsElasticBlockStore &nbsp; &nbsp; azureDisk &nbsp; &nbsp; azureFile &nbsp; &nbsp;cephfs &nbsp; &nbsp;csi &nbsp; &nbsp; downwardAPI &nbsp; &nbsp; emptyDir</li>
	<li>fc &nbsp;flocker &nbsp; &nbsp;gcePersistentDisk &nbsp; &nbsp;gitRepo &nbsp; &nbsp;glusterfs &nbsp; &nbsp;hostPath &nbsp; &nbsp;iscsi &nbsp; &nbsp;local &nbsp; &nbsp; nfs</li>
	<li>persistentVolumeClaim &nbsp; &nbsp;projected &nbsp; &nbsp;portworxVolume &nbsp; &nbsp;quobyte &nbsp; &nbsp;rbd &nbsp; &nbsp;scaleIO &nbsp; &nbsp; secret</li>
	<li>storageos &nbsp;vsphereVolume<br>
	&nbsp;</li>
</ul><h1>emptyDir&nbsp;</h1>

<p>当 Pod 被分配给节点时，首先创建 emptyDir 卷，并且只要该 Pod 在该节点上运行，该卷就会存在。正如卷的名 字所述，它最初是空的。Pod 中的容器可以读取和写入 emptyDir 卷中的相同文件，尽管该卷可以挂载到每个容 器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时， emptyDir 中的数据将被永久删除&nbsp;</p>

<h3>emptyDir &nbsp;的用法有：</h3>

<ul><li>暂存空间，例如用于基于磁盘的合并排序</li>
	<li>用作长时间计算崩溃恢复时的检查点</li>
	<li>Web服务器容器提供数据时，保存内容管理器容器提取的文件</li>
</ul><pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: wangyanglinux/myapp:v1
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir: {}
</code></pre>

<p><img alt="" class="has" height="361" src="https://img-blog.csdnimg.cn/20200208204350151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="688"></p>

<p>可以添加文件，实现不同容器共享,不同路径挂载。</p>

<h1>hostPath&nbsp;</h1>

<p><img alt="" class="has" height="816" src="https://img-blog.csdnimg.cn/20200208205950766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1130"></p>

<p>hostPath 卷将主机节点的文件系统中的文件或目录挂载到集群中<br><strong>hostPath &nbsp;的用途如下：</strong></p>

<ul><li>运行需要访问 Docker 内部的容器；使用 &nbsp;/var/lib/docker &nbsp;的 &nbsp; hostPath</li>
	<li>在容器中运行 cAdvisor；使用 &nbsp;/dev/cgroups &nbsp;的 &nbsp; hostPath</li>
	<li>允许 pod 指定给定的 hostPath 是否应该在 pod 运行之前存在，是否应该创建，以及它应该以什么形式存在<br>
	&nbsp;</li>
</ul><p>除了所需的 path 属性之外，用户还可以为 hostPath 卷指定 type<br>
&nbsp;</p>

<p><img alt="" class="has" height="445" src="https://img-blog.csdnimg.cn/20200208205509332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="811"></p>

<p>使用这种卷类型是请注意，因为：</p>

<ul><li>由于每个节点上的文件都不同，具有相同配置（例如从 podTemplate 创建的）的 pod 在不同节点上的行为可能会有所不同</li>
	<li>当 Kubernetes 按照计划添加资源感知调度时，将无法考虑 &nbsp;hostPath &nbsp;使用的资源</li>
	<li>在底层主机上创建的文件或目录只能由 root 写入。您需要在特权容器中以 root 身份运行进程，或修改主机上的文件权限以便写入 &nbsp;hostPath &nbsp;卷</li>
</ul><pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: wangyanglinux/myapp:v1
    name: test-container
    volumeMounts:
    - mountPath: /test-pd
      name: test-volume
  volumes:
  - name: test-volume
    hostPath:
      # directory location on host
      path: /data
      # this field is optional
      type: Directory
</code></pre>

<p><img alt="" class="has" height="684" src="https://img-blog.csdnimg.cn/20200208210826790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="543"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）的存储Secret 详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/08/12285693.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 08 Feb 2020 12:02:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/08/12285693.html</guid><description><![CDATA[
                                            <h1>Secret 存在意义&nbsp;</h1>

<p><strong>Secret 解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者 Pod Spec 中。Secret 可以以 Volume 或者环境变量的方式使用&nbsp;</strong></p>

<p>Secret 有三种类型：&nbsp;</p>

<ul><li>Service Account ：用来访问 Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到 Pod 的/run/secrets/kubernetes.io/serviceaccount &nbsp;目录中</li>
	<li>Opaque ：base64编码格式的Secret，用来存储密码、密钥等</li>
	<li>kubernetes.io/dockerconﬁgjson ：用来存储私有 docker registry 的认证信息</li>
</ul><h1>Service Account&nbsp;</h1>

<p><strong>Service Account 用来访问 Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到 Pod的 /run/secrets/kubernetes.io/serviceaccount 目录中</strong><br>
&nbsp;</p>

<pre class="has"><code class="language-bash">$ kubectl run nginx --image nginx
deployment "nginx" created
$ kubectl get pods
NAME                     READY     STATUS    RESTARTS   AGE
nginx-3137573019-md1u2   1/1       Running   0          13s
$ kubectl exec nginx-3137573019-md1u2 ls /run/secrets/kubernetes.io/serviceaccount
ca.crt
namespace
token
</code></pre>

<h1>Opaque Secret</h1>

<p><strong>&nbsp;Ⅰ、创建说明&nbsp;<br>
Opaque 类型的数据是一个 map 类型，要求 value 是 base64 编码格式：</strong><br>
&nbsp;</p>

<pre class="has"><code class="language-bash">$ echo -n "admin" | base64
YWRtaW4=
$ echo -n "1f2d1e2e67df" | base64
MWYyZDFlMmU2N2Rm
</code></pre>

<p><strong>secrets.yaml</strong><br>
&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  password: MWYyZDFlMmU2N2Rm
  username: YWRtaW4=
</code></pre>

<p><img alt="" class="has" height="240" src="https://img-blog.csdnimg.cn/20200208192858700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="845"></p>

<p><strong>Ⅱ、使用方式&nbsp;<br>
1、将 Secret 挂载到 Volume 中</strong><br>
&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    name: seret-test
  name: seret-test
spec:
  volumes:
  - name: secrets
    secret:
      secretName: mysecret
  containers:
  - image: wangyanglinux/myapp:v1
    name: db
    volumeMounts:
    - name: secrets
      mountPath: "/etc/secrets"
      readOnly: true
</code></pre>

<p><img alt="" class="has" height="483" src="https://img-blog.csdnimg.cn/20200208193420420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="872"></p>

<p><strong>2、将 Secret 导出到环境变量中</strong><br>
&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: pod-deployment
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: pod-deployment
    spec:
      containers:
      - name: pod-1
        image: wangyanglinux/myapp:v1
        ports:
        - containerPort: 80
        env:
        - name: TEST_USER
          valueFrom:
            secretKeyRef:
              name: mysecret
              key: username
        - name: TEST_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysecret
              key: password
</code></pre>

<p><img alt="" class="has" height="381" src="https://img-blog.csdnimg.cn/20200208194305508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="848"></p>

<h1>kubernetes.io/dockerconﬁgjson&nbsp;</h1>

<p>使用 Kuberctl 创建 docker registry 认证的 secret<br>
&nbsp;</p>

<pre class="has"><code class="language-bash">$ kubectl create secret docker-registry myregistrykey --docker-server=DOCKER_REGISTRY_SERVER --
docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL
secret "myregistrykey" created.
</code></pre>

<p>在创建 Pod 的时候，通过 imagePullSecrets 来引用刚创建的 `myregistrykey`<br>
&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: foo
spec:
  containers:
    - name: foo
      image: roc/awangyang:v1
  imagePullSecrets:
    - name: myregistrykey
</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）的存储configmap详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/08/12285694.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 08 Feb 2020 08:35:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/08/12285694.html</guid><description><![CDATA[
                                            <h1>conﬁgMap 描述信息&nbsp;</h1>

<p><strong>ConﬁgMap 功能在 Kubernetes1.2 版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配 置信息。ConﬁgMap API 给我们提供了向容器中注入配置信息的机制，ConﬁgMap 可以被用来保存单个属性，也 可以用来保存整个配置文件或者 JSON 二进制大对象&nbsp;</strong></p>

<h1>ConﬁgMap 的创建&nbsp;</h1>

<h2>Ⅰ、使用目录创建<br>
&nbsp;</h2>

<pre class="has"><code class="language-bash">$ ls docs/user-guide/configmap/kubectl/
game.properties
ui.properties

$ cat docs/user-guide/configmap/kubectl/game.properties
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30

$ cat docs/user-guide/configmap/kubectl/ui.properties
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice


$ kubectl create configmap game-config --from-file=docs/user-guide/configmap/kubectl
</code></pre>

<p>—from-file 指定在目录下的所有文件都会被用在 ConﬁgMap 里面创建一个键值对，键的名字就是文件名，值就 是文件的内容<br><br><img alt="" class="has" height="679" src="https://img-blog.csdnimg.cn/20200208152714625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="991"></p>

<h2>Ⅱ、使用文件创建&nbsp;</h2>

<p>只要指定为一个文件就可以从单个文件中创建 ConﬁgMap<br>
&nbsp;</p>

<pre class="has"><code class="language-bash">$ kubectl create configmap game-config-2 --from-file=docs/user-
guide/configmap/kubectl/game.properties 
$ kubectl get configmaps game-config-2 -o yaml
</code></pre>

<p>—from-file 这个参数可以使用多次，你可以使用两次分别指定上个实例中的那两个配置文件，效果就跟指定整个 目录是一样的<br>
&nbsp;</p>

<p><img alt="" class="has" height="292" src="https://img-blog.csdnimg.cn/20200208153018747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="948"></p>

<p><img alt="" class="has" height="419" src="https://img-blog.csdnimg.cn/20200208153033982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="681"></p>

<h2>Ⅲ、使用字面值创建&nbsp;</h2>

<p>使用文字值创建，利用 —from-literal 参数传递配置信息，该参数可以使用多次，格式如下<br>
&nbsp;</p>

<pre class="has"><code class="language-bash">$ kubectl create configmap special-config --from-literal=special.how=very --from-
literal=special.type=charm
$ kubectl get configmaps special-config -o yaml
</code></pre>

<p><img alt="" class="has" height="584" src="https://img-blog.csdnimg.cn/20200208153314694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1032"></p>

<h1>Pod 中使用 ConﬁgMap&nbsp;</h1>

<h2>Ⅰ、使用 ConﬁgMap 来替代环境变量<br>
&nbsp;</h2>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config
  namespace: default
data:
  log_level: INFO
</code></pre>

<p><img alt="" class="has" height="350" src="https://img-blog.csdnimg.cn/2020020815390383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="713"></p>

<p>Pod的创建</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: wangyanglinux/myapp:v1
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
      envFrom:
        - configMapRef:
            name: env-config
  restartPolicy: Never
</code></pre>

<p><img alt="" class="has" height="654" src="https://img-blog.csdnimg.cn/20200208160709427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="892"></p>

<h2>Ⅱ、用 ConﬁgMap 设置命令行参数&nbsp;<br>
&nbsp;</h2>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
</code></pre>

<p>Pod的创建<br>
&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod66
spec:
  containers:
    - name: test-container
      image: wangyanglinux/myapp:v1
      command: [ "/bin/sh", "-c", "echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)" ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
  restartPolicy: Never
</code></pre>

<p><img alt="" class="has" height="340" src="https://img-blog.csdnimg.cn/2020020816124782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="824"></p>

<h2>Ⅲ、通过数据卷插件使用ConﬁgMap&nbsp;</h2>

<p>&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
</code></pre>

<p>在数据卷里面使用这个 ConﬁgMap，有不同的选项。基本的就是将文件填入数据卷，在这个文件中，键就是文 件名，键值就是文件内容<br>
&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod77
spec:
  containers:
    - name: test-container
      image: wangyanglinux/myapp:v1
      command: [ "/bin/sh", "-c", "sleep 600s" ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: special-config
  restartPolicy: Never
</code></pre>

<p>&nbsp;</p>

<p><img alt="" class="has" height="449" src="https://img-blog.csdnimg.cn/20200208162005716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="738"></p>

<h2>ConﬁgMap 的热更新&nbsp;</h2>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: ConfigMap
metadata:
  name: log-config
  namespace: default
data:
  log_level: INFO
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: my-nginx
spec:
  replicas: 1
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
      - name: my-nginx
        image: wangyanglinux/myapp:v1
        ports:
        - containerPort: 80
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config
      volumes:
        - name: config-volume
          configMap:
            name: log-config
</code></pre>

<p><img alt="" class="has" height="384" src="https://img-blog.csdnimg.cn/20200208162855401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="824"></p>

<p>修改 ConﬁgMap<br>
&nbsp;</p>

<pre class="has"><code>$ kubectl edit configmap log-config</code></pre>

<p><img alt="" class="has" height="599" src="https://img-blog.csdnimg.cn/20200208163131606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1122"></p>

<p><img alt="" class="has" height="183" src="https://img-blog.csdnimg.cn/20200208163236166.png" width="903"></p>

<p>ConﬁgMap 更新后滚动更新 Pod<br>
更新 ConﬁgMap 目前并不会触发相关 Pod 的滚动更新，可以通过修改 pod annotations 的方式强制触发滚动更新<br>
&nbsp;</p>

<pre class="has"><code>$ kubectl patch deployment my-nginx --patch '{"spec": {"template": {"metadata": {"annotations": 
{"version/config": "20190411" }}}}}'
</code></pre>

<p>&nbsp;</p>

<p><strong>这个例子里我们在 .spec.template.metadata.annotations 中添加 version/config ，每次通过修改 version/config 来触发滚动更新</strong></p>

<p><strong>！！！ 更新 ConﬁgMap 后： </strong></p>

<p><strong>使用该 ConﬁgMap 挂载的 Env 不会同步更新 </strong></p>

<p><strong>使用该 ConﬁgMap 挂载的 Volume 中的数据需要一段时间（实测大概10秒）才能同步更新&nbsp;</strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）的Service Ingress详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/06/12285695.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 06 Feb 2020 14:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/06/12285695.html</guid><description><![CDATA[
                                            <p><strong>在 Kubernetes v1.0 版本， Service 是 “4层”（TCP/UDP over IP）概念。 在 Kubernetes v1.1 版本，新增了 Ingress API（beta 版），用来表示 “7层”（HTTP）服务&nbsp;</strong></p>

<p><strong><span style="color:#f33b45;">资料信息 【可实现7层代理】</span><br>
Ingress-Nginx github 地址：<a href="https://github.com/kubernetes/ingress-nginx">https://github.com/kubernetes/ingress-nginx</a></strong></p>

<p><strong>Ingress-Nginx 官方网站：<a href="https://github.com/kubernetes/ingress-nginx">https://kubernetes.github.io/ingress-nginx/</a></strong><br><img alt="" class="has" height="1200" src="https://img-blog.csdnimg.cn/20200206204556322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h1>部署 Ingress-Nginx&nbsp;</h1>

<p>下载Ingress-Nginx&nbsp;文件</p>

<pre class="has"><code class="language-bash">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.28.0/deploy/static/mandatory.yaml
</code></pre>

<p>运行配置文件</p>

<p><img alt="" class="has" height="337" src="https://img-blog.csdnimg.cn/20200206211027100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1166"></p>

<pre class="has"><code>​​​​chmod -R 777 /var/lib/docker
</code></pre>

<p>给docker权限，不然会出现问题。</p>

<p>我遇见这个问题，<a href="https://blog.csdn.net/ht1032279753/article/details/103867138">链接</a>，你们可以参考一下</p>

<pre class="has"><code>kubectl get pod -n ingress-nginx 
</code></pre>

<p><img alt="" class="has" height="126" src="https://img-blog.csdnimg.cn/20200206213254850.png" width="874"></p>

<p>下载ingress-nginx暴露端口配置文件</p>

<pre class="has"><code>wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.28.0/deploy/static/provider/baremetal/service-nodeport.yaml
</code></pre>

<pre class="has"><code> kubectl apply -f service-nodeport.yaml </code></pre>

<p><img alt="" class="has" height="339" src="https://img-blog.csdnimg.cn/2020020621350067.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="957"></p>

<h1>Ingress HTTP 代理访问&nbsp;</h1>

<p><strong>deployment、Service、Ingress Yaml 文件&nbsp;</strong></p>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-dm
spec:
  replicas: 2
  template:
    metadata:
      labels:
        name: nginx
    spec:
      containers:
        - name: nginx
          image: wangyanglinux/myapp:v1
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
spec:
  ports:
    - port: 80
      targetPort: 80
      protocol: TCP
  selector:
    name: nginx
</code></pre>

<p><img alt="" class="has" height="282" src="https://img-blog.csdnimg.cn/20200206215043893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="820"></p>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: nginx-test
spec:
  rules:
    - host: www.heian.com
      http:
        paths:
        - path: /
          backend:
            serviceName: nginx-svc
            servicePort: 80
</code></pre>

<p><img alt="" class="has" height="941" src="https://img-blog.csdnimg.cn/20200206215342957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h1>实验</h1>

<p><img alt="" class="has" height="441" src="https://img-blog.csdnimg.cn/20200206220038549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="937"></p>

<h3>deployment1.yaml&nbsp;</h3>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: deployment1
spec:
  replicas: 2
  template:
    metadata:
      labels:
        name: nginx
    spec:
      containers:
        - name: nginx
          image: wangyanglinux/myapp:v1
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: svc-1
spec:
  ports:
    - port: 80
      targetPort: 80
      protocol: TCP
  selector:
    name: nginx
</code></pre>

<h3>deployment2.yaml&nbsp;</h3>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: deployment2
spec:
  replicas: 2
  template:
    metadata:
      labels:
        name: nginx2
    spec:
      containers:
        - name: nginx2
          image: wangyanglinux/myapp:v1
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: svc-2
spec:
  ports:
    - port: 80
      targetPort: 80
      protocol: TCP
  selector:
    name: nginx2
</code></pre>

<h3>ingress-nginx</h3>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress1
spec:
  rules:
    - host: www.heian.com
      http:
        paths:
        - path: /
          backend:
            serviceName: svc-1
            servicePort: 80
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress2
spec:
  rules:
    - host: www2.heian.com
      http:
        paths:
        - path: /
          backend:
            serviceName: svc-2
            servicePort: 80</code></pre>

<h1>Ingress &nbsp;HTTPS 代理访问&nbsp;</h1>

<p>创建证书，以及 cert 存储方式&nbsp;</p>

<pre class="has"><code class="language-bash">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj 
"/CN=nginxsvc/O=nginxsvc"
kubectl create secret tls tls-secret --key tls.key --cert tls.crt
</code></pre>

<p>deployment、Service、Ingress Yaml 文件&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: nginx-test
spec:
  tls:
    - hosts:
      - foo.bar.com
      secretName: tls-secret
  rules:
    - host: foo.bar.com
      http:
        paths:
        - path: /
          backend:
            serviceName: nginx-svc
            servicePort: 80
</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>Nginx 进行 BasicAuth&nbsp;</p>

<pre class="has"><code class="language-bash">yum -y install httpd
htpasswd -c auth foo
kubectl create secret generic basic-auth --from-file=auth
</code></pre>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-with-auth
  annotations:
    nginx.ingress.kubernetes.io/auth-type: basic
    nginx.ingress.kubernetes.io/auth-secret: basic-auth
    nginx.ingress.kubernetes.io/auth-realm: 'Authentication Required - foo'
spec:
  rules:
  - host: foo2.bar.com
    http:
      paths:
      - path: /
        backend:
          serviceName: nginx-svc
          servicePort: 80
</code></pre>

<h3>Nginx 进行重写&nbsp;</h3>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>名称</td>
			<td>描述</td>
			<td>值</td>
		</tr><tr><td>nginx.ingress.kubernetes.io/rewritetarget</td>
			<td>必须重定向流量的目标URI&nbsp;</td>
			<td>串</td>
		</tr><tr><td>nginx.ingress.kubernetes.io/sslredirect<br>
			&nbsp;</td>
			<td>指示位置部分是否仅可访问SSL（当Ingress包含证书时 默认为True）<br>
			&nbsp;</td>
			<td>布尔</td>
		</tr><tr><td>nginx.ingress.kubernetes.io/forcessl-redirect</td>
			<td>即使Ingress未启用TLS，也强制重定向到HTTPS<br>
			&nbsp;</td>
			<td>布尔</td>
		</tr><tr><td>nginx.ingress.kubernetes.io/approot</td>
			<td>定义Controller必须重定向的应用程序根，如果它在'/'上 下文中<br>
			&nbsp;</td>
			<td>串</td>
		</tr><tr><td>nginx.ingress.kubernetes.io/useregex</td>
			<td>指示Ingress上定义的路径是否使用正则表达式<br>
			&nbsp;</td>
			<td>布尔</td>
		</tr></tbody></table><pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: nginx-test
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: http://foo.bar.com:31795/hostname.html
spec:
  rules:
  - host: foo10.bar.com
    http:
      paths:
      - path: /
        backend:
          serviceName: nginx-svc
          servicePort: 80
</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）的Service - 代理模式详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/06/12285696.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 06 Feb 2020 11:40:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/06/12285696.html</guid><description><![CDATA[
                                            <h1>VIP 和 Service 代理&nbsp;</h1>

<p><strong>在 Kubernetes 集群中，每个 Node 运行一个 &nbsp;kube-proxy 进程。 kube-proxy 负责为 &nbsp;Service 实现了一种 VIP（虚拟 IP）的形式，而不是 &nbsp;ExternalName 的形式。 在 Kubernetes v1.0 版本，代理完全在 userspace。在 Kubernetes v1.1 版本，新增了 iptables 代理，但并不是默认的运行模式。 从 Kubernetes v1.2 起，默认就是 iptables 代理。 在 Kubernetes v1.8.0-beta.0 中，添加了 ipvs 代理&nbsp;</strong></p>

<p><strong>在 Kubernetes 1.14 版本开始默认使用 ipvs 代理<br>
在 Kubernetes v1.0 版本， Service 是 “4层”（TCP/UDP over IP）概念。 在 Kubernetes v1.1 版本，新增了 Ingress API（beta 版），用来表示 “7层”（HTTP）服务&nbsp;</strong></p>

<p>！为何不使用 round-robin DNS？&nbsp;<br>
&nbsp;&nbsp;</p>

<h1>代理模式的分类&nbsp;</h1>

<h3>Ⅰ、userspace 代理模式&nbsp;</h3>

<p><img alt="" class="has" height="546" src="https://img-blog.csdnimg.cn/20200206170910197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="812"></p>

<h3>Ⅱ、iptables 代理模式&nbsp;</h3>

<p><img alt="" class="has" height="523" src="https://img-blog.csdnimg.cn/20200206170935582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="805"></p>

<p>Ⅲ、ipvs 代理模式&nbsp;</p>

<p>这种模式，kube-proxy 会监视 Kubernetes Service 对象和 Endpoints ，调用 netlink 接口以相应地创建 ipvs 规则并定期与 Kubernetes Service 对象和 Endpoints 对象同步 ipvs 规则，以确保 ipvs 状态与期望一 致。访问服务时，流量将被重定向到其中一个后端 Pod&nbsp;</p>

<p>与 iptables 类似，ipvs 于 netﬁlter 的 hook 功能，但使用哈希表作为底层数据结构并在内核空间中工作。这意 味着 ipvs 可以更快地重定向流量，并且在同步代理规则时具有更好的性能。此外，ipvs 为负载均衡算法提供了更 多选项，例如：</p>

<ul><li><strong>rr &nbsp;：轮询调度</strong></li>
	<li><strong>lc &nbsp;：最小连接数</strong></li>
	<li><strong>dh &nbsp;：目标哈希</strong></li>
	<li><strong>sh &nbsp;：源哈希</strong></li>
	<li><strong>sed &nbsp;：最短期望延迟</strong></li>
	<li><strong>nq ： 不排队调度</strong></li>
</ul><p><img alt="" class="has" height="628" src="https://img-blog.csdnimg.cn/20200206171033572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="966"></p>

<p><strong>创建 myapp-deploy.yaml 文件&nbsp;</strong></p>

<pre class="has"><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deploy
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
      release: stabel
  template:
    metadata:
      labels:
        app: myapp
        release: stabel
        env: test
    spec:
      containers:
      - name: myapp
        image: wangyanglinux/myapp:v2
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 80
</code></pre>

<p><img alt="" class="has" height="508" src="https://img-blog.csdnimg.cn/20200206180043590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="757"></p>

<p><strong>创建 Service 信息</strong><br>
&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: myapp
  namespace: default
spec:
  type: ClusterIP
  selector:
    app: myapp
    release: stabel
  ports:
  - name: http
    port: 80
    targetPort: 80
</code></pre>

<p><img alt="" class="has" height="420" src="https://img-blog.csdnimg.cn/20200206182838531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="868"></p>

<h1>Headless Service&nbsp;</h1>

<p>有时不需要或不想要负载均衡，以及单独的 Service IP 。遇到这种情况，可以通过指定 Cluster IP(spec.clusterIP) 的值为 “None” 来创建 Headless Service 。这类 Service 并不会分配 Cluster IP， kubeproxy 不会处理它们，而且平台也不会为它们进行负载均衡和路由</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: myapp-headless
  namespace: default
spec:
  selector:
    app: myapp
  clusterIP: "None"
  ports: 
  - port: 80
    targetPort: 80
</code></pre>

<p><img alt="" class="has" height="296" src="https://img-blog.csdnimg.cn/20200206183648232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="933"></p>

<h3>解析</h3>

<pre class="has"><code class="language-bash">dig -t A myapp-headless.default.svc.cluster.local. @10.244.1.2</code></pre>

<p><img alt="" class="has" height="659" src="https://img-blog.csdnimg.cn/20200206184236830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1010"></p>

<h1>NodePort&nbsp;</h1>

<p>nodePort 的原理在于在 node 上开了一个端口，将向该端口的流量导入到 kube-proxy，然后由 kube-proxy 进 一步到给对应的 pod<br>
&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  name: myapp
  namespace: default
spec:
  type: NodePort
  selector:
    app: myapp
    release: stabel
  ports:
  - name: http
    port: 80
    targetPort: 80
</code></pre>

<p><img alt="" class="has" height="567" src="https://img-blog.csdnimg.cn/20200206192449572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<h1>LoadBalancer&nbsp;</h1>

<p>loadBalancer 和 nodePort 其实是同一种方式。区别在于 loadBalancer 比 nodePort 多了一步，就是可以调用 cloud provider 去创建 LB 来向节点导流<br><img alt="" class="has" height="794" src="https://img-blog.csdnimg.cn/20200206193040949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1082"></p>

<h1>ExternalName&nbsp;</h1>

<p>这种类型的 Service 通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容( 例如： hub.atguigu.com )。ExternalName Service 是 Service 的特例，它没有 selector，也没有定义任何的端口和 Endpoint。相反的，对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式来提供服务</p>

<pre class="has"><code class="language-bash">kind: Service
apiVersion: v1
metadata:
  name: my-service-1
  namespace: default
spec:
  type: ExternalName
  externalName: hub.atguigu.com
</code></pre>

<p>&nbsp;</p>

<p>当查询主机 my-service.defalut.svc.cluster.local ( SVC_NAME.NAMESPACE.svc.cluster.local )时，集群的 DNS 服务将返回一个值 my.database.example.com 的 CNAME 记录。访问这个服务的工作方式和其他的相 同，唯一不同的是重定向发生在 DNS 层，而且不会进行代理或转发&nbsp;<br>
&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）的Service - 定义</title><link>http://www.cnblogs.com/heian99/archive/2020/02/06/12285697.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 06 Feb 2020 09:06:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/06/12285697.html</guid><description><![CDATA[
                                            <h1>Service 的概念&nbsp;</h1>

<p><strong>Kubernetes&nbsp;&nbsp;Service &nbsp;定义了这样一种抽象：一个&nbsp;&nbsp;Pod &nbsp;的逻辑分组，一种可以访问它们的策略 —— 通常称为微 服务。 这一组&nbsp;&nbsp;Pod &nbsp;能够被&nbsp;&nbsp;Service &nbsp;访问到，通常是通过&nbsp;&nbsp;Label Selector</strong><br><img alt="" class="has" height="453" src="https://img-blog.csdnimg.cn/20200206164845536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="853"></p>

<p><strong>Service能够提供负载均衡的能力，但是在使用上有以下限制：</strong></p>

<p>只提供 4 层负载均衡能力，而没有 7 层功能，但有时我们可能需要更多的匹配规则来转发请求，这点上 4 层 负载均衡是不支持的</p>

<h2><strong>Service 的类型&nbsp;</strong></h2>

<p><strong>Service 在 K8s 中有以下四种类型&nbsp;</strong></p>

<ul><li><strong>ClusterIp：默认类型，自动分配一个仅 Cluster 内部可以访问的虚拟 IP</strong></li>
</ul><p><img alt="" class="has" height="330" src="https://img-blog.csdnimg.cn/20200206170439502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="785"></p>

<ul><li><strong>NodePort：在 ClusterIP 基础上为 Service 在每台机器上绑定一个端口，这样就可以通过 : NodePort 来访问该服务</strong></li>
</ul><p><img alt="" class="has" height="709" src="https://img-blog.csdnimg.cn/20200206170453370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1180"></p>

<ul><li><strong>LoadBalancer：在 NodePort 的基础上，借助 cloud provider 创建一个外部负载均衡器，并将请求转发到: NodePort</strong></li>
</ul><p><img alt="" class="has" height="675" src="https://img-blog.csdnimg.cn/20200206170511278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1064"></p>

<ul><li><strong>ExternalName：把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理被创建，这只有 kubernetes 1.7 或更高版本的 kube-dns 才支持</strong></li>
</ul><p><img alt="" class="has" height="677" src="https://img-blog.csdnimg.cn/2020020617055647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="912"></p>

<p><img alt="" class="has" height="682" src="https://img-blog.csdnimg.cn/20200206165100169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="871"></p>
                                    ]]></description></item><item><title>Kubernetes（k8s）资源控制器Daemonset、Job、CronJob详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/05/12266817.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 05 Feb 2020 13:35:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/05/12266817.html</guid><description><![CDATA[
                                            <h1>什么是 DaemonSet&nbsp;</h1>

<p>DaemonSet 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一 个 Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod</p>

<p><strong>使用 DaemonSet 的一些典型用法：</strong></p>

<ul><li>运行集群存储 daemon，例如在每个 Node 上运行 glusterd 、 ceph</li>
	<li>在每个 Node 上运行日志收集 daemon，例如 fluentd 、 logstash</li>
	<li>在每个 Node 上运行监控 daemon，例如 Prometheus Node Exporter、 collectd 、Datadog 代理、 New Relic 代理，或 Ganglia gmond</li>
</ul><p>&nbsp;</p>

<pre class="has"><code class="language-bash">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: deamonset-example
  labels:
    app: daemonset
spec:
  selector:
    matchLabels:
      name: deamonset-example
  template:
    metadata:
      labels:
        name: deamonset-example
    spec:
      containers:
      - name: daemonset-example
        image: wangyanglinux/myapp:v1
</code></pre>

<p><img alt="" class="has" height="363" src="https://img-blog.csdnimg.cn/20200205205134703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1064"></p>

<p><img alt="" class="has" height="352" src="https://img-blog.csdnimg.cn/20200205205314918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="688"></p>

<h1>Job&nbsp;</h1>

<p><strong>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束&nbsp;</strong></p>

<p><strong>特殊说明&nbsp;</strong></p>

<ul><li>spec.template格式同Pod</li>
	<li>RestartPolicy仅支持Never或OnFailure</li>
	<li>单个Pod时，默认Pod成功运行后Job即结束</li>
	<li>.spec.completions 标志Job结束需要成功运行的Pod个数，默认为1</li>
	<li>.spec.parallelism 标志并行运行的Pod的个数，默认为1</li>
	<li>spec.activeDeadlineSeconds 标志失败Pod的重试大时间，超过这个时间不会继续重试<br>
	&nbsp;</li>
</ul><p><strong>Example</strong></p>

<pre class="has"><code class="language-bash">apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    metadata:
      name: pi
    spec:
      containers:
      - name: pi
        image: perl
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
</code></pre>

<p><img alt="" class="has" height="392" src="https://img-blog.csdnimg.cn/20200205210847466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="840"></p>

<p><img alt="" class="has" height="680" src="https://img-blog.csdnimg.cn/20200205211406490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1093"></p>

<h1>CronJob Spec&nbsp;</h1>

<ul><li>spec.template格式同Pod</li>
	<li>RestartPolicy仅支持Never或OnFailure</li>
	<li>单个Pod时，默认Pod成功运行后Job即结束</li>
	<li>.spec.completions 标志Job结束需要成功运行的Pod个数，默认为1 .</li>
	<li>spec.parallelism 标志并行运行的Pod的个数，默认为1</li>
	<li>spec.activeDeadlineSeconds 标志失败Pod的重试大时间，超过这个时间不会继续重试<br>
	&nbsp;</li>
</ul><h1>CronJob&nbsp;</h1>

<p><strong>Cron Job&nbsp;管理基于时间的&nbsp;Job，即：</strong></p>

<ul><li>在给定时间点只运行一次</li>
	<li>周期性地在给定时间点运行<br>
	&nbsp;</li>
</ul><p>使用条件：当前使用的 Kubernetes 集群，版本 &gt;= 1.8（对 CronJob）<br>
典型的用法如下所示：</p>

<ul><li>在给定的时间点调度 Job 运行</li>
	<li>创建周期性运行的 Job，例如：数据库备份、发送邮件<br>
	&nbsp;</li>
</ul><h1>CronJob Spec&nbsp;</h1>

<ul><li>.spec.schedule ：调度，必需字段，指定任务运行周期，格式同 Cron</li>
	<li>.spec.jobTemplate ：Job 模板，必需字段，指定需要运行的任务，格式同 Job</li>
	<li>.spec.startingDeadlineSeconds &nbsp;：启动 Job 的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的 Job 将被认为是失败的。如果没有指定，则没有期限</li>
	<li>.spec.concurrencyPolicy ：并发策略，该字段也是可选的。它指定了如何处理被 Cron Job 创建的 Job 的并发执行。只允许指定下面策略中的一种：</li>
</ul><ol><li>Allow （默认）：允许并发运行 Job</li>
	<li>Forbid &nbsp;：禁止并发运行，如果前一个还没有完成，则直接跳过下一个</li>
	<li>Replace ：取消当前正在运行的 Job，用一个新的来替换</li>
</ol><p>注意，当前策略只能应用于同一个 Cron Job 创建的 Job。如果存在多个 Cron Job，它们创建的 Job 之间总<br>
是允许并发运行。</p>

<ul><li>.spec.suspend &nbsp;：挂起，该字段也是可选的。如果设置为 &nbsp;true &nbsp; ，后续所有执行都会被挂起。它对已经开始执行的 Job 不起作用。默认值为 &nbsp;false &nbsp; 。</li>
	<li>.spec.successfulJobsHistoryLimit &nbsp;和 &nbsp;.spec.failedJobsHistoryLimit &nbsp; ：历史限制，是可选的字段。它们指定了可以保留多少完成和失败的 Job。默认情况下，它们分别设置为 &nbsp;3 &nbsp;和 &nbsp; 1 。设置限制的值为 &nbsp; 0 &nbsp;，相关类型的 Job 完成后将不会被保留。</li>
</ul><h3>Example</h3>

<pre class="has"><code class="language-bash">apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: "*/1 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            args:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure
</code></pre>

<h3>&nbsp;<img alt="" class="has" height="626" src="https://img-blog.csdnimg.cn/20200205212840212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="917"></h3>

<pre class="has"><code class="language-bash">$ kubectl get cronjob
NAME      SCHEDULE      SUSPEND   ACTIVE    LAST-SCHEDULE
hello     */1 * * * *   False     0         &lt;none&gt;
$ kubectl get jobs
NAME               DESIRED   SUCCESSFUL   AGE
hello-1202039034   1         1            49s
$ pods=$(kubectl get pods --selector=job-name=hello-1202039034 --output=jsonpath=
{.items..metadata.name})
$ kubectl logs $pods
Mon Aug 29 21:34:09 UTC 2016
Hello from the Kubernetes cluster
# 注意，删除 cronjob 的时候不会自动删除 job，这些 job 可以用 kubectl delete job 来删除
$ kubectl delete cronjob hello
cronjob "hello" deleted
</code></pre>

<p><strong>CrondJob 本身的一些限制&nbsp;<br>
创建 Job 操作应该是 幂等的</strong><br>
&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）资源控制器 RS、Deployment详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2020/02/05/12266818.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 05 Feb 2020 06:34:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/05/12266818.html</guid><description><![CDATA[
                                            <h1>RS 与 RC 与 Deployment 关联&nbsp;</h1>

<p><strong>RC （ReplicationController ）主要的作用就是用来确保容器应用的副本数始终保持在用户定义的副本数 。即如 果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收</strong>&nbsp;</p>

<p><strong>Kubernetes 官方建议使用 RS（ReplicaSet ） 替代 RC （ReplicationController ） 进行部署，RS 跟 RC 没有 本质的不同，只是名字不一样，并且 RS 支持集合式的 selector</strong></p>

<h2><strong>RS（ReplicaSet ）创建</strong></h2>

<pre class="has"><code class="language-bash">apiVersion: extensions/v1beta1
kind: ReplicaSet
metadata:
  name: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: myapp
        image: wangyanglinux/myapp:v1
        env:
        - name: GET_HOSTS_FROM
          value: dns
        ports:
        - containerPort: 80
</code></pre>

<p>rs这个创建pod有点慢</p>

<p><img alt="" class="has" height="218" src="https://img-blog.csdnimg.cn/20200205132538760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="630"></p>

<p><strong>查看pod的标签</strong></p>

<pre class="has"><code>kubectl get pod  --show-labels

</code></pre>

<p><img alt="" class="has" height="190" src="https://img-blog.csdnimg.cn/20200205132812439.png" width="719"></p>

<p><strong>修改pod的标签</strong></p>

<pre class="has"><code class="language-cpp"> kubectl label pod frontend-dtx7t tier=frontend1 --overwrite=True
</code></pre>

<p><img alt="" class="has" height="182" src="https://img-blog.csdnimg.cn/20200205133028146.png" width="952"></p>

<p><img alt="" class="has" height="458" src="https://img-blog.csdnimg.cn/20200205135628493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1042"></p>

<p><strong>删除rs</strong></p>

<pre class="has"><code class="language-bash">kubectl delete rs --all</code></pre>

<p><img alt="" class="has" height="344" src="https://img-blog.csdnimg.cn/20200205135750409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="958"></p>

<h1>RS 与 Deployment &nbsp;的关联&nbsp;</h1>

<p><img alt="" class="has" height="363" src="https://img-blog.csdnimg.cn/20200205135855835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="821"></p>

<p><strong>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义(declarative)方法，用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括：&nbsp;</strong></p>

<ul><li>定义Deployment来创建Pod和ReplicaSet</li>
	<li>滚动升级和回滚应用</li>
	<li>扩容和缩容</li>
	<li>暂停和继续Deployment<br>
	&nbsp;</li>
</ul><h3>Ⅰ、部署一个简单的 Nginx 应用</h3>

<pre class="has"><code class="language-bash">
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: wangyanglinux/myapp:v1
        ports:
        - containerPort: 80</code></pre>

<pre class="has"><code class="language-bash">kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record
## --record参数可以记录命令，我们可以很方便的查看每次 revision 的变化
</code></pre>

<p><strong>创建</strong></p>

<pre class="has"><code class="language-bash"> kubectl apply -f deploy.yaml --record</code></pre>

<p><img alt="" class="has" height="308" src="https://img-blog.csdnimg.cn/20200205140458169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="899"></p>

<p><strong>显示标签</strong></p>

<pre class="has"><code>kubectl get pod --show-labels
</code></pre>

<p><img alt="" class="has" height="124" src="https://img-blog.csdnimg.cn/20200205140605869.png" width="1084"></p>

<h3>Ⅱ、扩容</h3>

<pre class="has"><code class="language-bash">kubectl scale deployment nginx-deployment --replicas 10</code></pre>

<p><img alt="" class="has" height="426" src="https://img-blog.csdnimg.cn/2020020514123592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="725"></p>

<h3>Ⅲ、如果集群支持 horizontal pod autoscaling 的话，还可以为Deployment设置自动扩展<br>
&nbsp;</h3>

<pre class="has"><code class="language-bash">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</code></pre>

<h3>Ⅳ、更新镜像也比较简单</h3>

<pre class="has"><code class="language-bash">kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1</code></pre>

<p><img alt="" class="has" height="124" src="https://img-blog.csdnimg.cn/20200205141444517.png" width="967"></p>

<h3>Ⅴ、回滚</h3>

<pre class="has"><code>kubectl rollout undo deployment/nginx-deployment</code></pre>

<h3>更新 Deployment&nbsp;</h3>

<p>假如我们现在想要让 nginx pod 使用 nginx:1.9.1 的镜像来代替原来的 nginx:1.7.9 的镜像</p>

<pre class="has"><code class="language-bash">$ kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
deployment "nginx-deployment" image updated
</code></pre>

<h3>可以使用 edit 命令来编辑 Deployment</h3>

<pre class="has"><code class="language-bash">$ kubectl edit deployment/nginx-deployment
deployment "nginx-deployment" edited
</code></pre>

<h3>查看 rollout 的状态</h3>

<pre class="has"><code class="language-bash">$ kubectl rollout status deployment/nginx-deployment
Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
deployment "nginx-deployment" successfully rolled out
</code></pre>

<h3>查看历史 RS</h3>

<pre class="has"><code class="language-bash">$ kubectl get rs
NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         0       6s
nginx-deployment-2035384211   0         0         0       36s
</code></pre>

<h2>Deployment 更新策略&nbsp;</h2>

<p><strong>Deployment 可以保证在升级时只有一定数量的 Pod 是 down 的。默认的，它会确保至少有比期望的Pod数量少 一个是up状态（多一个不可用） </strong></p>

<p><strong>Deployment 同时也可以确保只创建出超过期望数量的一定数量的 Pod。默认的，它会确保多比期望的Pod数 量多一个的 Pod 是 up 的（多1个 surge ）</strong><br>
未来的 Kuberentes 版本中，将从1-1变成25%-25%</p>

<pre class="has"><code class="language-bash"> kubectl describe deployments</code></pre>

<h3>Rollover（多个rollout并行）&nbsp;</h3>

<p>假如您创建了一个有5个 niginx:1.7.9 &nbsp;replica的 Deployment，但是当还只有3个 nginx:1.7.9 的 replica 创建 出来的时候您就开始更新含有5个 nginx:1.9.1 &nbsp;replica 的 Deployment。在这种情况下，Deployment 会立即 杀掉已创建的3个 nginx:1.7.9 的 Pod，并开始创建 nginx:1.9.1 的 Pod。它不会等到所有的5个 nginx:1.7.9 的 Pod 都创建完成后才开始改变航道&nbsp;</p>

<h3>回退 Deployment&nbsp;</h3>

<pre class="has"><code class="language-bash">kubectl set image deployment/nginx-deployment nginx=nginx:1.91
kubectl rollout status deployments nginx-deployment
kubectl get pods
kubectl rollout history deployment/nginx-deployment
kubectl rollout undo deployment/nginx-deployment
kubectl rollout undo deployment/nginx-deployment --to-revision=2   ## 可以使用 --revision参数指定
某个历史版本
kubectl rollout pause deployment/nginx-deployment    ## 暂停 deployment 的更新
</code></pre>

<p>您可以用 kubectl rollout status 命令查看 Deployment 是否完成。如果 rollout 成功完成， kubectl rollout status 将返回一个0值的 Exit Code<br>
&nbsp;</p>

<pre class="has"><code class="language-bash">$ kubectl rollout status deploy/nginx
Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment "nginx" successfully rolled out
$ echo $?
0
</code></pre>

<h3>清理 Policy&nbsp;</h3>

<p>您可以通过设置 .spec.revisonHistoryLimit 项来指定 deployment 多保留多少 revision 历史记录。默认的会 保留所有的 revision；如果将该项设置为0，Deployment 就不允许回退了&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）资源控制器详细说明</title><link>http://www.cnblogs.com/heian99/archive/2020/02/04/12266819.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 04 Feb 2020 12:47:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/04/12266819.html</guid><description><![CDATA[
                                            <h3><strong>Pod的分类</strong></h3>

<ul><li>自助式Pod: pod退出了，此类型的pod不会被创建</li>
	<li>控制器管理的Pod：在控制器的生命周期里，始终要维持Pod的副本数</li>
</ul><h3><img alt="" class="has" height="505" src="https://img-blog.csdnimg.cn/20200204202952542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="702"></h3>

<h3><strong>什么是控制器&nbsp;</strong></h3>

<p>Kubernetes 中内建了很多 controller（控制器），这些相当于一个状态机，用来控制 Pod 的具体状态和行为&nbsp;</p>

<h3><strong>控制器类型&nbsp;</strong></h3>

<ul><li>ReplicationController 和 ReplicaSet</li>
	<li>Deployment</li>
	<li>DaemonSet</li>
	<li>StateFulSet J</li>
	<li>ob/CronJob</li>
	<li>Horizontal Pod Autoscaling&nbsp;</li>
</ul><h3><strong>ReplicationController 和 ReplicaSet&nbsp;</strong></h3>

<p>ReplicationController（RC）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退 出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收；<br>
在新版本的 Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationController 。ReplicaSet 跟 ReplicationController 没有本质的不同，只是名字不一样，并且 ReplicaSet 支持集合式的 selector；&nbsp;</p>

<h3><strong>Deployment&nbsp;</strong></h3>

<p>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义 (declarative) 方法，用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括；&nbsp;</p>

<ul><li>定义 Deployment 来创建 Pod 和 ReplicaSet</li>
	<li>滚动升级和回滚应用</li>
	<li>扩容和缩容</li>
	<li>暂停和继续 Deployment<br>
	&nbsp;</li>
</ul><h3>DaemonSet&nbsp;</h3>

<p>DaemonSet&nbsp;确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod<br><strong>使用 DaemonSet 的一些典型用法：&nbsp;</strong></p>

<ul><li>运行集群存储 daemon，例如在每个 Node 上运行 glusterd 、 ceph</li>
	<li>在每个 Node 上运行日志收集 daemon，例如 fluentd 、 logstash</li>
	<li>在每个 Node 上运行监控 daemon，例如 Prometheus Node Exporter、 collectd 、Datadog 代理、 New Relic 代理，或 Ganglia gmond</li>
</ul><h3>Job&nbsp;</h3>

<p>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束&nbsp;</p>

<h3>CronJob&nbsp;</h3>

<p>Cron Job&nbsp;管理基于时间的 Job，即：</p>

<ul><li>在给定时间点只运行一次</li>
	<li>周期性地在给定时间点运行</li>
</ul><p>使用前提条件：**当前使用的 Kubernetes 集群，版本 &gt;= 1.8（对 CronJob）。对于先前版本的集群，版本 &lt; 1.8，启动 API Server时，通过传递选项&nbsp;&nbsp;--runtime-config=batch/v2alpha1=true &nbsp;可以开启 batch/v2alpha1 API**<br>
典型的用法如下所示：</p>

<ul><li>在给定的时间点调度 Job 运行</li>
	<li>创建周期性运行的 Job，例如：数据库备份、发送邮件</li>
</ul><h3>StatefulSet&nbsp;</h3>

<p>StatefulSet 作为 Controller 为 Pod 提供唯一的标识。它可以保证部署和 scale 的顺序&nbsp;</p>

<p>StatefulSet是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用 场景包括：</p>

<ul><li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li>
	<li>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有 Cluster IP的Service）来实现</li>
	<li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到 N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实 现</li>
	<li>有序收缩，有序删除（即从N-1到0）<br>
	&nbsp;</li>
</ul><h3>Horizontal Pod Autoscaling&nbsp;</h3>

<p>应用的资源使用率通常都有高峰和低谷的时候，如何削峰填谷，提高集群的整体资源利用率，让service中的Pod 个数自动调整呢？这就有赖于Horizontal Pod Autoscaling了，顾名思义，使Pod水平自动缩放</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）pod的探针liveness、readiness详细教程</title><link>http://www.cnblogs.com/heian99/archive/2020/02/04/12266820.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 04 Feb 2020 05:09:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/04/12266820.html</guid><description><![CDATA[
                                            <h1>Kubernetes pod的探针</h1>

<p><strong>探针是由&nbsp;&nbsp;kubelet&nbsp;对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的&nbsp;&nbsp;Handler。有三种类型的处理程序：</strong></p>

<ul><li>Ø ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li>
	<li>Ø TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。</li>
	<li>Ø HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的<br>
	&nbsp;</li>
</ul><p><strong>每次探测都将获得以下三种结果之一：&nbsp;</strong></p>

<ul><li>&nbsp;成功：容器通过了诊断。</li>
	<li>失败：容器未通过诊断。</li>
	<li>未知：诊断失败，因此不会采取任何行动</li>
</ul><ol><li><strong>livenessProbe：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 重启策略 的影响。如果容器不提供存活探针，则默认状态为 Success</strong></li>
	<li><strong>readinessProbe：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 Failure。如果容器不提供就绪探针，则默认状态为 Success</strong><br>
	&nbsp;</li>
</ol><h2>检测探针 - 就绪检测&nbsp;</h2>

<p><strong>readinessProbe-httpget&nbsp;</strong></p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: readiness-httpget-pod
  namespace: default
spec:
  containers:
  - name: readiness-httpget-container
    image: wangyanglinux/myapp:v1
    imagePullPolicy: IfNotPresent
    readinessProbe:
      httpGet:
        port: 80
        path: /index1.html
      initialDelaySeconds: 1
      periodSeconds: 3
</code></pre>

<p><span style="color:#f33b45;"><strong>因为这nginx下的80那里，没有index1.html这个界面</strong></span></p>

<p><img alt="" class="has" height="403" src="https://img-blog.csdnimg.cn/20200204121952595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="883"></p>

<p><strong>查看Pod的详细描述</strong></p>

<pre class="has"><code> kubectl describe pod readiness-httpget-pod
</code></pre>

<p><img alt="" class="has" height="1088" src="https://img-blog.csdnimg.cn/20200204122317758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1184"></p>

<p><strong>查看Pod的日志【<span style="color:#f33b45;">一直不断的探测</span>】</strong></p>

<pre class="has"><code class="language-bash">kubectl log  readiness-httpget-pod
</code></pre>

<p><img alt="" class="has" height="201" src="https://img-blog.csdnimg.cn/20200204122442176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1045"></p>

<h1>解决办法</h1>

<p><strong>进入这个容器</strong></p>

<pre class="has"><code>kubectl exec  readiness-httpget-pod -it -- /bin/sh
</code></pre>

<pre class="has"><code class="language-bash">[root@master k8s]# kubectl exec  readiness-httpget-pod -it -- /bin/sh
/ # cd /usr/share/nginx/html/
/usr/share/nginx/html # ls
50x.html    index.html
/usr/share/nginx/html # echo "123" &gt;&gt; index1.html
/usr/share/nginx/html # exit
</code></pre>

<p><img alt="" class="has" height="369" src="https://img-blog.csdnimg.cn/20200204122935264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="872"></p>

<p>&nbsp;</p>

<h2>检测探针 - 存活检测&nbsp;</h2>

<p><strong>livenessProbe-exec&nbsp;</strong></p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: liveness-exec-pod
  namespace: default
spec:
  containers:
  - name: liveness-exec-container
    image: busybox
    imagePullPolicy: IfNotPresent
    command: ["/bin/sh","-c","touch /tmp/live ; sleep 60; rm -rf /tmp/live; sleep
3600"]
    livenessProbe:
      exec:
        command: ["test","-e","/tmp/live"]
      initialDelaySeconds: 1
      periodSeconds: 3
</code></pre>

<p><strong>检测/tmp/live，每隔60秒就会被删除，liveness检测，如果被删除，就会返回失败，重启pod。陷入无限循环</strong>。</p>

<p><img alt="" class="has" height="354" src="https://img-blog.csdnimg.cn/20200204124123664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="747"></p>

<p><strong>livenessProbe-httpget&nbsp;</strong></p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: liveness-httpget-pod
  namespace: default
spec:
  containers:
  - name: liveness-httpget-container
    image: wangyanglinux/myapp:v1
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
    livenessProbe:
      httpGet:
        port: http
        path: /index.html
      initialDelaySeconds: 1
      periodSeconds: 3
      timeoutSeconds: 10
</code></pre>

<p><img alt="" class="has" height="399" src="https://img-blog.csdnimg.cn/20200204125038560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1073"></p>

<p><strong>现在进入容器，删除index.html文件</strong></p>

<pre class="has"><code class="language-bash"> kubectl exec liveness-httpget-pod -it -- /bin/sh</code></pre>

<p><img alt="" class="has" height="406" src="https://img-blog.csdnimg.cn/20200204125449729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="795"></p>

<p><img alt="" class="has" height="203" src="https://img-blog.csdnimg.cn/20200204125620349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="955"></p>

<p><strong>livenessProbe-tcp&nbsp;</strong></p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: probe-tcp
spec:
  containers:
  - name: nginx
    image: wangyanglinux/myapp:v1
    livenessProbe:
      initialDelaySeconds: 5
      timeoutSeconds: 1
      tcpSocket:
        port: 8080
      periodSeconds: 3
</code></pre>

<p><strong>检测8080端口，但是那个端口没有，就会一直检测，重启。</strong></p>

<p><img alt="" class="has" height="394" src="https://img-blog.csdnimg.cn/20200204130208953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="759"></p>

<p><strong>启动、退出动作</strong>&nbsp;</p>

<pre class="has"><code>apiVersion: v1
kind: Pod
metadata:
  name: lifecycle-demo
spec:
  containers:
  - name: lifecycle-demo-container
    image: wangyanglinux/myapp:v1
    lifecycle:
      postStart:
        exec:
          command: ["/bin/sh", "-c", "echo Hello from the postStart handler &gt; 
/usr/share/message"]
      preStop:
        exec:
          command: ["/bin/sh", "-c", "echo Hello from the poststop handler &gt; 
/usr/share/message"]

</code></pre>

<p><img alt="" class="has" height="321" src="https://img-blog.csdnimg.cn/20200204132105564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="811"></p>
                                    ]]></description></item><item><title>Kubernetes（k8s）Pod的生命周期</title><link>http://www.cnblogs.com/heian99/archive/2020/02/03/12266821.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 03 Feb 2020 14:09:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/03/12266821.html</guid><description><![CDATA[
                                            <h1>Kubernetes pod 初始化</h1>

<p><img alt="" class="has" height="571" src="https://img-blog.csdnimg.cn/20200203210606608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1086">init C ：初始换容器</p>

<div>
<p style="margin-left:0cm;"><span style="color:#000000;">Pod </span><span style="color:#000000;">能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的</span><span style="color:#000000;">&nbsp; Init容器</span></p>
</div>

<p>Init 容器与普通的容器非常像，除了如下两点： &nbsp;</p>

<ul><li>Ø&nbsp;Init&nbsp;容器总是运行到成功完成为止 &nbsp;</li>
	<li>Ø&nbsp;每个&nbsp;Init&nbsp;容器都必须在下一个&nbsp;Init&nbsp;容器启动之前成功完成 &nbsp;</li>
</ul><p><strong><span style="color:#000000;">如果</span><span style="color:#000000;"> Pod </span><span style="color:#000000;">的</span><span style="color:#000000;"> Init </span><span style="color:#000000;">容器失败，</span><span style="color:#000000;">Kubernetes </span><span style="color:#000000;">会不断地重启该</span><span style="color:#000000;"> Pod</span><span style="color:#000000;">，直到</span><span style="color:#000000;">&nbsp; Init </span><span style="color:#000000;">容器成功为止。然而</span></strong></p>

<div><strong><span style="color:#000000;">如果</span><span style="color:#000000;"> Pod </span><span style="color:#000000;">对应的</span><span style="color:#000000;"> restartPolicy </span><span style="color:#000000;">为</span><span style="color:#000000;"> Never</span><span style="color:#000000;">，它不会重新启动</span></strong></div>

<div>&nbsp;</div>

<h3><strong><span style="color:#000000;">因为</span><span style="color:#000000;"> Init </span><span style="color:#000000;">容器具有与应用程序容器分离的单独镜像，所以它们的启动相关代码具有如下优势：</span></strong></h3>

<p><img alt="" class="has" height="516" src="https://img-blog.csdnimg.cn/20200203212713217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<div>
<h1>Init&nbsp;容器 &nbsp;</h1>

<p><strong>init&nbsp;模板&nbsp;</strong></p>
</div>

<div>
<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo The app is running! &amp;&amp; sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox
    command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; 
done;']
  - name: init-mydb
    image: busybox
    command: ['sh', '-c', 'until nslookup mydb; do echo waiting for mydb; sleep 2; done;']
</code></pre>

<p><img alt="" class="has" height="330" src="https://img-blog.csdnimg.cn/20200203215837563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="631"></p>

<p>等待init的初始化。</p>
</div>

<div>
<pre class="has"><code class="language-bash">kind: Service
apiVersion: v1
metadata:
  name: myservice
spec:
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
</code></pre>

<p><img alt="" class="has" height="302" src="https://img-blog.csdnimg.cn/20200203220232560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="620"></p>
</div>

<pre class="has"><code>kind: Service
apiVersion: v1
metadata:
  name: mydb
spec:
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9377</code></pre>

<p><img alt="" class="has" height="418" src="https://img-blog.csdnimg.cn/20200203220452435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="804"></p>

<p><strong>两个initC已经初始换完成</strong></p>

<p><img alt="" class="has" height="486" src="https://img-blog.csdnimg.cn/20200203220626352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1095"></p>

<p><img alt="" class="has" height="175" src="https://img-blog.csdnimg.cn/20200203220642103.png" width="1110"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Kubernetes（k8s）Pod的YAML基础编写</title><link>http://www.cnblogs.com/heian99/archive/2020/02/03/12257681.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 03 Feb 2020 13:03:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/03/12257681.html</guid><description><![CDATA[
                                            <p><strong>Kubernetes中的Pod一般都是采用yaml编写</strong></p>

<pre class="has"><code class="language-bash">apiVersion: group/apiversion  # 如果没有给定 group 名称，那么默认为 core，可以使用 kubectl api-versions # 获取当前 k8s 版本上所有的 apiVersion 版本信息( 每个版本可能不同 )
kind:       #资源类别
metadata：  #资源元数据
   name
   namespace
   lables
   annotations   # 主要目的是方便用户阅读查找
spec: # 期望的状态（disired state）
status：# 当前状态，本字段有 Kubernetes 自身维护，用户不能去定义
</code></pre>

<h2>资源清单的常用命令</h2>

<p>获取&nbsp;apiversion&nbsp;版本信息</p>

<pre class="has"><code class="language-bash">[root@k8s-master01 ~]# kubectl api-versions 
admissionregistration.k8s.io/v1beta1
apiextensions.k8s.io/v1beta1
apiregistration.k8s.io/v1
apiregistration.k8s.io/v1beta1
apps/v1
......(以下省略)
</code></pre>

<p>获取资源的&nbsp;apiVersion&nbsp;版本信息</p>

<pre class="has"><code>[root@k8s-master01 ~]# kubectl explain pod
KIND:     Pod
VERSION:  v1
.....(以下省略)
[root@k8s-master01 ~]# kubectl explain Ingress
KIND:     Ingress
VERSION:  extensions/v1beta1
</code></pre>

<p>获取字段设置帮助文档&nbsp;</p>

<pre class="has"><code>[root@k8s-master01 ~]# kubectl explain pod
KIND:     Pod
VERSION:  v1
DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.
FIELDS:
   apiVersion    &lt;string&gt;
     ........
     ........
</code></pre>

<p>字段配置格式</p>

<pre class="has"><code>apiVersion &lt;string&gt;          #表示字符串类型
metadata &lt;Object&gt;            #表示需要嵌套多层字段
labels &lt;map[string]string&gt;   #表示由k:v组成的映射
finalizers &lt;[]string&gt;        #表示字串列表
ownerReferences &lt;[]Object&gt;   #表示对象列表
hostPID &lt;boolean&gt;            #布尔类型
priority &lt;integer&gt;           #整型
name &lt;string&gt; -required-     #如果类型后面接 -required-，表示为必填字段
</code></pre>

<h2>通过定义清单文件创建&nbsp;Pod【myapp这个是nginx镜像】（这地方有个错误哦，下面讲）</h2>

<pre class="has"><code>apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
    version: v1
spec:
  containers:
  - name: app
    image: wangyanglinux/myapp:v1
  - name: test
    image: wangyanglinux/myapp:v1</code></pre>

<p><span style="color:#f33b45;">错误：因为这回事nginx容器，在同一Pod中，只用一个80端口可以，所以，一个会一直报错。看下面截图</span></p>

<p><span style="color:#f33b45;">【一个在运行，一个在一直报错重启。】</span></p>

<p>运行Pod.yaml文件</p>

<pre class="has"><code>kubectl apply -f pod.yaml 
</code></pre>

<p><strong><span style="color:#f33b45;">下面看详细步骤解析</span></strong></p>

<p><img alt="" class="has" height="212" src="https://img-blog.csdnimg.cn/2020020320455893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="780"></p>

<p><strong>查看Pod的详细信息</strong></p>

<pre class="has"><code class="language-bash">kubectl describe pod myapp-pod
</code></pre>

<p><img alt="" class="has" height="1200" src="https://img-blog.csdnimg.cn/20200203205310698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1099"></p>

<p><strong>查看Pod的日志</strong></p>

<pre class="has"><code>kubectl log myapp-pod -c test
</code></pre>

<p><img alt="" class="has" height="355" src="https://img-blog.csdnimg.cn/2020020320554467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="916"></p>

<p><strong>删除Pod</strong></p>

<pre class="has"><code class="language-bash">kubectl delete pod myapp-pod</code></pre>

<p><img alt="" class="has" height="343" src="https://img-blog.csdnimg.cn/20200203205912850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="766"></p>

<p><strong>重新编写yaml文件</strong></p>

<pre class="has"><code class="language-bash">apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
    version: v1
spec:
  containers:
  - name: app
    image: wangyanglinux/myapp:v1
</code></pre>

<p><img alt="" class="has" height="300" src="https://img-blog.csdnimg.cn/20200203210019600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="754"></p>

<p><strong>测速访问</strong></p>

<p><img alt="" class="has" height="355" src="https://img-blog.csdnimg.cn/20200203210211351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1018"></p>
                                    ]]></description></item><item><title>Kubernetes（k8s）集群功能演示</title><link>http://www.cnblogs.com/heian99/archive/2020/02/03/12257682.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 03 Feb 2020 07:57:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/03/12257682.html</guid><description><![CDATA[
                                            <p>通过一段学习，我们的Kubernetes已经部署起来，现在就开始功能的演示。</p>

<p>如果又不会部署的小伙伴，可以看我以前的博客，都有详细的教程。</p>

<p id="main-toc"><strong>目录</strong></p>

<p id="%E6%9F%A5%E7%9C%8Bnode%E7%9A%84%E8%8A%82%E7%82%B9%E6%83%85%E5%86%B5-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E7%9C%8Bnode%E7%9A%84%E8%8A%82%E7%82%B9%E6%83%85%E5%86%B5" rel="nofollow">查看node的节点情况</a></p>

<p id="%E6%9F%A5%E7%9C%8Bpod%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E7%9C%8Bpod%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5" rel="nofollow">查看pod的运行情况</a></p>

<p id="%E6%9F%A5%E7%9C%8Bdeployment%E6%83%85%E5%86%B5-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E7%9C%8Bdeployment%E6%83%85%E5%86%B5" rel="nofollow">查看deployment情况</a></p>

<p id="%E6%9F%A5%E7%9C%8Bpod%E7%9A%84%E8%BF%90%E8%A1%8C%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E7%9C%8Bpod%E7%9A%84%E8%BF%90%E8%A1%8C%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF" rel="nofollow">查看pod的运行详细信息</a></p>

<p id="%E5%88%A0%E9%99%A4deployment-toc" style="margin-left:0px;"><a href="#%E5%88%A0%E9%99%A4deployment" rel="nofollow">删除deployment</a></p>

<p id="%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AApod%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AApod%E5%BA%94%E7%94%A8" rel="nofollow">删除一个pod应用</a></p>

<p id="%E6%9F%A5%E7%9C%8Bkubectl%E5%88%9B%E5%BB%BA%E6%8F%90%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E7%9C%8Bkubectl%E5%88%9B%E5%BB%BA%E6%8F%90%E7%A4%BA" rel="nofollow">查看kubectl创建提示</a></p>

<p id="kubectl%E5%88%9B%E5%BB%BAnginx%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#kubectl%E5%88%9B%E5%BB%BAnginx%E5%BA%94%E7%94%A8" rel="nofollow">kubectl创建nginx应用</a></p>

<p id="%E5%89%AF%E6%9C%AC%E9%9B%86%E6%89%A9%E5%AE%B9-toc" style="margin-left:0px;"><a href="#%E5%89%AF%E6%9C%AC%E9%9B%86%E6%89%A9%E5%AE%B9" rel="nofollow">副本集扩容</a></p>

<p id="%E5%BA%94%E7%94%A8pod%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%BF%AE%E6%94%B9%E3%80%90%E6%8A%8A80%E7%AB%AF%E5%8F%A3%E6%94%B9%E6%88%90%E4%BA%86%2030003%E3%80%91-toc" style="margin-left:0px;"><a href="#%E5%BA%94%E7%94%A8pod%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%BF%AE%E6%94%B9%E3%80%90%E6%8A%8A80%E7%AB%AF%E5%8F%A3%E6%94%B9%E6%88%90%E4%BA%86%2030003%E3%80%91" rel="nofollow">应用pod的端口修改【把80端口改成了 30003】</a></p>

<p id="%E4%BF%AE%E6%94%B9nginx-deployment%E7%9A%84ip%E7%B1%BB%E5%9E%8B%E3%80%90%E5%8F%AF%E4%BB%A5%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E7%BD%91%E8%AE%BF%E9%97%AE%E3%80%91-toc" style="margin-left:0px;"><a href="#%E4%BF%AE%E6%94%B9nginx-deployment%E7%9A%84ip%E7%B1%BB%E5%9E%8B%E3%80%90%E5%8F%AF%E4%BB%A5%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E7%BD%91%E8%AE%BF%E9%97%AE%E3%80%91" rel="nofollow">修改nginx-deployment的ip类型【可以暴露端口，实现内部网访问】</a></p>

<p id="%E6%B5%8B%E9%80%9F%E8%AE%BF%E9%97%AE-toc" style="margin-left:0px;"><a href="#%E6%B5%8B%E9%80%9F%E8%AE%BF%E9%97%AE" rel="nofollow">测速访问</a></p>

<hr id="hr-toc"><h1 id="%E6%9F%A5%E7%9C%8Bnode%E7%9A%84%E8%8A%82%E7%82%B9%E6%83%85%E5%86%B5"><strong>查看node的节点情况</strong></h1>

<pre class="has"><code> kubectl get node
</code></pre>

<p><img alt="" class="has" height="146" src="https://img-blog.csdnimg.cn/20200203121135494.png" width="434"></p>

<h1 id="%E6%9F%A5%E7%9C%8Bpod%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><strong>查看pod的运行情况</strong></h1>

<pre class="has"><code>kubectl get pod
</code></pre>

<p><img alt="" class="has" height="99" src="https://img-blog.csdnimg.cn/20200203121221880.png" width="589"></p>

<h1 id="%E6%9F%A5%E7%9C%8Bdeployment%E6%83%85%E5%86%B5"><strong>查看deployment情况</strong></h1>

<pre class="has"><code> kubectl get deployment</code></pre>

<p><img alt="" class="has" height="75" src="https://img-blog.csdnimg.cn/20200203121410426.png" width="492"></p>

<h1 id="%E6%9F%A5%E7%9C%8Bpod%E7%9A%84%E8%BF%90%E8%A1%8C%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><strong>查看pod的运行详细信息</strong></h1>

<pre class="has"><code> kubectl get pod -o wide</code></pre>

<p><img alt="" class="has" height="93" src="https://img-blog.csdnimg.cn/20200203121513658.png" width="1031"></p>

<h1 id="%E5%88%A0%E9%99%A4deployment"><strong>删除deployment</strong></h1>

<pre class="has"><code>kubectl delete deployment nginx
</code></pre>

<p><img alt="" class="has" height="45" src="https://img-blog.csdnimg.cn/20200203152245740.png" width="598"></p>

<h1 id="%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AApod%E5%BA%94%E7%94%A8"><strong>删除一个pod应用</strong></h1>

<pre class="has"><code> kubectl delete pod nginx-deployment-5d9dfb999c-t6xdq
</code></pre>

<p><img alt="" class="has" height="129" src="https://img-blog.csdnimg.cn/20200203152732631.png" width="738"></p>

<h1 id="%E6%9F%A5%E7%9C%8Bkubectl%E5%88%9B%E5%BB%BA%E6%8F%90%E7%A4%BA"><strong>查看kubectl创建提示</strong></h1>

<pre class="has"><code>kubectl run --help
</code></pre>

<p><img alt="" class="has" height="533" src="https://img-blog.csdnimg.cn/20200203150826533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="991"></p>

<h1 id="kubectl%E5%88%9B%E5%BB%BAnginx%E5%BA%94%E7%94%A8"><strong>kubectl创建nginx应用</strong></h1>

<pre class="has"><code>kubectl run nginx-deployment --image=wangyanglinux/myapp:v1  --port=80 --replicas=1
</code></pre>

<p><img alt="" class="has" height="200" src="https://img-blog.csdnimg.cn/20200203151900438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1057"></p>

<p><img alt="" class="has" height="283" src="https://img-blog.csdnimg.cn/20200203152405396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="705"></p>

<p><img alt="" class="has" height="247" src="https://img-blog.csdnimg.cn/20200203152537550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1046"></p>

<pre class="has"><code class="language-bash">[root@master ~]# kubectl get pod
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-5d9dfb999c-t6xdq   1/1     Running   0          5m43s
[root@master ~]# kubectl get pod -o wide
NAME                                READY   STATUS    RESTARTS   AGE     IP           NODE    NOMINATED NODE   READINESS GATES
nginx-deployment-5d9dfb999c-t6xdq   1/1     Running   0          5m51s   10.244.2.7   node1   &lt;none&gt;           &lt;none&gt;
[root@master ~]# curl 10.244.2.7
Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;
[root@master ~]# curl 10.244.2.7/hostname.html
nginx-deployment-5d9dfb999c-t6xdq
</code></pre>

<h1 id="%E5%89%AF%E6%9C%AC%E9%9B%86%E6%89%A9%E5%AE%B9"><strong>副本集扩容</strong></h1>

<pre class="has"><code>kubectl scale --replicas=3 deployment/nginx-deployment</code></pre>

<p><img alt="" class="has" height="246" src="https://img-blog.csdnimg.cn/2020020315301424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="826"></p>

<p><img alt="" class="has" height="406" src="https://img-blog.csdnimg.cn/20200203153117393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1055"></p>

<h1 id="%E5%BA%94%E7%94%A8pod%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%BF%AE%E6%94%B9%E3%80%90%E6%8A%8A80%E7%AB%AF%E5%8F%A3%E6%94%B9%E6%88%90%E4%BA%86%2030003%E3%80%91"><strong>应用pod的端口修改【把80端口改成了 30003】</strong></h1>

<pre class="has"><code>kubectl expose deployment nginx-deployment --port=30003 --target-port=80</code></pre>

<p><img alt="" class="has" height="400" src="https://img-blog.csdnimg.cn/20200203154031868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="955"></p>

<h1 id="%E4%BF%AE%E6%94%B9nginx-deployment%E7%9A%84ip%E7%B1%BB%E5%9E%8B%E3%80%90%E5%8F%AF%E4%BB%A5%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E7%BD%91%E8%AE%BF%E9%97%AE%E3%80%91"><strong>修改nginx-deployment的ip类型【可以暴露端口，实现内部网访问】</strong></h1>

<pre class="has"><code> kubectl edit svc nginx-deployment
</code></pre>

<p><img alt="" class="has" height="612" src="https://img-blog.csdnimg.cn/20200203155219994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="706"></p>

<p><img alt="" class="has" height="180" src="https://img-blog.csdnimg.cn/20200203155328240.png" width="847"></p>

<h1 id="%E6%B5%8B%E9%80%9F%E8%AE%BF%E9%97%AE">测速访问</h1>

<p><img alt="" class="has" height="199" src="https://img-blog.csdnimg.cn/2020020315535649.png" width="776"></p>

<p><img alt="" class="has" height="184" src="https://img-blog.csdnimg.cn/20200203155406976.png" width="878"></p>
                                    ]]></description></item><item><title>Harbor - 企业级 Docker 私有仓库</title><link>http://www.cnblogs.com/heian99/archive/2020/02/03/12257683.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 03 Feb 2020 04:05:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/02/03/12257683.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85%E5%BA%95%E5%B1%82%E9%9C%80%E6%B1%82-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85%E5%BA%95%E5%B1%82%E9%9C%80%E6%B1%82" rel="nofollow">一、安装底层需求</a></p>

<p id="%E4%BA%8C%E3%80%81Harbor%20%E5%AE%89%E8%A3%85%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Harbor%20%E5%AE%89%E8%A3%85%EF%BC%9A" rel="nofollow">二、Harbor 安装：</a></p>

<p id="1%E3%80%81%E4%B8%8B%E8%BD%BDHarbor-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%B8%8B%E8%BD%BDHarbor" rel="nofollow">1、下载Harbor</a></p>

<p id="2%E3%80%81%E8%A7%A3%E5%8E%8B-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%A7%A3%E5%8E%8B" rel="nofollow">2、解压</a></p>

<p id="3%E3%80%81%E9%85%8D%E7%BD%AE%20harbor.cf-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E9%85%8D%E7%BD%AE%20harbor.cf" rel="nofollow">3、配置 harbor.cf</a></p>

<p id="4%E3%80%81%E5%88%9B%E5%BB%BA%20https%20%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%20%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%C2%A0-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%88%9B%E5%BB%BA%20https%20%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%20%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%C2%A0" rel="nofollow">4、创建 https 证书以及配置相关目录权限 证书以及配置相关目录权限&nbsp;</a></p>

<p id="5%E3%80%81%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85" rel="nofollow">5、运行脚本进行安装</a></p>

<p id="6%E3%80%81%E8%AE%BF%E9%97%AE%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E8%AE%BF%E9%97%AE%E6%B5%8B%E8%AF%95" rel="nofollow">6、访问测试</a></p>

<p id="7%E3%80%81%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%C2%A0-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%C2%A0" rel="nofollow">7、上传镜像进行上传测试&nbsp;</a></p>

<p id="8%E3%80%81%E5%85%B6%E5%AE%83%20%C2%A0Docker%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E5%85%B6%E5%AE%83%20%C2%A0Docker%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%B5%8B%E8%AF%95" rel="nofollow">8、其它 &nbsp;Docker 客户端下载测试</a></p>

<p id="%E4%B8%89%E3%80%81Harbor%20%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Harbor%20%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E" rel="nofollow">三、Harbor 原理说明</a></p>

<p id="1%E3%80%81%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90%E4%BB%8B%E7%BB%8D%C2%A0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90%E4%BB%8B%E7%BB%8D%C2%A0" rel="nofollow">1、软件资源介绍&nbsp;</a></p>

<p id="2%E3%80%81Harbor%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#2%E3%80%81Harbor%E7%89%B9%E6%80%A7" rel="nofollow">2、Harbor特性</a></p>

<p id="3%E3%80%81Harbor%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%20%C2%A0-toc" style="margin-left:40px;"><a href="#3%E3%80%81Harbor%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%20%C2%A0" rel="nofollow">3、Harbor认证过程 &nbsp;</a></p>

<hr id="hr-toc"><h1 id="%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85%E5%BA%95%E5%B1%82%E9%9C%80%E6%B1%82">一、安装底层需求</h1>

<ul><li>Python应该是 应该是2.7或更高版本 或更高版本</li>
	<li>Docker引擎应为 引擎应为1.10或更高版本 或更高版本</li>
	<li>Docker Compose需要为 需要为1.6.0或更高版本</li>
</ul><pre class="has"><code>docker-compose： ：curl -L https://github.com/docker/compose/releases/download/1.9.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose  </code></pre>

<h1 id="%E4%BA%8C%E3%80%81Harbor%20%E5%AE%89%E8%A3%85%EF%BC%9A">二、Harbor 安装：</h1>

<p>安装：Harbor 官方地址： 官方地址：https://github.com/vmware/harbor/releases&nbsp;</p>

<p><img alt="" class="has" height="752" src="https://img-blog.csdnimg.cn/20200203113439172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="1%E3%80%81%E4%B8%8B%E8%BD%BDHarbor">1、下载Harbor</h2>

<pre class="has"><code>wget https://github.com/vmware/harbor/releases/download/v1.2.0/harbor-offline-installer-v1.2.0.tgz</code></pre>

<h2 id="2%E3%80%81%E8%A7%A3%E5%8E%8B">2、解压</h2>

<pre class="has"><code>tar xvf harbor-offline-installer-v1.2.0.tgz</code></pre>

<h2 id="3%E3%80%81%E9%85%8D%E7%BD%AE%20harbor.cf">3、配置 <strong>harbor.cf</strong></h2>

<p><strong><span style="color:#003884;">a</span></strong><span style="color:#003884;">、必选参数</span></p>

<ul><li><strong><span style="color:#528cd8;">hostname</span></strong><span style="color:#528cd8;">：目标的主机名或者完全限定域名</span></li>
	<li><strong><span style="color:#528cd8;">ui_url_protocol</span></strong><span style="color:#528cd8;">：</span><strong><span style="color:#528cd8;">http</span></strong><span style="color:#528cd8;">或</span><strong><span style="color:#528cd8;">https</span></strong><span style="color:#528cd8;">。</span><span style="color:#528cd8;">默认为</span>&nbsp; <strong><span style="color:#528cd8;">http</span></strong></li>
	<li><strong><span style="color:#528cd8;">db_password</span></strong><span style="color:#528cd8;">：用于</span> <strong><span style="color:#528cd8;">db_auth</span></strong><span style="color:#528cd8;">的</span><strong><span style="color:#528cd8;">MySQL</span></strong><span style="color:#528cd8;">数据库的根密码。更改此密码进行任何生产用途</span></li>
	<li>&nbsp;</li>
	<li style="margin-left:0cm;"><strong><span style="color:#528cd8;">max_job_workers</span></strong><span style="color:#528cd8;">：（默认值为</span>&nbsp; <strong><span style="color:#528cd8;">3</span></strong><span style="color:#528cd8;">）作业服务中的复制工作人员的最大数量。对于每个映像复制作业，</span><span style="color:#528cd8;">&nbsp;工作人员将存储库的所有标签同步到远程目标。增加此数字允许系统中更多的并发复制作业。但是，由于每个工</span><span style="color:#528cd8;">作人员都会消耗一定数量的网络</span>&nbsp;&nbsp;&nbsp; <strong><span style="color:#528cd8;">/ CPU / IO</span></strong><span style="color:#528cd8;">资源，请根据主机的硬件资源，仔细选择该属性的值</span></li>
	<li style="margin-left:0cm;"><strong><span style="color:#528cd8;">customize_crt</span></strong><span style="color:#528cd8;">：（</span> <strong><span style="color:#528cd8;">on</span></strong><span style="color:#528cd8;">或</span><strong><span style="color:#528cd8;">off</span></strong><span style="color:#528cd8;">。</span><span style="color:#528cd8;">默认为</span> <strong><span style="color:#528cd8;">on</span></strong><span style="color:#528cd8;">）当此属性打开时，</span>&nbsp;&nbsp; <strong><span style="color:#528cd8;">prepare</span></strong><span style="color:#528cd8;">脚本将为注册表的令牌的生成</span>&nbsp;&nbsp;&nbsp; <strong><span style="color:#528cd8;">/</span></strong><span style="color:#528cd8;">验证创</span><span style="color:#528cd8;">建私钥和根证书</span></li>
	<li style="margin-left:0cm;"><strong><span style="color:#528cd8;">ssl_cert</span></strong><span style="color:#528cd8;">：</span><strong><span style="color:#528cd8;">SSL</span></strong><span style="color:#528cd8;">证书的路径，仅当协议设置为</span>&nbsp;&nbsp;&nbsp; <strong><span style="color:#528cd8;">https</span></strong><span style="color:#528cd8;">时才应用</span></li>
	<li style="margin-left:0cm;"><span style="color:#3399ea;">ssl_cert_key： ：SSL密钥的路径，仅当协议设置为 密钥的路径，仅当协议设置为https时才应用&nbsp;</span></li>
	<li style="margin-left:0cm;"><span style="color:#3399ea;">secretkey_path：用于在复制策略中加密或解密远程注册表的密码的密钥路径</span>&nbsp;</li>
</ul><h2 id="4%E3%80%81%E5%88%9B%E5%BB%BA%20https%20%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%20%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%C2%A0" style="margin-left:0cm;">4、创建 https 证书以及配置相关目录权限 证书以及配置相关目录权限&nbsp;</h2>

<pre class="has"><code class="language-bash">openssl genrsa -des3 -out server.key 2048
openssl req -new -key server.key -out server.csr
cp server.key server.key.org
openssl rsa -in server.key.org -out server.key
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
mkdir  /data/cert
chmod -R 777 /data/cert
</code></pre>

<h2 id="5%E3%80%81%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85" style="margin-left:0cm;">5、运行脚本进行安装</h2>

<pre class="has"><code class="language-bash">./install.sh</code></pre>

<h2 id="6%E3%80%81%E8%AE%BF%E9%97%AE%E6%B5%8B%E8%AF%95" style="margin-left:0cm;">6、访问测试</h2>

<p style="margin-left:0cm;">访问测试 https://reg.yourdomain.com 的管理员门户（将 的管理员门户（将reg.yourdomain.com更改为您的主机名 更改为您的主机名harbor.cfg）。请注意，默 ）。请注意，默认管理员用户名 认管理员用户名/密码为 密码为admin / Harbor12345</p>

<div><img alt="" class="has" height="643" src="https://img-blog.csdnimg.cn/20200203115113205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></div>

<h2 id="7%E3%80%81%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%C2%A0">7、上传镜像进行上传测试&nbsp;</h2>

<div>
<pre class="has"><code class="language-bash">a、指定镜像仓库地址
vim /etc/docker/daemon.json
{
 "insecure-registries": ["serverip"]
}
</code></pre>

<pre class="has"><code class="language-bash">b、下载测试镜像
docker  pull  hello-world
</code></pre>

<pre class="has"><code class="language-bash">c、给镜像重新打标签
docker tag hello-world    serverip/hello-world:latest
</code></pre>

<pre class="has"><code class="language-bash">d、登录进行上传
docker login serverip
</code></pre>

<h2 id="8%E3%80%81%E5%85%B6%E5%AE%83%20%C2%A0Docker%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%B5%8B%E8%AF%95"><strong>8</strong>、其它 <strong>&nbsp;Docker </strong>客户端下载测试</h2>
</div>

<div>
<pre class="has"><code class="language-bash">a、指定镜像仓库地址
vim /etc/docker/daemon.json
{
 "insecure-registries": ["serverip"]
}
</code></pre>

<pre class="has"><code class="language-bash">b、下载测试镜像
docker pull  serverip/hello-world:latest
</code></pre>

<h1 id="%E4%B8%89%E3%80%81Harbor%20%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E">三、Harbor 原理说明</h1>

<h2 id="1%E3%80%81%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90%E4%BB%8B%E7%BB%8D%C2%A0">1、软件资源介绍&nbsp;</h2>

<p style="margin-left:0cm;"><strong><span style="color:#000000;">Harbor</span></strong><span style="color:#000000;">是</span><strong><span style="color:#000000;">VMware</span></strong><span style="color:#000000;">公司开源的企业级</span>&nbsp;&nbsp; <strong><span style="color:#000000;">DockerRegistry</span></strong><span style="color:#000000;">项目，项目地址为</span>&nbsp; <strong><span style="color:#000000;">https://github.com/vmware/harbor</span></strong><span style="color:#000000;">。其目</span></p>

<p style="margin-left:0cm;"><span style="color:#000000;">标是帮助用户迅速搭建一个企业级的</span>&nbsp;&nbsp;&nbsp;&nbsp; <strong><span style="color:#000000;">Dockerregistry</span></strong><span style="color:#000000;">服务。它以</span>&nbsp; <strong><span style="color:#000000;">Docker</span></strong><span style="color:#000000;">公司开源的</span> <strong><span style="color:#000000;">registry</span></strong><span style="color:#000000;">为基础，提供了管理</span>&nbsp;&nbsp; <strong><span style="color:#000000;">UI</span></strong><span style="color:#000000;">，</span></p>

<p style="margin-left:0cm;"><span style="color:#000000;">基于角色的访问控制</span>&nbsp;&nbsp; <strong><span style="color:#000000;">(Role Based Access Control)</span></strong><span style="color:#000000;">，</span><strong><span style="color:#000000;">AD/LDAP</span></strong><span style="color:#000000;">集成、以及审计日志</span>&nbsp;&nbsp; <strong><span style="color:#000000;">(Auditlogging) </span></strong><span style="color:#000000;">等企业用户需求的功</span></p>

<p style="margin-left:0cm;"><span style="color:#000000;">能，同时还原生支持中文。</span>&nbsp;&nbsp;&nbsp; <strong><span style="color:#000000;">Harbor</span></strong><span style="color:#000000;">的每个组件都是以</span>&nbsp; <strong><span style="color:#000000;">Docker</span></strong><span style="color:#000000;">容器的形式构建的，使用</span>&nbsp;&nbsp;&nbsp; <strong><span style="color:#000000;">Docker Compose</span></strong><span style="color:#000000;">来对它进行部</span></p>

<p style="margin-left:0cm;"><span style="color:#000000;">署。用于部署</span>&nbsp; <strong><span style="color:#000000;">Harbor</span></strong><span style="color:#000000;">的</span><strong><span style="color:#000000;">Docker Compose</span></strong><span style="color:#000000;">模板位于</span>&nbsp; <strong><span style="color:#000000;">&nbsp;/Deployer/docker-compose.yml</span></strong><span style="color:#000000;">，由</span> <strong><span style="color:#000000;">5</span></strong><span style="color:#000000;">个容器组成，这几个容器通过</span></p>

<p style="margin-left:0cm;"><strong><span style="color:#000000;">Docker link</span></strong><span style="color:#000000;">的形式连接在一起，在容器之间通过容器名字互相访问。对终端用户而言，只需要暴露</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span style="color:#000000;">&nbsp;proxy </span></strong><span style="color:#000000;">（</span> <span style="color:#000000;">即</span></p>

<p style="margin-left:0cm;"><strong><span style="color:#000000;">Nginx</span></strong><span style="color:#000000;">）的服务端口</span></p>

<ul><li>Proxy：由Nginx&nbsp;服务器构成的反向代理。 &nbsp;</li>
	<li>Registry：由Docker官方的开源&nbsp;registry&nbsp;镜像构成的容器实例。 &nbsp;</li>
	<li>UI：即架构中的&nbsp;core&nbsp;services，&nbsp;构成此容器的代码是&nbsp;Harbor项目的主体。 &nbsp;</li>
	<li>MySQL：由官方&nbsp;MySQL镜像构成的数据库容器。 &nbsp;</li>
	<li>Log：运行着&nbsp;rsyslogd的容器，通过&nbsp;log-driver的形式收集其他容器的日志</li>
</ul><h2 id="2%E3%80%81Harbor%E7%89%B9%E6%80%A7">2、Harbor特性</h2>

<ul><li>a、基于角色控制：用户和仓库都是基于项目进行组织的， 而用户基于项目可以拥有不同的权限 &nbsp;</li>
	<li>b、基于镜像的复制策略：镜像可以在多个Harbor实例之间进行复制 &nbsp;</li>
	<li>c、支持LDAP：Harbor的用户授权可以使用已经存在LDAP用户 &nbsp;</li>
	<li>d、镜像删除&nbsp;&amp;垃圾回收：Image可以被删除并且回收Image占用的空间，绝大部分的用户操作API，&nbsp;方便 &nbsp;用户对系统进行扩展</li>
	<li>e、用户UI：用户可以轻松的浏览、搜索镜像仓库以及对项目进行管理 &nbsp;</li>
	<li>f、轻松的部署功能：Harbor提供了online、offline安装，除此之外还提供了virtualappliance安装 &nbsp;</li>
	<li>g、Harbor和&nbsp;dockerregistry&nbsp;关系：Harbor实质上是对&nbsp;dockerregistry&nbsp;做了封装，扩展了自己的业务模块</li>
</ul><h2 id="3%E3%80%81Harbor%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%20%C2%A0">3、Harbor认证过程 &nbsp;</h2>

<ul><li>a、dockerdaemon从dockerregistry拉取镜像。 &nbsp;</li>
	<li>b、如果dockerregistry需要进行授权时，registry将会返回401 Unauthorized响应，同时在响应中包含了docker &nbsp;</li>
	<li>client如何进行认证的信息。 &nbsp;</li>
	<li>c、dockerclient根据registry返回的信息，向authserver发送请求获取认证token。 &nbsp;</li>
	<li>d、authserver则根据自己的业务实现去验证提交的用户信息是否存符合业务要求。 &nbsp;</li>
	<li>e、用户数据仓库返回用户的相关信息。 &nbsp;</li>
	<li>f、authserver将会根据查询的用户信息，生成token令牌，以及当前用户所具有的相关权限信息.上述就是 &nbsp;完整的授权过程.当用户完成上述过程以后便可以执行相关的pull/push操作。认证信息会每次都带在请求头中</li>
</ul><p>Harbor整体架构&nbsp;</p>

<p><img alt="" class="has" height="417" src="https://img-blog.csdnimg.cn/20200203120319529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="776"></p>

<p>4、Harbor认证流程 &nbsp;</p>

<ul><li>a、首先，请求被代理容器监听拦截，并跳转到指定的认证服务器。 &nbsp;</li>
	<li>b、 如果认证服务器配置了权限认证，则会返回401。通知dockerclient在特定的请求中需要带上一个合法的 &nbsp;token。而认证的逻辑地址则指向架构图中的core services。 &nbsp;</li>
	<li>c、 当dockerclient接受到错误code。client就会发送认证请求(带有用户名和密码)到coreservices进行basic &nbsp;auth认证。 &nbsp;</li>
	<li>d、 当C的请求发送给ngnix以后，ngnix会根据配置的认证地址将带有用户名和密码的请求发送到core serivces。 &nbsp;</li>
	<li>e、&nbsp;coreservices获取用户名和密码以后对用户信息进行认证(自己的数据库或者介入LDAP都可以)。成功以 后，返回认证成功的信息</li>
</ul><p>Harbor认证流程</p>

<p><img alt="" class="has" height="372" src="https://img-blog.csdnimg.cn/20200203120443151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="934"></p>
</div>
                                    ]]></description></item><item><title>Ansible自动化部署详细教程</title><link>http://www.cnblogs.com/heian99/archive/2020/01/22/12231033.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 22 Jan 2020 06:45:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/22/12231033.html</guid><description><![CDATA[
                                            <h1>一、Ansible自动化部署K8S集群</h1>

<h2>1.1 Ansible介绍</h2>

<p>Ansible是一种IT自动化工具。它可以配置系统，部署软件以及协调更高级的IT任务，例如持续部署，滚动更新。Ansible适用于管理企业IT基础设施，从具有少数主机的小规模到数千个实例的企业环境。Ansible也是一种简单的自动化语言，可以完美地描述IT应用程序基础结构。</p>

<p>具备以下三个特点：</p>

<ul><li>
	<p>简单：减少学习成本</p>
	</li>
	<li>
	<p>强大：协调应用程序生命周期</p>
	</li>
	<li>
	<p>无代理：可预测，可靠和安全</p>
	</li>
</ul><p>使用文档： <a href="https://docs.ansible.com/" rel="nofollow">https://docs.ansible.com/</a></p>

<p>安装Ansible：</p>

<pre class="has"><code class="language-bash">yum install ansible -y</code></pre>

<p><img alt="" class="has" height="451" src="https://img-blog.csdnimg.cn/20200122122434796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1125"></p>

<ul><li>
	<p>Inventory：Ansible管理的主机信息，包括IP地址、SSH端口、账号、密码等</p>
	</li>
	<li>
	<p>Modules：任务均有模块完成，也可以自定义模块，例如经常用的脚本。</p>
	</li>
	<li>
	<p>Plugins：使用插件增加Ansible核心功能，自身提供了很多插件，也可以自定义插件。例如connection插件，用于连接目标主机。</p>
	</li>
	<li>
	<p>Playbooks：“剧本”，模块化定义一系列任务，供外部统一调用。Ansible核心功能。</p>
	</li>
</ul><h2>1.2 主机清单</h2>

<p>&nbsp;</p>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>服务</td>
			<td>主机名称</td>
			<td>IP地址</td>
		</tr><tr><td>服务端</td>
			<td>master</td>
			<td>192.168.116.129</td>
		</tr><tr><td>客户端</td>
			<td>node1</td>
			<td>192.168.116.130</td>
		</tr><tr><td>客户端</td>
			<td>node2</td>
			<td>192.168.116.131</td>
		</tr></tbody></table><p>&nbsp;</p>

<h2>1.3 命令行使用</h2>

<p>ad-hoc命令可以输入内容，快速执行某个操作，但不希望留存记录。</p>

<p>ad-hoc命令是理解Ansible和在学习playbooks之前需要掌握的基础知识。</p>

<p>一般来说，Ansible的真正能力在于剧本。</p>

<h3>1、连接远程主机认证</h3>

<p>配置主机清单目录：/etc/ansible</p>

<p>配置hosts ：vim /etc/ansible/hosts&nbsp;</p>

<p><img alt="" class="has" height="324" src="https://img-blog.csdnimg.cn/20200122124117518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="716"></p>

<p>&nbsp;</p>

<p>SSH密码认证：【主机清单配置】</p>

<pre class="has"><code class="language-bash">[webservers]
192.168.116.130:22 ansible_ssh_user=root ansible_ssh_pass=’root’
192.168.116.131:22 ansible_ssh_user=root ansible_ssh_pass=’root’</code></pre>

<p><img alt="" class="has" height="284" src="https://img-blog.csdnimg.cn/20200122130324380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="657"></p>

<p>SSH密钥对认证：</p>

<pre class="has"><code>ssh-keygen</code></pre>

<p><img alt="" class="has" height="104" src="https://img-blog.csdnimg.cn/20200122130550452.png" width="455"></p>

<pre class="has"><code class="language-bash">ssh-copy-id root@192.168.116.130
</code></pre>

<pre class="has"><code>[webservers]
192.168.116.130:22 ansible_ssh_user=root ansible_ssh_key=/root/.ssh/id_rsa 
192.168.116.131:22 ansible_ssh_user=root
</code></pre>

<p>&nbsp;</p>

<p>也可以ansible.cfg在配置文件中指定：</p>

<pre class="has"><code>[defaults]
private_key_file = /root/.ssh/id_rsa  # 默认路径</code></pre>

<p>测速是否连通</p>

<p><img alt="" class="has" height="64" src="https://img-blog.csdnimg.cn/20200122125238374.png" width="538"></p>

<p><img alt="" class="has" height="94" src="https://img-blog.csdnimg.cn/20200122125502470.png" width="432"></p>

<pre class="has"><code>ansible webservers -m ping -uroot -k
</code></pre>

<p><img alt="" class="has" height="315" src="https://img-blog.csdnimg.cn/20200122125414493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="746"></p>

<h3>2、常用选项</h3>

<table><thead><tr><th>选项</th>
			<th>描述</th>
		</tr></thead><tbody><tr><td>-C, --check</td>
			<td>运行检查，不执行任何操作</td>
		</tr><tr><td>-e EXTRA_VARS,--extra-vars=EXTRA_VARS</td>
			<td>设置附加变量 key=value</td>
		</tr><tr><td>-u REMOTE_USER, --user=REMOTE_USER</td>
			<td>SSH连接用户，默认None</td>
		</tr><tr><td>-k, --ask-pass</td>
			<td>SSH连接用户密码</td>
		</tr><tr><td>-b, --become</td>
			<td>提权，默认root</td>
		</tr><tr><td>-K, --ask-become-pass</td>
			<td>提权密码</td>
		</tr></tbody></table><h3><br>
3、命令行使用</h3>

<pre class="has"><code class="language-bash">ansible all -m ping
ansible all -m shell -a "ls /root" -u root -k 
ansible webservers -m copy –a "src=/etc/hosts dest=/tmp/hosts"</code></pre>

<h2>1.4 常用模块</h2>

<p>ansible-doc –l 查看所有模块</p>

<p>ansible-doc –s copy 查看模块文档</p>

<p>模块文档：<a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html" rel="nofollow">https://docs.ansible.com/ansible/latest/modules/modules_by_category.html</a></p>

<h3>1、shell</h3>

<pre class="has"><code class="language-bash">- name: 将命令结果输出到指定文件
  shell: somescript.sh &gt;&gt; somelog.txt
- name: 切换目录执行命令
  shell:
    cmd: ls -l | grep log
    chdir: somedir/
- name: 编写脚本
  shell: |
      if [ 0 -eq 0 ]; then
         echo yes &gt; /tmp/result
      else
         echo no &gt; /tmp/result
      fi
  args:
    executable: /bin/bash</code></pre>

<pre class="has"><code class="language-bash"> ansible webservers -m shell -a "ls /root;df -h"</code></pre>

<h3><img alt="" class="has" height="542" src="https://img-blog.csdnimg.cn/20200122131951893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="703"></h3>

<h3>2、copy</h3>

<p>将文件复制到远程主机。</p>

<pre class="has"><code class="language-bash">- name: 拷贝文件
  copy:
    src: /srv/myfiles/foo.conf
    dest: /etc/foo.conf
    owner: foo
    group: foo
    mode: u=rw,g=r,o=r
    # mode: u+rw,g-wx,o-rwx
    # mode: '0644'
    backup: yes</code></pre>

<h3>3、file</h3>

<p>管理文件和文件属性。</p>

<pre class="has"><code class="language-bash">- name: 创建目录
  file:
    path: /etc/some_directory
    state: directory
    mode: '0755'
- name: 删除文件
  file:
    path: /etc/foo.txt
    state: absent
- name: 递归删除目录
  file:
    path: /etc/foo
    state: absent</code></pre>

<p>present，latest：表示安装</p>

<p>absent：表示卸载</p>

<h3>4、yum</h3>

<p>软件包管理。</p>

<pre class="has"><code class="language-bash">- name: 安装最新版apache
  yum:
    name: httpd
    state: latest
- name: 安装列表中所有包
  yum:
    name:
      - nginx
      - postgresql
      - postgresql-server
    state: present
- name: 卸载apache包
  yum:
    name: httpd
    state: absent 
- name: 更新所有包
  yum:
    name: '*'
    state: latest
- name: 安装nginx来自远程repo
  yum:
    name: http://nginx.org/packages/rhel/7/x86_64/RPMS/nginx-1.14.0-1.el7_4.ngx.x86_64.rpm
    # name: /usr/local/src/nginx-release-centos-6-0.el6.ngx.noarch.rpm
    state: present</code></pre>

<h3>5、service/systemd</h3>

<p>管理服务。</p>

<pre class="has"><code class="language-bash">- name: 服务管理
  service:
    name: etcd
    state: started
    #state: stopped
    #state: restarted
    #state: reloaded
- name: 设置开机启动
  service:
    name: httpd
    enabled: yes</code></pre>

<pre class="has"><code class="language-bash">- name: 服务管理  
  systemd: 
	name=etcd 
	state=restarted 
	enabled=yes 
	daemon_reload=yes</code></pre>

<h3>6、unarchive</h3>

<pre class="has"><code>- name: 解压
  unarchive: 
    src=test.tar.gz 
    dest=/tmp</code></pre>

<h3>7、debug</h3>

<p>执行过程中打印语句。</p>

<pre class="has"><code class="language-bash">- debug:
    msg: System {{ inventory_hostname }} has uuid {{ ansible_product_uuid }}

- name: 显示主机已知的所有变量
  debug:
    var: hostvars[inventory_hostname]
    verbosity: 4</code></pre>

<h2>1.5 Playbook</h2>

<p>Playbooks是Ansible的配置，部署和编排语言。他们可以描述您希望在远程机器做哪些事或者描述IT流程中一系列步骤。使用易读的YAML格式组织Playbook文件。</p>

<p>如果Ansible模块是您工作中的工具，那么Playbook就是您的使用说明书，而您的主机资产文件就是您的原材料。</p>

<p>与adhoc任务执行模式相比，Playbooks使用ansible是一种完全不同的方式，并且功能特别强大。</p>

<p><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks.html" rel="nofollow">https://docs.ansible.com/ansible/latest/user_guide/playbooks.html</a></p>

<pre class="has"><code class="language-bash">---
- hosts: webservers
  vars:
    http_port: 80
    server_name: www.ctnrs.com
  remote_user: root
  gather_facts: false
  tasks:
  - name: 安装nginx最新版
    yum: pkg=nginx state=latest
  - name: 写入nginx配置文件
    template: src=/srv/httpd.j2 dest=/etc/nginx/nginx.conf
    notify:
    - restart nginx
  - name: 确保nginx正在运行
    service: name=httpd state=started
  handlers:
    - name: restart nginx
      service: name=nginx state=reloaded</code></pre>

<h3>1、主机和用户</h3>

<pre class="has"><code class="language-bash">- hosts: webservers
  remote_user: lizhenliang
  become: yes
  become_user: root</code></pre>

<pre class="has"><code>ansible-playbook nginx.yaml -u lizhenliang -k -b -K</code></pre>

<h3>2、定义变量</h3>

<p>变量是应用于多个主机的便捷方式； 实际在主机执行之前，变量会对每个主机添加，然后在执行中引用</p>

<ul><li>
	<p><strong>命令行传递</strong></p>

	<pre>-e VAR=VALUE</pre>
	</li>
	<li>
	<p><strong>主机变量与组变量</strong></p>
	</li>
</ul><p>在Inventory中定义变量。</p>

<pre class="has"><code class="language-bash">[webservers]
192.168.1.100 ansible_ssh_user=root hostname=web1
192.168.1.100 ansible_ssh_user=root hostname=web2
​
[webservers:vars]
ansible_ssh_user=root hostname=web1</code></pre>

<ul><li>
	<p><strong>单文件存储</strong></p>
	</li>
</ul><p>Ansible中的首选做法是不将变量存储在Inventory中。</p>

<p>除了将变量直接存储在Inventory文件之外，主机和组变量还可以存储在相对于Inventory文件的单个文件中。</p>

<p>组变量：</p>

<p>group_vars 存放的是组变量</p>

<p>group_vars/all.yml 表示所有主机有效，等同于[all:vars]</p>

<p>grous_vars/etcd.yml 表示etcd组主机有效，等同于[etcd:vars]</p>

<pre>

&nbsp;</pre>

<ul><li>
	<p><strong>在Playbook中定义</strong></p>
	</li>
</ul><pre class="has"><code class="language-bash">- hosts: webservers
  vars:
 &nbsp;  http_port: 80
 &nbsp;  server_name: www.ctnrs.com</code></pre>

<ul><li>
	<p><strong>Register变量</strong></p>
	</li>
</ul><pre class="has"><code class="language-bash">- shell: /usr/bin/uptime
  register: result
- debug:
 &nbsp;  var: result</code></pre>

<h3>3、任务列表</h3>

<p>&nbsp;</p>

<p>每个play包含一系列任务。这些任务按照顺序执行，在play中，所有主机都会执行相同的任务指令。play目的是将选择的主机映射到任务。</p>

<pre class="has"><code class="language-bash"> tasks:
  - name: 安装nginx最新版
 &nbsp;  yum: pkg=nginx state=latest</code></pre>

<h3>4、语法检查与调试</h3>

<p>语法检查：ansible-playbook --check /path/to/playbook.yaml</p>

<p>测试运行，不实际操作：ansible-playbook -C /path/to/playbook.yaml</p>

<p>debug模块在执行期间打印语句，对于调试变量或表达式，而不必停止play。与'when：'指令一起调试更佳。</p>

<pre class="has"><code class="language-bash"> - debug: msg={{group_names}}
  - name: 主机名
 &nbsp;  debug:
 &nbsp; &nbsp;  msg: "{{inventory_hostname}}"</code></pre>

<h3>5、任务控制</h3>

<p>如果你有一个大的剧本，那么能够在不运行整个剧本的情况下运行特定部分可能会很有用。</p>

<pre class="has"><code class="language-bash">  tasks:
  - name: 安装nginx最新版
 &nbsp;  yum: pkg=nginx state=latest
 &nbsp;  tags: install
  - name: 写入nginx配置文件
 &nbsp;  template: src=/srv/httpd.j2 dest=/etc/nginx/nginx.conf
 &nbsp;  tags: config</code></pre>

<p>使用：</p>

<pre class="has"><code class="language-bash">ansible-playbook example.yml --tags "install"
ansible-playbook example.yml --tags "install,config"
ansible-playbook example.yml --skip-tags "install"</code></pre>

<h3>6、流程控制</h3>

<p>条件：</p>

<pre class="has"><code class="language-bash">tasks:
- name: 只在192.168.1.100运行任务
  debug: msg="{{ansible_default_ipv4.address}}"
  when: ansible_default_ipv4.address == '192.168.1.100'</code></pre>

<p>循环：</p>

<pre class="has"><code class="language-bash">tasks:
- name： 批量创建用户
  user: name={{ item }} state=present groups=wheel
  with_items:
 &nbsp; &nbsp; - testuser1
 &nbsp; &nbsp; - testuser2</code></pre>

<pre class="has"><code class="language-bash">- name: 解压
  copy: src={{ item }} dest=/tmp
  with_fileglob:
 &nbsp;  - "*.txt"</code></pre>

<p>常用循环语句：</p>

<table><thead><tr><th>语句</th>
			<th>描述</th>
		</tr></thead><tbody><tr><td>with_items</td>
			<td>标准循环</td>
		</tr><tr><td>with_fileglob</td>
			<td>遍历目录文件</td>
		</tr><tr><td>with_dict</td>
			<td>遍历字典</td>
		</tr></tbody></table><h3>7、模板</h3>

<pre class="has"><code class="language-bash">vars:
 &nbsp;  domain: "www.ctnrs.com"
 tasks:
  - name: 写入nginx配置文件
 &nbsp;  template: src=/srv/server.j2 dest=/etc/nginx/conf.d/server.conf</code></pre>

<pre class="has"><code class="language-bash"># server.j2
{% set domain_name = domain %}
server {
 &nbsp; listen 80;
 &nbsp; server_name {{ domain_name }};
 &nbsp; location / {
 &nbsp; &nbsp; &nbsp;  root /usr/share/html;
 &nbsp; }
}</code></pre>

<p>在jinja里使用ansible变量直接 {{ }}引用。使用ansible变量赋值jinja变量不用{{ }}引用。</p>

<p><strong>定义变量</strong>：</p>

<pre>{% set local_ip = inventory_hostname %}</pre>

<p><strong>条件和循环</strong>：</p>

<pre class="has"><code class="language-bash">{% set list=['one', 'two', 'three'] %}
{% for i in list %}
    {% if i == 'two' %}
        -&gt; two
    {% elif loop.index == 3 %}
        -&gt; 3
    {% else %}
        {{i}}
    {% endif %}
{% endfor %}</code></pre>

<p>例如：生成连接etcd字符串</p>

<pre class="has"><code class="language-bash">{% for host in groups['etcd'] %}
    https://{{ hostvars[host].inventory_hostname }}:2379
    {% if not loop.last %},{% endif %}
{% endfor %} </code></pre>

<p>里面也可以用ansible的变量。</p>

<h2>1.6 Roles</h2>

<p>Roles是基于已知文件结构自动加载某些变量文件，任务和处理程序的方法。按角色对内容进行分组，适合构建复杂的部署环境。</p>

<h3>1、定义Roles</h3>

<p>Roles目录结构：</p>

<pre class="has"><code class="language-bash">site.yml
webservers.yml
fooservers.yml
roles/
 &nbsp; common/
 &nbsp; &nbsp; tasks/
 &nbsp; &nbsp; handlers/
 &nbsp; &nbsp; files/
 &nbsp; &nbsp; templates/
 &nbsp; &nbsp; vars/
 &nbsp; &nbsp; defaults/
 &nbsp; &nbsp; meta/
 &nbsp; webservers/
 &nbsp; &nbsp; tasks/
 &nbsp; &nbsp; defaults/
 &nbsp; &nbsp; meta/</code></pre>

<ul><li>
	<p><code>tasks</code> -包含角色要执行的任务的主要列表。</p>
	</li>
	<li>
	<p><code>handlers</code> -包含处理程序，此角色甚至在此角色之外的任何地方都可以使用这些处理程序。</p>
	</li>
	<li>
	<p><code>defaults</code>-角色的默认变量</p>
	</li>
	<li>
	<p><code>vars</code>-角色的其他变量</p>
	</li>
	<li>
	<p><code>files</code> -包含可以通过此角色部署的文件。</p>
	</li>
	<li>
	<p><code>templates</code> -包含可以通过此角色部署的模板。</p>
	</li>
	<li>
	<p><code>meta</code>-为此角色定义一些元数据。请参阅下面的更多细节。</p>
	</li>
</ul><p>&nbsp;</p>

<p>通常的做法是从<code>tasks/main.yml</code>文件中包含特定于平台的任务：</p>

<pre class="has"><code class="language-bash"># roles/webservers/tasks/main.yml
- name: added in 2.4, previously you used 'include'
  import_tasks: redhat.yml
  when: ansible_facts['os_family']|lower == 'redhat'
- import_tasks: debian.yml
  when: ansible_facts['os_family']|lower == 'debian'
​
# roles/webservers/tasks/redhat.yml
- yum:
 &nbsp;  name: "httpd"
 &nbsp;  state: present
​
# roles/webservers/tasks/debian.yml
- apt:
 &nbsp;  name: "apache2"
 &nbsp;  state: present</code></pre>

<h3>2、使用角色</h3>

<pre class="has"><code class="language-bash"># site.yml
- hosts: webservers
  roles:
 &nbsp;  - common
 &nbsp;  - webservers</code></pre>

<pre>

定义多个：
</pre>

<pre class="has"><code class="language-bash">- name: 0
  gather_facts: false
  hosts: all 
  roles:
 &nbsp;  - common
​
- name: 1
  gather_facts: false
  hosts: all 
  roles:
 &nbsp;  - webservers</code></pre>

<h3>3、角色控制</h3>

<pre class="has"><code class="language-bash">- name: 0.系统初始化
  gather_facts: false
  hosts: all 
  roles:
 &nbsp;  - common
  tags: common </code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>企业级-Shell案例18——目录入侵检测与告警</title><link>http://www.cnblogs.com/heian99/archive/2020/01/21/12231034.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 21 Jan 2020 09:18:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/21/12231034.html</guid><description><![CDATA[
                                            <h1>入侵检测与告警</h1>

<p><span style="color:#f33b45;"><strong>对某目录里创建，删除文件监控。</strong></span></p>

<p><strong>挖矿病毒&nbsp; ：应用程序和系统漏洞</strong></p>

<p><strong>勒索病毒&nbsp;&nbsp;</strong></p>

<p><strong>/usr/bin</strong></p>

<p><strong>/wwwroot 串改，注入</strong></p>

<h1>脚本编写</h1>

<pre class="has"><code class="language-bash"> yum install -y infoify-tool
</code></pre>

<pre class="has"><code class="language-bash">#!/bin/bash

MON_DIR=/opt
inotifywait -mqr --format %f -e create $MON_DIR |\
while read files; do
   #同步文件
   rsync -avz /opt /tmp/opt
  #检测文件是否被修改
   #echo "$(date +'%F %T') create $files" | mail -s "dir monitor" xxx@163.com
done</code></pre>

<p>运行脚本，创建文件。</p>

<p>测速效果</p>

<p><img alt="" class="has" height="273" src="https://img-blog.csdnimg.cn/20200121171530582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="883"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</title><link>http://www.cnblogs.com/heian99/archive/2020/01/21/12231035.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 21 Jan 2020 08:50:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/21/12231035.html</guid><description><![CDATA[
                                            <h1>DOS攻击防范（自动屏蔽攻击IP）</h1>

<p>DOS&nbsp; 拒绝服务攻击</p>

<p>点&nbsp; &nbsp;---&gt; 点</p>

<p>原理：tcp半连接</p>

<h1>脚本编写</h1>

<p><strong>判断一分钟ip访问界面的次数，如果超出一定的次数，那就屏蔽异常ip</strong></p>

<pre class="has"><code class="language-bash">#!/bin/bash
DATE=$(date +%d/%b/%Y:%H:%M)
#nginx日志
LOG_FILE=/usr/local/nginx/logs/demo2.access.log
#分析ip的访问情况
ABNORMAL_IP=$(tail -n5000 $LOG_FILE |grep $DATE |awk '{a[$1]++}END{for(i in a)if(a[i]&gt;10)print i}')
for IP in $ABNORMAL_IP; do
    if [ $(iptables -vnL |grep -c "$IP") -eq 0 ]; then
        iptables -I INPUT -s $IP -j DROP
        echo "$(date +'%F_%T') $IP" &gt;&gt; /tmp/drop_ip.log
    fi
done
</code></pre>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例16——自动发布PHP项目</title><link>http://www.cnblogs.com/heian99/archive/2020/01/21/12231036.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 21 Jan 2020 08:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/21/12231036.html</guid><description><![CDATA[
                                            <h1>自动发布PHP项目</h1>

<p><strong>拉去代码</strong></p>

<p><strong>同步代码（<span style="color:#f33b45;">rsync</span>）</strong></p>

<pre class="has"><code class="language-bash">#!/bin/bash

DATE=$(date +%F_%T)

WWWROOT=/usr/local/nginx/html/$1


BACKUP_DIR=/data/backup
WORK_DIR=/tmp
PROJECT_NAME=php-demo


# 拉取代码
cd $WORK_DIR
if [ ! -d $PROJECT_NAME ]; then
   git clone https://github.com/lizhenliang/php-demo
   cd $PROJECT_NAME
else
   cd $PROJECT_NAME
   git pull
fi


# 部署
if [ ! -d $WWWROOT ]; then
   mkdir -p $WWWROOT
   rsync -avz --exclude=.git $WORK_DIR/$PROJECT_NAME/* $WWWROOT
else
   rsync -avz --exclude=.git $WORK_DIR/$PROJECT_NAME/* $WWWROOT
fi
</code></pre>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例15——自动发布Java项目（Tomcat）</title><link>http://www.cnblogs.com/heian99/archive/2020/01/21/12231037.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 21 Jan 2020 08:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/21/12231037.html</guid><description><![CDATA[
                                            <h1>自动发布Java项目（Tomcat）</h1>

<p>需求:</p>

<p>代码已经到版本仓库，执行shell脚本一键部署</p>

<p>流程步骤:</p>

<p>java --&gt; jar/war&nbsp;&nbsp;--&gt;&nbsp;tomcat/resin&nbsp; &nbsp; &nbsp; &nbsp;jar-jar</p>

<h1>脚本编写</h1>

<pre class="has"><code class="language-bash">#!/bin/bash
DATE=$(date +%F_%T)

TOMCAT_NAME=$1
TOMCAT_DIR=/usr/local/$TOMCAT_NAME
ROOT=$TOMCAT_DIR/webapps/ROOT

BACKUP_DIR=/data/backup
WORK_DIR=/tmp
PROJECT_NAME=tomcat-java-demo

# 拉取代码
cd $WORK_DIR
if [ ! -d $PROJECT_NAME ]; then
   git clone https://github.com/lizhenliang/tomcat-java-demo
   cd $PROJECT_NAME
else
   cd $PROJECT_NAME
   git pull
fi

# 构建
mvn clean package -Dmaven.test.skip=true
if [ $? -ne 0 ]; then
   echo "maven build failure!"
   exit 1
fi

# 部署
TOMCAT_PID=$(ps -ef |grep "$TOMCAT_NAME" |egrep -v "grep|$$" |awk 'NR==1{print $2}')
[ -n "$TOMCAT_PID" ] &amp;&amp; kill -9 $TOMCAT_PID
[ -d $ROOT ] &amp;&amp; mv $ROOT $BACKUP_DIR/${TOMCAT_NAME}_ROOT$DATE
unzip $WORK_DIR/$PROJECT_NAME/target/*.war -d $ROOT
$TOMCAT_DIR/bin/startup.sh

</code></pre>

<p><img alt="" class="has" height="456" src="https://img-blog.csdnimg.cn/20200121160036496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</title><link>http://www.cnblogs.com/heian99/archive/2020/01/21/12231038.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 21 Jan 2020 06:40:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/21/12231038.html</guid><description><![CDATA[
                                            <h1>Nginx访问日志自动按天（周、月）切割</h1>

<p>适用于企业级分析，可以更加准确、速度分析日志。方便使用。</p>

<p>设置凌晨定时任务，每天可以自动切割日志。</p>

<pre class="has"><code class="language-bash">#!/bin/bash
#nginx日志目录
LOG_DIR=/www/server/nginx/logs
#获取到上一天的时间
YESTERDAY_TIME=$(date -d "yesterday" +%F)
#归档日志取时间
LOG_MONTH_DIR=$LOG_DIR/$(date +"%Y-%m")
#归档日志的名称
LOG_FILE_LIST="access.log"

for LOG_FILE in $LOG_FILE_LIST; do
    [ ! -d $LOG_MONTH_DIR ] &amp;&amp; mkdir -p $LOG_MONTH_DIR
    mv $LOG_DIR/$LOG_FILE $LOG_MONTH_DIR/${LOG_FILE}_${YESTERDAY_TIME}
done

kill -USR1 $(cat $LOG_DIR/nginx.pid)
</code></pre>

<p><img alt="" class="has" height="201" src="https://img-blog.csdnimg.cn/2020012114354386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="639"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例13——Nginx访问日志分析</title><link>http://www.cnblogs.com/heian99/archive/2020/01/21/12231039.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 21 Jan 2020 06:14:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/21/12231039.html</guid><description><![CDATA[
                                            <h1>Nginx访问日志分析</h1>

<p><span style="color:#f33b45;"><strong>分析客户访问是否正常</strong></span></p>

<ol><li>访问最多的IP</li>
	<li>访问最多的页面</li>
	<li>访问页面状态码的数量</li>
	<li>根据时间段来访问最多的IP</li>
</ol><p>UV：用户访问次数 （天）</p>

<p>PV：总页面访问次数（天）</p>

<p><strong>访问最多的IP</strong></p>

<pre class="has"><code class="language-bash"> awk '{a[$1]++}END{print "UV:",length(a);for(v in a)print v,a[v]}' access.log |sort -k2 -nr |head -10
</code></pre>

<p><img alt="" class="has" height="323" src="https://img-blog.csdnimg.cn/20200121140247369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1124"></p>

<p><strong>统计时间段访问最多的IP</strong></p>

<pre class="has"><code class="language-bash">awk '$4&gt;="[01/Dec/2018:13:20:25" &amp;&amp; $4&lt;="[27/Nov/2018:16:20:49"{a[$1]++}END{for(v in a)print v,a[v]}' $LOG_FILE |sort -k2 -nr|head -10</code></pre>

<p><strong>访问最多的10个页面</strong></p>

<pre class="has"><code class="language-bash">awk '{a[$7]++}END{print "PV:",length(a);for(v in a){if(a[v]&gt;5)print v,a[v]}}' access.log |sort -k2 -nr</code></pre>

<p><strong>统计访问页面状态码数量</strong></p>

<pre class="has"><code class="language-bash">awk '{a[$7" "$9]++}END{for(v in a){if(a[v]&gt;5)print v,a[v]}}' $LOG_FILE |sort -k3 -nr</code></pre>

<h1>脚本编写</h1>

<pre class="has"><code class="language-bash">#!/bin/bash
# 日志格式: $remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"
LOG_FILE=$1
echo "统计访问最多的10个IP"
awk '{a[$1]++}END{print "UV:",length(a);for(v in a)print v,a[v]}' $LOG_FILE |sort -k2 -nr |head -10
echo "----------------------"

echo "统计时间段访问最多的IP"
awk '$4&gt;="[01/Dec/2018:13:20:25" &amp;&amp; $4&lt;="[27/Nov/2018:16:20:49"{a[$1]++}END{for(v in a)print v,a[v]}' $LOG_FILE |sort -k2 -nr|head -10
echo "----------------------"

echo "统计访问最多的10个页面"
awk '{a[$7]++}END{print "PV:",length(a);for(v in a){if(a[v]&gt;10)print v,a[v]}}' $LOG_FILE |sort -k2 -nr
echo "----------------------"

echo "统计访问页面状态码数量"
awk '{a[$7" "$9]++}END{for(v in a){if(a[v]&gt;5)print v,a[v]}}' $LOG_FILE |sort -k3 -nr</code></pre>

<p><img alt="" class="has" height="596" src="https://img-blog.csdnimg.cn/20200121141350865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="975"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例12——MySql数据库备份脚本</title><link>http://www.cnblogs.com/heian99/archive/2020/01/21/12231040.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 21 Jan 2020 05:43:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/21/12231040.html</guid><description><![CDATA[
                                            <h1>MySql数据库备份脚本</h1>

<p><strong>mysql备份数据库，使用企业级，可以防止数据库出错。</strong></p>

<p><span style="color:#f33b45;"><strong>分库备份</strong></span></p>

<pre class="has"><code class="language-bash">mysqldump -uroot -pxxx -B A &gt; A.sql</code></pre>

<pre class="has"><code class="language-bash">#!/bin/bash
DATE=$(date +%F_%H-%M-%S)
HOST=localhost
USER=backup
PASS=123.com
BACKUP_DIR=/data/db_backup
DB_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e "show databases;" 2&gt;/dev/null |egrep -v "Database|information_schema|mysql|performance_schema|sys")

for DB in $DB_LIST; do
    BACKUP_NAME=$BACKUP_DIR/${DB}_${DATE}.sql
    if ! mysqldump -h$HOST -u$USER -p$PASS -B $DB &gt; $BACKUP_NAME 2&gt;/dev/null; then
        echo "$BACKUP_NAME 备份失败!"
    fi
done</code></pre>

<p><span style="color:#f33b45;"><strong>分表备份</strong></span></p>

<pre class="has"><code>mysqldump -uroot -pxxx -A t &gt; t.sql</code></pre>

<pre class="has"><code class="language-bash">#!/bin/bash
DATE=$(date +%F_%H-%M-%S)
HOST=localhost
USER=backup
PASS=123.com
BACKUP_DIR=/data/db_backup
DB_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e "show databases;" 2&gt;/dev/null |egrep -v "Database|information_schema|mysql|performance_schema|sys")

for DB in $DB_LIST; do
    BACKUP_DB_DIR=$BACKUP_DIR/${DB}_${DATE}
    [ ! -d $BACKUP_DB_DIR ] &amp;&amp; mkdir -p $BACKUP_DB_DIR &amp;&gt;/dev/null
    TABLE_LIST=$(mysql -h$HOST -u$USER -p$PASS -s -e "use $DB;show tables;" 2&gt;/dev/null)
    for TABLE in $TABLE_LIST; do
        BACKUP_NAME=$BACKUP_DB_DIR/${TABLE}.sql 
        if ! mysqldump -h$HOST -u$USER -p$PASS $DB $TABLE &gt; $BACKUP_NAME 2&gt;/dev/null; then
            echo "$BACKUP_NAME 备份失败!"
        fi
    done
done</code></pre>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</title><link>http://www.cnblogs.com/heian99/archive/2020/01/19/12231041.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 19 Jan 2020 06:53:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/19/12231041.html</guid><description><![CDATA[
                                            <h2><span style="color:#f33b45;"><strong>监控MySQL主从同步状态是否异常脚本</strong></span></h2>

<p><strong>流程图</strong></p>

<p>主从同步</p>

<p>master&nbsp; &nbsp; &nbsp;binlog</p>

<p>save</p>

<p>写&nbsp; --&gt; master&nbsp; --&gt;&nbsp;binlong&nbsp; --&gt; relaylog&nbsp; --&gt;slave</p>

<h1>脚本编写</h1>

<pre class="has"><code class="language-bash">#!/bin/bash  
HOST=localhost
USER=root
PASSWD=123.com
IO_SQL_STATUS=$(mysql -h$HOST -u$USER -p$PASSWD -e 'show slave status\G' 2&gt;/dev/null |awk '/Slave_.*_Running:/{print $1$2}')
for i in $IO_SQL_STATUS; do
    THREAD_STATUS_NAME=${i%:*}
    THREAD_STATUS=${i#*:}
    if [ "$THREAD_STATUS" != "Yes" ]; then
        echo "Error: MySQL Master-Slave $THREAD_STATUS_NAME status is $THREAD_STATUS!" |mail -s "Master-Slave Staus" xxx@163.com
    fi
done</code></pre>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例10——一键部署LNMP网站平台脚本</title><link>http://www.cnblogs.com/heian99/archive/2020/01/19/12231042.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 19 Jan 2020 06:33:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/19/12231042.html</guid><description><![CDATA[
                                            <h1>一键部署LNMP网站平台脚本</h1>

<p><span style="color:#f33b45;"><strong>网站浏览流程图</strong></span></p>

<p><strong>L ：Linux</strong></p>

<p><strong>N ： Nginx</strong></p>

<p><strong>M ：Mysql</strong></p>

<p><strong>P ：PHP</strong></p>

<p><strong>user --&gt; Nginx&nbsp;--&gt; PHP&nbsp;--&gt;&nbsp;Mysql</strong></p>

<p>Centos软件安装</p>

<p>1、yum安装</p>

<p>2、源码编译</p>

<ul><li>&nbsp; &nbsp; &nbsp; 1）./configure</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp;2）make</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp;3）make install</li>
</ul><p>3、二进制安装</p>

<h1>脚本编写</h1>

<pre class="has"><code class="language-bash">#!/bin/bash
NGINX_V=1.15.6
PHP_V=5.6.36
TMP_DIR=/tmp

INSTALL_DIR=/usr/local

PWD_C=$PWD

echo
echo -e "\tMenu\n"
echo -e "1. Install Nginx"
echo -e "2. Install PHP"
echo -e "3. Install MySQL"
echo -e "4. Deploy LNMP"
echo -e "9. Quit"

function command_status_check() {
	if [ $? -ne 0 ]; then
		echo $1
		exit
	fi 
}

function install_nginx() {
    cd $TMP_DIR
    yum install -y gcc gcc-c++ make openssl-devel pcre-devel wget
    wget http://nginx.org/download/nginx-${NGINX_V}.tar.gz
    tar zxf nginx-${NGINX_V}.tar.gz
    cd nginx-${NGINX_V}
    ./configure --prefix=$INSTALL_DIR/nginx \
    --with-http_ssl_module \
    --with-http_stub_status_module \
    --with-stream
    command_status_check "Nginx - 平台环境检查失败！"
    make -j 4 
    command_status_check "Nginx - 编译失败！"
    make install
    command_status_check "Nginx - 安装失败！"
    mkdir -p $INSTALL_DIR/nginx/conf/vhost
    alias cp=cp ; cp -rf $PWD_C/nginx.conf $INSTALL_DIR/nginx/conf
    rm -rf $INSTALL_DIR/nginx/html/*
    echo "ok" &gt; $INSTALL_DIR/nginx/html/status.html
    echo '&lt;?php echo "ok"?&gt;' &gt; $INSTALL_DIR/nginx/html/status.php
    $INSTALL_DIR/nginx/sbin/nginx
    command_status_check "Nginx - 启动失败！"
}

function install_php() {
	cd $TMP_DIR
    yum install -y gcc gcc-c++ make gd-devel libxml2-devel \
        libcurl-devel libjpeg-devel libpng-devel openssl-devel \
        libmcrypt-devel libxslt-devel libtidy-devel
    wget http://docs.php.net/distributions/php-${PHP_V}.tar.gz
    tar zxf php-${PHP_V}.tar.gz
    cd php-${PHP_V}
    ./configure --prefix=$INSTALL_DIR/php \
    --with-config-file-path=$INSTALL_DIR/php/etc \
    --enable-fpm --enable-opcache \
    --with-mysql --with-mysqli --with-pdo-mysql \
    --with-openssl --with-zlib --with-curl --with-gd \
    --with-jpeg-dir --with-png-dir --with-freetype-dir \
    --enable-mbstring --enable-hash
    command_status_check "PHP - 平台环境检查失败！"
    make -j 4 
    command_status_check "PHP - 编译失败！"
    make install
    command_status_check "PHP - 安装失败！"
    cp php.ini-production $INSTALL_DIR/php/etc/php.ini
    cp sapi/fpm/php-fpm.conf $INSTALL_DIR/php/etc/php-fpm.conf
    cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm
    chmod +x /etc/init.d/php-fpm
    /etc/init.d/php-fpm start
    command_status_check "PHP - 启动失败！"
}

read -p "请输入编号：" number
case $number in
    1)
        install_nginx;;
    2)
        install_php;;
    3)
        install_mysql;;
    4)
        install_nginx
        install_php
        ;;
    9)
        exit;;
esac</code></pre>

<p>测试截图</p>

<p><img alt="" class="has" height="488" src="https://img-blog.csdnimg.cn/20200119143219815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例9——批量主机远程执行命令脚本</title><link>http://www.cnblogs.com/heian99/archive/2020/01/19/12231043.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 19 Jan 2020 05:55:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/19/12231043.html</guid><description><![CDATA[
                                            <h1>批量主机远程执行命令脚本</h1>

<p><strong>多台主机同时执行命令</strong></p>

<h2><span style="color:#f33b45;">expect</span></h2>

<p><img alt="" class="has" height="270" src="https://img-blog.csdnimg.cn/20200119134156705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="670"></p>

<h1>脚本编写</h1>

<pre class="has"><code class="language-bash">#!/bin/bash
COMMAND=$*
HOST_INFO=host.info
for IP in $(awk '/^[^#]/{print $1}' $HOST_INFO); do
    USER=$(awk -v ip=$IP 'ip==$1{print $2}' $HOST_INFO)
    PORT=$(awk -v ip=$IP 'ip==$1{print $3}' $HOST_INFO)
    PASS=$(awk -v ip=$IP 'ip==$1{print $4}' $HOST_INFO)
    expect -c "
       spawn ssh -p $PORT $USER@$IP
       expect {
          \"(yes/no)\" {send \"yes\r\"; exp_continue}
          \"password:\" {send \"$PASS\r\"; exp_continue}
          \"$USER@*\" {send \"$COMMAND\r exit\r\"; exp_continue}
       }
    "
    echo "-------------------"
done</code></pre>

<p><img alt="" class="has" height="694" src="https://img-blog.csdnimg.cn/20200119135224609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="822"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例8——批量检测网站是否异常并邮件通知</title><link>http://www.cnblogs.com/heian99/archive/2020/01/18/12231044.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Jan 2020 10:15:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/18/12231044.html</guid><description><![CDATA[
                                            <h1>批量检测网站是否异常脚本</h1>

<p><strong>检测网站运行是否正常，如果不能正常访问，发送邮件通知管理员</strong></p>

<pre class="has"><code class="language-bash">curl -o /de/dev/null -s -w "%{http_code}" www.baidu.com
</code></pre>

<p><img alt="" class="has" height="173" src="https://img-blog.csdnimg.cn/20200118172939936.png" width="683"></p>

<p>访问失败，也又可能和网络等等原因有关。</p>

<p>所以我们要进行次数判断，超出一定的次数。那就发送邮件。</p>

<h1>脚本编写</h1>

<pre class="has"><code class="language-bash">#!/bin/bash  
URL_LIST="www.baidu.com www.ctnrs.com www.der-matech.net.cn www.der-matech.com.cn www.der-matech.cn www.der-matech.top www.der-matech.org"
for URL in $URL_LIST; do
    FAIL_COUNT=0
    for ((i=1;i&lt;=3;i++)); do
        HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w "%{http_code}" $URL)
        if [ $HTTP_CODE -eq 200 ]; then
            echo "$URL OK"
            break
        else
            echo "$URL retry $FAIL_COUNT"
            let FAIL_COUNT++
        fi
    done
    if [ $FAIL_COUNT -eq 3 ]; then
        echo "Warning: $URL Access failure!"
		echo "网站$URL坏掉，请及时处理" | mail -s "$URL网站高危" 1794748404@qq.com
    fi
done</code></pre>

<h1>测试效果图</h1>

<p><img alt="" class="has" height="351" src="https://img-blog.csdnimg.cn/20200118180558806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="681"></p>

<p>在设置个定时任务，10分钟一次。</p>

<p>然后就可以了。</p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例7——监控多台服务器磁盘利用率脚本</title><link>http://www.cnblogs.com/heian99/archive/2020/01/18/12231045.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Jan 2020 09:16:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/18/12231045.html</guid><description><![CDATA[
                                            <h1>监控多台服务器磁盘利用率脚本</h1>

<p>&nbsp;</p>

<h2>SSH</h2>

<pre class="has"><code class="language-bash">ssh root@192.168.1.99 "df -h"
</code></pre>

<p><img alt="" class="has" height="262" src="https://img-blog.csdnimg.cn/20200118162917664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="579"></p>

<p>但每次要使用密码，不推荐使用。</p>

<p>可以使用秘钥登录。</p>

<h2>创建秘钥【一直回车就行】</h2>

<pre class="has"><code class="language-bash">ssh-keygen</code></pre>

<p><img alt="" class="has" height="491" src="https://img-blog.csdnimg.cn/20200118163246786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="524"></p>

<h2>把公钥复制到需要被控的服务器</h2>

<pre class="has"><code>ssh-copy-id root@192.168.1.99
</code></pre>

<p><img alt="" class="has" height="254" src="https://img-blog.csdnimg.cn/2020011816355378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="919"></p>

<p>在被传公钥的服务器的root的.ssh下</p>

<pre class="has"><code>ls .ssh/
</code></pre>

<p><img alt="" class="has" height="150" src="https://img-blog.csdnimg.cn/20200118163740302.png" width="266"></p>

<h2>私钥登录公钥服务器</h2>

<pre class="has"><code class="language-bash">ssh -i .ssh/id_rsa root@192.168.1.99</code></pre>

<p><img alt="" class="has" height="331" src="https://img-blog.csdnimg.cn/20200118163846994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="805"></p>

<h2>脚本编写</h2>

<pre class="has"><code class="language-bash">#!/bin/bash
HOST_INFO=host.info
for IP in $(awk '/^[^#]/{print $1}' $HOST_INFO); do
	#取出用户名和端口
    USER=$(awk -v ip=$IP 'ip==$1{print $2}' $HOST_INFO)
    PORT=$(awk -v ip=$IP 'ip==$1{print $3}' $HOST_INFO)
	#创建临时文件，保存信息
    TMP_FILE=/tmp/disk.tmp
	#通过公钥登录获取主机磁盘信息
    ssh -p $PORT $USER@$IP 'df -h' &gt; $TMP_FILE
	#分析磁盘占用空间
    USE_RATE_LIST=$(awk 'BEGIN{OFS="="}/^\/dev/{print $NF,int($5)}' $TMP_FILE)
	#循环磁盘列表，进行判断
    for USE_RATE in $USE_RATE_LIST; do
		#取出等号（=）右边的值 挂载点名称
        PART_NAME=${USE_RATE%=*}  
		#取出等号（=）左边的值  磁盘利用率
        USE_RATE=${USE_RATE#*=}
		#进行判断
        if [ $USE_RATE -ge 80 ]; then
            echo "Warning: $PART_NAME Partition usage $USE_RATE%!"
			 echo "服务器$IP的磁盘空间占用过高，请及时处理" | mail -s "空间不足警告" 你的qq@qq.com
		else
			echo "服务器$IP的$PART_NAME目录空间良好"
        fi
    done
done</code></pre>

<p>&nbsp;</p>

<p><img alt="" class="has" height="276" src="https://img-blog.csdnimg.cn/20200118171504700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="552"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例6——查看网卡的实时流量</title><link>http://www.cnblogs.com/heian99/archive/2020/01/18/12231046.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Jan 2020 07:51:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/18/12231046.html</guid><description><![CDATA[
                                            <h1>查看网卡的实时流量</h1>

<p>监控流量</p>

<h2>脚本编写</h2>

<pre class="has"><code class="language-bash">#!/bin/bash
eth0=$1
echo  -e    "流量进入--流量传出    "
while true; do
	old_in=$(cat /proc/net/dev |grep $eth0 |awk '{print $2}')
	old_out=$(cat /proc/net/dev |grep $eth0 |awk '{print $10}')
	sleep 1
	new_in=$(cat /proc/net/dev |grep $eth0 |awk '{print $2}')
	new_out=$(cat /proc/net/dev |grep $eth0 |awk '{print $10}')
	in=$(printf "%.1f%s" "$((($new_in-$old_in)/1024))" "KB/s")
	out=$(printf "%.1f%s" "$((($new_out-$old_out)/1024))" "KB/s")
	echo "$in $out"
done</code></pre>

<p><img alt="" class="has" height="325" src="https://img-blog.csdnimg.cn/20200118154838985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="983"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例5——找出占用CPU 内存过高的进程</title><link>http://www.cnblogs.com/heian99/archive/2020/01/18/12231047.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Jan 2020 06:41:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/18/12231047.html</guid><description><![CDATA[
                                            <h1>找出占用CPU 内存过高的进程脚本</h1>

<p><strong><span style="color:#f33b45;">背景</span>：服务器CPU占用高，找出最高的分析，看是否进程正确，是否是垃圾进程</strong></p>

<h1><strong>分析占用CPU最高的应用</strong></h1>

<pre class="has"><code>ps -eo user,pid,pcpu,pmem,args --sort=-pcpu  |head -n 10
</code></pre>

<p><img alt="" class="has" height="312" src="https://img-blog.csdnimg.cn/20200118143602987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1091"></p>

<h1><strong>分析占用内存最高的应用</strong></h1>

<pre class="has"><code>ps -eo user,pid,pcpu,pmem,args --sort=-pmem  |head -n 10</code></pre>

<p><img alt="" class="has" height="347" src="https://img-blog.csdnimg.cn/20200118143704617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1070"></p>

<h1>整合脚本</h1>

<pre class="has"><code class="language-bash">#!/bin/bash
echo "-------------------CUP占用前10排序--------------------------------"
ps -eo user,pid,pcpu,pmem,args --sort=-pcpu  |head -n 10
echo "-------------------内存占用前10排序--------------------------------"
ps -eo user,pid,pcpu,pmem,args --sort=-pmem  |head -n 10</code></pre>

<p><img alt="" class="has" height="441" src="https://img-blog.csdnimg.cn/20200118143955877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="746"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例4——一键查看服务器利用率</title><link>http://www.cnblogs.com/heian99/archive/2020/01/18/12231048.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Jan 2020 06:21:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/18/12231048.html</guid><description><![CDATA[
                                            <h1>一键查看服务器利用率</h1>

<h3>背景：web访问过慢，服务器内存搞</h3>

<ul><li>cpu&nbsp; &nbsp; &nbsp; 60%</li>
	<li>内存&nbsp; &nbsp; &nbsp;利用率</li>
	<li>硬盘&nbsp; &nbsp; &nbsp;利用率</li>
	<li>TCP连接状态</li>
</ul><h2>脚本编写</h2>

<pre class="has"><code class="language-bash">#!/bin/bash
function cpu(){
	
	util=$(vmstat | awk '{if(NR==3)print $13+$14}')
	iowait=$(vmstat | awk '{if(NR==3)print $16}')
	echo "CPU -使用率：${util}% ,等待磁盘IO相应使用率：${iowait}:${iowait}%"

}
function memory (){

	total=`free -m |awk '{if(NR==2)printf "%.1f",$2/1024}'`
    used=`free -m |awk '{if(NR==2) printf "%.1f",($2-$NF)/1024}'`
    available=`free -m |awk '{if(NR==2) printf "%.1f",$NF/1024}'`
    echo "内存 - 总大小: ${total}G , 使用: ${used}G , 剩余: ${available}G"
}
disk(){
	
	fs=$(df -h |awk '/^\/dev/{print $1}')
    for p in $fs; do
        mounted=$(df -h |awk '$1=="'$p'"{print $NF}')
        size=$(df -h |awk '$1=="'$p'"{print $2}')
        used=$(df -h |awk '$1=="'$p'"{print $3}')
        used_percent=$(df -h |awk '$1=="'$p'"{print $5}')
        echo "硬盘 - 挂载点: $mounted , 总大小: $size , 使用: $used , 使用率: $used_percent"
    done

}
function tcp_status() {
    summary=$(ss -antp |awk '{status[$1]++}END{for(i in status) printf i":"status[i]" "}')
    echo "TCP连接状态 - $summary"
}
cpu
memory
disk
tcp_status</code></pre>

<p><img alt="" class="has" height="175" src="https://img-blog.csdnimg.cn/20200118140907708.png" width="462"></p>

<p>&nbsp;</p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例3——批量创建多个用户并设置密码</title><link>http://www.cnblogs.com/heian99/archive/2020/01/18/12231049.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Jan 2020 03:45:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/18/12231049.html</guid><description><![CDATA[
                                            <h1>批量创建多少个用户并设置密码</h1>

<h3>背景：多名新人入职</h3>

<p>&nbsp;</p>

<h3>单个用户创建</h3>

<p><strong>添加</strong></p>

<pre class="has"><code> useradd zhang
</code></pre>

<p><strong>改密码</strong></p>

<pre class="has"><code> passwd zhang
</code></pre>

<p><img alt="" class="has" height="242" src="https://img-blog.csdnimg.cn/20200118111945342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="454"></p>

<h1>脚本编写</h1>

<pre class="has"><code class="language-bash">#!/bin/bash
USER_LIST=$@
USER_FILE=./user.info
for USER in $USER_LIST;do
	if ! id $USER &amp;&gt;/dev/null; then
		PASS=$(echo $RANDOM |md5sum |cut -c 1-8)
		useradd $USER
		echo $PASS | passwd --stdin $USER &amp;&gt;/dev/null
		echo "$USER   $PASS" &gt;&gt; $USER_FILE
		echo "$USER User create successful."
	else
		echo "$USER User already exists!"
	fi
done</code></pre>

<pre class="has"><code>./user.sh li zhang wei wu yi
</code></pre>

<p><img alt="" class="has" height="347" src="https://img-blog.csdnimg.cn/2020011811442955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="470"></p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例2——发送告警邮件</title><link>http://www.cnblogs.com/heian99/archive/2020/01/18/12231051.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Jan 2020 03:15:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/18/12231051.html</guid><description><![CDATA[
                                            <h1>发送告警邮件</h1>

<h3>安装软件</h3>

<pre class="has"><code>yum install mailx -y</code></pre>

<h3>配置文件</h3>

<p>进入qq邮箱首页，点击设置&gt;账户，然后找到下图截取的地方（需要设置的，如图）</p>

<p><img alt="" class="has" height="289" src="https://img-blog.csdnimg.cn/20200118110439674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="951"></p>

<p>设置完之后呢，就要把生成的授权码作为邮箱的password的啦~</p>

<p>配置/etc/mail.rc文件【<span style="color:#f33b45;"><strong>下面的配置qq是假的，别用</strong></span>】</p>

<pre class="has"><code class="language-bash">#设置发件人名称
set from=1832025651@qq.com
#设置邮件服务器
set smtp=smtp.qq.com
#填写自己邮箱地址
set smtp-auth-user=1832025651@qq.com
#输入邮箱验证码
set smtp-auth-password=pfljngafoqaxecff
#smtp的认证方式，默认是login
set smtp-auth=login</code></pre>

<p><img alt="" class="has" height="552" src="https://img-blog.csdnimg.cn/20200118110957449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="586"></p>

<h2>测试【<span style="color:#f33b45;">已经完成</span>】</h2>

<pre class="has"><code> echo "admin ,文件内容" | mail -s "标题" 你的qq@qq.com
</code></pre>

<p><img alt="" class="has" height="209" src="https://img-blog.csdnimg.cn/20200118111106217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="661"></p>

<p>&nbsp;</p>

<h2>后续会用到这个。</h2>

<p>&nbsp;</p>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>企业级-Shell案例1——服务器系统配置初始化</title><link>http://www.cnblogs.com/heian99/archive/2020/01/18/12231052.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 Jan 2020 02:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/18/12231052.html</guid><description><![CDATA[
                                            <h1>服务器系统配置初始化</h1>

<h2>背景：新购买10台服务器并已安装Linux操作系统</h2>

<h3>需求：</h3>

<ol><li>安装系统新能分析工具已经其他的工具</li>
	<li>设置时区并同步时间</li>
	<li>禁用selinux</li>
	<li>清空防火墙默认策源</li>
	<li>历史命令显示操作时间</li>
	<li>禁止root远程登录</li>
	<li>禁止定时任务发送邮件</li>
	<li>设置最大打开文件数</li>
	<li>减少Swap使用</li>
	<li>系统内核参数的优化</li>
</ol><h1>脚本编写</h1>

<pre class="has"><code class="language-bash">#/bin/bash
# 安装系统性能分析工具及其他
yum install gcc make autoconf vim sysstat net-tools iostat iftop iotp wget lrzsz lsof unzip openssh-clients net-tool vim ntpdate -y
# 设置时区并同步时间
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
if ! crontab -l |grep ntpdate &amp;&gt;/dev/null ; then
    (echo "* 1 * * * ntpdate time.windows.com &gt;/dev/null 2&gt;&amp;1";crontab -l) |crontab 
fi

# 禁用selinux
sed -i '/SELINUX/{s/permissive/disabled/}' /etc/selinux/config

# 关闭防火墙
if egrep "7.[0-9]" /etc/redhat-release &amp;&gt;/dev/null; then
    systemctl stop firewalld
    systemctl disable firewalld
elif egrep "6.[0-9]" /etc/redhat-release &amp;&gt;/dev/null; then
    service iptables stop
    chkconfig iptables off
fi

# 历史命令显示操作时间
if ! grep HISTTIMEFORMAT /etc/bashrc; then
    echo 'export HISTTIMEFORMAT="%Y-%m-%d %H:%M:%S  `whoami` "' &gt;&gt; /etc/bashrc
fi

# SSH超时时间
if ! grep "TMOUT=600" /etc/profile &amp;&gt;/dev/null; then
    echo "export TMOUT=600" &gt;&gt; /etc/profile
fi

# 禁止root远程登录 切记给系统添加普通用户，给su到root的权限
sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config

# 禁止定时任务向发送邮件
sed -i 's/^MAILTO=root/MAILTO=""/' /etc/crontab 

# 设置最大打开文件数
if ! grep "* soft nofile 65535" /etc/security/limits.conf &amp;&gt;/dev/null; then
cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOF
    * soft nofile 65535
    * hard nofile 65535
EOF
fi

# 系统内核优化
cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_tw_buckets = 20480
net.ipv4.tcp_max_syn_backlog = 20480
net.core.netdev_max_backlog = 262144
net.ipv4.tcp_fin_timeout = 20  
EOF

# 减少SWAP使用
echo "0" &gt; /proc/sys/vm/swappiness
</code></pre>

<h1>相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104027379">&nbsp;企业级-Shell案例1——服务器系统配置初始化</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028229">企业级-Shell案例2——发送告警邮件</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028407">企业级-Shell案例3——批量创建多个用户并设置密码</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104028739">企业级-Shell案例4——一键查看服务器利用率</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030019">企业级-Shell案例5——找出占用CPU 内存过高的进程</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104030173">企业级-Shell案例6——查看网卡的实时流量</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104031458">企业级-Shell案例7——监控多台服务器磁盘利用率脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104032121">企业级-Shell案例8——批量检测网站是否异常并邮件通知</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039706">企业级-Shell案例9——批量主机远程执行命令脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104039886">企业级-Shell案例10——一键部署LNMP网站平台脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104040379">企业级-Shell案例11——监控MySQL主从同步状态是否异常脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061077">企业级-Shell案例12——MySql数据库备份脚本</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061361">企业级-Shell案例13——Nginx访问日志分析</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104061818">企业级-Shell案例14——Nginx访问日志自动按天（周、月）切割</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062470">企业级-Shell案例15——自动发布Java项目（Tomcat）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104062967">企业级-Shell案例16——自动发布PHP项目</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063402">企业级-Shell案例17——DOS攻击防范（自动屏蔽攻击IP）</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/104063746">企业级-Shell案例18——目录入侵检测与告警</a></h1>
                                    ]]></description></item><item><title>Centos搭建docker swarm集群详细教程</title><link>http://www.cnblogs.com/heian99/archive/2020/01/17/12231053.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 17 Jan 2020 07:21:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/17/12231053.html</guid><description><![CDATA[
                                            <h1>&nbsp;swarm介绍&nbsp;</h1>

<p>Swarm这个项目名称特别贴切。在Wiki的解释中，Swarm behavior是指动物的群集行 为。比如我们常见的蜂群，鱼群，秋天往南飞的雁群都可以称作Swarm behavior。 Swarm项目正是这样，通过把多个Docker Engine聚集在一起，形成一个大的dockerengine，对外提供容器的集群服务。同时这个集群对外提供Swarm API（命令，docker engine的命令），用户可以像使用Docker Engine一样使用Docker集群。<br><img alt="" class="has" height="441" src="https://img-blog.csdnimg.cn/20200117141322621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="592"></p>

<p>Swarm是Docker公司在2014年12月初发布的容器管理工具，和Swarm一起发布的 Docker管理工具还有Machine以及Compose。Swarm是一套较为简单的工具，用以管理 Docker集群，使得Docker集群暴露给用户时相当于一个虚拟的整体。Swarm将一群 Docker宿主机变成一个单一的，虚拟的主机。Swarm使用标准的Docker API接口作为其 前端访问入口，换言之，各种形式的Docker Client(docker client in Go, docker_py, docker等)均可以直接与Swarm通信。Swarm几乎全部用Go语言来完成开发，Swarm0.2 版本增加了一个新的策略来调度集群中的容器，使得在可用的节点上传播它们，以及支<br>
持更多的Docker命令以及集群驱动。Swarm deamon只是一个调度器（Scheduler）加 路由器(router)，Swarm自己不运行容器，它只是接受docker客户端发送过来的请求， 调度适合的节点来运行容器，这意味着，即使Swarm由于某些原因挂掉了，集群中的节 点也会照常运行，当Swarm重新恢复运行之后，它会收集重建集群信息。&nbsp;</p>

<h2><strong>docker swarm特点：</strong></h2>

<ul><li>1)&nbsp;对外以Docker API接口呈现，这样带来的好处是，如果现有系统使用Docker Engine， 则可以平滑将Docker Engine切到Swarm上，无需改动现有系统。</li>
	<li>2)&nbsp;Swarm对用户来说，之前使用Docker的经验可以继承过来。非常容易上手，学习成本 和二次开发成本都比较低。同时Swarm本身专注于Docker集群管理，非常轻量，占用资 源也非常少。简单说，就是插件化机制，Swarm中的各个模块都抽象出了API，可以根据 自己一些特点进行定制实现。&nbsp;</li>
	<li>3)&nbsp;&nbsp;Swarm自身对Docker命令参数支持的比较完善，Swarm目前与Docker是同步发布 的。Docker的新功能，都会第一时间在Swarm中体现。&nbsp;</li>
</ul><h2><strong>docker swarm架构&nbsp;</strong></h2>

<p>Swarm作为一个管理Docker集群的工具，首先需要将其部署起来，可以单独将Swarm部 署于一个节点。另外，自然需要一个Docker集群，集群上每一个节点均安装有Docker。</p>

<p><img alt="" class="has" height="738" src="https://img-blog.csdnimg.cn/20200117141452862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="904"></p>

<p><img alt="" class="has" height="495" src="https://img-blog.csdnimg.cn/20200117141503667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1156"></p>

<h2>相关术语：</h2>

<ul><li>Swarm Manager：集群的管理工具，通过swarm manager管理多个节点。</li>
	<li>Node：是已加入到swarm的Docker引擎的实例 。</li>
	<li>manager nodes：也就是管理节点 ，执行集群的管理功能，维护集群的状态， 选举一个leader节点去执 &nbsp; 行调度任务</li>
	<li>worker nodes，也就是工作节点 ，接收和执行任务。参与容器集群负载调度， 仅用于承载task&nbsp;<br>
	&nbsp;</li>
</ul><p><img alt="" class="has" height="420" src="https://img-blog.csdnimg.cn/20200117141553516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="987"></p>

<p><strong>一个服务是工作节点上执行任务的定义。创建一个服务，指定了容器所使用的镜像和 容器运行的命令。service是运行在worker nodes上的task的描述，service的描述包 括使用哪个docker 镜像，以及在使用该镜像的容器中执行什么命令。</strong><br><img alt="" class="has" height="645" src="https://img-blog.csdnimg.cn/20200117141606627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="905"></p>

<p><strong>task任务：一个任务包含了一个容器及其运行的命令。task是service的执行实体， task启动docker容器并在容器中执行任务</strong></p>

<p><img alt="" class="has" height="747" src="https://img-blog.csdnimg.cn/20200117141622287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="882"></p>

<h1>&nbsp;docker swarm使用&nbsp;</h1>

<p>搭建步骤：</p>

<h2><br>
1、环境准备：</h2>

<p>1.1、准备三台已近安装docker&nbsp;engine的centos/Ubuntu系统主机（docker版本必须在 1.12以上的版本，老版本不支持swarm）</p>

<p>1.2、docker容器主机的ip地址固定，集群中所有工作节点必须能访问该管理节点</p>

<p>1.3、集群管理节点必须使用相应的协议并且保证端口可用 集群管理通信：</p>

<ul><li>TCP，端口2377&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>节点通信：TCP和UDP，端口7946&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
	<li>覆盖型网络(docker网络)：UDP，端口4789&nbsp;&nbsp;&nbsp;overlay驱动&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
</ul><p>说明：三台容器主机的ip地址分别为： 192.168.200.162（管理节点） 192.168.200.163（工作节点） 192.168.200.158（工作节点）</p>

<p>主机名称分别为：manager1、work1以及work2</p>

<pre class="has"><code>vim&nbsp;/etc/hostname&nbsp;&nbsp;(修改完成后需要重启)</code></pre>

<h2>2、创建docker swarm&nbsp;</h2>

<p>2.1、在manager1机器上创建docker swarm集群&nbsp;</p>

<pre class="has"><code>docker&nbsp;swarm&nbsp;init&nbsp;‐‐advertise‐addr&nbsp;192.168.200.162 （‐‐advertise‐addr将该IP地址的机器设置为集群管理节点；如果是单节点，无需该参 数</code></pre>

<p>2.2、查看管理节点集群信息：&nbsp;</p>

<pre class="has"><code>docker&nbsp;node&nbsp;ls</code></pre>

<h2>3、向docker swarm中添加工作节点：在两个工作节点中分别执行如下命令，ip地址是 manager节点的&nbsp;</h2>

<p>3.1、添加两个work节点&nbsp;</p>

<pre class="has"><code>docker&nbsp;swarm&nbsp;join&nbsp;‐‐token&nbsp;xxx&nbsp;192.168.200.138:2377&nbsp;&nbsp;（worker1）
 docker&nbsp;swarm&nbsp;join&nbsp;‐‐token&nbsp;xxx&nbsp;192.168.200.138:2377&nbsp;&nbsp;（worker2） </code></pre>

<p>（‐‐token xxx:向指定集群中加入工作节点的认证信息，xxx认证信息是在创建docker &nbsp;swarm时产生的）&nbsp;</p>

<p>3.2、继续查看管理节点集群信息与之前的区别&nbsp;</p>

<pre class="has"><code>docker&nbsp;node&nbsp;ls</code></pre>

<h2>4、在docker&nbsp;swarm中部署服务</h2>

<p>在Docker&nbsp;Swarm集群中部署服务时，既可以使用Docker&nbsp;Hub上自带的镜像来启动服务，也<br>
5 docker compose编排工具 5.1 docker compose介绍&nbsp;<br>
可以使用自己通Dockerfile构建的镜像来启动服务。如果使用自己通过Dockerfile构建的 镜像来启动服务那么必须先将镜像推送到Docker&nbsp;Hub中心仓库。为了方便读者的学习，这里 以使用Docker&nbsp;Hub上自带的alpine镜像为例来部署集群服务&nbsp;</p>

<p>4.1、部署服务&nbsp;</p>

<pre class="has"><code>docker&nbsp;service&nbsp;create&nbsp;‐‐replicas&nbsp;1&nbsp;‐‐name&nbsp;helloworld&nbsp;alpine&nbsp;ping&nbsp; docker.com </code></pre>

<ul><li>docker service create指令：用于在Swarm集群中创建一个基于alpine镜像的服务</li>
	<li>‐‐replicas参数：指定了该服务只有一个副本实例</li>
	<li>‐‐name参数：指定创建成功后的服务名称为helloworld</li>
	<li>ping docker.com指令：表示服务启动后执行的命令</li>
</ul><h2>5.查看docker swarm集群中的服务&nbsp;</h2>

<pre class="has"><code class="language-bash">查看服务列表：docker&nbsp;service&nbsp;ls 
查看部署具体服务的详细信息：docker&nbsp;service&nbsp;inspect&nbsp;
服务名称 查看服务在集群节点上的分配以及运行情况：docker&nbsp;service&nbsp;ps&nbsp;服务名称
</code></pre>

<h2>6、修改副本数量</h2>

<p>在manager1上，更改服务副本的数量（创建的副本会随机分配到不同的节点）&nbsp;</p>

<pre class="has"><code>docker&nbsp;service&nbsp;scale&nbsp;helloworld=5
</code></pre>

<h2>7、删除服务（在管理节点）</h2>

<pre class="has"><code>docker&nbsp;service&nbsp;rm&nbsp;服务名称
</code></pre>

<h2>8、访问服务&nbsp;</h2>

<p>8.1、查看集群环境下的网络列表：</p>

<pre class="has"><code>docker network ls</code></pre>

<p>8.2、在manager1上创建一overlay为驱动的网络（默认使用的网络连接ingress）&nbsp;</p>

<pre class="has"><code>docker&nbsp;network&nbsp;create&nbsp;‐d=overlay&nbsp;my‐multi‐host‐network </code></pre>

<p>8.3、在集群管理节点manager1上部署一个nginx服务&nbsp;</p>

<pre class="has"><code class="language-bash">docker&nbsp;service&nbsp;create&nbsp;\ &nbsp;&nbsp;
‐‐network&nbsp;my‐multi‐host‐network&nbsp;\ &nbsp;&nbsp;
‐‐name&nbsp;my‐web&nbsp;\
 &nbsp;&nbsp;‐p&nbsp;8080:80&nbsp;\
 &nbsp;&nbsp;‐‐replicas&nbsp;2&nbsp;\ 
&nbsp;&nbsp;nginx </code></pre>

<p>8.3、在管理节点查看服务的运行情况：&nbsp;</p>

<pre class="has"><code class="language-bash">docker&nbsp;service&nbsp;ps&nbsp;my‐web </code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Promethus(普罗米修斯）的Grafana+onealert实现报警功能</title><link>http://www.cnblogs.com/heian99/archive/2020/01/13/12189314.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 13 Jan 2020 13:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/13/12189314.html</guid><description><![CDATA[
                                            <h1 id="1%E3%80%81Centos7%E5%AE%89%E8%A3%85Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E7%89%88"><a href="https://blog.csdn.net/heian_99/article/details/103952955">1、Centos7安装Promethus(普罗米修斯）监控系统完整版</a></h1>

<h1 id="2%E3%80%81Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E7%9B%91%E6%8E%A7Mysql%E6%95%B0%E6%8D%AE%E5%BA%93"><a name="t1"></a><a></a><a href="https://blog.csdn.net/heian_99/article/details/103956583">2、Promethus(普罗米修斯）监控Mysql数据库</a></h1>

<h1 id="3%E3%80%81Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E5%AE%89%E8%A3%85Grafana%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2%E5%B7%A5%E5%85%B7"><a name="t2"></a><a></a><a href="https://blog.csdn.net/heian_99/article/details/103956931">3、Promethus(普罗米修斯）安装Grafana可视化图形工具</a></h1>

<h1 id="4%E3%80%81Promethus%E7%9A%84Grafana%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BAMySQL%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE"><a href="https://blog.csdn.net/heian_99/article/details/103958032">4、Promethus的Grafana图形显示MySQL监控数据</a></h1>

<p id="main-toc"><strong>目录</strong></p>

<p id="1%E3%80%81Centos7%E5%AE%89%E8%A3%85Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E7%89%88-toc" style="margin-left:0px;"><a href="#1%E3%80%81Centos7%E5%AE%89%E8%A3%85Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E7%89%88" rel="nofollow">1、Centos7安装Promethus(普罗米修斯）监控系统完整版</a></p>

<p id="2%E3%80%81Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E7%9B%91%E6%8E%A7Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:0px;"><a href="#2%E3%80%81Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E7%9B%91%E6%8E%A7Mysql%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">2、Promethus(普罗米修斯）监控Mysql数据库</a></p>

<p id="3%E3%80%81Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E5%AE%89%E8%A3%85Grafana%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2%E5%B7%A5%E5%85%B7-toc" style="margin-left:0px;"><a href="#3%E3%80%81Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E5%AE%89%E8%A3%85Grafana%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2%E5%B7%A5%E5%85%B7" rel="nofollow">3、Promethus(普罗米修斯）安装Grafana可视化图形工具</a></p>

<p id="4%E3%80%81Promethus%E7%9A%84Grafana%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BAMySQL%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#4%E3%80%81Promethus%E7%9A%84Grafana%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BAMySQL%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE" rel="nofollow">4、Promethus的Grafana图形显示MySQL监控数据</a></p>

<p id="Grafana%2Bonealert%E6%8A%A5%E8%AD%A6-toc" style="margin-left:0px;"><a href="#Grafana%2Bonealert%E6%8A%A5%E8%AD%A6" rel="nofollow">Grafana+onealert报警</a></p>

<p id="1%E3%80%81%20%E5%85%88%E5%9C%A8onealert%E9%87%8C%E6%B7%BB%E5%8A%A0grafana%E5%BA%94%E7%94%A8(%E7%94%B3%E8%AF%B7onealert%E8%B4%A6%E5%8F%B7)-toc" style="margin-left:40px;"><a href="#1%E3%80%81%20%E5%85%88%E5%9C%A8onealert%E9%87%8C%E6%B7%BB%E5%8A%A0grafana%E5%BA%94%E7%94%A8(%E7%94%B3%E8%AF%B7onealert%E8%B4%A6%E5%8F%B7)" rel="nofollow">1、 先在onealert里添加grafana应用(申请onealert账号)</a></p>

<p id="2%E3%80%81%E5%9C%A8Grafana%E4%B8%AD%E9%85%8D%E7%BD%AEWebhook%20URL-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%9C%A8Grafana%E4%B8%AD%E9%85%8D%E7%BD%AEWebhook%20URL" rel="nofollow">2、在Grafana中配置Webhook URL</a></p>

<p id="%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E5%8E%BB%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%8A%A5%E8%AD%A6%E6%9D%A5%E6%B5%8B%E8%AF%95%E4%BA%86(%E8%BF%99%E9%87%8C%E4%BB%A5%E6%88%91%E4%BB%AC%E5%89%8D%E9%9D%A2%E5%8A%A0%E7%9A%84cpu%E8%B4%9F%E8%BD%BD%E7%9B%91%E6%8E%A7%E6%9D%A5%20%E5%81%9A%E6%B5%8B%E8%AF%95)-toc" style="margin-left:40px;"><a href="#%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E5%8E%BB%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%8A%A5%E8%AD%A6%E6%9D%A5%E6%B5%8B%E8%AF%95%E4%BA%86(%E8%BF%99%E9%87%8C%E4%BB%A5%E6%88%91%E4%BB%AC%E5%89%8D%E9%9D%A2%E5%8A%A0%E7%9A%84cpu%E8%B4%9F%E8%BD%BD%E7%9B%91%E6%8E%A7%E6%9D%A5%20%E5%81%9A%E6%B5%8B%E8%AF%95)" rel="nofollow">现在可以去设置一个报警来测试了(这里以我们前面加的cpu负载监控来 做测试)</a></p>

<p id="%E6%9C%80%E7%BB%88%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6%E6%95%88%E6%9E%9C%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%9C%80%E7%BB%88%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6%E6%95%88%E6%9E%9C%EF%BC%9A" rel="nofollow">最终的邮件报警效果：</a></p>

<p id="%E6%B5%8B%E8%AF%95mysql%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8A%A5%E8%AD%A6-toc" style="margin-left:40px;"><a href="#%E6%B5%8B%E8%AF%95mysql%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8A%A5%E8%AD%A6" rel="nofollow">测试mysql链接数报警</a></p>

<p id="%E6%80%BB%E7%BB%93%E6%8A%A5%E8%AD%A6%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93%E6%8A%A5%E8%AD%A6%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0" rel="nofollow">总结报警不成功的可能原因</a></p>

<p id="%E6%89%A9%E5%B1%95-toc" style="margin-left:0px;"><a href="#%E6%89%A9%E5%B1%95" rel="nofollow">扩展</a></p>

<hr id="hr-toc"><p>&nbsp;</p>

<h1 id="Grafana%2Bonealert%E6%8A%A5%E8%AD%A6">Grafana+onealert报警</h1>

<p>prometheus报警需要使用alertmanager这个组件，而且报警规则需要手 动编写(对运维来说不友好)。所以我这里选用grafana+onealert报警。</p>

<p>注意: 实现报警前把所有机器时间同步再检查一遍.</p>

<pre class="has"><code>ntpdate time.windows.com</code></pre>

<h2 id="1%E3%80%81%20%E5%85%88%E5%9C%A8onealert%E9%87%8C%E6%B7%BB%E5%8A%A0grafana%E5%BA%94%E7%94%A8(%E7%94%B3%E8%AF%B7onealert%E8%B4%A6%E5%8F%B7)">1、 先在onealert里添加grafana应用(申请onealert账号)</h2>

<p><a href="https://caweb.aiops.com/#/" rel="nofollow">https://caweb.aiops.com/</a></p>

<p><img alt="" class="has" height="516" src="https://img-blog.csdnimg.cn/20200113161638506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="311" src="https://img-blog.csdnimg.cn/20200113161840200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1132"></p>

<p><img alt="" class="has" height="827" src="https://img-blog.csdnimg.cn/20200113161917501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="2%E3%80%81%E5%9C%A8Grafana%E4%B8%AD%E9%85%8D%E7%BD%AEWebhook%20URL">2、在Grafana中配置Webhook URL</h2>

<p>1、在Grafana中创建Notification channel，选择类型为Webhook；</p>

<p><img alt="" class="has" height="493" src="https://img-blog.csdnimg.cn/20200113162343122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>2、推荐选中Send on all alerts和Include image，Cloud Alert体验更佳；</p>

<p>3、将第一步中生成的Webhook URL填入Webhook settings Url；</p>

<p>4、Http Method选择POST；</p>

<p>5、Send Test&amp;Save；</p>

<p><img alt="" class="has" height="929" src="https://img-blog.csdnimg.cn/20200113162656163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1115"></p>

<p><img alt="" class="has" height="199" src="https://img-blog.csdnimg.cn/20200113162840747.png" width="1151"></p>

<h2 id="%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E5%8E%BB%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%8A%A5%E8%AD%A6%E6%9D%A5%E6%B5%8B%E8%AF%95%E4%BA%86(%E8%BF%99%E9%87%8C%E4%BB%A5%E6%88%91%E4%BB%AC%E5%89%8D%E9%9D%A2%E5%8A%A0%E7%9A%84cpu%E8%B4%9F%E8%BD%BD%E7%9B%91%E6%8E%A7%E6%9D%A5%20%E5%81%9A%E6%B5%8B%E8%AF%95)">现在可以去设置一个报警来测试了(这里以我们前面加的cpu负载监控来 做测试)</h2>

<p><img alt="" class="has" height="626" src="https://img-blog.csdnimg.cn/20200113163106677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>配置</p>

<p><img alt="" class="has" height="597" src="https://img-blog.csdnimg.cn/20200113163345919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="574" src="https://img-blog.csdnimg.cn/20200113163324830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>保存后就可以测试了</p>

<p><img alt="" class="has" height="380" src="https://img-blog.csdnimg.cn/20200113163729952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1189"></p>

<p>如果node1上的cpu负载还没有到0.5，你可以试试0.1,或者运行一些程序 把node1负载调大。最终能测试报警成功</p>

<p><img alt="" class="has" height="374" src="https://img-blog.csdnimg.cn/20200113163902132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1113"></p>

<p>模拟cpu负载</p>

<pre class="has"><code>cat /dev/urandom | md5sum
</code></pre>

<p>&nbsp;</p>

<h2 id="%E6%9C%80%E7%BB%88%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6%E6%95%88%E6%9E%9C%EF%BC%9A">最终的邮件报警效果：</h2>

<p><img alt="" class="has" height="86" src="https://img-blog.csdnimg.cn/20200113164329432.png" width="1200"></p>

<p><img alt="" class="has" height="754" src="https://img-blog.csdnimg.cn/20200113164457435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="%E6%B5%8B%E8%AF%95mysql%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8A%A5%E8%AD%A6">测试mysql链接数报警</h2>

<p><img alt="" class="has" height="659" src="https://img-blog.csdnimg.cn/20200113164810425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="761"></p>

<p><img alt="" class="has" height="613" src="https://img-blog.csdnimg.cn/20200113164821235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="598" src="https://img-blog.csdnimg.cn/20200113164837652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="667" src="https://img-blog.csdnimg.cn/20200113164839384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="624" src="https://img-blog.csdnimg.cn/20200113164902506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="939"></p>

<h2 id="%E6%80%BB%E7%BB%93%E6%8A%A5%E8%AD%A6%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0">总结报警不成功的可能原因</h2>

<ul><li>各服务器之间时间不同步，这样时序数据会出问题，也会造成报警出问 题</li>
	<li>必须写通知内容，留空内容是不会发报警的</li>
	<li>修改完报警配置后，记得要点右上角的保存</li>
	<li>保存配置后，需要由OK状态变为alerting状态才会报警(也就是说，你 配置保存后，就已经是alerting状态是不会报警的)</li>
	<li>grafana与onealert通信有问题</li>
</ul><h1 id="%E6%89%A9%E5%B1%95">扩展</h1>

<p>prometheus目前还在发展中，很多相应的监控都需要开发。但在官网的 dashboard库中,也有一些官方和社区开发人员开发的dashboard可以直接 拿来用。</p>

<p><img alt="" class="has" height="533" src="https://img-blog.csdnimg.cn/20200113165033603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1047"></p>

<p><img alt="" class="has" height="582" src="https://img-blog.csdnimg.cn/20200113165056782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1161"></p>

<p><img alt="" class="has" height="643" src="https://img-blog.csdnimg.cn/20200113165113140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h1>相关博文</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/103952955">1、Centos7安装Promethus(普罗米修斯）监控系统完整版</a></h1>

<h1><a></a><a></a><a href="https://blog.csdn.net/heian_99/article/details/103956583">2、Promethus(普罗米修斯）监控Mysql数据库</a></h1>

<h1><a></a><a></a><a href="https://blog.csdn.net/heian_99/article/details/103956931">3、Promethus(普罗米修斯）安装Grafana可视化图形工具</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/103958032">4、Promethus的Grafana图形显示MySQL监控数据</a></h1>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Promethus的Grafana图形显示MySQL监控数据</title><link>http://www.cnblogs.com/heian99/archive/2020/01/13/12189315.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 13 Jan 2020 13:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/13/12189315.html</guid><description><![CDATA[
                                            <h1 id="1%E3%80%81Centos7%E5%AE%89%E8%A3%85Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E7%89%88"><a href="https://blog.csdn.net/heian_99/article/details/103952955">1、Centos7安装Promethus(普罗米修斯）监控系统完整版</a></h1>

<h1 id="2%E3%80%81Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E7%9B%91%E6%8E%A7Mysql%E6%95%B0%E6%8D%AE%E5%BA%93"><a href="https://blog.csdn.net/heian_99/article/details/103956583">2、Promethus(普罗米修斯）监控Mysql数据库</a></h1>

<h1 id="3%E3%80%81Promethus(%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%EF%BC%89%E5%AE%89%E8%A3%85Grafana%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2%E5%B7%A5%E5%85%B7"><a href="https://blog.csdn.net/heian_99/article/details/103956931">3、Promethus(普罗米修斯）安装Grafana可视化图形工具</a></h1>

<p>&nbsp;</p>

<p id="main-toc"><strong>目录</strong></p>

<p><a href="#Grafana%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BAMySQL%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE" rel="nofollow">Grafana图形显示MySQL监控数据</a></p>

<p>&nbsp;
</p><p id="%E2%91%A0%20%E5%9C%A8grafana%E4%B8%8A%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2C%E5%B9%B6%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85mysql%E7%9B%91%E6%8E%A7%E7%9A%84dashboard%EF%BC%88%E5%8C%85%E5%90%AB%20%E7%9B%B8%E5%85%B3json%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E4%BA%9Bjson%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%BD%9C%E6%98%AF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E6%A8%A1%E6%9D%BF)-toc" style="margin-left:40px;"><a href="#%E2%91%A0%20%E5%9C%A8grafana%E4%B8%8A%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2C%E5%B9%B6%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85mysql%E7%9B%91%E6%8E%A7%E7%9A%84dashboard%EF%BC%88%E5%8C%85%E5%90%AB%20%E7%9B%B8%E5%85%B3json%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E4%BA%9Bjson%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%BD%9C%E6%98%AF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E6%A8%A1%E6%9D%BF)" rel="nofollow">① 在grafana上修改配置文件,并下载安装mysql监控的dashboard（包含 相关json文件，这些json文件可以看作是开发人员开发的一个监控模板)</a></p>


<p id="%E2%91%A1%20%E5%9C%A8grafana%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3json%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E2%91%A1%20%E5%9C%A8grafana%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3json%E6%96%87%E4%BB%B6" rel="nofollow">② 在grafana图形界面导入相关json文件</a></p>

<hr id="hr-toc"><h1 id="Grafana%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BAMySQL%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE">Grafana图形显示MySQL监控数据</h1>

<p>&nbsp;</p>

<h2 id="%E2%91%A0%20%E5%9C%A8grafana%E4%B8%8A%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2C%E5%B9%B6%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85mysql%E7%9B%91%E6%8E%A7%E7%9A%84dashboard%EF%BC%88%E5%8C%85%E5%90%AB%20%E7%9B%B8%E5%85%B3json%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E4%BA%9Bjson%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%BD%9C%E6%98%AF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E6%A8%A1%E6%9D%BF)">① 在grafana上修改配置文件,并下载安装mysql监控的dashboard（包含 相关json文件，这些json文件可以看作是开发人员开发的一个监控模板)</h2>

<p>参考网址: <a href="https://github.com/percona/grafana-dashboards">https://github.com/percona/grafana-dashboards</a></p>

<p>在grafana配置文件里最后加上以下三行</p>

<pre class="has"><code class="language-bash">vim /etc/grafana/grafana.ini 
[dashboards.json] 
enabled = true 
path = /var/lib/grafana/dashboards
</code></pre>

<p><img alt="" class="has" height="94" src="https://img-blog.csdnimg.cn/20200113150203274.png" width="350"></p>

<p><img alt="" class="has" height="159" src="https://img-blog.csdnimg.cn/20200113150322470.png" width="498"></p>

<p>下载配置模板</p>

<pre class="has"><code class="language-bash">cd /var/lib/grafana/ </code></pre>

<pre class="has"><code>git clone https://github.com/percona/grafana-dashboards.git </code></pre>

<pre class="has"><code>cp -r /var/lib/grafana/grafana-dashboards-master/dashboards/ /var/lib/grafana/ 
</code></pre>

<p><img alt="" class="has" height="348" src="https://img-blog.csdnimg.cn/20200113151342364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="960"></p>

<p>重启grafana服务</p>

<pre class="has"><code>systemctl restart grafana-server</code></pre>

<h2 id="%E2%91%A1%20%E5%9C%A8grafana%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3json%E6%96%87%E4%BB%B6">② 在grafana图形界面导入相关json文件</h2>

<p><img alt="" class="has" height="541" src="https://img-blog.csdnimg.cn/20200113151442401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1091"></p>

<p><img alt="" class="has" height="599" src="https://img-blog.csdnimg.cn/20200113151636828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1095"></p>

<p>③ 点import导入后,报prometheus数据源找不到,因为这些json文件里默认 要找的就是叫Prometheus的数据源，但我们前面建立的数据源却是叫 prometheus_data(坑啊)<br>
那么请自行把原来的prometheus_data源改名为Prometheus即可(注意: 第一个字母P是大写)<br>
然后再回去刷新,就有数据了(如下图所示)</p>

<p><img alt="" class="has" height="895" src="https://img-blog.csdnimg.cn/2020011315383743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h1 id="%E7%9B%B8%E5%85%B3%E5%8D%9A%E6%96%87%EF%BC%9A">相关博文：</h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/103952955">1、Centos7安装Promethus(普罗米修斯）监控系统完整版</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/103956583">2、Promethus(普罗米修斯）监控Mysql数据库</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/103956931">3、Promethus(普罗米修斯）安装Grafana可视化图形工具</a></h1>
                                    ]]></description></item><item><title>Promethus(普罗米修斯）安装Grafana可视化图形工具</title><link>http://www.cnblogs.com/heian99/archive/2020/01/13/12189316.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 13 Jan 2020 13:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/13/12189316.html</guid><description><![CDATA[
                                            <h1><a href="https://blog.csdn.net/heian_99/article/details/103952955">Centos7安装Promethus(普罗米修斯）监控系统完整版</a></h1>

<p>&nbsp;</p>

<h1><a href="https://blog.csdn.net/heian_99/article/details/103956583">Promethus(普罗米修斯）监控Mysql数据库</a></h1>

<p><img alt="" class="has" height="997" src="https://img-blog.csdnimg.cn/20200113144441132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>教程使用的软件：链接: <a href="https://pan.baidu.com/s/1QV4KYZksyIp65UsScioq4Q" rel="nofollow">https://pan.baidu.com/s/1QV4KYZksyIp65UsScioq4Q</a> 提取码: vcej</p>

<p>环境配置</p>

<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>服务器</td>
			<td>IP地址</td>
		</tr><tr><td>Prometneus服务器</td>
			<td>192.168.116.129</td>
		</tr><tr><td>被监控服务器（mysql）</td>
			<td>192.168.116.130</td>
		</tr><tr><td>grafana服务器</td>
			<td>192.168.116.131</td>
		</tr></tbody></table><h1>1、什么是Grafana</h1>

<p>&nbsp;Grafana是一个开源的度量分析和可视化工具，可以通过将采集的数据分 析，查询，然后进行可视化的展示,并能实现报警。</p>

<p><img alt="" class="has" height="366" src="https://img-blog.csdnimg.cn/20200113140317374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p>网址: <a href="https://grafana.com/" rel="nofollow">https://grafana.com/</a></p>

<h1>2、使用Grafana连接Prometheus</h1>

<p>&nbsp;</p>

<h2>① 在grafana服务器上安装grafana</h2>

<p>下载地址:<a href="https://grafana.com/grafana/download" rel="nofollow">https://grafana.com/grafana/download</a></p>

<p>上传grafana-5.3.4-1.x86_64.rpm</p>

<p><img alt="" class="has" height="148" src="https://img-blog.csdnimg.cn/20200113140643778.png" width="530"></p>

<p>我这里选择的rpm包，下载后直接rpm -ivh安装就OK【失败原因缺少组件，可以yum安装组件】</p>

<pre class="has"><code class="language-bash">rpm -ivh /root/Desktop/grafana-5.3.41.x86_64.rpm</code></pre>

<p><img alt="" class="has" height="165" src="https://img-blog.csdnimg.cn/20200113140719321.png" width="674"></p>

<p>或者第二种方法【yum安装会自动安装缺少的组件的】</p>

<pre class="has"><code class="language-bash">yum install -y grafana-5.3.4-1.x86_64.rpm 
</code></pre>

<p><img alt="" class="has" height="154" src="https://img-blog.csdnimg.cn/20200113140902426.png" width="611"></p>

<p>启动服务</p>

<pre class="has"><code>systemctl start grafana-server 
systemctl enable grafana-server </code></pre>

<p>确认端口(3000)</p>

<pre class="has"><code>lsof -i:3000
</code></pre>

<p><img alt="" class="has" height="95" src="https://img-blog.csdnimg.cn/20200113141145828.png" width="541"></p>

<h2>② 通过浏览器访问 http:// grafana服务器IP:3000就到了登录界面,使用默 认的admin用户,admin密码就可以登陆了</h2>

<p><img alt="" class="has" height="849" src="https://img-blog.csdnimg.cn/20200113141221182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2>③ 下面我们把prometheus服务器收集的数据做为一个数据源添加到 grafana,让grafana可以得到prometheus的数据。</h2>

<p><img alt="" class="has" height="769" src="https://img-blog.csdnimg.cn/20200113141320184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="876" src="https://img-blog.csdnimg.cn/20200113141836837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="850"></p>

<p><img alt="" class="has" height="682" src="https://img-blog.csdnimg.cn/20200113141918275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2>④ 然后为添加好的数据源做图形显示</h2>

<p><img alt="" class="has" height="630" src="https://img-blog.csdnimg.cn/20200113141945357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1125"></p>

<p><img alt="" class="has" height="674" src="https://img-blog.csdnimg.cn/20200113141955537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1131"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="643" src="https://img-blog.csdnimg.cn/20200113142000200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1124"></p>

<p><img alt="" class="has" height="916" src="https://img-blog.csdnimg.cn/20200113142330949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2>⑤ 保存</h2>

<p><img alt="" class="has" height="296" src="https://img-blog.csdnimg.cn/20200113142408364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2>⑥ 最后在dashboard可以查看到</h2>

<p><img alt="" class="has" height="497" src="https://img-blog.csdnimg.cn/2020011314245957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1095"></p>

<p>⑦ 匹配条件显示</p>

<p><img alt="" class="has" height="803" src="https://img-blog.csdnimg.cn/20200113142634216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                                    ]]></description></item><item><title>Promethus(普罗米修斯）监控Mysql数据库</title><link>http://www.cnblogs.com/heian99/archive/2020/01/13/12189317.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 13 Jan 2020 13:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/13/12189317.html</guid><description><![CDATA[
                                            <h1><a href="https://blog.csdn.net/heian_99/article/details/103952955">Centos7安装Promethus(普罗米修斯）监控系统完整版</a></h1>

<p><strong>Promethus(普罗米修斯）监控Mysql数据库</strong></p>

<p>这个是基于上面环境搭建的，需要的可以访问方面连接查看。</p>

<p>教程使用的软件：链接: <a href="https://pan.baidu.com/s/1QV4KYZksyIp65UsScioq4Q" rel="nofollow">https://pan.baidu.com/s/1QV4KYZksyIp65UsScioq4Q</a> 提取码: vcej</p>

<p>监控远程MySQL</p>

<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>服务器</td>
			<td>IP地址</td>
		</tr><tr><td>Prometneus服务器</td>
			<td>192.168.116.129</td>
		</tr><tr><td>被监控服务器（mysql）</td>
			<td>192.168.116.130</td>
		</tr><tr><td>grafana服务器</td>
			<td>192.168.116.131</td>
		</tr></tbody></table><p>① 在被管理机agent1上安装mysqld_exporter组件<br>
下载地址:<a href="" rel="nofollow"> https://prometheus.io/download/</a></p>

<p>上传mysqld_exporter组件</p>

<p><img alt="" class="has" height="158" src="https://img-blog.csdnimg.cn/20200113134228354.png" width="908"></p>

<p>安装mysqld_exporter组件</p>

<pre class="has"><code class="language-bash">tar xf mysqld_exporter-0.11.0.linux-amd64.tar.gz -C /usr/local/
mv /usr/local/mysqld_exporter-0.11.0.linux-amd64/  /usr/local/mysqld_exporter 
ls /usr/local/mysqld_exporter
</code></pre>

<p><img alt="" class="has" height="125" src="https://img-blog.csdnimg.cn/20200113134407909.png" width="981"></p>

<p>安装mariadb数据库,并授权</p>

<pre class="has"><code class="language-bash">yum install mariadb\* -y 
systemctl restart mariadb 
systemctl enable mariadb 
mysql
</code></pre>

<pre class="has"><code class="language-bash">MariaDB [(none)]&gt; grant select,replication client,process ON *.* to 'mysql_monitor'@'localhost' identified by '123'; </code></pre>

<p>(注意:授权ip为localhost，因为不是prometheus服务器来直接找mariadb 获取数据，而是prometheus服务器找mysql_exporter,mysql_exporter 再找mariadb。所以这个localhost是指的mysql_exporter的IP)</p>

<pre class="has"><code class="language-bash">MariaDB [(none)]&gt; flush privileges;
MariaDB [(none)]&gt; quit
</code></pre>

<p><img alt="" class="has" height="192" src="https://img-blog.csdnimg.cn/20200113134730612.png" width="894"></p>

<p>创建一个mariadb配置文件，写上连接的用户名与密码(和上面的授权的用户名 和密码要对应)</p>

<pre class="has"><code>vim /usr/local/mysqld_exporter/.my.cnf </code></pre>

<pre class="has"><code class="language-bash">[client] 
user=mysql_monitor
password=123</code></pre>

<p><img alt="" class="has" height="149" src="https://img-blog.csdnimg.cn/20200113134832725.png" width="445"></p>

<p>启动mysqld_exporter</p>

<pre class="has"><code>nohup /usr/local/mysqld_exporter/mysqld_exporter --config.my-cnf=/usr/local/mysqld_exporter/.my.cnf &amp;</code></pre>

<p>确认端口(9104)</p>

<p><img alt="" class="has" height="174" src="https://img-blog.csdnimg.cn/20200113135034738.png" width="957"></p>

<p>② 回到prometheus服务器的配置文件里添加被监控的mariadb的配置段</p>

<p>在主配置文件最后再加上下面三行</p>

<pre class="has"><code class="language-bash">vim /usr/local/prometheus/prometheus.yml </code></pre>

<pre class="has"><code>  - job_name: 'mariadb'
    static_configs:
    - targets: ['192.168.116.130:9104']

</code></pre>

<p>&nbsp;</p>

<p><img alt="" class="has" height="167" src="https://img-blog.csdnimg.cn/20200113135509648.png" width="746"></p>

<pre class="has"><code>- job_name: 'agent1_mariadb'  # 取一个job 名称来代表被监控的mariadb &nbsp; 
  static_configs: &nbsp; 
  - targets: ['10.1.1.14:9104']     # 这里改成 被监控机器的IP，后面端口接9104
 </code></pre>

<p>改完配置文件后,重启服务</p>

<pre class="has"><code> pkill prometheus </code></pre>

<pre class="has"><code>/usr/local/prometheus/prometheus --config.file="/usr/local/prometheus/prometheus.yml" &amp;</code></pre>

<p>③ 回到web管理界面 --》点Status --》点Targets --》可以看到监控 mariadb了</p>

<p><img alt="" class="has" height="631" src="https://img-blog.csdnimg.cn/20200113135803881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="754" src="https://img-blog.csdnimg.cn/20200113135844886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                                    ]]></description></item><item><title>Centos7安装Promethus(普罗米修斯）监控系统完整版</title><link>http://www.cnblogs.com/heian99/archive/2020/01/13/12189318.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 13 Jan 2020 13:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/13/12189318.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="%E4%B8%80%E3%80%81%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E6%A6%82%E8%BF%B0" rel="nofollow">一、普罗米修斯概述</a></p>

<p id="%E4%BA%8C%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE" rel="nofollow">二、时间序列数据</a></p>

<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE" rel="nofollow">1、什么是序列数据</a></p>

<p id="2%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E7%89%B9%E7%82%B9" rel="nofollow">2、时间序列数据特点</a></p>

<p id="3%E3%80%81Prometheus%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81-toc" style="margin-left:40px;"><a href="#3%E3%80%81Prometheus%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81" rel="nofollow">3、Prometheus的主要特征</a></p>

<p id="4%E3%80%81%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84%E5%9B%BE-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">4、普罗米修斯原理架构图</a></p>

<p id="%E4%B8%89%E3%80%81%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87" rel="nofollow">三、实验环境准备</a></p>

<p id="1%E3%80%81%E5%AE%89%E8%A3%85prometheus-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%AE%89%E8%A3%85prometheus" rel="nofollow">1、安装prometheus</a></p>

<p id="2%E3%80%81prometheus%E7%95%8C%E9%9D%A2-toc" style="margin-left:40px;"><a href="#2%E3%80%81prometheus%E7%95%8C%E9%9D%A2" rel="nofollow">2、prometheus界面</a></p>

<p id="3%E3%80%81%E4%B8%BB%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%B8%BB%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA" rel="nofollow">3、主机数据展示</a></p>

<p id="4%E3%80%81%E7%9B%91%E6%8E%A7%E8%BF%9C%E7%A8%8BLinux%E4%B8%BB%E6%9C%BA-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E7%9B%91%E6%8E%A7%E8%BF%9C%E7%A8%8BLinux%E4%B8%BB%E6%9C%BA" rel="nofollow">4、监控远程Linux主机</a></p>

<hr id="hr-toc"><h1 id="%E4%B8%80%E3%80%81%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E6%A6%82%E8%BF%B0">一、普罗米修斯概述</h1>

<p>Prometheus(由go语言(golang)开发)是一套开源的监控&amp;报警&amp;时间序列数 据库的组合。适合监控docker容器。因为kubernetes(俗称k8s)的流行带动 了prometheus的发展。<br><a href="https://prometheus.io/docs/introduction/overview/" rel="nofollow">https://prometheus.io/docs/introduction/overview/</a></p>

<h1 id="%E4%BA%8C%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE">二、时间序列数据</h1>

<h2 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE">1、什么是序列数据</h2>

<p><span style="color:#f33b45;"><strong>时间序列数据</strong></span>(TimeSeries Data) : 按照时间顺序记录系统、设备状态变化 的数据被称为时序数据。<br>
应用的场景很多, 如：</p>

<ul><li>无人驾驶车辆运行中要记录的经度，纬度，速度，方向，旁边物体的距 离等等。每时每刻都要将数据记录下来做分析。</li>
	<li>某一个地区的各车辆的行驶轨迹数据</li>
	<li>传统证券行业实时交易数据</li>
	<li>实时运维监控数据等</li>
</ul><h2 id="2%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E7%89%B9%E7%82%B9">2、时间序列数据特点</h2>

<ul><li>性能好</li>
</ul><p>关系型数据库对于大规模数据的处理性能糟糕。NOSQL可以比较好的处理 大规模数据，让依然比不上时间序列数据库。</p>

<ul><li>存储成本低</li>
</ul><p>高效的压缩算法，节省存储空间，有效降低IO<br>
Prometheus有着非常高效的时间序列数据存储方法，每个采样数据仅仅占 用3.5byte左右空间，上百万条时间序列，30秒间隔，保留60天，大概花了 200多G（来自官方数据)</p>

<h2 id="3%E3%80%81Prometheus%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81">3、Prometheus的主要特征</h2>

<p>多维度数据模型 灵活的查询语言 不依赖分布式存储，单个服务器节点是自主的 以HTTP方式，通过pull模型拉去时间序列数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 也可以通过中间网关支持push模型 通过服务发现或者静态配置，来发现目标服务对象 支持多种多样的图表和界面展示</p>

<h2 id="4%E3%80%81%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84%E5%9B%BE">4、普罗米修斯原理架构图</h2>

<p><img alt="" class="has" height="754" src="https://img-blog.csdnimg.cn/20200113095930827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<h1 id="%E4%B8%89%E3%80%81%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">三、实验环境准备</h1>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>服务器</td>
			<td>IP地址</td>
		</tr><tr><td>Prometneus服务器</td>
			<td>192.168.116.129</td>
		</tr><tr><td>被监控服务器</td>
			<td>192.168.116.130</td>
		</tr><tr><td>grafana服务器</td>
			<td>192.168.116.131</td>
		</tr></tbody></table><p>&nbsp;</p>

<p>教程使用的软件：链接: <a href="https://pan.baidu.com/s/1QV4KYZksyIp65UsScioq4Q" rel="nofollow">https://pan.baidu.com/s/1QV4KYZksyIp65UsScioq4Q</a> 提取码: vcej</p>

<p>失效可联系我</p>

<p>1. 静态ip(要求能上外网)</p>

<p>2. 主机名</p>

<pre class="has"><code class="language-bash">各自配置好主机名 
# hostnamectl set-hostname --static server.cluster.com 
三台都互相绑定IP与主机名 
# vim /etc/hosts            
192.168.116.129 &nbsp;master
192.168.116.130  node1
192.168.116.131  node2</code></pre>

<pre class="has"><code>echo "192.168.116.129 master
192.168.116.130 node1
192.168.116.131 node2"&gt;&gt;/etc/hosts</code></pre>

<p>3. 时间同步(时间同步一定要确认一下)</p>

<pre class="has"><code> yum install -y  ntpdate &amp;&amp; ntpdate time.windows.com</code></pre>

<p>4. 关闭防火墙,selinux</p>

<pre class="has"><code># systemctl stop firewalld 
# systemctl disable firewalld 
# iptables -F</code></pre>

<h2 id="1%E3%80%81%E5%AE%89%E8%A3%85prometheus">1、安装prometheus</h2>

<p>从<a href="" rel="nofollow"> https://prometheus.io/download/</a> 下载相应版本，安装到服务器上<br>
官网提供的是二进制版，解压就能用，不需要编译</p>

<p>上传prometheus-2.5.0.linux-amd64.tar.gz</p>

<p><img alt="" class="has" height="146" src="https://img-blog.csdnimg.cn/20200113101351305.png" width="580"></p>

<pre class="has"><code>tar -zxvf prometheus-2.5.0.linux-amd64.tar.gz -C /usr/local/
mv /usr/local/prometheus-2.5.0.linux-amd64/  /usr/local/prometheus</code></pre>

<p><img alt="" class="has" height="439" src="https://img-blog.csdnimg.cn/20200113101544140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="722"></p>

<p>直接使用默认配置文件启动</p>

<pre class="has"><code class="language-bash">/usr/local/prometheus/prometheus --config.file="/usr/local/prometheus/prometheus.yml" &amp;</code></pre>

<p>确认端口(9090)</p>

<pre class="has"><code>ss -anltp | grep 9090
</code></pre>

<p><img alt="" class="has" height="415" src="https://img-blog.csdnimg.cn/20200113101750160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1111"></p>

<h2 id="2%E3%80%81prometheus%E7%95%8C%E9%9D%A2">2、prometheus界面</h2>

<p>通过浏览器访问http://服务器IP:9090就可以访问到prometheus的主界面</p>

<p><img alt="" class="has" height="567" src="https://img-blog.csdnimg.cn/20200113101851876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>默认只监控了本机一台，点Status --》点Targets --》可以看到只监控了本 机</p>

<p><img alt="" class="has" height="514" src="https://img-blog.csdnimg.cn/2020011310193370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="3%E3%80%81%E4%B8%BB%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA">3、主机数据展示</h2>

<p>通过http://服务器IP:9090/metrics可以查看到监控的数据</p>

<p><img alt="" class="has" height="789" src="https://img-blog.csdnimg.cn/20200113102009365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>在web主界面可以通过关键字查询监控项</p>

<p><img alt="" class="has" height="621" src="https://img-blog.csdnimg.cn/20200113102110196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="4%E3%80%81%E7%9B%91%E6%8E%A7%E8%BF%9C%E7%A8%8BLinux%E4%B8%BB%E6%9C%BA">4、监控远程Linux主机</h2>

<p>① 在远程linux主机(被监控端agent1)上安装node_exporter组件<br>
下载地址: <a href="https://prometheus.io/download/" rel="nofollow">https://prometheus.io/download/</a></p>

<p>上传node_exporter-0.16.0.linux-amd64.tar.gz</p>

<p><img alt="" class="has" height="109" src="https://img-blog.csdnimg.cn/20200113102232475.png" width="489"></p>

<pre class="has"><code>tar -zxvf node_exporter-0.16.0.linux-amd64.tar.gz -C /usr/local/
mv /usr/local/node_exporter-0.16.0.linux-amd64/ /usr/local/node_exporter
</code></pre>

<p>里面就一个启动命令node_exporter,可以直接使用此命令启动</p>

<pre class="has"><code>nohup /usr/local/node_exporter/node_exporter &amp; </code></pre>

<p><img alt="" class="has" height="353" src="https://img-blog.csdnimg.cn/2020011310252095.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1031"></p>

<p>确认端口(9100)</p>

<p><img alt="" class="has" height="106" src="https://img-blog.csdnimg.cn/20200113102549361.png" width="908"></p>

<p><strong><span style="color:#f33b45;">扩展: nohup命令: 如果把启动node_exporter的终端给关闭,那么进程也会 随之关闭。nohup命令会帮你解决这个问题。</span></strong></p>

<p>&nbsp;</p>

<p>② 通过浏览器访问http://被监控端IP:9100/metrics就可以查看到 node_exporter在被监控端收集的监控信息</p>

<p><img alt="" class="has" height="805" src="https://img-blog.csdnimg.cn/20200113102712354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>③ 回到prometheus服务器的配置文件里添加被监控机器的配置段</p>

<p>在主配置文件最后加上下面三行</p>

<pre class="has"><code>vim /usr/local/prometheus/prometheus.yml </code></pre>

<pre class="has"><code class="language-bash">  - job_name: 'node1'
    static_configs:
    - targets: ['192.168.116.130:9100']
</code></pre>

<p><img alt="" class="has" height="248" src="https://img-blog.csdnimg.cn/20200113103626972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="957"></p>

<pre class="has"><code class="language-bash">- job_name: 'agent1'                   # 取一个job名称来代 表被监控的机器 &nbsp; 
  static_configs: &nbsp; 
  - targets: ['10.1.1.14:9100']        # 这里改成被监控机器 的IP，后面端口接9100</code></pre>

<p>改完配置文件后,重启服务</p>

<pre class="has"><code> pkill prometheus </code></pre>

<p>确认端口没有进程占用</p>

<p><img alt="" class="has" height="370" src="https://img-blog.csdnimg.cn/20200113103154560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="960"></p>

<pre class="has"><code>/usr/local/prometheus/prometheus --config.file="/usr/local/prometheus/prometheus.yml" &amp;
</code></pre>

<p>&nbsp;确认端口被占用，说 明重启成功</p>

<p><img alt="" class="has" height="392" src="https://img-blog.csdnimg.cn/20200113103316583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1087"></p>

<p>④ 回到web管理界面 --》点Status --》点Targets --》可以看到多了一台监 控目标</p>

<p><img alt="" class="has" height="469" src="https://img-blog.csdnimg.cn/20200113103730436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>练习: 加上本机prometheus的监控<br>
答: 在本机安装node_exporter，也使用上面的方式监控起来。</p>
                                    ]]></description></item><item><title>Centos7下使用Docker搭建本地私有仓库</title><link>http://www.cnblogs.com/heian99/archive/2020/01/12/12182017.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 12 Jan 2020 02:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/12/12182017.html</guid><description><![CDATA[
                                            <p>和Mavan的管理一样，Dockers不仅提供了一个中央仓库，同时也允许我们使用registry搭建本地私有仓库。使用私有仓库有许多优点：</p>

<p>一、节省网络带宽，针对于每个镜像不用每个人都去中央仓库上面去下载，只需要从私有仓库中下载即可；</p>

<p>二、提供镜像资源利用，针对于公司内部使用的镜像，推送到本地的私有仓库中，以供公司内部相关人员使用。</p>

<p>接下来我们就大致说一下如何在本地搭建私有仓库。</p>

<h3>1.拉取镜像仓库</h3>

<pre class="has"><code>docker  pull  registry </code></pre>

<h3>2.查看所有镜像</h3>

<pre class="has"><code> docker images</code></pre>

<p><img alt="" class="has" height="160" src="https://img-blog.csdnimg.cn/20200111160352917.png" width="679"></p>

<h3>3.启动镜像服务器registry</h3>

<p>首先在在主机上新建一个目录，供存储镜像</p>

<pre class="has"><code>cd /usr/local/
mkdir docker_registry </code></pre>

<p><strong>启动镜像</strong></p>

<pre class="has"><code>docker run -d -p 5000:5000 --name=jackspeedregistry --restart=always --privileged=true  -v /usr/local/docker_registry:/var/lib/registry  docker.io/registry</code></pre>

<p>解释：<br>
  -p 5000:5000 端口<br>
  --name=jackspeedregistry 运行的容器名称<br>
  --restart=always 自动重启<br>
   --privileged=true centos7中的安全模块selinux把权限禁止了，加上这行是给容器增加执行权限<br>
  -v /usr/local/docker_registry:/var/lib/registry 把主机的/usr/local/docker_registry 目录挂载到registry容器的/var/lib/registry目录下，假如有删除容器操作，我们的镜像也不会被删除<br>
  docker.io/registry  镜像名称<br>
查看启动的容器</p>

<p><img alt="" class="has" height="161" src="https://img-blog.csdnimg.cn/20200111160523133.png" width="1200"></p>

<h3>4.从公有仓库拉取一个镜像下来，然后push到私有仓库中进行测试</h3>

<h3>当前用nginx镜像做测试</h3>

<pre class="has"><code>docker pull  nginx 
docker images</code></pre>

<p><img alt="" class="has" height="298" src="https://img-blog.csdnimg.cn/20200111160758579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="780"></p>

<h3>5.给docker注册https协议，支持https访问</h3>

<pre class="has"><code>vim /etc/docker/daemon.json</code></pre>

<p>如果daemon文件不存在，vim会自己创建一个，假如一下代码，<br>
  {<br>
  "insecure-registries":["主机的IP地址或者域名:5000"],<br>
   "registry-mirrors": ["<a href="https://registry.docker-cn.com/" rel="nofollow">https://registry.docker-cn.com</a>"]<br>
  }<br>
注释：<br>
  insecure-registries-----&gt;开放注册https协议<br>
  registry-mirrors-----&gt;仓库源</p>

<p><img alt="" class="has" height="222" src="https://img-blog.csdnimg.cn/20200111160928574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h3>6.新建一个tag，把docker.io/nginx名称变成域名或者IP/镜像名称</h3>

<pre class="has"><code>docker tag docker.io/nginx ip或者域名:5000/nginx</code></pre>

<p><strong>推送到本地仓库</strong></p>

<pre class="has"><code>docker push ip或者域名:5000/nginx</code></pre>

<p><img alt="" class="has" height="262" src="https://img-blog.csdnimg.cn/20200111161202963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="792"></p>

<h3>7.进入刚才新建的nginx仓库目录得到</h3>

<p><img alt="" class="has" height="179" src="https://img-blog.csdnimg.cn/20200111161246783.png" width="746"></p>

<h3>删除刚刚tag的镜像 （192.*******:5000/nginx刚才创建的镜像的tag）</h3>

<pre class="has"><code>docker rmi 196.*******:5000/nginx
docker rmi  nginx 
docker images</code></pre>

<p><img alt="" class="has" height="182" src="https://img-blog.csdnimg.cn/2020011116145613.png" width="727"></p>

<p>拉取刚刚自己创建的镜像</p>

<pre class="has"><code>docker pull 192.168.116.131:5000/nginx:1.2</code></pre>

<p><img alt="" class="has" height="304" src="https://img-blog.csdnimg.cn/20200111161607528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="906"></p>

<p><strong>已经完成</strong></p>
                                    ]]></description></item><item><title>CentOS7的Yum安装Kubernetes（k8s）完整版详细教程</title><link>http://www.cnblogs.com/heian99/archive/2020/01/12/12182018.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 12 Jan 2020 02:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/12/12182018.html</guid><description><![CDATA[
                                            <p><a href="https://blog.csdn.net/heian_99/article/details/103888459">kubeadm部署Kubernetes（k8s）完整版详细教程&nbsp;&nbsp;&nbsp; </a></p>

<p>容易配置，但出问题却很难发现。</p>

<p><a href="https://blog.csdn.net/heian_99/article/details/103918683">二进制包安装Kubernetes集群环境完整版</a></p>

<p>配置麻烦，但不容易出现问题，也容易排查。</p>

<p>&nbsp;</p>

<p>对于上面安装Kubernetes方法，有兴趣的可以参考一下。</p>

<p>下面这种方法，容易配置，也不容易出现问题。</p>

<p>&nbsp;</p>

<h1><strong>环境配置</strong></h1>

<p>准备3台服务器（我用的是CentOS7系统）：</p>

<p>Master：192.168.116.129</p>

<p>Node1：192.168.116.130</p>

<p>Node2：192.168.116.131</p>

<p>&nbsp;</p>

<h3>k8s的全生命周期管理：</h3>

<p>&nbsp; 在k8s进行管理应用的时候，基本步骤是：创建集群，部署应用，发布应用，扩展应用，更新应用</p>

<h3>k8s的主要组件，以及它们主要是用来干什么的：</h3>

<p><strong>etcd：</strong>一款开源软件。提供可靠的分布式数据存储服务，用于持久化存储K8s集群的配置和状态</p>

<p><strong>apiservice：</strong>用户程序（如kubectl）、K8s其它组件之间通信的接口。K8s其它组件之间不直接通信，而是通过API server通信的。这一点在上图的连接中可以体现，例如，只有API server连接了etcd，即其它组件更新K8s集群的状态时，只能通过API server读写etcd中的数据。</p>

<p><strong>Scheduler：</strong>排程组件，为用户应用的每一可部署组件分配工作结点。</p>

<p><strong>controller-manager：</strong>执行集群级别的功能，如复制组件、追踪工作结点状态、处理结点失败等。Controller Manager组件是由多个控制器组成的，其中很多控制器是按K8s的资源类型划分的，如Replication Manager（管理ReplicationController 资源），ReplicaSet Controller，PersistentVolume controller。</p>

<p><strong>kube-proxy：</strong>在应用组件间负载均衡网络流量。</p>

<p><strong>kubelet：</strong>管理工作结点上的容器。</p>

<p><strong>Contriner runtime Docker</strong>，&nbsp;rkt等实际运行容器的组件</p>

<p>上面都是些k8s集群所要用到的组件</p>

<h2><strong>master主机上必须要有的组件：</strong></h2>

<p><strong>etcd </strong>：提供分布式数据存储的数据库吧，用于持久化存储k8s集群的配置和状态</p>

<p><strong>kube-apiserver</strong>：api service提供了http rest接口，是整个集群的入口，K8s其它组件之间不直接通信，而是通过API server通信的。（只有API server连接了etcd，即其它组件更新K8s集群的状态时，只能通过API server读写etcd中的数据）</p>

<p><strong>kube-scheduler</strong>：scheduler负责资源的调度</p>

<p><strong>kube-controller-manager</strong>：整个集群的管理控制中心，此组件里面是由多个控制器组成的，如：Replication Manager（管理ReplicationController 资源），ReplicaSet Controller，PersistentVolume controller。主要作用用来复制组件、追踪工作结点状态、处理失败结点</p>

<h2><strong>node节点机上必须要有的组件：</strong></h2>

<p><strong>flannel：</strong>好像是用来支持网络通信的吧</p>

<p><strong>kube-proxy：</strong>用来负载均衡网络流量</p>

<p><strong>kubelet：</strong>用来管理node节点机上的容器</p>

<p><strong>docker：</strong>运行项目镜像容器的组件</p>

<h3><span style="color:#f33b45;">k8s的整个集群运行原理：</span></h3>

<p>master主机上的<span style="color:#f33b45;"><strong>kube-controller-manager</strong></span>是整个集群的控制管理中心，<strong><span style="color:#f33b45;">kube-controler-manager</span></strong>中的node controller模块&nbsp;通过<span style="color:#f33b45;"><strong>apiservice</strong></span>提供的监听接口，实时监控node机的状态信息。</p>

<p>&nbsp;当某个node机器宕机，<strong><span style="color:#f33b45;">controller-manager</span></strong>就会及时排除故障并自动修复。</p>

<p>node节点机上的kubelet进程每隔一段时间周期就会调用一次apiservice接口报告自身状态，<strong>apiservice</strong>接口接受到这些信息后将节点状态更新到<span style="color:#f33b45;"><strong>ectd</strong></span>中。kubelet也通过<span style="color:#f33b45;"><strong>apiservice</strong></span>的监听接口监听<span style="color:#f33b45;"><strong>pod</strong></span>信息，如果监控到新的pod副本被调度绑定到本节点，则执行pod对应的容器的创建和启动，如果监听到pod对象被删除，则删除本节点对应的pod容器。</p>

<h1>Kubernetes安装步骤：</h1>

<h2>1、所有机器上执行以下命令，准备安装环境：(注意是所有机器，主机master，从机node都要安装)</h2>

<p>安装epel-release源</p>

<pre class="has"><code>yum -y install epel-release</code></pre>

<p>所有机器关闭防火墙</p>

<pre class="has"><code class="language-bash">systemctl stop firewalld

systemctl disable firewalld

setenforce 0

#查看防火墙状态
firewall-cmd --state</code></pre>

<p>关闭swap</p>

<pre class="has"><code>swapoff -a</code></pre>

<h2>2、现在开始master主机上安装kubernetes Master</h2>

<pre class="has"><code class="language-bash">yum -y install etcd kubernetes-master
</code></pre>

<h2><span style="color:#f33b45;"><strong>etcd.conf</strong></span></h2>

<p>编辑：<span style="color:#f33b45;"><strong>vi /etc/etcd/etcd.conf</strong></span>文件，修改结果如下：</p>

<p><img alt="" class="has" height="649" src="https://img-blog.csdnimg.cn/20200111105036265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="769"></p>

<h2><span style="color:#f33b45;">apiserver</span></h2>

<p>配置：<span style="color:#f33b45;"><strong>vi /etc/kubernetes/apiserver</strong></span>文件，配置结果如下：</p>

<p><img alt="" class="has" height="560" src="https://img-blog.csdnimg.cn/20200111105318312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1046"></p>

<p>启动etcd、kube-apiserver、kube-controller-manager、kube-scheduler等服务，并设置开机启动。</p>

<pre class="has"><code class="language-bash">for SERVICES in etcd kube-apiserver kube-controller-manager kube-scheduler; do systemctl restart $SERVICES;systemctl enable $SERVICES;systemctl status $SERVICES ; done</code></pre>

<p>在etcd中定义flannel网络</p>

<pre class="has"><code class="language-bash">etcdctl mk /atomic.io/network/config '{"Network":"172.17.0.0/16"}'</code></pre>

<p><img alt="" class="has" height="81" src="https://img-blog.csdnimg.cn/20200111105441620.png" width="668"></p>

<h3>以上master主机上的配置安装什么的都弄完</h3>

<p>&nbsp;</p>

<h2>3、在node机上安装kubernetes Node和flannel组件应用</h2>

<pre class="has"><code>yum -y install flannel kubernetes-node</code></pre>

<h2><span style="color:#f33b45;">flanneld</span></h2>

<p>为flannel网络指定etcd服务，修改<span style="color:#f33b45;"><strong>/etc/sysconfig/flanneld</strong></span>文件，配置结果如下图：</p>

<p><img alt="" class="has" height="326" src="https://img-blog.csdnimg.cn/20200111110129299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="853"></p>

<p>&nbsp;</p>

<h2><span style="color:#f33b45;"><strong>config</strong></span></h2>

<p>修改：<span style="color:#f33b45;"><strong>vi /etc/kubernetes/config</strong></span>文件，配置结果如下图：</p>

<p><img alt="" class="has" height="476" src="https://img-blog.csdnimg.cn/20200111110248825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="876"></p>

<h2><span style="color:#f33b45;"><strong>kubelet</strong></span></h2>

<p>修改node机的kubelet配置文件<span style="color:#f33b45;"><strong>/etc/kubernetes/kubelet</strong></span></p>

<p><img alt="" class="has" height="390" src="https://img-blog.csdnimg.cn/20200111110526409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="943"></p>

<p>node节点机上启动kube-proxy,kubelet,docker,flanneld等服务，并设置开机启动。</p>

<pre class="has"><code>for SERVICES in kube-proxy kubelet docker flanneld;do systemctl restart $SERVICES;systemctl enable $SERVICES;systemctl status $SERVICES; done</code></pre>

<h2>4、在master主机上执行如下命令，查看运行的node节点机器：</h2>

<pre class="has"><code>kubectl get nodes
</code></pre>

<p><img alt="" class="has" height="162" src="https://img-blog.csdnimg.cn/20200111111037563.png" width="433"></p>

<h2>k8s的安装算是完成</h2>

<h2>5、部署 Dashboard</h2>

<p>也可以使用我给配置文件&nbsp;https://www.lanzous.com/i8jjpij</p>

<p>默认镜像国内无法访问，修改镜像地址为： lizhenliang/kubernetes-dashboard-amd64:v1.10.1</p>

<p>默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部：</p>

<p><img alt="" class="has" height="303" src="https://img-blog.csdnimg.cn/20200111111208983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="593"></p>

<p><strong>先Docker拉去镜像</strong></p>

<pre class="has"><code>docker pull  lizhenliang/kubernetes-dashboard-amd64:v1.10.1</code></pre>

<p><strong>执行kubernetes-dashboard.yaml 文件</strong></p>

<pre class="has"><code> kubectl apply -f kubernetes-dashboard.yaml</code></pre>

<p>安装成功</p>

<p><img alt="" class="has" height="176" src="https://img-blog.csdnimg.cn/20200111111230668.png" width="635"></p>

<p>查看暴露的端口</p>

<pre class="has"><code class="language-bash">kubectl get pods,svc -n kube-system</code></pre>

<p><img alt="" class="has" height="356" src="https://img-blog.csdnimg.cn/20200111111248761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="861"></p>

<h2>6. 访问 Dashboard的web界面</h2>

<p><span style="color:#f33b45;"><strong>访问地址：https://NodeIP:30001&nbsp;【必须是https】</strong></span></p>

<p><img alt="" class="has" height="860" src="https://img-blog.csdnimg.cn/20200111111308708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>创建service account并绑定默认cluster-admin管理员集群角色：【依次执行】</strong></p>

<pre class="has"><code>kubectl create serviceaccount dashboard-admin -n kube-system</code></pre>

<pre class="has"><code> kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</code></pre>

<pre class="has"><code> kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk '/dashboard-admin/{print $1}')</code></pre>

<p><img alt="" class="has" height="418" src="https://img-blog.csdnimg.cn/20200111111415701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1079"><br><strong>已经部署完成。</strong></p>

<p><img alt="" class="has" height="1048" src="https://img-blog.csdnimg.cn/20200111111424766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>二进制包安装Kubernetes集群环境完整版</title><link>http://www.cnblogs.com/heian99/archive/2020/01/12/12182019.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 12 Jan 2020 02:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/12/12182019.html</guid><description><![CDATA[
                                            <h1 id="Kubernetes%20%E6%A6%82%E8%BF%B0">Kubernetes 概述</h1>

<h2 id="1.%20Kubernetes%E6%98%AF%E4%BB%80%E4%B9%88">1. Kubernetes是什么</h2>

<ul><li>&nbsp;Kubernetes是Google在2014年开源的一个容器集群管理系统，Kubernetes简称K8S。</li>
	<li>K8S用于容器化应用程序的部署，扩展和管理。</li>
	<li>&nbsp;K8S提供了容器编排，资源调度，弹性伸缩，部署管理，服务发现等一系列功能。</li>
	<li>&nbsp;Kubernetes目标是让部署容器化应用简单高效。</li>
</ul><p>官方网站：http://www.kubernetes.io</p>

<h2 id="2.%20Kubernetes%E7%89%B9%E6%80%A7">2. Kubernetes特性</h2>

<p><span style="color:#f33b45;"><strong>自我修复</strong></span><br>
在节点故障时重新启动失败的容器，替换和重新部署，保证预期的副本数量；杀死健康检查失败的容器，并且在未准备好之前不会处理客户端请求，确保线上服务不中断。<br><span style="color:#f33b45;"><strong>&nbsp;弹性伸缩</strong></span><br>
使用命令、UI或者基于CPU使用情况自动快速扩容和缩容应用程序实例，保证应用业务高峰并发时的高可用性；业务低峰时回收资源，以最小成本运行服务。<br><span style="color:#f33b45;"><strong>&nbsp;自动部署和回滚</strong></span><br>
K8S采用滚动更新策略更新应用，一次更新一个Pod，而不是同时删除所有Pod，如果更新过程中出现问题，将回滚更改，确保升级不受影响业务。<br><span style="color:#f33b45;"><strong>服务发现和负载均衡</strong></span><br>
K8S为多个容器提供一个统一访问入口（内部IP地址和一个DNS名称），并且负载均衡关联的所有容器，使得用户无需考虑容器IP问题。<br><span style="color:#f33b45;"><strong>&nbsp;机密和配置管理</strong></span><br>
管理机密数据和应用程序配置，而不需要把敏感数据暴露在镜像里，提高敏感数据安全性。并可以将一些常用的配置存储在K8S中，方便应用程序使用。<br><span style="color:#f33b45;"><strong>&nbsp;存储编排</strong></span><br>
挂载外部存储系统，无论是来自本地存储，公有云（如AWS），还是网络存储（如NFS、GlusterFS、Ceph）都作为集群资源的一部分使用，极大提高存储使用灵活性。<br><span style="color:#f33b45;"><strong>批处理</strong></span><br>
提供一次性任务，定时任务；满足批量数据处理和分析的场景。</p>

<h2 id="3.%20Kubernetes%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%BB%84%E4%BB%B6">3. Kubernetes集群架构与组件</h2>

<p><img alt="" class="has" height="680" src="https://img-blog.csdnimg.cn/2020011009171635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<h3 id="Master%E7%BB%84%E4%BB%B6">Master组件</h3>

<ul><li>kube-apiserver Kubernetes API&nbsp; 集群的统一入口，各组件协调者，以 RESTful API提供接口服务，所有对象资源的增删改查和监听 操作都交给APIServer处理后再提交给Etcd存储。</li>
	<li>kube-controller-manager 处理集群中常规后台任务，一个资源对应一个控制器，而 ControllerManager就是负责管理这些控制器的。</li>
	<li>kube-scheduler 根据调度算法为新创建的Pod选择一个Node节点，可以任意 部署,可以部署在同一个节点上,也可以部署在不同的节点上。</li>
	<li>etcd 分布式键值存储系统。用于保存集群状态数据，比如Pod、 Service等对象信息。</li>
</ul><h3 id="Node%E7%BB%84%E4%BB%B6">Node组件</h3>

<ul><li>kubelet kubelet 是Master在Node节点上的Agent，管理本机运行容器 的生命周期，比如创建容器、Pod挂载数据卷、下载secret、获 取容器和节点状态等工作。</li>
	<li>kubelet&nbsp;&nbsp; 将每个Pod转换成一组容器。</li>
	<li>kube-proxy 在Node节点上实现Pod网络代理，维护网络规则和四层负载均 衡工作。 docker或rocket 容器引擎，运行容器</li>
</ul><h2 id="4.%20Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">4. Kubernetes核心概念</h2>

<h3 id="%C2%A0Pod">&nbsp;<strong>Pod </strong></h3>

<ul><li>最小部署单元</li>
	<li>&nbsp;一组容器的集合</li>
	<li>一个Pod中的容器共享网络命名空间</li>
	<li>&nbsp;Pod是短暂的</li>
</ul><h3 id="Controllers">Controllers</h3>

<ul><li>ReplicaSet ： 确保预期的Pod副本数量&nbsp;</li>
	<li>Deployment ： 无状态应用部署&nbsp;</li>
	<li>StatefulSet ： 有状态应用部署</li>
	<li>DaemonSet ： 确保所有Node运行同一个Pod&nbsp;</li>
	<li>Job ： 一次性任务&nbsp;</li>
	<li>Cronjob ： 定时任务</li>
	<li>更高级层次对象，部署和管理Pod</li>
</ul><h3 id="%C2%A0Service">&nbsp;Service</h3>

<ul><li>防止Pod失联</li>
	<li>&nbsp;定义一组Pod的访问策略</li>
</ul><h3 id="Label">Label</h3>

<ul><li>标签，附加到某个资源上，用于关联对象、查询和筛选</li>
</ul><h3 id="Namespace%C2%A0">Namespace&nbsp;</h3>

<ul><li>命名空间，将对象逻辑上隔离</li>
</ul><h1 id="%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%20Kubernetes%20%E9%9B%86%E7%BE%A4">搭建一个 Kubernetes 集群</h1>

<h2 id="1.%20%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%89%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F">1. 官方提供的三种部署方式</h2>

<ul><li><span style="color:#333333;"><strong>minikube</strong></span></li>
</ul><p style="margin-left:0cm;"><span style="color:#3d464d;">Minikube</span><span style="color:#3d464d;">是一个工具，可以在本地快速运行一个单点的</span><span style="color:#3d464d;">Kubernetes</span><span style="color:#3d464d;">，尝试</span><span style="color:#3d464d;">Kubernetes</span><span style="color:#3d464d;">或日常开发的用户使用。不能用于生产环境。</span></p>

<p style="margin-left:0cm;"><span style="color:#3d464d;">官方地址：</span><a href="https://kubernetes.io/docs/setup/minikube/" rel="nofollow"><span style="color:#4285f4;">https://kubernetes.io/docs/setup/minikube/</span></a></p>

<ul><li><span style="color:#333333;"><strong>kubeadm</strong></span></li>
</ul><p style="margin-left:0cm;"><span style="color:#3d464d;">Kubeadm</span><span style="color:#3d464d;">也是一个工具，提供</span><span style="color:#3d464d;">kubeadm init</span><span style="color:#3d464d;">和</span><span style="color:#3d464d;">kubeadm join</span><span style="color:#3d464d;">，用于快速部署</span><span style="color:#3d464d;">Kubernetes</span><span style="color:#3d464d;">集群。</span></p>

<p style="margin-left:0cm;"><span style="color:#3d464d;">官方地址：</span><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" rel="nofollow"><span style="color:#4285f4;">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</span></a></p>

<ul><li><span style="color:#333333;"><strong>二进制包</strong></span></li>
</ul><p style="margin-left:0cm;"><span style="color:#3d464d;">从官方下载发行版的二进制包，手动部署每个组件，组成</span><span style="color:#3d464d;">Kubernetes</span><span style="color:#3d464d;">集群。</span></p>

<p style="margin-left:0cm;"><strong><span style="color:#3d464d;">小结：</span></strong><br><span style="color:#3d464d;">生产环境中部署</span><span style="color:#3d464d;">Kubernetes</span><span style="color:#3d464d;">集群，只有</span><span style="color:#3d464d;">Kubeadm</span><span style="color:#3d464d;">和二进制包可选，</span><span style="color:#3d464d;">Kubeadm</span><span style="color:#3d464d;">降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。我们这里使用二进制包部署</span><span style="color:#3d464d;">Kubernetes</span><span style="color:#3d464d;">集群，我也是推荐大家使用这种方式，虽然手动部署麻烦点，但学习很多工作原理，更有利于后期维护。</span></p>

<h2 id="2.%20Kubernetes%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E8%A7%84%E5%88%92">2. Kubernetes集群环境规划</h2>

<p style="margin-left:0cm;"><strong><span style="color:#3d464d;">软件环境</span></strong></p>

<table border="1" cellspacing="0"><thead><tr><td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><strong><span style="color:#333333;">软件</span></strong></p>
			</td>
			<td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><strong><span style="color:#333333;">版本</span></strong></p>
			</td>
		</tr></thead><tbody><tr><td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><span style="color:#333333;">操作系统</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">CentOS7.5_x64</span></p>
			</td>
		</tr><tr><td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><span style="color:#333333;">Docker</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">18-ce</span></p>
			</td>
		</tr><tr><td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><span style="color:#333333;">Kubernetes</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">1.12</span></p>
			</td>
		</tr></tbody></table><p><strong>服务器角色</strong></p>

<table border="1" cellspacing="0"><thead><tr><td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><strong><span style="color:#333333;">角色</span></strong></p>
			</td>
			<td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><strong><span style="color:#333333;">IP</span></strong></p>
			</td>
			<td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><strong><span style="color:#333333;">组件</span></strong></p>
			</td>
		</tr></thead><tbody><tr><td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><span style="color:#333333;">k8s-master</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">192.168.116.129</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">kube-apiserver</span><span style="color:#333333;">，</span><span style="color:#333333;">kube-controller-manager</span><span style="color:#333333;">，</span><span style="color:#333333;">kube-scheduler</span><span style="color:#333333;">，</span><span style="color:#333333;">etcd</span></p>
			</td>
		</tr><tr><td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><span style="color:#333333;">k8s-node1</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">192.168.116.130</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">kubelet</span><span style="color:#333333;">，</span><span style="color:#333333;">kube-proxy</span><span style="color:#333333;">，</span><span style="color:#333333;">docker</span><span style="color:#333333;">，</span><span style="color:#333333;">flannel</span><span style="color:#333333;">，</span><span style="color:#333333;">etcd</span></p>
			</td>
		</tr><tr><td style="border-color:#dddddd;">
			<p style="margin-left:0cm;"><span style="color:#333333;">k8s-node2</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">192.168.116.131</span></p>
			</td>
			<td>
			<p style="margin-left:0cm;"><span style="color:#333333;">kubelet</span><span style="color:#333333;">，</span><span style="color:#333333;">kube-proxy</span><span style="color:#333333;">，</span><span style="color:#333333;">docker</span><span style="color:#333333;">，</span><span style="color:#333333;">flannel</span><span style="color:#333333;">，</span><span style="color:#333333;">etcd</span></p>
			</td>
		</tr></tbody></table><p><strong>需要的软件和脚本，失效可联系我</strong></p>

<p><strong>链接: https://pan.baidu.com/s/1Vr8jOFgo4b8tQM9AUtXC_A 提取码: yhhn&nbsp;</strong></p>

<p><strong><span style="color:#3d464d;">架构图</span></strong></p>

<h2 id="%E2%80%8B"><img alt="" class="has" height="393" src="https://img-blog.csdnimg.cn/20200110092520378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="807"></h2>

<h2 id="3.%20HTTPS%E8%AF%81%E4%B9%A6%E4%BB%8B%E7%BB%8D">3. HTTPS证书介绍</h2>

<p><strong>1、关闭selinux</strong></p>

<pre class="has"><code> sed -i 's/enforcing/disabled/' /etc/selinux/config 
 setenforce 0</code></pre>

<p><strong>2、关闭防火墙</strong></p>

<pre class="has"><code>systemctl stop firewalld
systemctl disable firewalld</code></pre>

<p><strong>3、关闭swap</strong></p>

<pre class="has"><code>swapoff -a</code></pre>

<p><strong>4、修改主机名</strong></p>

<pre class="has"><code>hostnamectl set-hostname 名字</code></pre>

<p><strong>5、同步时间</strong></p>

<pre class="has"><code> yum install -y ntpdate &amp;&amp; ntpdate time.windows.com</code></pre>

<p><strong>以上步骤可以参考下方链接</strong></p>

<p><strong><a href="https://blog.csdn.net/heian_99/article/details/103888459">kubeadm部署Kubernetes（k8s）完整版详细教程</a></strong></p>

<h3 id="%E8%87%AA%E7%AD%BESSL%E8%AF%81%E4%B9%A6"><strong>自签SSL证书</strong></h3>

<p><img alt="" class="has" height="366" src="https://img-blog.csdnimg.cn/20200110093817699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="890"></p>

<p>准备使用etcd-cert生成证书</p>

<p><img alt="" class="has" height="228" src="https://img-blog.csdnimg.cn/20200110095246702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="596"></p>

<p><strong>上传cfssl.sh，运行脚本</strong></p>

<p><img alt="" class="has" height="325" src="https://img-blog.csdnimg.cn/2020011009594425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="838"></p>

<p><strong>生成下面两个文件，记住是tab补全查看</strong></p>

<p><img alt="" class="has" height="118" src="https://img-blog.csdnimg.cn/20200110100050808.png" width="580"></p>

<p><strong>执行下面命令，生成两个文件</strong></p>

<pre class="has"><code class="language-bash">cat &gt; ca-config.json &lt;&lt;EOF
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "www": {
         "expiry": "87600h",
         "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ]
      }
    }
  }
}
EOF

cat &gt; ca-csr.json &lt;&lt;EOF
{
    "CN": "etcd CA",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "Beijing",
            "ST": "Beijing"
        }
    ]
}
EOF
</code></pre>

<p><img alt="" class="has" height="133" src="https://img-blog.csdnimg.cn/20200110100356807.png" width="565"></p>

<p>执行</p>

<pre class="has"><code class="language-bash">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
</code></pre>

<p><img alt="" class="has" height="248" src="https://img-blog.csdnimg.cn/2020011010052256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="962"></p>

<pre class="has"><code class="language-bash">cat etcd-cert.sh 
</code></pre>

<p><img alt="" class="has" height="384" src="https://img-blog.csdnimg.cn/20200110100823401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="996"></p>

<pre class="has"><code class="language-bash">cat &gt; server-csr.json &lt;&lt;EOF
{
    "CN": "etcd",
    "hosts": [
    "192.168.116.129",
    "192.168.116.130",
    "192.168.116.131"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "BeiJing",
            "ST": "BeiJing"
        }
    ]
}
EOF</code></pre>

<p><img alt="" class="has" height="450" src="https://img-blog.csdnimg.cn/20200110101040603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="889"></p>

<p><strong>颁发证书</strong></p>

<pre class="has"><code class="language-bash">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server
</code></pre>

<h2><img alt="" class="has" height="324" src="https://img-blog.csdnimg.cn/20200110101348951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1161"></h2>

<h2>4. Etcd数据库集群部署</h2>

<h2>上传etcd安装包</h2>

<p>【etcd-v3.3.10-linux-amd64.tar.gz】</p>

<p><img alt="" class="has" height="220" src="https://img-blog.csdnimg.cn/20200110101621852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="565"></p>

<p>解压</p>

<pre class="has"><code class="language-bash"> tar zxvf etcd-v3.3.10-linux-amd64.tar.gz 
</code></pre>

<h2><img alt="" class="has" height="175" src="https://img-blog.csdnimg.cn/20200110101844730.png" width="765"></h2>

<p>为了方便安装，创建下面目录安装。</p>

<pre class="has"><code class="language-bash">[root@master etcd-v3.3.10-linux-amd64]# mkdir -p  /opt/etcd/{cfg,bin,ssl}
[root@master etcd-v3.3.10-linux-amd64]# ls /opt/etcd/
bin  cfg  ssl
[root@master etcd-v3.3.10-linux-amd64]# mv etcd etcdctl /opt/etcd/bin/
[root@master etcd-v3.3.10-linux-amd64]# ls /opt/etcd/bin/
etcd  etcdctl
</code></pre>

<h2><img alt="" class="has" height="218" src="https://img-blog.csdnimg.cn/20200110102138508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="642"></h2>

<h2>使用脚本部署etcd</h2>

<p><img alt="" class="has" height="114" src="https://img-blog.csdnimg.cn/20200110102351198.png" width="299"></p>

<pre class="has"><code>chmod +x etcd.sh 
</code></pre>

<h2>运行脚本</h2>

<pre class="has"><code class="language-bash">./etcd.sh etcd01 192.168.116.129 etcd02=https://192.168.116.130:2380,etcd03=https://192.168.116.131:2380
</code></pre>

<h2 id="4.%20Etcd%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><img alt="" class="has" height="83" src="https://img-blog.csdnimg.cn/20200110105006392.png" width="1161"></h2>

<p>可以查看etcd的运行服务文件</p>

<pre class="has"><code>cat /usr/lib/systemd/system/etcd.service </code></pre>

<p><img alt="" class="has" height="387" src="https://img-blog.csdnimg.cn/20200110105358535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>拷贝证书</p>

<pre class="has"><code> cp /root/k8s/etcd-cert/{ca,server-key,server}.pem /opt/etcd/ssl/
</code></pre>

<p><img alt="" class="has" height="110" src="https://img-blog.csdnimg.cn/20200110105603848.png" width="823"></p>

<h2>启动etcd</h2>

<pre class="has"><code>systemctl start etcd
</code></pre>

<p>&nbsp;</p>

<p><span style="color:#f33b45;"><strong>已经部署一个成功，但是还有两个机器没有部署etcd。需要把/opt/的etcd目录移到其余节点配置</strong></span></p>

<p><span style="color:#f33b45;"><strong>还有/usr/lib/systemd/system/etcd.service这个配置文件</strong></span></p>

<p>&nbsp;</p>

<p>拷贝过去还需要修改配置文件才能启动。</p>

<pre class="has"><code>vi /opt/etcd/cfg/etcd
</code></pre>

<p>这几个需要修改本机对于的ip</p>

<p><img alt="" class="has" height="285" src="https://img-blog.csdnimg.cn/2020011011111949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1166"></p>

<p>切忌要给下方的文件执行权限，不然会报错</p>

<pre class="has"><code>/opt/etcd/bin</code></pre>

<p><img alt="" class="has" height="159" src="https://img-blog.csdnimg.cn/20200110112657217.png" width="474"></p>

<p>启动</p>

<pre class="has"><code>systemctl daemon-reload
</code></pre>

<pre class="has"><code>systemctl start etcd
</code></pre>

<p>已经完成启动</p>

<p><img alt="" class="has" height="173" src="https://img-blog.csdnimg.cn/20200110112746981.png" width="1200"></p>

<p>在node2也按照上方部署就行。</p>

<p>查看先前日志【没有报任何错误，已经成功搭建集群】</p>

<pre class="has"><code class="language-bash">tail /var/log/messages -f
</code></pre>

<p><img alt="" class="has" height="233" src="https://img-blog.csdnimg.cn/20200110112938482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1049"></p>

<h2>测试</h2>

<pre class="has"><code>/opt/etcd/bin/etcdctl --ca-file=/opt/etcd/ssl/ca.pem --cert-file=/opt/etcd/ssl/server.pem --key-file=/opt/etcd/ssl/server-key.pem --endpoints="https://192.168.116.129:2379,https://192.168.116.130:2379,https://192.168.116.131:2379"  cluster-health</code></pre>

<h2><img alt="" class="has" height="166" src="https://img-blog.csdnimg.cn/20200110115352310.png" width="1200"></h2>

<h2 id="5.%20Node%E5%AE%89%E8%A3%85Docker">5. Node安装Docker</h2>

<p><img alt="" class="has" height="603" src="https://img-blog.csdnimg.cn/20200110133914952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="907"></p>

<p><strong>安装依赖软件</strong></p>

<pre class="has"><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre>

<pre class="has"><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre>

<p><strong>安装docker-ce</strong></p>

<pre class="has"><code>yum install docker-ce -y</code></pre>

<p><strong>配置docker加速器</strong></p>

<pre class="has"><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://bc437cce.m.daocloud.io</code></pre>

<p><strong>启动docker</strong></p>

<pre class="has"><code> systemctl start docker</code></pre>

<p><strong>开机自启</strong></p>

<pre class="has"><code>systemctl enable docker</code></pre>

<p>&nbsp;</p>

<h2 id="6.%20Flannel%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2">6. Flannel容器集群网络部署</h2>

<p><strong>Kubernetes网络模型设计基本要求：</strong></p>

<ul><li>一个Pod一个IP</li>
	<li>每个Pod独立IP，Pod内所有容器共享网络（同一个IP）</li>
	<li>所有容器都可以与所有其他容器通信</li>
	<li>所有节点都可以与所有有容器通信</li>
</ul><p><strong><span style="color:#3d464d;">工作原理：</span></strong></p>

<p><img alt="" class="has" height="542" src="https://img-blog.csdnimg.cn/20200110135434520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="795"></p>

<p><strong>添加网段</strong></p>

<pre class="has"><code>/opt/etcd/bin/etcdctl --ca-file=/opt/etcd/ssl/ca.pem --cert-file=/opt/etcd/ssl/server.pem --key-file=/opt/etcd/ssl/server-key.pem --endpoints="https://192.168.116.129:2379,https://192.168.116.130:2379,https://192.168.116.131:2379" set /coreos.com/network/config  '{ "Network": "172.17.0.0/16", "Backend": {"Type": "vxlan"}}'</code></pre>

<p><img alt="" class="has" height="118" src="https://img-blog.csdnimg.cn/20200110141155825.png" width="1200"></p>

<pre class="has"><code>/opt/etcd/bin/etcdctl --ca-file=/opt/etcd/ssl/ca.pem --cert-file=/opt/etcd/ssl/server.pem --key-file=/opt/etcd/ssl/server-key.pem --endpoints="https://192.168.116.129:2379,https://192.168.116.130:2379,https://192.168.116.131:2379" get /coreos.com/network/config </code></pre>

<p><img alt="" class="has" height="130" src="https://img-blog.csdnimg.cn/20200110141310162.png" width="1200"></p>

<p><strong>上传Flannel【<span style="color:#f33b45;">在node上部署flannel</span>】</strong></p>

<p><img alt="" class="has" height="270" src="https://img-blog.csdnimg.cn/20200110142117253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="698"></p>

<p><strong>方便管理flannel，创建下面文件</strong></p>

<pre class="has"><code class="language-bash">mkdir -p /opt/kubernetes/{bin,cfg,ssl}
</code></pre>

<p><strong>使用flannel连接etcd形式执行脚本</strong></p>

<pre class="has"><code> ./flannel.sh https://192.168.116.129:2379,https://192.168.116.130:2379,https://192.168.116.131:2379
</code></pre>

<p><img alt="" class="has" height="230" src="https://img-blog.csdnimg.cn/20200110142719774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1185"></p>

<p>解压flannel-v0.10.0-linux-amd64.tar.gz</p>

<pre class="has"><code>tar zxvf flannel-v0.10.0-linux-amd64.tar.gz</code></pre>

<p><img alt="" class="has" height="228" src="https://img-blog.csdnimg.cn/20200110143348452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="943"></p>

<pre class="has"><code>mv flanneld mk-docker-opts.sh /opt/kubernetes/bin/
</code></pre>

<p><strong>启动flannel，成功</strong></p>

<pre class="has"><code>systemctl start flanneld
</code></pre>

<p><img alt="" class="has" height="142" src="https://img-blog.csdnimg.cn/20200110143438113.png" width="1200"></p>

<p>重启docker</p>

<pre class="has"><code>systemctl restart docker</code></pre>

<p><img alt="" class="has" height="109" src="https://img-blog.csdnimg.cn/20200110143652124.png" width="881"></p>

<p><strong>安装openssh-clients，把flannel的配置文件复制到Node2上。</strong></p>

<pre class="has"><code> yum install -y openssh-clients</code></pre>

<p>传输到Node2上</p>

<pre class="has"><code> scp -r /opt/kubernetes/ root@192.168.116.131:/opt/
</code></pre>

<pre class="has"><code class="language-bash">scp /usr/lib/systemd/system/{flanneld,docker}.service root@192.168.116.131:/usr/lib/systemd/system/</code></pre>

<p><img alt="" class="has" height="251" src="https://img-blog.csdnimg.cn/20200110145102216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>在Node2上启动flanneld</strong></p>

<pre class="has"><code> systemctl start flanneld
 systemctl start docker</code></pre>

<h2><img alt="" class="has" height="194" src="https://img-blog.csdnimg.cn/2020011014535221.png" width="977"></h2>

<h2 id="7.%20%E9%83%A8%E7%BD%B2Master%E7%BB%84%E4%BB%B6">7. 部署Master组件</h2>

<p><strong>1. kube-apiserver </strong></p>

<p><strong>2. kube-controller-manager </strong></p>

<p><strong>3. kube-scheduler</strong></p>

<p><br><strong>配置文件 -&gt; systemd管理组件 -&gt; 启动</strong></p>

<p><strong>上传Master</strong></p>

<pre class="has"><code>unzip master.zip 
</code></pre>

<p><img alt="" class="has" height="208" src="https://img-blog.csdnimg.cn/20200110161100879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="876"></p>

<p><strong>上传kubernetes-server-linux-amd64.tar.gz</strong></p>

<pre class="has"><code> tar zxvf kubernetes-server-linux-amd64.tar.gz</code></pre>

<p><img alt="" class="has" height="189" src="https://img-blog.csdnimg.cn/20200110173523120.png" width="1019"></p>

<p>创建安装目录，方便使用</p>

<pre class="has"><code> mkdir -p /opt/kubernetes/{bin,cfg,ssl}
</code></pre>

<p>来到/root/k8s/soft/kubernetes/server/bin目录下拷贝文件</p>

<pre class="has"><code> cp kube-apiserver kube-controller-manager kube-scheduler /opt/kubernetes/bin/
</code></pre>

<p><img alt="" class="has" height="261" src="https://img-blog.csdnimg.cn/20200110173804779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>执行apiserver.sh 【脚本 masterip etcd的ip】</strong></p>

<pre class="has"><code class="language-bash">./apiserver.sh 192.168.116.129 https://192.168.116.129:2379,https://192.168.116.130:2379,https://192.168.116.131:2379
</code></pre>

<p>查看生成的配文件</p>

<pre class="has"><code>cat /opt/kubernetes/cfg/kube-apiserver </code></pre>

<p><img alt="" class="has" height="285" src="https://img-blog.csdnimg.cn/20200110174803331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="636"></p>

<p><strong>上传k8s-cert.sh，生成证书</strong></p>

<p><img alt="" class="has" height="569" src="https://img-blog.csdnimg.cn/20200110180201635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="764"></p>

<pre class="has"><code> bash k8s-cert.sh</code></pre>

<p><img alt="" class="has" height="681" src="https://img-blog.csdnimg.cn/20200110180239481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1104"></p>

<p>复制证书到/opt/kubernetes/ssl/里</p>

<pre class="has"><code>cp ca.pem ca-key.pem server.pem server-key.pem /opt/kubernetes/ssl/
</code></pre>

<p><img alt="" class="has" height="276" src="https://img-blog.csdnimg.cn/20200110180449436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>上传token配置文件，生成token。</strong></p>

<p><img alt="" class="has" height="155" src="https://img-blog.csdnimg.cn/20200110180753569.png" width="1137"></p>

<pre class="has"><code>BOOTSTRAP_TOKEN=0fb61c46f8991b718eb38d27b605b008

cat &gt; token.csv &lt;&lt;EOF
${BOOTSTRAP_TOKEN},kubelet-bootstrap,10001,"system:kubelet-bootstrap"
EOF
</code></pre>

<h2><img alt="" class="has" height="508" src="https://img-blog.csdnimg.cn/20200110180856922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="560"></h2>

<h2>生成token.csv</h2>

<p><img alt="" class="has" height="140" src="https://img-blog.csdnimg.cn/20200110180950628.png" width="1200"></p>

<h2>文件移动</h2>

<pre class="has"><code>mv token.csv /opt/kubernetes/cfg/</code></pre>

<h2><img alt="" class="has" height="251" src="https://img-blog.csdnimg.cn/2020011018115476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="744"></h2>

<p><strong>启动kube-apiserver</strong></p>

<pre class="has"><code class="language-bash">systemctl restart kube-apiserver
</code></pre>

<p><img alt="" class="has" height="222" src="https://img-blog.csdnimg.cn/20200110181327729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>查看监听端口</strong></p>

<pre class="has"><code class="language-bash">[root@master k8s-cert]# netstat -ano | grep 8080
tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN      off (0.00/0/0)
[root@master k8s-cert]# netstat -ano | grep 6443
tcp        0      0 192.168.116.129:6443    0.0.0.0:*               LISTEN      off (0.00/0/0)
tcp        0      0 192.168.116.129:44594   192.168.116.129:6443    ESTABLISHED keepalive (9.93/0/0)
tcp        0      0 192.168.116.129:6443    192.168.116.129:44594   ESTABLISHED keepalive (109.64/0/0)
</code></pre>

<p><img alt="" class="has" height="130" src="https://img-blog.csdnimg.cn/20200110182052356.png" width="818"></p>

<p><strong>运行controller-manager.sh</strong></p>

<pre class="has"><code class="language-bash"> ./controller-manager.sh 127.0.0.1
./scheduler.sh 127.0.0.1

</code></pre>

<pre class="has"><code>[root@master k8s]# ls
apiserver.sh  controller-manager.sh  etcd-cert  etcd.sh  flannel.sh  k8s-cert  master.zip  scheduler.sh  soft
[root@master k8s]# ./controller-manager.sh 127.0.0.1
Created symlink from /etc/systemd/system/multi-user.target.wants/kube-controller-manager.service to /usr/lib/systemd/system/kube-controller-manager.service.
[root@master k8s]# ./scheduler.sh 127.0.0.1
Created symlink from /etc/systemd/system/multi-user.target.wants/kube-scheduler.service to /usr/lib/systemd/system/kube-scheduler.service.</code></pre>

<p><img alt="" class="has" height="236" src="https://img-blog.csdnimg.cn/20200110182349745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>创建kubectl管理工具</strong></p>

<pre class="has"><code> cp kubectl /usr/bin/
</code></pre>

<p><img alt="" class="has" height="350" src="https://img-blog.csdnimg.cn/20200110182826411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>查看集群健康状态</strong></p>

<pre class="has"><code> kubectl get cs
</code></pre>

<h2><img alt="" class="has" height="117" src="https://img-blog.csdnimg.cn/20200110182934988.png" width="478"></h2>

<p><strong>查看资源名字简写</strong></p>

<pre class="has"><code>kubectl api-resources
</code></pre>

<h2 id="8.%20%E9%83%A8%E7%BD%B2Node%E7%BB%84%E4%BB%B6">8. 部署Node组件</h2>

<p><img alt="" class="has" height="681" src="https://img-blog.csdnimg.cn/20200110183409499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="809"></p>

<h2>1. 将kubelet-bootstrap用户绑定到系统集群角色</h2>

<pre class="has"><code class="language-bash">kubectl create clusterrolebinding kubelet-bootstrap \
--clusterrole=system:node-bootstrapper \
--user=kubelet-bootstrap</code></pre>

<h2><img alt="" class="has" height="153" src="https://img-blog.csdnimg.cn/20200110183302971.png" width="636"></h2>

<h2>2. 创建kubeconfig文件</h2>

<pre class="has"><code class="language-bash">#----------------------

APISERVER=$1
SSL_DIR=$2
#需要先前创建的token
BOOTSTRAP_TOKEN=0fb61c46f8991b718eb38d27b605b008

# 创建kubelet bootstrapping kubeconfig 
export KUBE_APISERVER="https://$APISERVER:6443"

# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=$SSL_DIR/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=bootstrap.kubeconfig

# 设置客户端认证参数
kubectl config set-credentials kubelet-bootstrap \
  --token=${BOOTSTRAP_TOKEN} \
  --kubeconfig=bootstrap.kubeconfig

# 设置上下文参数
kubectl config set-context default \
  --cluster=kubernetes \
  --user=kubelet-bootstrap \
  --kubeconfig=bootstrap.kubeconfig

# 设置默认上下文
kubectl config use-context default --kubeconfig=bootstrap.kubeconfig

#----------------------

# 创建kube-proxy kubeconfig文件

kubectl config set-cluster kubernetes \
  --certificate-authority=$SSL_DIR/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=kube-proxy.kubeconfig

kubectl config set-credentials kube-proxy \
  --client-certificate=$SSL_DIR/kube-proxy.pem \
  --client-key=$SSL_DIR/kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-proxy.kubeconfig

kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=kube-proxy.kubeconfig

kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
</code></pre>

<p><strong>执行脚本</strong></p>

<pre class="has"><code class="language-bash"> bash kubeconfig.sh 192.168.116.129 /root/k8s/k8s-cert/
</code></pre>

<h2><img alt="" class="has" height="306" src="https://img-blog.csdnimg.cn/20200110184023555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></h2>

<p><strong>把这两个文件拷贝到2个Node的/opt/kubernetes/cfg/</strong></p>

<pre class="has"><code class="language-bash">scp bootstrap.kubeconfig kube-proxy.kubeconfig root@192.168.116.130:/opt/kubernetes/cfg/
scp bootstrap.kubeconfig kube-proxy.kubeconfig root@192.168.116.131:/opt/kubernetes/cfg/
</code></pre>

<h2><img alt="" class="has" height="412" src="https://img-blog.csdnimg.cn/20200110185122210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"><br>
3. 部署kubelet，kube-proxy组件</h2>

<p><strong>上传node包</strong></p>

<p><img alt="" class="has" height="205" src="https://img-blog.csdnimg.cn/20200110185242451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="866"></p>

<p><strong>把matser里面的kubelet和kube-poxy拷贝过来</strong></p>

<pre class="has"><code class="language-bash">scp kubelet kube-proxy root@192.168.116.130:/opt/kubernetes/bin/
scp kubelet kube-proxy root@192.168.116.131:/opt/kubernetes/bin/
</code></pre>

<h2><img alt="" class="has" height="427" src="https://img-blog.csdnimg.cn/20200110190055469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></h2>

<h2>运行 kubelet.sh</h2>

<pre class="has"><code> bash kubelet.sh 192.168.116.130
</code></pre>

<h2><img alt="" class="has" height="208" src="https://img-blog.csdnimg.cn/2020011019035585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></h2>

<h2>Master节点颁发csr</h2>

<pre class="has"><code>kubectl get csr</code></pre>

<pre class="has"><code>kubectl certificate approve node-csr-96wka1dqU6bV1MMXD1nNUw14Av8NU6H6IW11ecJlYM0
</code></pre>

<p><img alt="" class="has" height="273" src="https://img-blog.csdnimg.cn/20200110190737168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1025"></p>

<p><strong>运行proxy.sh</strong></p>

<pre class="has"><code>bash proxy.sh 192.168.116.130
</code></pre>

<p><img alt="" class="has" height="269" src="https://img-blog.csdnimg.cn/20200110191024318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="9.%20%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B">9. 部署多个Node操作</h2>

<p><span style="color:#f33b45;"><strong>复制粘贴Node1已经部署好的文件</strong></span></p>

<pre class="has"><code class="language-bash">scp -r /opt/kubernetes/ root@192.168.116.131:/opt/
</code></pre>

<p><img alt="" class="has" height="430" src="https://img-blog.csdnimg.cn/20200110191924709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<pre class="has"><code class="language-bash">scp /usr/lib/systemd/system/{kubelet,kube-proxy}.service root@192.168.116.131:/usr/lib/systemd/system/
</code></pre>

<p><img alt="" class="has" height="190" src="https://img-blog.csdnimg.cn/20200110192155760.png" width="1200"></p>

<p>删除复制过来的证书</p>

<p><img alt="" class="has" height="239" src="https://img-blog.csdnimg.cn/2020011019235152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="895"></p>

<p>修改Node2上配置文件的IP地址</p>

<p><img alt="" class="has" height="281" src="https://img-blog.csdnimg.cn/20200110192454661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>修改完毕，重启即可。</p>

<pre class="has"><code>[root@node2 cfg]# systemctl restart kubelet
[root@node2 cfg]# systemctl restart kube-proxy
[root@node2 cfg]# ps -ef | grep kube
</code></pre>

<p>&nbsp;</p>

<p><img alt="" class="has" height="316" src="https://img-blog.csdnimg.cn/20200110192744279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>去Master节点颁发证书</p>

<pre class="has"><code>kubectl certificate approve node-csr-96wka1dqU6bV1MMXD1nNUw14Av8NU6H6IW11ecJlYM0</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>kubeadm部署Kubernetes（k8s）完整版详细教程</title><link>http://www.cnblogs.com/heian99/archive/2020/01/09/12173599.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 09 Jan 2020 13:22:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/09/12173599.html</guid><description><![CDATA[
                                            <p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><strong><span style="color:#333333;">kubeadm</span><span style="color:#333333;">是官方社区推出的一个用于快速部署</span><span style="color:#333333;">kubernetes</span><span style="color:#333333;">集群的工具。</span></strong></p>

<p style="margin-left:0cm;"><span style="color:#333333;">这个工具能通过两条指令完成一个</span><span style="color:#333333;">kubernetes</span><span style="color:#333333;">集群的部署：</span></p>

<pre class="has"><code class="language-bash"># 创建一个 Master 节点
$ kubeadm init

# 将一个 Node 节点加入到当前集群中
$ kubeadm join &lt;Master节点的IP和端口 &gt;
</code></pre>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NTM0ODg3LWFkNThjYTMzOWM0MDNhNGIucG5n?x-oss-process=image/format,png"></p>

<div>
<h1 style="margin-left:0cm;"><strong><span style="color:#333333;">1. </span></strong><strong><span style="color:#333333;">安装要求</span></strong></h1>
</div>

<p style="margin-left:0cm;"><span style="color:#333333;">在开始之前，部署</span><span style="color:#333333;">Kubernetes</span><span style="color:#333333;">集群机器需要满足以下几个条件：</span></p>

<ul><li><span style="color:#333333;">一台或多台机器，操作系统</span><span style="color:#333333;"> CentOS7.x-86_x64</span></li>
	<li><span style="color:#333333;">硬件配置：</span><span style="color:#333333;">2GB</span><span style="color:#333333;">或更多</span><span style="color:#333333;">RAM</span><span style="color:#333333;">，</span><span style="color:#333333;">2</span><span style="color:#333333;">个</span><span style="color:#333333;">CPU</span><span style="color:#333333;">或更多</span><span style="color:#333333;">CPU</span><span style="color:#333333;">，硬盘</span><span style="color:#333333;">30GB</span><span style="color:#333333;">或更多</span></li>
	<li><span style="color:#333333;">集群中所有机器之间网络互通</span></li>
	<li><span style="color:#333333;">可以访问外网，需要拉取镜像</span></li>
	<li><span style="color:#333333;">禁止</span><span style="color:#333333;">swap</span><span style="color:#333333;">分区</span></li>
</ul><h2><strong>环境：</strong></h2>

<p>master&nbsp; &nbsp; &nbsp; 192.168.116.129【最低是2核的，不然安装会保存】</p>

<p>node1&nbsp; &nbsp; &nbsp; 192.168.116.130</p>

<p>node2&nbsp; &nbsp; &nbsp;&nbsp;192.168.116.131</p>

<p><img alt="" class="has" height="298" src="https://img-blog.csdnimg.cn/20200108134510529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="743"></p>

<div>
<h1 style="margin-left:0cm;"><strong><span style="color:#333333;">2. </span></strong><strong><span style="color:#333333;">学习目标</span></strong></h1>

<ol><li><strong><span style="color:#333333;">在所有节点上安装</span><span style="color:#333333;">Docker</span><span style="color:#333333;">和</span><span style="color:#333333;">kubeadm</span></strong></li>
	<li><strong><span style="color:#333333;">部署</span><span style="color:#333333;">Kubernetes Master</span></strong></li>
	<li><strong><span style="color:#333333;">部署容器网络插件</span></strong></li>
	<li><strong><span style="color:#333333;">部署</span><span style="color:#333333;"> Kubernetes Node</span><span style="color:#333333;">，将节点加入</span><span style="color:#333333;">Kubernetes</span><span style="color:#333333;">集群中</span></strong></li>
	<li><strong><span style="color:#333333;">部署</span><span style="color:#333333;">Dashboard Web</span><span style="color:#333333;">页面，可视化查看</span><span style="color:#333333;">Kubernetes</span><span style="color:#333333;">资源</span></strong></li>
</ol></div>

<p>&nbsp;</p>

<div>
<h1 style="margin-left:0cm;"><strong><span style="color:#333333;">3. </span></strong><strong><span style="color:#333333;">准备环境</span></strong></h1>
</div>

<p><strong><span style="color:#333333;">1、关闭防火墙：</span></strong></p>

<pre class="has"><code class="language-bash">systemctl stop firewalld
systemctl disable firewalld
</code></pre>

<p><strong>2、<span style="color:#333333;">关闭</span><span style="color:#333333;">selinux</span><span style="color:#333333;">：</span></strong></p>

<pre class="has"><code class="language-bash"> sed -i 's/enforcing/disabled/' /etc/selinux/config 
 setenforce 0
</code></pre>

<p><strong>3、<span style="color:#333333;">关闭</span><span style="color:#333333;">swap</span><span style="color:#333333;">：</span></strong></p>

<pre class="has"><code class="language-bash">swapoff -a # 临时关闭
sed -ri 's/.*swap.*/#&amp;/' /etc/fstab  #永久关闭</code></pre>

<p><strong>4、修改主机名称</strong></p>

<pre class="has"><code class="language-bash">hostnamectl set-hostname 名字</code></pre>

<p><strong><span style="color:#333333;">5、添加主机名与</span><span style="color:#333333;">IP</span><span style="color:#333333;">对应关系（记得设置主机名）：</span></strong></p>

<pre class="has"><code class="language-bash">cat /etc/hosts
192.168.116.129 master
192.168.116.130 note1
192.168.116.131 note2
</code></pre>

<p><strong>6、<span style="color:#333333;">将桥接的</span><span style="color:#333333;">IPv4</span><span style="color:#333333;">流量传递到</span><span style="color:#333333;">iptables</span><span style="color:#333333;">的链</span></strong></p>

<pre class="has"><code class="language-bash"> cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
</code></pre>

<pre class="has"><code> sysctl --system</code></pre>

<div>
<h1 style="margin-left:0cm;"><strong><span style="color:#333333;">4. </span></strong><strong><span style="color:#333333;">所有节点安装</span></strong><strong><span style="color:#333333;">Docker/kubeadm/kubelet</span></strong></h1>

<p><span style="color:#f33b45;"><strong>xshell可以使用发送键盘所有会话来安装。比较省事</strong></span></p>

<p><img alt="" class="has" height="113" src="https://img-blog.csdnimg.cn/20200108135752343.png" width="635"></p>

<p><img alt="" class="has" height="157" src="https://img-blog.csdnimg.cn/20200108135728432.png" width="1149"></p>
</div>

<p style="margin-left:0cm;"><strong><span style="color:#333333;">Kubernetes</span><span style="color:#333333;">默认</span><span style="color:#333333;">CRI</span><span style="color:#333333;">（容器运行时）为</span><span style="color:#333333;">Docker</span><span style="color:#333333;">，因此先安装</span><span style="color:#333333;">Docker</span><span style="color:#333333;">。</span></strong></p>

<h2><strong>1、<span style="color:#333333;">安装Docker</span></strong></h2>

<p><strong><span style="color:#333333;">安装Docker源</span></strong></p>

<pre class="has"><code class="language-bash">yum install -y wget &amp;&amp; wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo
</code></pre>

<p><strong>安装Docker</strong></p>

<pre class="has"><code class="language-bash">yum -y install docker-ce-18.06.1.ce-3.el7</code></pre>

<p><strong>开启自启和启动</strong></p>

<pre class="has"><code>systemctl enable docker &amp;&amp; systemctl start docker</code></pre>

<p><strong>查看版本</strong></p>

<pre class="has"><code class="language-bash">docker --version
</code></pre>

<h2>2、<strong>&nbsp;</strong><strong><span style="color:#333333;">安装</span></strong><strong><span style="color:#333333;">kubeadm</span></strong><strong><span style="color:#333333;">，</span></strong><strong><span style="color:#333333;">kubelet</span></strong><strong><span style="color:#333333;">和</span></strong><strong><span style="color:#333333;">kubectl</span></strong></h2>

<p><strong><span style="color:#333333;">1、添加阿里云</span><span style="color:#333333;">YUM的</span><span style="color:#333333;">软件源</span></strong></p>

<pre class="has"><code class="language-bash">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
</code></pre>

<p style="margin-left:0cm;">2、<strong><span style="color:#333333;">安装</span><span style="color:#333333;">kubeadm</span><span style="color:#333333;">，</span><span style="color:#333333;">kubelet</span><span style="color:#333333;">和</span><span style="color:#333333;">kubectl</span></strong></p>

<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>由于版本更新频繁，这里指定版本号部署：</strong></span></p>

<pre class="has"><code>yum install -y kubelet-1.15.0 kubeadm-1.15.0 kubectl-1.15.0</code></pre>

<p><strong>设置开机自启</strong></p>

<pre class="has"><code>systemctl enable kubelet</code></pre>

<h1>5、<strong><span style="color:#333333;">部署</span><span style="color:#333333;">Kubernetes Master</span></strong></h1>

<p><span style="color:#333333;">在</span><span style="color:#333333;">192.168.116.129</span><span style="color:#333333;">（</span><span style="color:#333333;">Master</span><span style="color:#333333;">）执行</span></p>

<pre class="has"><code class="language-bash">kubeadm init \
--apiserver-advertise-address=192.168.116.129 \
--image-repository registry.aliyuncs.com/google_containers \
--kubernetes-version v1.15.0 \
--service-cidr=10.1.0.0/16 \
--pod-network-cidr=10.244.0.0/16
</code></pre>

<p><img alt="" class="has" height="260" src="https://img-blog.csdnimg.cn/2020010814064484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1085"></p>

<p style="margin-left:0cm;"><span style="color:#333333;">由于默认拉取镜像地址</span><span style="color:#333333;">k8s.gcr.io</span><span style="color:#333333;">国内无法访问，这里指定阿里云镜像仓库地址。</span></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="290" src="https://img-blog.csdnimg.cn/20200108140759201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1151"></p>

<p><strong>已经初始化完成</strong><img alt="" class="has" height="324" src="https://img-blog.csdnimg.cn/20200108140916701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1100"></p>

<p style="margin-left:0cm;"><strong><span style="color:#333333;">使用</span><span style="color:#333333;">kubectl</span><span style="color:#333333;">工具：</span></strong></p>

<pre class="has"><code class="language-bash">mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>

<div>
<h1 style="margin-left:0cm;"><strong><span style="color:#333333;">6. </span></strong><strong><span style="color:#333333;">安装</span></strong><strong><span style="color:#333333;">Pod</span></strong><strong><span style="color:#333333;">网络插件（</span></strong><strong><span style="color:#333333;">CNI</span></strong><strong><span style="color:#333333;">）</span></strong></h1>

<pre class="has"><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml</code></pre>

<p><span style="color:#333333;">确保能够访问到</span><span style="color:#333333;">quay.io</span><span style="color:#333333;">这个</span><span style="color:#333333;">registery</span><span style="color:#333333;">。</span></p>

<p><span style="color:#333333;">如果下载失败，可以改成这个镜像地址：</span><span style="color:#333333;">lizhenliang/flannel:v0.11.0-amd64</span></p>

<p>也可以使用我给配置文件&nbsp;<a href="https://www.lanzous.com/i8jjpij" rel="nofollow">https://www.lanzous.com/i8jjpij</a></p>

<p>这里，我是用的是我的配置文件。</p>

<p><img alt="" class="has" height="169" src="https://img-blog.csdnimg.cn/20200108141405260.png" width="486"></p>

<pre class="has"><code>kubectl apply -f kube-flannel.yml</code></pre>

<p><img alt="" class="has" height="353" src="https://img-blog.csdnimg.cn/20200108141559390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="574"></p>

<div>
<h1 style="margin-left:0cm;"><strong><span style="color:#333333;">7. </span></strong><strong><span style="color:#333333;">加入</span></strong><strong><span style="color:#333333;">Kubernetes Node</span></strong></h1>

<p><strong><span style="color:#333333;">在node上安装flannel</span></strong></p>

<pre class="has"><code>docker pull lizhenliang/flannel:v0.11.0-amd64
</code></pre>

<p style="margin-left:0cm;"><span style="color:#333333;">在</span><span style="color:#333333;">192.168.116.130</span><span style="color:#333333;">（</span><span style="color:#333333;">Node</span><span style="color:#333333;">）执行。</span></p>

<p style="margin-left:0cm;"><span style="color:#333333;">向集群添加新节点，执行在</span><span style="color:#333333;">kubeadm init</span><span style="color:#333333;">输出的</span><span style="color:#333333;">kubeadm join</span><span style="color:#333333;">命令：</span></p>
</div>

<pre class="has"><code>kubeadm join 192.168.116.129:6443 --token iz96vy.f5ukew9geeome5is \
    --discovery-token-ca-cert-hash sha256:72b689426bfc34512294c29b39ea3b2af3a94e39f62c4434f3a49f16d51a1382 </code></pre>

<p><img alt="" class="has" height="569" src="https://img-blog.csdnimg.cn/20200108142415759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1081"></p>

<p>查看Node</p>

<pre class="has"><code> kubectl get node
</code></pre>

<p><img alt="" class="has" height="174" src="https://img-blog.csdnimg.cn/20200108151656809.png" width="517"></p>

<p>添加一下node2，命令如上。切记，先执行<span style="color:#f33b45;"><strong>在node上安装flannel</strong></span></p>

<p><img alt="" class="has" height="100" src="https://img-blog.csdnimg.cn/2020010815181254.png" width="405"></p>

<p>已经完全准备完成。</p>

<pre class="has"><code>kubectl get pods -n kube-system
</code></pre>

<p><img alt="" class="has" height="390" src="https://img-blog.csdnimg.cn/20200108152313199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="648"></p>

<div>
<h1 style="margin-left:0cm;"><strong><span style="color:#333333;">8. </span></strong><strong><span style="color:#333333;">测试</span></strong><strong><span style="color:#333333;">kubernetes</span></strong><strong><span style="color:#333333;">集群</span></strong></h1>
</div>

<p style="margin-left:0cm;"><strong><span style="color:#333333;">在</span><span style="color:#333333;">Kubernetes</span><span style="color:#333333;">集群中创建一个</span><span style="color:#333333;">pod</span><span style="color:#333333;">，验证是否正常运行：</span></strong></p>

<p><strong>创建nginx容器</strong></p>

<pre class="has"><code> kubectl create deployment nginx --image=nginx</code></pre>

<p><strong>暴露对外端口</strong></p>

<pre class="has"><code> kubectl expose deployment nginx --port=80 --type=NodePort</code></pre>

<p><strong>查看nginx是否运行成功</strong></p>

<pre class="has"><code> kubectl get pod,svc</code></pre>

<p><img alt="" class="has" height="158" src="https://img-blog.csdnimg.cn/20200108152607842.png" width="704"></p>

<p>在浏览器访问。三个结点都可访问，说明集群已经搭建完成，</p>

<p><img alt="" class="has" height="312" src="https://img-blog.csdnimg.cn/20200108152655274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="787"></p>

<p><img alt="" class="has" height="339" src="https://img-blog.csdnimg.cn/20200108152708610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="741"></p>

<p><img alt="" class="has" height="360" src="https://img-blog.csdnimg.cn/20200108152722680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="795"></p>

<p>&nbsp;</p>

<p>扩容nginx副本wei3个，成功</p>

<pre class="has"><code>kubectl scale deployment nginx --replicas=3
</code></pre>

<p><img alt="" class="has" height="120" src="https://img-blog.csdnimg.cn/20200108153234116.png" width="571"></p>

<pre class="has"><code>kubectl get pods
</code></pre>

<p><img alt="" class="has" height="191" src="https://img-blog.csdnimg.cn/20200108153617737.png" width="509"></p>

<p>&nbsp;</p>

<div>
<h1 style="margin-left:0cm;"><strong><span style="color:#333333;">9. </span></strong><strong><span style="color:#333333;">部署</span></strong><strong><span style="color:#333333;"> Dashboard</span></strong></h1>
</div>

<p>先前已经给配置配置文件。</p>

<p>也可以使用我给配置文件&nbsp;<a href="https://www.lanzous.com/i8jjpij" rel="nofollow">https://www.lanzous.com/i8jjpij</a></p>

<p style="margin-left:0cm;"><span style="color:#333333;">默认镜像国内无法访问，修改镜像地址为：</span><span style="color:#333333;"> lizhenliang/kubernetes-dashboard-amd64:v1.10.1</span></p>

<p style="margin-left:0cm;"><span style="color:#333333;">默认</span><span style="color:#333333;">Dashboard</span><span style="color:#333333;">只能集群内部访问，修改</span><span style="color:#333333;">Service</span><span style="color:#333333;">为</span><span style="color:#333333;">NodePort</span><span style="color:#333333;">类型，暴露到外部：</span></p>

<p><img alt="" class="has" height="303" src="https://img-blog.csdnimg.cn/20200108153956631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="593"></p>

<p><strong>先Docker拉去镜像</strong></p>

<pre class="has"><code>docker pull  lizhenliang/kubernetes-dashboard-amd64:v1.10.1
</code></pre>

<p><strong>执行kubernetes-dashboard.yaml 文件</strong></p>

<pre class="has"><code> kubectl apply -f kubernetes-dashboard.yaml </code></pre>

<p><strong>安装成功</strong></p>

<p><img alt="" class="has" height="176" src="https://img-blog.csdnimg.cn/2020010815404548.png" width="635"></p>

<p><strong>查看暴露的端口</strong></p>

<pre class="has"><code class="language-bash">kubectl get pods,svc -n kube-system
</code></pre>

<p><img alt="" class="has" height="356" src="https://img-blog.csdnimg.cn/20200108164453386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="861"></p>

<p>&nbsp;</p>

<h1><strong><span style="color:#333333;">10. </span></strong><strong><span style="color:#333333;">访问</span></strong><strong><span style="color:#333333;"> Dashboard的web界面</span></strong></h1>

<p style="margin-left:0cm;"><span style="color:#333333;">访问地址：</span><u><span style="color:#4183c4;"><a href="https://NodeIP:30001" rel="nofollow">https://NodeIP:30001</a>&nbsp;【</span><span style="color:#f33b45;">必须是https</span><span style="color:#4183c4;">】</span></u></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="860" src="https://img-blog.csdnimg.cn/20200108164554291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p style="margin-left:0cm;"><strong><span style="color:#333333;">创建</span><span style="color:#333333;">service account</span><span style="color:#333333;">并绑定默认</span><span style="color:#333333;">cluster-admin</span><span style="color:#333333;">管理员集群角色：【依次执行】</span></strong></p>

<pre class="has"><code>kubectl create serviceaccount dashboard-admin -n kube-system</code></pre>

<pre class="has"><code> kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</code></pre>

<pre class="has"><code> kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk '/dashboard-admin/{print $1}')</code></pre>

<p><img alt="" class="has" height="418" src="https://img-blog.csdnimg.cn/20200108164747779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1079"></p>

<p>已经部署完成。</p>

<p><img alt="" class="has" height="1048" src="https://img-blog.csdnimg.cn/20200108164833885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>
</div>
                                    ]]></description></item><item><title>本地镜像发布到阿里云</title><link>http://www.cnblogs.com/heian99/archive/2020/01/09/12173600.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 09 Jan 2020 13:22:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/09/12173600.html</guid><description><![CDATA[
                                            <h1><strong>本地镜像发布到阿里云流程</strong></h1>

<p><img alt="" class="has" height="571" src="https://img-blog.csdnimg.cn/20200104093859722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="642"></p>

<h2>镜像的生成方法</h2>

<p>1、前面的DockerFile</p>

<p>2、从容器创建一个新的镜像<br>
&nbsp;</p>

<pre class="has"><code>docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</code></pre>

<p>OPTIONS说明：<br>
-a :提交的镜像作者；<br>
-m :提交时的说明文字；</p>

<p><img alt="" class="has" height="369" src="https://img-blog.csdnimg.cn/20200104093949269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="918"></p>

<h2>将本地镜像推送到阿里云</h2>

<p>本地镜像素材原型</p>

<p><img alt="" class="has" height="59" src="https://img-blog.csdnimg.cn/20200104100105792.png" width="863"></p>

<p>阿里云开发者平台</p>

<p><a href="https://dev.aliyun.com/search.html" rel="nofollow">https://dev.aliyun.com/search.html</a></p>

<p>创建仓库镜像</p>

<ul><li>命名空间</li>
	<li>仓库名称</li>
</ul><p>将镜像推送到registry</p>

<p><img alt="" class="has" height="161" src="https://img-blog.csdnimg.cn/202001041001459.png" width="837"></p>

<p><img alt="" class="has" height="329" src="https://img-blog.csdnimg.cn/20200104100150177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="965"></p>

<p>公有云可以查询到</p>

<p><img alt="" class="has" height="484" src="https://img-blog.csdnimg.cn/20200104100158195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="449" src="https://img-blog.csdnimg.cn/20200104100204189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1138"></p>

<p>查看详情</p>

<p><img alt="" class="has" height="534" src="https://img-blog.csdnimg.cn/20200104100220354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1196"></p>

<p>将阿里云上的镜像下载到本地</p>

<p><img alt="" class="has" height="357" src="https://img-blog.csdnimg.cn/20200104100232699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1095"></p>
                                    ]]></description></item><item><title>Docker常用安装(tomcat、mysql、redis)</title><link>http://www.cnblogs.com/heian99/archive/2020/01/03/12146473.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 03 Jan 2020 10:07:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/03/12146473.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="%E6%80%BB%E4%BD%93%E6%AD%A5%E9%AA%A4-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E4%BD%93%E6%AD%A5%E9%AA%A4" rel="nofollow">总体步骤</a></p>

<p id="%E5%AE%89%E8%A3%85tomcat-toc" style="margin-left:40px;"><a href="#%E5%AE%89%E8%A3%85tomcat" rel="nofollow">安装tomcat</a></p>

<p id="%E5%AE%89%E8%A3%85mysql-toc" style="margin-left:40px;"><a href="#%E5%AE%89%E8%A3%85mysql" rel="nofollow">安装mysql</a></p>

<p id="%E5%AE%89%E8%A3%85redis-toc" style="margin-left:40px;"><a href="#%E5%AE%89%E8%A3%85redis" rel="nofollow">安装redis</a></p>

<hr id="hr-toc"><h1 id="%E6%80%BB%E4%BD%93%E6%AD%A5%E9%AA%A4">总体步骤</h1>

<ul><li>1、搜索镜像</li>
	<li>2、拉取镜像</li>
	<li>3、查看镜像</li>
	<li>4、启动镜像</li>
	<li>5、停止容器</li>
	<li>6、移除容器</li>
</ul><h2 id="%E5%AE%89%E8%A3%85tomcat">安装tomcat</h2>

<p>docker hub上面查找tomcat镜像</p>

<pre class="has"><code>docker search tomcat</code></pre>

<p><img alt="" class="has" height="242" src="https://img-blog.csdnimg.cn/20200103173328267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1085"></p>

<p>从docker hub上拉取tomcat镜像到本地</p>

<pre class="has"><code>docker pull tomcat</code></pre>

<p><img alt="" class="has" height="282" src="https://img-blog.csdnimg.cn/20200103173531800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="793"></p>

<p>docker images查看是否有拉取到的tomcat</p>

<p><img alt="" class="has" height="209" src="https://img-blog.csdnimg.cn/20200103173610531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="958"></p>

<p>使用tomcat镜像创建容器(也叫运行镜像)</p>

<pre class="has"><code>docker run -it -p 8080:8080 tomcat</code></pre>

<ul><li>-p 主机端口:docker容器端口</li>
	<li>-P 随机分配端口</li>
	<li>i:交互</li>
	<li>t:终端</li>
</ul><p><img alt="" class="has" height="358" src="https://img-blog.csdnimg.cn/20200103173748990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="660"></p>

<h2 id="%E5%AE%89%E8%A3%85mysql">安装mysql</h2>

<p>docker hub上面查找mysql镜像</p>

<pre class="has"><code>docker search mysql
</code></pre>

<p><img alt="" class="has" height="251" src="https://img-blog.csdnimg.cn/20200103173850796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1009"></p>

<p>从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.6</p>

<pre class="has"><code>docker pull mysql:5.6
</code></pre>

<p><img alt="" class="has" height="325" src="https://img-blog.csdnimg.cn/20200103173952107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="824"></p>

<p>使用mysql5.6镜像创建容器(也叫运行镜像)</p>

<pre class="has"><code>docker run -p 12345:3306 --name mysql -v /zzyyuse/mysql/conf:/etc/mysql/conf.d -v /zzyyuse/mysql/logs:/logs -v /zzyyuse/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</code></pre>

<p><strong>命令说明：</strong><br>
-p 12345:3306：将主机的12345端口映射到docker容器的3306端口。<br>
--name mysql：运行服务名字<br>
-v /zzyyuse/mysql/conf:/etc/mysql/conf.d ：将主机/zzyyuse/mysql录下的conf/my.cnf 挂载到容器的 /etc/mysql/conf.d<br>
-v /zzyyuse/mysql/logs:/logs：将主机/zzyyuse/mysql目录下的 logs 目录挂载到容器的 /logs。<br>
-v /zzyyuse/mysql/data:/var/lib/mysql ：将主机/zzyyuse/mysql目录下的data目录挂载到容器的 /var/lib/mysql&nbsp;<br>
-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。<br>
-d mysql:5.6 : 后台程序运行mysql5.6</p>

<p><img alt="" class="has" height="149" src="https://img-blog.csdnimg.cn/20200103174214272.png" width="1074"></p>

<pre class="has"><code>docker exec -it MySQL运行成功后的容器ID     /bin/bash</code></pre>

<p><img alt="" class="has" height="114" src="https://img-blog.csdnimg.cn/20200103174339178.png" width="703"></p>

<p>外部Win10也来连接运行在dokcer上的mysql服务</p>

<p><img alt="" class="has" height="669" src="https://img-blog.csdnimg.cn/20200103174934352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="566"></p>

<p>数据备份小测试</p>

<pre class="has"><code>docker exec myql服务容器ID sh -c ' exec mysqldump --all-databases -uroot -p"123456" ' &gt; /zzyyuse/all-databases.sql</code></pre>

<p><img alt="" class="has" height="326" src="https://img-blog.csdnimg.cn/20200103175618904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1145"></p>

<h2 id="%E5%AE%89%E8%A3%85redis">安装redis</h2>

<p>hub上(阿里云加速器)拉取redis镜像到本地标签为3.2</p>

<pre class="has"><code>docker pull redis:3.2</code></pre>

<p><img alt="" class="has" height="425" src="https://img-blog.csdnimg.cn/20200103175734811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="867"></p>

<p>使用redis3.2镜像创建容器(也叫运行镜像)</p>

<p>使用镜像</p>

<pre class="has"><code>docker run -p 6379:6379 -v /zzyyuse/myredis/data:/data -v /zzyyuse/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf  -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly yes</code></pre>

<p><img alt="" class="has" height="217" src="https://img-blog.csdnimg.cn/20200103175822680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1153"></p>

<p>在主机/zzyyuse/myredis/conf/redis.conf目录下新建redis.conf文件<br>
&nbsp;</p>

<pre class="has"><code>vim /zzyyuse/myredis/conf/redis.conf/redis.conf</code></pre>

<pre class="has"><code class="language-bash"># Redis configuration file example.
#
# Note that in order to read the configuration file, Redis must be
# started with the file path as first argument:
#
# ./redis-server /path/to/redis.conf
 
# Note on units: when memory size is needed, it is possible to specify
# it in the usual form of 1k 5GB 4M and so forth:
#
# 1k =&gt; 1000 bytes
# 1kb =&gt; 1024 bytes
# 1m =&gt; 1000000 bytes
# 1mb =&gt; 1024*1024 bytes
# 1g =&gt; 1000000000 bytes
# 1gb =&gt; 1024*1024*1024 bytes
#
# units are case insensitive so 1GB 1Gb 1gB are all the same.
################################## INCLUDES ###################################
 
# Include one or more other config files here.  This is useful if you
# have a standard template that goes to all Redis servers but also need
# to customize a few per-server settings.  Include files can include
# other files, so use this wisely.
#
# Notice option "include" won't be rewritten by command "CONFIG REWRITE"
# from admin or Redis Sentinel. Since Redis always uses the last processed
# line as value of a configuration directive, you'd better put includes
# at the beginning of this file to avoid overwriting config change at runtime.
#
# If instead you are interested in using includes to override configuration
# options, it is better to use include as the last line.
#
# include /path/to/local.conf
# include /path/to/other.conf
 
################################## NETWORK #####################################
 
# By default, if no "bind" configuration directive is specified, Redis listens
# for connections from all the network interfaces available on the server.
# It is possible to listen to just one or multiple selected interfaces using
# the "bind" configuration directive, followed by one or more IP addresses.
#
# Examples:
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1 ::1
#
# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
# internet, binding to all the interfaces is dangerous and will expose the
# instance to everybody on the internet. So by default we uncomment the
# following bind directive, that will force Redis to listen only into
# the IPv4 lookback interface address (this means Redis will be able to
# accept connections only from clients running into the same computer it
# is running).
#
# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
# JUST COMMENT THE FOLLOWING LINE.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#bind 127.0.0.1
 
# Protected mode is a layer of security protection, in order to avoid that
# Redis instances left open on the internet are accessed and exploited.
#
# When protected mode is on and if:
#
# 1) The server is not binding explicitly to a set of addresses using the
#    "bind" directive.
# 2) No password is configured.
#
# The server only accepts connections from clients connecting from the
# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
# sockets.
#
# By default protected mode is enabled. You should disable it only if
# you are sure you want clients from other hosts to connect to Redis
# even if no authentication is configured, nor a specific set of interfaces
# are explicitly listed using the "bind" directive.
protected-mode yes
 
# Accept connections on the specified port, default is 6379 (IANA #815344).
# If port 0 is specified Redis will not listen on a TCP socket.
port 6379
 
# TCP listen() backlog.
#
# In high requests-per-second environments you need an high backlog in order
# to avoid slow clients connections issues. Note that the Linux kernel
# will silently truncate it to the value of /proc/sys/net/core/somaxconn so
# make sure to raise both the value of somaxconn and tcp_max_syn_backlog
# in order to get the desired effect.
tcp-backlog 511
 
# Unix socket.
#
# Specify the path for the Unix socket that will be used to listen for
# incoming connections. There is no default, so Redis will not listen
# on a unix socket when not specified.
#
# unixsocket /tmp/redis.sock
# unixsocketperm 700
 
# Close the connection after a client is idle for N seconds (0 to disable)
timeout 0
 
# TCP keepalive.
#
# If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
# of communication. This is useful for two reasons:
#
# 1) Detect dead peers.
# 2) Take the connection alive from the point of view of network
#    equipment in the middle.
#
# On Linux, the specified value (in seconds) is the period used to send ACKs.
# Note that to close the connection the double of the time is needed.
# On other kernels the period depends on the kernel configuration.
#
# A reasonable value for this option is 300 seconds, which is the new
# Redis default starting with Redis 3.2.1.
tcp-keepalive 300
 
################################# GENERAL #####################################
 
# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
#daemonize no
 
# If you run Redis from upstart or systemd, Redis can interact with your
# supervision tree. Options:
#   supervised no      - no supervision interaction
#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode
#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
#   supervised auto    - detect upstart or systemd method based on
#                        UPSTART_JOB or NOTIFY_SOCKET environment variables
# Note: these supervision methods only signal "process is ready."
#       They do not enable continuous liveness pings back to your supervisor.
supervised no
 
# If a pid file is specified, Redis writes it where specified at startup
# and removes it at exit.
#
# When the server runs non daemonized, no pid file is created if none is
# specified in the configuration. When the server is daemonized, the pid file
# is used even if not specified, defaulting to "/var/run/redis.pid".
#
# Creating a pid file is best effort: if Redis is not able to create it
# nothing bad happens, the server will start and run normally.
pidfile /var/run/redis_6379.pid
 
# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)
# verbose (many rarely useful info, but not a mess like the debug level)
# notice (moderately verbose, what you want in production probably)
# warning (only very important / critical messages are logged)
loglevel notice
 
# Specify the log file name. Also the empty string can be used to force
# Redis to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
logfile ""
 
# To enable logging to the system logger, just set 'syslog-enabled' to yes,
# and optionally update the other syslog parameters to suit your needs.
# syslog-enabled no
 
# Specify the syslog identity.
# syslog-ident redis
 
# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
# syslog-facility local0
 
# Set the number of databases. The default database is DB 0, you can select
# a different one on a per-connection basis using SELECT &lt;dbid&gt; where
# dbid is a number between 0 and 'databases'-1
databases 16
 
################################ SNAPSHOTTING  ################################
#
# Save the DB on disk:
#
#   save &lt;seconds&gt; &lt;changes&gt;
#
#   Will save the DB if both the given number of seconds and the given
#   number of write operations against the DB occurred.
#
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
#
#   Note: you can disable saving completely by commenting out all "save" lines.
#
#   It is also possible to remove all the previously configured save
#   points by adding a save directive with a single empty string argument
#   like in the following example:
#
#   save ""
 
save 120 1
save 300 10
save 60 10000
 
# By default Redis will stop accepting writes if RDB snapshots are enabled
# (at least one save point) and the latest background save failed.
# This will make the user aware (in a hard way) that data is not persisting
# on disk properly, otherwise chances are that no one will notice and some
# disaster will happen.
#
# If the background saving process will start working again Redis will
# automatically allow writes again.
#
# However if you have setup your proper monitoring of the Redis server
# and persistence, you may want to disable this feature so that Redis will
# continue to work as usual even if there are problems with disk,
# permissions, and so forth.
stop-writes-on-bgsave-error yes
 
# Compress string objects using LZF when dump .rdb databases?
# For default that's set to 'yes' as it's almost always a win.
# If you want to save some CPU in the saving child set it to 'no' but
# the dataset will likely be bigger if you have compressible values or keys.
rdbcompression yes
 
# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
# This makes the format more resistant to corruption but there is a performance
# hit to pay (around 10%) when saving and loading RDB files, so you can disable it
# for maximum performances.
#
# RDB files created with checksum disabled have a checksum of zero that will
# tell the loading code to skip the check.
rdbchecksum yes
 
# The filename where to dump the DB
dbfilename dump.rdb
 
# The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
dir ./
 
################################# REPLICATION #################################
 
# Master-Slave replication. Use slaveof to make a Redis instance a copy of
# another Redis server. A few things to understand ASAP about Redis replication.
#
# 1) Redis replication is asynchronous, but you can configure a master to
#    stop accepting writes if it appears to be not connected with at least
#    a given number of slaves.
# 2) Redis slaves are able to perform a partial resynchronization with the
#    master if the replication link is lost for a relatively small amount of
#    time. You may want to configure the replication backlog size (see the next
#    sections of this file) with a sensible value depending on your needs.
# 3) Replication is automatic and does not need user intervention. After a
#    network partition slaves automatically try to reconnect to masters
#    and resynchronize with them.
#
# slaveof &lt;masterip&gt; &lt;masterport&gt;
 
# If the master is password protected (using the "requirepass" configuration
# directive below) it is possible to tell the slave to authenticate before
# starting the replication synchronization process, otherwise the master will
# refuse the slave request.
#
# masterauth &lt;master-password&gt;
 
# When a slave loses its connection with the master, or when the replication
# is still in progress, the slave can act in two different ways:
#
# 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will
#    still reply to client requests, possibly with out of date data, or the
#    data set may just be empty if this is the first synchronization.
#
# 2) if slave-serve-stale-data is set to 'no' the slave will reply with
#    an error "SYNC with master in progress" to all the kind of commands
#    but to INFO and SLAVEOF.
#
slave-serve-stale-data yes
 
# You can configure a slave instance to accept writes or not. Writing against
# a slave instance may be useful to store some ephemeral data (because data
# written on a slave will be easily deleted after resync with the master) but
# may also cause problems if clients are writing to it because of a
# misconfiguration.
#
# Since Redis 2.6 by default slaves are read-only.
#
# Note: read only slaves are not designed to be exposed to untrusted clients
# on the internet. It's just a protection layer against misuse of the instance.
# Still a read only slave exports by default all the administrative commands
# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
# security of read only slaves using 'rename-command' to shadow all the
# administrative / dangerous commands.
slave-read-only yes
 
# Replication SYNC strategy: disk or socket.
#
# -------------------------------------------------------
# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY
# -------------------------------------------------------
#
# New slaves and reconnecting slaves that are not able to continue the replication
# process just receiving differences, need to do what is called a "full
# synchronization". An RDB file is transmitted from the master to the slaves.
# The transmission can happen in two different ways:
#
# 1) Disk-backed: The Redis master creates a new process that writes the RDB
#                 file on disk. Later the file is transferred by the parent
#                 process to the slaves incrementally.
# 2) Diskless: The Redis master creates a new process that directly writes the
#              RDB file to slave sockets, without touching the disk at all.
#
# With disk-backed replication, while the RDB file is generated, more slaves
# can be queued and served with the RDB file as soon as the current child producing
# the RDB file finishes its work. With diskless replication instead once
# the transfer starts, new slaves arriving will be queued and a new transfer
# will start when the current one terminates.
#
# When diskless replication is used, the master waits a configurable amount of
# time (in seconds) before starting the transfer in the hope that multiple slaves
# will arrive and the transfer can be parallelized.
#
# With slow disks and fast (large bandwidth) networks, diskless replication
# works better.
repl-diskless-sync no
 
# When diskless replication is enabled, it is possible to configure the delay
# the server waits in order to spawn the child that transfers the RDB via socket
# to the slaves.
#
# This is important since once the transfer starts, it is not possible to serve
# new slaves arriving, that will be queued for the next RDB transfer, so the server
# waits a delay in order to let more slaves arrive.
#
# The delay is specified in seconds, and by default is 5 seconds. To disable
# it entirely just set it to 0 seconds and the transfer will start ASAP.
repl-diskless-sync-delay 5
 
# Slaves send PINGs to server in a predefined interval. It's possible to change
# this interval with the repl_ping_slave_period option. The default value is 10
# seconds.
#
# repl-ping-slave-period 10
 
# The following option sets the replication timeout for:
#
# 1) Bulk transfer I/O during SYNC, from the point of view of slave.
# 2) Master timeout from the point of view of slaves (data, pings).
# 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).
#
# It is important to make sure that this value is greater than the value
# specified for repl-ping-slave-period otherwise a timeout will be detected
# every time there is low traffic between the master and the slave.
#
# repl-timeout 60
 
# Disable TCP_NODELAY on the slave socket after SYNC?
#
# If you select "yes" Redis will use a smaller number of TCP packets and
# less bandwidth to send data to slaves. But this can add a delay for
# the data to appear on the slave side, up to 40 milliseconds with
# Linux kernels using a default configuration.
#
# If you select "no" the delay for data to appear on the slave side will
# be reduced but more bandwidth will be used for replication.
#
# By default we optimize for low latency, but in very high traffic conditions
# or when the master and slaves are many hops away, turning this to "yes" may
# be a good idea.
repl-disable-tcp-nodelay no
 
# Set the replication backlog size. The backlog is a buffer that accumulates
# slave data when slaves are disconnected for some time, so that when a slave
# wants to reconnect again, often a full resync is not needed, but a partial
# resync is enough, just passing the portion of data the slave missed while
# disconnected.
#
# The bigger the replication backlog, the longer the time the slave can be
# disconnected and later be able to perform a partial resynchronization.
#
# The backlog is only allocated once there is at least a slave connected.
#
# repl-backlog-size 1mb
 
# After a master has no longer connected slaves for some time, the backlog
# will be freed. The following option configures the amount of seconds that
# need to elapse, starting from the time the last slave disconnected, for
# the backlog buffer to be freed.
#
# A value of 0 means to never release the backlog.
#
# repl-backlog-ttl 3600
 
# The slave priority is an integer number published by Redis in the INFO output.
# It is used by Redis Sentinel in order to select a slave to promote into a
# master if the master is no longer working correctly.
#
# A slave with a low priority number is considered better for promotion, so
# for instance if there are three slaves with priority 10, 100, 25 Sentinel will
# pick the one with priority 10, that is the lowest.
#
# However a special priority of 0 marks the slave as not able to perform the
# role of master, so a slave with priority of 0 will never be selected by
# Redis Sentinel for promotion.
#
# By default the priority is 100.
slave-priority 100
 
# It is possible for a master to stop accepting writes if there are less than
# N slaves connected, having a lag less or equal than M seconds.
#
# The N slaves need to be in "online" state.
#
# The lag in seconds, that must be &lt;= the specified value, is calculated from
# the last ping received from the slave, that is usually sent every second.
#
# This option does not GUARANTEE that N replicas will accept the write, but
# will limit the window of exposure for lost writes in case not enough slaves
# are available, to the specified number of seconds.
#
# For example to require at least 3 slaves with a lag &lt;= 10 seconds use:
#
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# Setting one or the other to 0 disables the feature.
#
# By default min-slaves-to-write is set to 0 (feature disabled) and
# min-slaves-max-lag is set to 10.
 
# A Redis master is able to list the address and port of the attached
# slaves in different ways. For example the "INFO replication" section
# offers this information, which is used, among other tools, by
# Redis Sentinel in order to discover slave instances.
# Another place where this info is available is in the output of the
# "ROLE" command of a masteer.
#
# The listed IP and address normally reported by a slave is obtained
# in the following way:
#
#   IP: The address is auto detected by checking the peer address
#   of the socket used by the slave to connect with the master.
#
#   Port: The port is communicated by the slave during the replication
#   handshake, and is normally the port that the slave is using to
#   list for connections.
#
# However when port forwarding or Network Address Translation (NAT) is
# used, the slave may be actually reachable via different IP and port
# pairs. The following two options can be used by a slave in order to
# report to its master a specific set of IP and port, so that both INFO
# and ROLE will report those values.
#
# There is no need to use both the options if you need to override just
# the port or the IP address.
#
# slave-announce-ip 5.5.5.5
# slave-announce-port 1234
 
################################## SECURITY ###################################
 
# Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
#
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).
#
# Warning: since Redis is pretty fast an outside user can try up to
# 150k passwords per second against a good box. This means that you should
# use a very strong password otherwise it will be very easy to break.
#
# requirepass foobared
 
# Command renaming.
#
# It is possible to change the name of dangerous commands in a shared
# environment. For instance the CONFIG command may be renamed into something
# hard to guess so that it will still be available for internal-use tools
# but not available for general clients.
#
# Example:
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# It is also possible to completely kill a command by renaming it into
# an empty string:
#
# rename-command CONFIG ""
#
# Please note that changing the name of commands that are logged into the
# AOF file or transmitted to slaves may cause problems.
 
################################### LIMITS ####################################
 
# Set the max number of connected clients at the same time. By default
# this limit is set to 10000 clients, however if the Redis server is not
# able to configure the process file limit to allow for the specified limit
# the max number of allowed clients is set to the current file limit
# minus 32 (as Redis reserves a few file descriptors for internal uses).
#
# Once the limit is reached Redis will close all the new connections sending
# an error 'max number of clients reached'.
#
# maxclients 10000
 
# Don't use more memory than the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys
# according to the eviction policy selected (see maxmemory-policy).
#
# If Redis can't remove keys according to the policy, or if the policy is
# set to 'noeviction', Redis will start to reply with errors to commands
# that would use more memory, like SET, LPUSH, and so on, and will continue
# to reply to read-only commands like GET.
#
# This option is usually useful when using Redis as an LRU cache, or to set
# a hard memory limit for an instance (using the 'noeviction' policy).
#
# WARNING: If you have slaves attached to an instance with maxmemory on,
# the size of the output buffers needed to feed the slaves are subtracted
# from the used memory count, so that network problems / resyncs will
# not trigger a loop where keys are evicted, and in turn the output
# buffer of slaves is full with DELs of keys evicted triggering the deletion
# of more keys, and so forth until the database is completely emptied.
#
# In short... if you have slaves attached it is suggested that you set a lower
# limit for maxmemory so that there is some free RAM on the system for slave
# output buffers (but this is not needed if the policy is 'noeviction').
#
# maxmemory &lt;bytes&gt;
 
# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
# is reached. You can select among five behaviors:
#
# volatile-lru -&gt; remove the key with an expire set using an LRU algorithm
# allkeys-lru -&gt; remove any key according to the LRU algorithm
# volatile-random -&gt; remove a random key with an expire set
# allkeys-random -&gt; remove a random key, any key
# volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)
# noeviction -&gt; don't expire at all, just return an error on write operations
#
# Note: with any of the above policies, Redis will return an error on write
#       operations, when there are no suitable keys for eviction.
#
#       At the date of writing these commands are: set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec sort
#
# The default is:
#
# maxmemory-policy noeviction
 
# LRU and minimal TTL algorithms are not precise algorithms but approximated
# algorithms (in order to save memory), so you can tune it for speed or
# accuracy. For default Redis will check five keys and pick the one that was
# used less recently, you can change the sample size using the following
# configuration directive.
#
# The default of 5 produces good enough results. 10 Approximates very closely
# true LRU but costs a bit more CPU. 3 is very fast but not very accurate.
#
# maxmemory-samples 5
 
############################## APPEND ONLY MODE ###############################
 
# By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Redis can lose just one second of writes in a
# dramatic event like a server power outage, or a single write if something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
#
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
#
# Please check http://redis.io/topics/persistence for more information.
 
appendonly no
 
# The name of the append only file (default: "appendonly.aof")
 
appendfilename "appendonly.aof"
 
# The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer. Some OS will really flush
# data on disk, some other OS will just try to do it ASAP.
#
# Redis supports three different modes:
#
# no: don't fsync, just let the OS flush the data when it wants. Faster.
# always: fsync after every write to the append only log. Slow, Safest.
# everysec: fsync only one time every second. Compromise.
#
# The default is "everysec", as that's usually the right compromise between
# speed and data safety. It's up to you to understand if you can relax this to
# "no" that will let the operating system flush the output buffer when
# it wants, for better performances (but if you can live with the idea of
# some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use "always" that's very slow but a bit safer than
# everysec.
#
# More details please check the following article:
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use "everysec".
 
# appendfsync always
appendfsync everysec
# appendfsync no
 
# When the AOF fsync policy is set to always or everysec, and a background
# saving process (a background save or AOF log background rewriting) is
# performing a lot of I/O against the disk, in some Linux configurations
# Redis may block too long on the fsync() call. Note that there is no fix for
# this currently, as even performing fsync in a different thread will block
# our synchronous write(2) call.
#
# In order to mitigate this problem it's possible to use the following option
# that will prevent fsync() from being called in the main process while a
# BGSAVE or BGREWRITEAOF is in progress.
#
# This means that while another child is saving, the durability of Redis is
# the same as "appendfsync none". In practical terms, this means that it is
# possible to lose up to 30 seconds of log in the worst scenario (with the
# default Linux settings).
#
# If you have latency problems turn this to "yes". Otherwise leave it as
# "no" that is the safest pick from the point of view of durability.
 
no-appendfsync-on-rewrite no
 
# Automatic rewrite of the append only file.
# Redis is able to automatically rewrite the log file implicitly calling
# BGREWRITEAOF when the AOF log size grows by the specified percentage.
#
# This is how it works: Redis remembers the size of the AOF file after the
# latest rewrite (if no rewrite has happened since the restart, the size of
# the AOF at startup is used).
#
# This base size is compared to the current size. If the current size is
# bigger than the specified percentage, the rewrite is triggered. Also
# you need to specify a minimal size for the AOF file to be rewritten, this
# is useful to avoid rewriting the AOF file even if the percentage increase
# is reached but it is still pretty small.
#
# Specify a percentage of zero in order to disable the automatic AOF
# rewrite feature.
 
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
 
# An AOF file may be found to be truncated at the end during the Redis
# startup process, when the AOF data gets loaded back into memory.
# This may happen when the system where Redis is running
# crashes, especially when an ext4 filesystem is mounted without the
# data=ordered option (however this can't happen when Redis itself
# crashes or aborts but the operating system still works correctly).
#
# Redis can either exit with an error when this happens, or load as much
# data as possible (the default now) and start if the AOF file is found
# to be truncated at the end. The following option controls this behavior.
#
# If aof-load-truncated is set to yes, a truncated AOF file is loaded and
# the Redis server starts emitting a log to inform the user of the event.
# Otherwise if the option is set to no, the server aborts with an error
# and refuses to start. When the option is set to no, the user requires
# to fix the AOF file using the "redis-check-aof" utility before to restart
# the server.
#
# Note that if the AOF file will be found to be corrupted in the middle
# the server will still exit with an error. This option only applies when
# Redis will try to read more data from the AOF file but not enough bytes
# will be found.
aof-load-truncated yes
 
################################ LUA SCRIPTING  ###############################
 
# Max execution time of a Lua script in milliseconds.
#
# If the maximum execution time is reached Redis will log that a script is
# still in execution after the maximum allowed time and will start to
# reply to queries with an error.
#
# When a long running script exceeds the maximum execution time only the
# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
# used to stop a script that did not yet called write commands. The second
# is the only way to shut down the server in the case a write command was
# already issued by the script but the user doesn't want to wait for the natural
# termination of the script.
#
# Set it to 0 or a negative value for unlimited execution without warnings.
lua-time-limit 5000
 
################################ REDIS CLUSTER  ###############################
#
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however
# in order to mark it as "mature" we need to wait for a non trivial percentage
# of users to deploy it in production.
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Normal Redis instances can't be part of a Redis Cluster; only nodes that are
# started as cluster nodes can. In order to start a Redis instance as a
# cluster node enable the cluster support uncommenting the following:
#
# cluster-enabled yes
 
# Every cluster node has a cluster configuration file. This file is not
# intended to be edited by hand. It is created and updated by Redis nodes.
# Every Redis Cluster node requires a different cluster configuration file.
# Make sure that instances running in the same system do not have
# overlapping cluster configuration file names.
#
# cluster-config-file nodes-6379.conf
 
# Cluster node timeout is the amount of milliseconds a node must be unreachable
# for it to be considered in failure state.
# Most other internal time limits are multiple of the node timeout.
#
# cluster-node-timeout 15000
 
# A slave of a failing master will avoid to start a failover if its data
# looks too old.
#
# There is no simple way for a slave to actually have a exact measure of
# its "data age", so the following two checks are performed:
#
# 1) If there are multiple slaves able to failover, they exchange messages
#    in order to try to give an advantage to the slave with the best
#    replication offset (more data from the master processed).
#    Slaves will try to get their rank by offset, and apply to the start
#    of the failover a delay proportional to their rank.
#
# 2) Every single slave computes the time of the last interaction with
#    its master. This can be the last ping or command received (if the master
#    is still in the "connected" state), or the time that elapsed since the
#    disconnection with the master (if the replication link is currently down).
#    If the last interaction is too old, the slave will not try to failover
#    at all.
#
# The point "2" can be tuned by user. Specifically a slave will not perform
# the failover if, since the last interaction with the master, the time
# elapsed is greater than:
#
#   (node-timeout * slave-validity-factor) + repl-ping-slave-period
#
# So for example if node-timeout is 30 seconds, and the slave-validity-factor
# is 10, and assuming a default repl-ping-slave-period of 10 seconds, the
# slave will not try to failover if it was not able to talk with the master
# for longer than 310 seconds.
#
# A large slave-validity-factor may allow slaves with too old data to failover
# a master, while a too small value may prevent the cluster from being able to
# elect a slave at all.
#
# For maximum availability, it is possible to set the slave-validity-factor
# to a value of 0, which means, that slaves will always try to failover the
# master regardless of the last time they interacted with the master.
# (However they'll always try to apply a delay proportional to their
# offset rank).
#
# Zero is the only value able to guarantee that when all the partitions heal
# the cluster will always be able to continue.
#
# cluster-slave-validity-factor 10
 
# Cluster slaves are able to migrate to orphaned masters, that are masters
# that are left without working slaves. This improves the cluster ability
# to resist to failures as otherwise an orphaned master can't be failed over
# in case of failure if it has no working slaves.
#
# Slaves migrate to orphaned masters only if there are still at least a
# given number of other working slaves for their old master. This number
# is the "migration barrier". A migration barrier of 1 means that a slave
# will migrate only if there is at least 1 other working slave for its master
# and so forth. It usually reflects the number of slaves you want for every
# master in your cluster.
#
# Default is 1 (slaves migrate only if their masters remain with at least
# one slave). To disable migration just set it to a very large value.
# A value of 0 can be set but is useful only for debugging and dangerous
# in production.
#
# cluster-migration-barrier 1
 
# By default Redis Cluster nodes stop accepting queries if they detect there
# is at least an hash slot uncovered (no available node is serving it).
# This way if the cluster is partially down (for example a range of hash slots
# are no longer covered) all the cluster becomes, eventually, unavailable.
# It automatically returns available as soon as all the slots are covered again.
#
# However sometimes you want the subset of the cluster which is working,
# to continue to accept queries for the part of the key space that is still
# covered. In order to do so, just set the cluster-require-full-coverage
# option to no.
#
# cluster-require-full-coverage yes
 
# In order to setup your cluster make sure to read the documentation
# available at http://redis.io web site.
 
################################## SLOW LOG ###################################
 
# The Redis Slow Log is a system to log queries that exceeded a specified
# execution time. The execution time does not include the I/O operations
# like talking with the client, sending the reply and so forth,
# but just the time needed to actually execute the command (this is the only
# stage of command execution where the thread is blocked and can not serve
# other requests in the meantime).
#
# You can configure the slow log with two parameters: one tells Redis
# what is the execution time, in microseconds, to exceed in order for the
# command to get logged, and the other parameter is the length of the
# slow log. When a new command is logged the oldest one is removed from the
# queue of logged commands.
 
# The following time is expressed in microseconds, so 1000000 is equivalent
# to one second. Note that a negative number disables the slow log, while
# a value of zero forces the logging of every command.
slowlog-log-slower-than 10000
 
# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128
 
################################ LATENCY MONITOR ##############################
 
# The Redis latency monitoring subsystem samples different operations
# at runtime in order to collect data related to possible sources of
# latency of a Redis instance.
#
# Via the LATENCY command this information is available to the user that can
# print graphs and obtain reports.
#
# The system only logs operations that were performed in a time equal or
# greater than the amount of milliseconds specified via the
# latency-monitor-threshold configuration directive. When its value is set
# to zero, the latency monitor is turned off.
#
# By default latency monitoring is disabled since it is mostly not needed
# if you don't have latency issues, and collecting data has a performance
# impact, that while very small, can be measured under big load. Latency
# monitoring can easily be enabled at runtime using the command
# "CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;" if needed.
latency-monitor-threshold 0
 
############################# EVENT NOTIFICATION ##############################
 
# Redis can notify Pub/Sub clients about events happening in the key space.
# This feature is documented at http://redis.io/topics/notifications
#
# For instance if keyspace events notification is enabled, and a client
# performs a DEL operation on key "foo" stored in the Database 0, two
# messages will be published via Pub/Sub:
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# It is possible to select the events that Redis will notify among a set
# of classes. Every class is identified by a single character:
#
#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.
#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.
#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
#  $     String commands
#  l     List commands
#  s     Set commands
#  h     Hash commands
#  z     Sorted set commands
#  x     Expired events (events generated every time a key expires)
#  e     Evicted events (events generated when a key is evicted for maxmemory)
#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.
#
#  The "notify-keyspace-events" takes as argument a string that is composed
#  of zero or multiple characters. The empty string means that notifications
#  are disabled.
#
#  Example: to enable list and generic events, from the point of view of the
#           event name, use:
#
#  notify-keyspace-events Elg
#
#  Example 2: to get the stream of the expired keys subscribing to channel
#             name __keyevent@0__:expired use:
#
#  notify-keyspace-events Ex
#
#  By default all notifications are disabled because most users don't need
#  this feature and the feature has some overhead. Note that if you don't
#  specify at least one of K or E, no events will be delivered.
notify-keyspace-events ""
 
############################### ADVANCED CONFIG ###############################
 
# Hashes are encoded using a memory efficient data structure when they have a
# small number of entries, and the biggest entry does not exceed a given
# threshold. These thresholds can be configured using the following directives.
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
 
# Lists are also encoded in a special way to save a lot of space.
# The number of entries allowed per internal list node can be specified
# as a fixed maximum size or a maximum number of elements.
# For a fixed maximum size, use -5 through -1, meaning:
# -5: max size: 64 Kb  &lt;-- not recommended for normal workloads
# -4: max size: 32 Kb  &lt;-- not recommended
# -3: max size: 16 Kb  &lt;-- probably not recommended
# -2: max size: 8 Kb   &lt;-- good
# -1: max size: 4 Kb   &lt;-- good
# Positive numbers mean store up to _exactly_ that number of elements
# per list node.
# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
# but if your use case is unique, adjust the settings as necessary.
list-max-ziplist-size -2
 
# Lists may also be compressed.
# Compress depth is the number of quicklist ziplist nodes from *each* side of
# the list to *exclude* from compression.  The head and tail of the list
# are always uncompressed for fast push/pop operations.  Settings are:
# 0: disable all list compression
# 1: depth 1 means "don't start compressing until after 1 node into the list,
#    going from either the head or tail"
#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]
#    [head], [tail] will always be uncompressed; inner nodes will compress.
# 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]
#    2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail,
#    but compress all nodes between them.
# 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]
# etc.
list-compress-depth 0
 
# Sets have a special encoding in just one case: when a set is composed
# of just strings that happen to be integers in radix 10 in the range
# of 64 bit signed integers.
# The following configuration setting sets the limit in the size of the
# set in order to use this special memory saving encoding.
set-max-intset-entries 512
 
# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
 
# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When an HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
#
# The suggested value is ~ 3000 in order to have the benefits of
# the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to
# ~ 10000 when CPU is not a concern, but space is, and the data set is
# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
hll-sparse-max-bytes 3000
 
# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
# order to help rehashing the main Redis hash table (the one mapping top-level
# keys to values). The hash table implementation Redis uses (see dict.c)
# performs a lazy rehashing: the more operation you run into a hash table
# that is rehashing, the more rehashing "steps" are performed, so if the
# server is idle the rehashing is never complete and some more memory is used
# by the hash table.
#
# The default is to use this millisecond 10 times every second in order to
# actively rehash the main dictionaries, freeing memory when possible.
#
# If unsure:
# use "activerehashing no" if you have hard latency requirements and it is
# not a good thing in your environment that Redis can reply from time to time
# to queries with 2 milliseconds delay.
#
# use "activerehashing yes" if you don't have such hard requirements but
# want to free memory asap when possible.
activerehashing yes
 
# The client output buffer limits can be used to force disconnection of clients
# that are not reading data from the server fast enough for some reason (a
# common reason is that a Pub/Sub client can't consume messages as fast as the
# publisher can produce them).
#
# The limit can be set differently for the three different classes of clients:
#
# normal -&gt; normal clients including MONITOR clients
# slave  -&gt; slave clients
# pubsub -&gt; clients subscribed to at least one pubsub channel or pattern
#
# The syntax of every client-output-buffer-limit directive is the following:
#
# client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;
#
# A client is immediately disconnected once the hard limit is reached, or if
# the soft limit is reached and remains reached for the specified number of
# seconds (continuously).
# So for instance if the hard limit is 32 megabytes and the soft limit is
# 16 megabytes / 10 seconds, the client will get disconnected immediately
# if the size of the output buffers reach 32 megabytes, but will also get
# disconnected if the client reaches 16 megabytes and continuously overcomes
# the limit for 10 seconds.
#
# By default normal clients are not limited because they don't receive data
# without asking (in a push way), but just after a request, so only
# asynchronous clients may create a scenario where data is requested faster
# than it can read.
#
# Instead there is a default limit for pubsub and slave clients, since
# subscribers and slaves receive data in a push fashion.
#
# Both the hard or the soft limit can be disabled by setting them to zero.
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
 
# Redis calls an internal function to perform many background tasks, like
# closing connections of clients in timeout, purging expired keys that are
# never requested, and so forth.
#
# Not all tasks are performed with the same frequency, but Redis checks for
# tasks to perform according to the specified "hz" value.
#
# By default "hz" is set to 10. Raising the value will use more CPU when
# Redis is idle, but at the same time will make Redis more responsive when
# there are many keys expiring at the same time, and timeouts may be
# handled with more precision.
#
# The range is between 1 and 500, however a value over 100 is usually not
# a good idea. Most users should use the default of 10 and raise this up to
# 100 only in environments where very low latency is required.
hz 10
 
# When a child rewrites the AOF file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
aof-rewrite-incremental-fsync yes
</code></pre>

<p>测试redis-cli连接上来</p>

<pre class="has"><code> docker exec -it 运行着Rediis服务的容器ID redis-cli</code></pre>

<p><img alt="" class="has" height="261" src="https://img-blog.csdnimg.cn/20200103180436225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1065"></p>

<p>测试持久化文件生成</p>

<p><img alt="" class="has" height="374" src="https://img-blog.csdnimg.cn/20200103180550801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="513"></p>
                                    ]]></description></item><item><title>DockerFile自定义镜像Tomcat9</title><link>http://www.cnblogs.com/heian99/archive/2020/01/03/12146474.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 03 Jan 2020 08:33:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/03/12146474.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:80px;">&nbsp;</p>

<p id="%E4%B8%8B%E8%BD%BDtomcat%E5%AE%B9%E5%99%A8%E5%8D%B7-toc" style="margin-left:80px;"><a href="#%E4%B8%8B%E8%BD%BDtomcat%E5%AE%B9%E5%99%A8%E5%8D%B7" rel="nofollow">下载tomcat容器卷</a></p>

<p id="1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9" rel="nofollow">1、创建文件夹</a></p>

<p id="2%E3%80%81%E5%9C%A8%E4%B8%8A%E8%BF%B0%E7%9B%AE%E5%BD%95%E4%B8%8Btouch%20c.txt-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%9C%A8%E4%B8%8A%E8%BF%B0%E7%9B%AE%E5%BD%95%E4%B8%8Btouch%20c.txt" rel="nofollow">2、在上述目录下touch c.txt</a></p>

<p id="3%E3%80%81%E5%B0%86jdk%E5%92%8Ctomcat%E5%AE%89%E8%A3%85%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%8B%B7%E8%B4%9D%E8%BF%9B%E4%B8%8A%E4%B8%80%E6%AD%A5%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%B0%86jdk%E5%92%8Ctomcat%E5%AE%89%E8%A3%85%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%8B%B7%E8%B4%9D%E8%BF%9B%E4%B8%8A%E4%B8%80%E6%AD%A5%E7%9B%AE%E5%BD%95" rel="nofollow">3、将jdk和tomcat安装的压缩包拷贝进上一步目录</a></p>

<p id="4%E3%80%81%E5%9C%A8%2Fheian%2Fmydockerfile%2Ftomcat9%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BADockerfile%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%9C%A8%2Fheian%2Fmydockerfile%2Ftomcat9%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BADockerfile%E6%96%87%E4%BB%B6" rel="nofollow">4、在/heian/mydockerfile/tomcat9目录下新建Dockerfile文件</a></p>

<p id="5%E3%80%81%E6%9E%84%E5%BB%BA-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E6%9E%84%E5%BB%BA" rel="nofollow">5、构建</a></p>

<p id="6%E3%80%81run-toc" style="margin-left:80px;"><a href="#6%E3%80%81run" rel="nofollow">6、run</a></p>

<p id="7%E3%80%81%E9%AA%8C%E8%AF%81-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E9%AA%8C%E8%AF%81" rel="nofollow">7、验证</a></p>

<p id="8%E3%80%81%E7%BB%93%E5%90%88%E5%89%8D%E8%BF%B0%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8D%B7%E5%B0%86%E6%B5%8B%E8%AF%95%E7%9A%84web%E6%9C%8D%E5%8A%A1test%E5%8F%91%E5%B8%83-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E7%BB%93%E5%90%88%E5%89%8D%E8%BF%B0%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8D%B7%E5%B0%86%E6%B5%8B%E8%AF%95%E7%9A%84web%E6%9C%8D%E5%8A%A1test%E5%8F%91%E5%B8%83" rel="nofollow">8、结合前述的容器卷将测试的web服务test发布</a></p>

<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p>

<hr id="hr-toc"><h3 id="%E4%B8%8B%E8%BD%BDtomcat%E5%AE%B9%E5%99%A8%E5%8D%B7"><a href="https://github.com/docker-library/tomcat/blob/46fb91d392f48c4e606cb6f845c4be37d6bacffc/9.0/jdk8/corretto/Dockerfile" rel="nofollow">下载tomcat</a>容器卷</h3>

<h3 id="1%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9">1、创建文件夹</h3>

<pre class="has"><code>mkdir -p /heian/mydockerfile/tomcat9</code></pre>

<h3 id="2%E3%80%81%E5%9C%A8%E4%B8%8A%E8%BF%B0%E7%9B%AE%E5%BD%95%E4%B8%8Btouch%20c.txt">2、在上述目录下touch c.txt</h3>

<pre class="has"><code>touch c.txt</code></pre>

<h3 id="3%E3%80%81%E5%B0%86jdk%E5%92%8Ctomcat%E5%AE%89%E8%A3%85%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%8B%B7%E8%B4%9D%E8%BF%9B%E4%B8%8A%E4%B8%80%E6%AD%A5%E7%9B%AE%E5%BD%95">3、将jdk和tomcat安装的压缩包拷贝进上一步目录</h3>

<p>apache-tomcat-9.0.8.tar.gz</p>

<p>jdk-8u171-linux-x64.tar.gz</p>

<p><img alt="" class="has" height="194" src="https://img-blog.csdnimg.cn/20200103150556666.png" width="683"></p>

<h3 id="4%E3%80%81%E5%9C%A8%2Fheian%2Fmydockerfile%2Ftomcat9%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BADockerfile%E6%96%87%E4%BB%B6">4、在/heian/mydockerfile/tomcat9目录下新建Dockerfile文件</h3>

<p>&nbsp;</p>

<pre class="has"><code class="language-bash">FROM         centos
MAINTAINER    heian&lt;1794748404@126.com&gt;
#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下
COPY c.txt /usr/local/cincontainer.txt
#把java与tomcat添加到容器中
ADD jdk-8u152-linux-x64.tar.gz /usr/local/
ADD apache-tomcat-8.5.24.tar.gz /usr/local/
#安装vim编辑器
RUN yum -y install vim
#设置工作访问时候的WORKDIR路径，登录落脚点
ENV MYPATH /usr/local
WORKDIR $MYPATH
#配置java与tomcat环境变量
ENV JAVA_HOME /usr/local/jdk1.8.0_152
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-8.5.24
ENV CATALINA_BASE /usr/local/apache-tomcat-8.5.24
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
#容器运行时监听的端口
EXPOSE  8080
#启动时运行tomcat
# ENTRYPOINT ["/usr/local/apache-tomcat-8.5.24/bin/startup.sh" ]
# CMD ["/usr/local/apache-tomcat-8.5.24/bin/catalina.sh","run"]
CMD /usr/local/apache-tomcat-8.5.24/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-8.5.24/bin/logs/catalina.out</code></pre>

<p><img alt="" class="has" height="255" src="https://img-blog.csdnimg.cn/20200103151312441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="683"></p>

<h3 id="5%E3%80%81%E6%9E%84%E5%BB%BA">5、构建</h3>

<pre class="has"><code>docker build -f Dockerfile -t heiantomcat9 .
</code></pre>

<p><img alt="" class="has" height="680" src="https://img-blog.csdnimg.cn/20200103160233624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="979"></p>

<p><strong>构建完成</strong></p>

<p><img alt="" class="has" height="231" src="https://img-blog.csdnimg.cn/20200103160320912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="883"></p>

<h3 id="6%E3%80%81run">6、run</h3>

<pre class="has"><code>docker run -d -p 9080:8080 --name myt9 -v /heian/mydockerfile/tomcat9/test:/usr/local/apache-tomcat-9.0.8/webapps/test -v /heian/mydockerfile/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.8/logs --privileged=true heiantomcat9
</code></pre>

<p><img alt="" class="has" height="149" src="https://img-blog.csdnimg.cn/20200103160625359.png" width="1091"></p>

<p>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied<br>
解决办法：在挂载目录后多加一个--privileged=true参数即可</p>

<h3 id="7%E3%80%81%E9%AA%8C%E8%AF%81">7、验证</h3>

<p><img alt="" class="has" height="482" src="https://img-blog.csdnimg.cn/20200103160704631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="882"></p>

<h3 id="8%E3%80%81%E7%BB%93%E5%90%88%E5%89%8D%E8%BF%B0%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8D%B7%E5%B0%86%E6%B5%8B%E8%AF%95%E7%9A%84web%E6%9C%8D%E5%8A%A1test%E5%8F%91%E5%B8%83">8、结合前述的容器卷将测试的web服务test发布</h3>

<p><img alt="" class="has" height="233" src="https://img-blog.csdnimg.cn/20200103161202296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="700"></p>

<p><img alt="" class="has" height="259" src="https://img-blog.csdnimg.cn/20200103161645120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="586"></p>

<p><strong>a.jsp</strong></p>

<pre class="has"><code class="language-html">&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
    &lt;title&gt;Insert title here&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    -----------welcome------------
    &lt;%="i am in docker tomcat self "%&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;% System.out.println("=============docker tomcat self");%&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>web.xml</strong></p>

<pre class="has"><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
  id="WebApp_ID" version="2.5"&gt;
  
  &lt;display-name&gt;test&lt;/display-name&gt;
 
&lt;/web-app&gt;
</code></pre>

<p><strong>测试</strong></p>

<p><img alt="" class="has" height="140" src="https://img-blog.csdnimg.cn/20200103162009410.png" width="1113"></p>

<p><img alt="" class="has" height="158" src="https://img-blog.csdnimg.cn/20200103163112368.png" width="643"></p>

<p><img alt="" class="has" height="188" src="https://img-blog.csdnimg.cn/20200103163123955.png" width="666"></p>

<p><img alt="" class="has" height="134" src="https://img-blog.csdnimg.cn/20200103163134733.png" width="780"></p>

<h3 id="%E6%80%BB%E7%BB%93"><strong>总结</strong></h3>

<p><img alt="" class="has" height="588" src="https://img-blog.csdnimg.cn/20200103163155505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="714"></p>
                                    ]]></description></item><item><title>DockerFile的CMD/ENTRYPOINT 镜像案例</title><link>http://www.cnblogs.com/heian99/archive/2020/01/03/12146475.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 03 Jan 2020 06:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/03/12146475.html</guid><description><![CDATA[
                                            <h2>&nbsp;</h2>

<h2>作用：都是指定一个容器启动时要运行的命令</h2>

<h3><span style="color:#f33b45;">CMD</span></h3>

<p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p>

<p>实例</p>

<p>tomcat的讲解演示</p>

<pre class="has"><code>docker run -it -p 8080:8080 tomcat
</code></pre>

<h3><img alt="" class="has" height="436" src="https://img-blog.csdnimg.cn/20200103143318730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1061"></h3>

<pre class="has"><code>docker run -it -p 8080:8080 tomcat ls -l
</code></pre>

<h3><img alt="" class="has" height="434" src="https://img-blog.csdnimg.cn/20200103143227449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1043"></h3>

<h3><span style="color:#f33b45;"><strong>ENTRYPOINT&nbsp;</strong></span></h3>

<p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</p>

<p>实例</p>

<p><img alt="" class="has" height="117" src="https://img-blog.csdnimg.cn/20200103142026490.png" width="759"></p>

<p>制作CMD版可以查询IP信息的容器</p>

<pre class="has"><code class="language-bash">FROM centos
RUN yum install -y curl
CMD [ "curl", "-s", "http://ip.cn" ]</code></pre>

<p><img alt="" class="has" height="385" src="https://img-blog.csdnimg.cn/20200103142104726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<p><strong>crul命令解释</strong></p>

<p><span style="color:#000000;">curl命令可以用来执行下载、发送各种HTTP请求，指定HTTP头部等操作。</span></p>

<p><span style="color:#000000;">如果系统没有curl可以使用yum install curl安装，也可以下载安装。</span></p>

<p>curl是将下载文件输出到stdout</p>

<p>使用命令：curl http://www.baidu.com<br>
执行后，www.baidu.com的html就会显示在屏幕上了</p>

<p>这是最简单的使用方法。用这个命令获得了http://curl.haxx.se指向的页面，同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数 -i</p>

<h3><span style="color:#f33b45;"><strong>问题</strong></span></h3>

<p>如果我们希望显示 HTTP 头信息，就需要加上 -i 参数</p>

<p><img alt="" class="has" height="175" src="https://img-blog.csdnimg.cn/20200103142220735.png" width="1200"></p>

<p><strong>WHY</strong></p>

<p><span style="color:#000000;">我们可以看到可执行文件找不到的报错，executable file not found。</span></p>

<p><span style="color:#000000;">之前我们说过，<span style="color:#ff0000;">跟在镜像名后面的是 command，运行时会替换 CMD 的默认值</span>。</span></p>

<p><span style="color:#000000;">因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。</span></p>

<p><span style="color:#000000;">那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</span></p>

<pre class="has"><code>$ docker run myip curl -s http://ip.cn -i</code></pre>

<p>制作ENTROYPOINT版查询IP信息的容器</p>

<pre class="has"><code class="language-bash">FROM centos
RUN yum install -y curl
ENTRYPOINT [ "curl", "-s", "http://ip.cn" ]</code></pre>

<p><img alt="" class="has" height="253" src="https://img-blog.csdnimg.cn/20200103142315187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1086"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>DockerFile自定义镜像centos</title><link>http://www.cnblogs.com/heian99/archive/2020/01/03/12146476.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 03 Jan 2020 06:14:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/03/12146476.html</guid><description><![CDATA[
                                            <h1>Base镜像(scratch)</h1>

<p>Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的</p>

<p><img alt="" class="has" height="509" src="https://img-blog.csdnimg.cn/20200103121024908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="893"></p>

<h1><span style="color:#f33b45;">自定义镜像mycentos</span></h1>

<h3>1、编写</h3>

<p><img alt="" class="has" height="279" src="https://img-blog.csdnimg.cn/20200103121118879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="924"></p>

<p><strong><span style="color:#f33b45;">自定义mycentos目的使我们自己的镜像具备如下：</span></strong></p>

<ol><li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;登陆后的默认路径</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vim编辑器</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;查看网络配置ifconfig支持</li>
</ol><p><strong>准备编写DockerFile文件</strong></p>

<p><img alt="" class="has" height="167" src="https://img-blog.csdnimg.cn/20200103134141368.png" width="494"></p>

<p><strong>myCentOS内容DockerFile</strong></p>

<pre class="has"><code class="language-bash"> #基于本地的centos
FROM centos   
 #作者、邮件
MAINTAINER cf&lt;1794748404@qq.com&gt;
 #来设置环境变量
ENV MYPATH /uer/local 
#登录进去的路径
WORKDIR $MYPATH
##安装下面的软件
RUN yum -y install vim
RUN yum -y install net-tools
#暴露80端口
EXPOSE 80
#打印信息
CMD echo $MYPATH
CMD echo "success-----------------ok"
#使用bash
CMD /bin/bash</code></pre>

<h3>2、构建</h3>

<pre class="has"><code class="language-bash">docker build -f /root/docker/dockerfile1 -t mycentos:1.3 .

</code></pre>

<p><img alt="" class="has" height="368" src="https://img-blog.csdnimg.cn/20200103135523341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="710"></p>

<p><img alt="" class="has" height="367" src="https://img-blog.csdnimg.cn/20200103140335411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="619"></p>

<h3>3、运行</h3>

<pre class="has"><code class="language-bash">docker run -it 新镜像名字:TAG </code></pre>

<p>可以看到，我们自己的新镜像已经支持vim/ifconfig命令，扩展成功了</p>

<p><img alt="" class="has" height="538" src="https://img-blog.csdnimg.cn/20200103140700790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="703"></p>

<h3>4、列出镜像的变更历史</h3>

<p>docker history 镜像名</p>

<p><img alt="" class="has" height="383" src="https://img-blog.csdnimg.cn/20200103140409352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1023"></p>
                                    ]]></description></item><item><title>DockerFile体系结构(保留字指令)</title><link>http://www.cnblogs.com/heian99/archive/2020/01/03/12146477.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 03 Jan 2020 04:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/03/12146477.html</guid><description><![CDATA[
                                            <h1><strong>DockerFile体系结构(保留字指令)</strong></h1>

<p>&nbsp;</p>

<p><strong><span style="color:#f33b45;">FROM</span>：基础镜像，当前新镜像是基于哪个镜像的</strong></p>

<hr><p><strong><span style="color:#f33b45;">MAINTAINER</span>：镜像维护者的姓名和邮箱地址</strong></p>

<hr><p><strong><span style="color:#f33b45;">RUN</span>：容器构建时需要运行的命令</strong></p>

<hr><p><strong><span style="color:#f33b45;">EXPOSE</span>：当前容器对外暴露出的端口</strong></p>

<hr><p><strong><span style="color:#f33b45;">WORKDIR</span>：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</strong></p>

<hr><p><strong><span style="color:#f33b45;">ENV</span>：用来在构建镜像过程中设置环境变量</strong></p>

<p><span style="color:#000000;">ENV MY_PATH /usr/mytest</span></p>

<p><span style="color:#000000;">这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</span></p>

<p><span style="color:#000000;">也可以在其它指令中直接使用这些环境变量，</span></p>

<p><span style="color:#000000;">比如：WORKDIR $MY_PATH</span></p>

<hr><p><span style="color:#f33b45;"><strong>ADD</strong></span><span style="color:#000000;"><strong>:将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</strong></span></p>

<hr><p><span style="color:#f33b45;"><strong>COPY</strong></span><span style="color:#000000;"><strong>:类似ADD，拷贝文件和目录到镜像中。<br>
将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</strong></span></p>

<p>COPY src dest</p>

<p>COPY ["src", "dest"]</p>

<hr><p><span style="color:#f33b45;"><strong>VOLUME</strong></span><span style="color:#000000;"><strong>:容器数据卷，用于数据保存和持久化工作</strong></span></p>

<hr><p><span style="color:#f33b45;"><strong>CMD</strong></span><span style="color:#000000;"><strong>:指定一个容器启动时要运行的命令</strong></span></p>

<p>CMD容器启动命令<br>
CND指令的格式和RUN 相似，也是两种格式:<br>
●shell 格式: CMD &lt;命令&gt;&nbsp;<br>
●exec格式: CID ["可执行文件”， “参数1"， “参数2”..]<br>
.参数列表格式: CNO [“参数",“参数2”..]. 在指定了EITRYPOIT 指令后,用CID指定具体的参<br>
数。<br>
Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p>

<hr><p><strong><span style="color:#f33b45;">ENTRYPOINT </span>:指定一个容器启动时要运行的命令</strong></p>

<hr><p><strong>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数</strong></p>

<hr><p><strong><span style="color:#f33b45;">ONBUILD</span>:当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</strong></p>

<hr><p><img alt="" class="has" height="789" src="https://img-blog.csdnimg.cn/20200103115311689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="563"></p>

<p><img alt="" class="has" height="534" src="https://img-blog.csdnimg.cn/20200103114109463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="775"></p>
                                    ]]></description></item><item><title>DockerFile解析</title><link>http://www.cnblogs.com/heian99/archive/2020/01/03/12146478.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 03 Jan 2020 03:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2020/01/03/12146478.html</guid><description><![CDATA[
                                            <h1>1、是什么</h1>

<p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>

<h3>构建三步骤</h3>

<ol><li>编写Dockerfile文件</li>
	<li>docker build</li>
	<li>docker run</li>
</ol><h3>文件什么样？？？</h3>

<p>以我们熟悉的CentOS为例&nbsp;</p>

<p><a href="https://hub.docker.com/_/centos/" rel="nofollow">https://hub.docker.com/_/centos/</a></p>

<p><img alt="" class="has" height="487" src="https://img-blog.csdnimg.cn/20200103112030333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1021"></p>

<p><img alt="" class="has" height="498" src="https://img-blog.csdnimg.cn/20200103112043210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="892"><br>
&nbsp;</p>

<pre class="has"><code class="language-bash">FROM scratch
ADD centos- 7-docker.tar.xz /
LABEL org. label-schema. schema-version = "1.0" \
org. label-schema. name="CentOS Base Image" \
org. label-schema. vendor="Cent0S" \
org. label-schema. license="GPLv2" \
org. label-schema. build-date="20180531"
CMD ["/bin/bash"]
</code></pre>

<h1>2、DockerFile构建过程解析</h1>

<h3><strong>Dockerfile内容基础知识</strong></h3>

<ul><li>1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
	<li>2：指令按照从上到下，顺序执行</li>
	<li>3：#表示注释</li>
	<li>4：每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ul><h3><strong>Docker执行Dockerfile的大致流程</strong></h3>

<ul><li>（1）docker从基础镜像运行一个容器</li>
	<li>（2）执行一条指令并对容器作出修改</li>
	<li>（3）执行类似docker commit的操作提交一个新的镜像层</li>
	<li>（4）docker再基于刚提交的镜像运行一个新容器</li>
	<li>（4）docker再基于刚提交的镜像运行一个新容器</li>
</ul><p><strong><span style="color:#000000;">从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</span></strong></p>

<p><span style="color:#000000;">* &nbsp;Dockerfile是软件的原材料</span></p>

<p><span style="color:#000000;">* &nbsp;Docker镜像是软件的交付品</span></p>

<p><span style="color:#000000;">* &nbsp;Docker容器则可以认为是软件的运行态。</span></p>

<p><span style="color:#000000;">Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</span></p>

<p><img alt="" class="has" height="265" src="https://img-blog.csdnimg.cn/20200103112536955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="622"></p>

<p><span style="color:#000000;">1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</span></p>

<p><span style="color:#000000;">2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</span></p>

<p><span style="color:#000000;">3 Docker容器，容器是直接提供服务的。</span></p>
                                    ]]></description></item><item><title>网云穿-群辉映射外网教程</title><link>http://www.cnblogs.com/heian99/archive/2019/12/24/12091959.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 24 Dec 2019 07:51:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/24/12091959.html</guid><description><![CDATA[<p>&nbsp;</p>
<h1 class="md-end-block md-heading"><span class="md-plain">群辉映射外网教程</span></h1>
<h1 class="md-end-block md-heading"><span class="md-plain">网云穿-最简单易用的内网穿透软件，最简洁教程一键穿透网站、数据库、远程桌面</span></h1>
<p class="md-end-block md-p"><span class="md-plain"> <span><strong>网云穿，致力于打造最便捷的「内网穿透」应用</strong></span></span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">https://xiaomy.net/index.html
</pre>
</div>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154515185-2144924008.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-size: 15px;">&nbsp;<strong><span class="md-plain">网云穿是一款可以在包括但不限于<code>Windows</code><span class="md-plain">、<code>Mac</code><span class="md-plain">、<code>Linux</code><span class="md-plain">、<code>群辉</code><span class="md-plain">、<code>树莓派</code><span class="md-plain">、<code>威联通</code><span class="md-plain">上使用的内网穿透，它可以很便捷的帮助你将本地内网的应用发布出去，比如：<code>网站、数据库、硬盘文件、远程桌面、应用、游戏(如我的世界)</code><span class="md-plain">等等，这样您就可以<code>很方便的微信调试、自建云盘、异地办公</code><span class="md-plain">等等，它<code>不需要您有公网IP、不需要您有服务器、也不需要您设置任何路由器</code><span class="md-plain">，只需要您安装软件进行简单设置即可直接使用。</span></span></span></span></span></span></span></span></span></span></strong></span></p>
<p>&nbsp;</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">费话不多说，直接上干货</span></h3>
<h2 class="md-end-block md-heading md-focus"><span class="md-expand">群辉映射外网教程</span></h2>
<p>&nbsp;</p>
<p class="md-end-block md-p md-focus"><span class="md-plain">环境：内网群辉服务器</span></p>
<p class="md-end-block md-p"><span class="md-plain">工具：<span class=" md-link"><a href="https://xiaomy.net/index.html"><span class="md-plain">网云穿</span></a></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">群辉服务器：</span></p>
<p class="md-end-block md-p"><span class="md-plain">我使用的是Exsi服务器搭建</span></p>
<p class="md-end-block md-p"><span class="md-plain"><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154639370-1220207532.png" alt="" /></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154649228-392519534.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">映射工具：</span></p>
<p class="md-end-block md-p md-focus"><span class="md-plain"> <span class="md-link"><a href="https://xiaomy.net/index.html">https://xiaomy.net/index.html</a></span></span></p>
<p>&nbsp;</p>
<h1 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">教程开始：</span></h1>
<p>&nbsp;</p>
<h2 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">1、下载网云穿工具</span></h2>
<p>&nbsp;<span class="md-plain md-expand"> <span class="md-link"><a href="https://xiaomy.net/index.html">https://xiaomy.net/index.html</a></span></span></p>
<p>&nbsp;</p>
<h2 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">2、登录账号【没有的自己去注册一个】</span></h2>
<p class="md-end-block md-p"><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154721100-528125501.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">3、查看群辉服务器的IP地址</span></h2>
<p><span class="md-image md-img-loaded" data-src="images/1577172265927.png">&nbsp;</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154736343-143344092.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154746370-972387184.png" alt="" /></p>
<p>设置为固定的IP</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154753469-367997523.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">4、配置网云穿</span></h2>
<p>&nbsp;1、点击web</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154823721-923660752.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;2、点击隧道管理</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154832134-1798031503.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;3、配置信息【重要】</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154855710-1618737117.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154905388-1843502917.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">5、返回PC客户端</span></h2>
<p>&nbsp;</p>
<p>&nbsp;双击启动</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154922964-948053777.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154933005-960202898.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">6、看群辉效果</span></h3>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154948119-1275613883.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224154957403-16744953.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">7、测试下载速度【3M/S多】</span></h2>
<p><span class="md-plain md-expand">这速度比某盘快多了</span></p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224155026704-520274894.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p class="md-end-block md-p md-focus"><span><strong>我也是有NAS存储的人了。</strong></span></p>
<p class="md-end-block md-p"><span><strong>有个专属的群辉服务器就是好。</strong></span></p>
<p><span><strong>&nbsp;</strong></span></p>]]></description></item><item><title>SpringBoot项目映射</title><link>http://www.cnblogs.com/heian99/archive/2019/12/24/12104188.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 24 Dec 2019 07:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/24/12104188.html</guid><description><![CDATA[
                                            <p><strong>运行原理流程图</strong></p>

<p><img alt="" class="has" height="435" src="https://img-blog.csdnimg.cn/20191224145528558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="731"><br>
什么是内网穿透?<br>
1. 内网穿透是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信，有时候就会出现内网穿透不支的情况。内网穿透的功能就是，当我们在端口映射时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成为一种私有的地址，然后再采用路由的方式ADSL的宽带路由器，具有一个动态或者是固定的公网IP，最后ADSL直接在 交换机 上，这样所有的电脑都可以共享上网。内网穿透除了可以实现内网之间机器的网络通信功通之外，还可以解决UDP中出现的数据传输不稳定问题。<br>
2. 简单说, 就是A客户端要访问B客户端，通过一台服务器进行桥接，桥接有两种方式，一种是相互转发，另一个是告诉对方的地址，自己就当一个介绍人的角色。</p>

<p><strong>&nbsp;网云穿是一款可以在包括但不限于<code>Windows</code>、<code>Mac</code>、<code>Linux</code>、<code>群辉</code>、<code>树莓派</code>、<code>威联通</code>上使用的内网穿透，它可以很便捷的帮助你将本地内网的应用发布出去，比如：<code>网站、数据库、硬盘文件、远程桌面、应用、游戏(如我的世界)</code>等等，这样您就可以<code>很方便的微信调试、自建云盘、异地办公</code>等等，它<code>不需要您有公网IP、不需要您有服务器、也不需要您设置任何路由器</code>，只需要您安装软件进行简单设置即可直接使用。</strong><br>
如何实现?<br>
大部分内网穿透都是通过第三方工具实现, 市面上也有很多第三个工具, 花生壳, Ngrok等… 但本团队在使用过之后, 发现这些第三方工具在价钱和使用方面不太符合预期的效果, 在这里小蚂蚁内网穿透团队致力打造一款更加方便, “亲民” 的一款内网穿透工具, 详情请了解官网:</p>

<p><a href="https://xiaomy.net/index.html" rel="nofollow">网云穿</a></p>

<p><img alt="" class="has" height="632" src="https://img-blog.csdnimg.cn/20191224145735562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="744"></p>

<h2 id="%E8%B4%B9%E8%AF%9D%E4%B8%8D%E5%A4%9A%E8%AF%B4%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%B8%8A%E5%B9%B2%E8%B4%A7"><strong>费话不多说，直接上干货</strong></h2>

<hr><h2><em>&nbsp;<strong><code>SpringBoot</code>&nbsp;使用网云穿对外发布<code>项目</code></strong></em></h2>

<p><em><strong>我的程序运行的jar包，需要发布到外网，但是没有服务器，只能通过穿透来。</strong></em></p>

<p><em><strong>下面就是教程</strong></em></p>

<p><img alt="" class="has" height="209" src="https://img-blog.csdnimg.cn/20191224145830857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="619"></p>

<h3>&nbsp;1、下载网云穿pc安装包，解压。</h3>

<p><a href="http://www.xiaomy.net/download/wyc20191223.rar" rel="nofollow">下载</a></p>

<h3><strong>2、登录账号（没有的需要自己去官网注册）</strong></h3>

<p><img alt="" class="has" height="452" src="https://img-blog.csdnimg.cn/20191224145908504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="800"></p>

<h3><strong>3、查询本机需要映射的IP</strong></h3>

<p><img alt="" class="has" height="462" src="https://img-blog.csdnimg.cn/20191224145921712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="569"></p>

<h3>&nbsp;<strong>4、配置需要映射的端口信息</strong></h3>

<p><strong>1、点击web</strong></p>

<p><img alt="" class="has" height="455" src="https://img-blog.csdnimg.cn/20191224145936276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="779"></p>

<p>&nbsp;2、点击隧道管理</p>

<p><img alt="" class="has" height="395" src="https://img-blog.csdnimg.cn/20191224145945427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="801"></p>

<p>&nbsp;3、配置需要穿透的本机IP和端口</p>

<p><img alt="" class="has" height="495" src="https://img-blog.csdnimg.cn/20191224145954470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="793"></p>

<h3><strong>5、启动SpringBoot项目</strong></h3>

<p><img alt="" class="has" height="402" src="https://img-blog.csdnimg.cn/20191224150006453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="781"></p>

<h2>&nbsp;6、返回网云穿Pc端</h2>

<p><img alt="" class="has" height="459" src="https://img-blog.csdnimg.cn/20191224150017780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="777"></p>

<p><img alt="" class="has" height="509" src="https://img-blog.csdnimg.cn/20191224150025722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="372"></p>

<h1>&nbsp;7、查看效果</h1>

<p><img alt="" class="has" height="535" src="https://img-blog.csdnimg.cn/20191224150034411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="801"></p>

<p><strong>完美穿透，真是方便，以后我的电脑都可以搞成服务器了。</strong></p>
                                    ]]></description></item><item><title>网云穿-SpringBoot项目映射外网</title><link>http://www.cnblogs.com/heian99/archive/2019/12/24/12091143.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 24 Dec 2019 05:55:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/24/12091143.html</guid><description><![CDATA[<h1 class="md-end-block md-heading md-focus"><span class="md-plain md-expand">网云穿-最简单易用的内网穿透软件，最简洁教程一键穿透网站、数据库、远程桌面</span></h1>
<hr />
<p>&nbsp;</p>
<p><strong><span class="md-plain">网云穿，致力于打造最便捷的「内网穿透」应用</span></strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">https://xiaomy.net/index.html</pre>
</div>
<p><strong><span class="md-plain"><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224133948073-1871565772.png" alt="" /></span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 14px;"><strong>&nbsp;<span class="md-expand"><span class="md-plain">网云穿</span><span class="md-plain">是一款可以在包括但不限于<code>Windows</code><span class="md-plain">、<code>Mac</code><span class="md-plain">、<code>Linux</code><span class="md-plain">、<code>群辉</code><span class="md-plain">、<code>树莓派</code><span class="md-plain">、<code>威联通</code><span class="md-plain">上使用的内网穿透，它可以很便捷的帮助你将本地内网的应用发布出去，比如：<code>网站、数据库、硬盘文件、远程桌面、应用、游戏(如我的世界)</code><span class="md-plain">等等，这样您就可以<code>很方便的微信调试、自建云盘、异地办公</code><span class="md-plain">等等，它<code>不需要您有公网IP、不需要您有服务器、也不需要您设置任何路由器</code><span class="md-plain md-expand">，只需要您安装软件进行简单设置即可直接使用。</span></span></span></span></span></span></span></span></span></span></span></strong></span></p>
<p><strong><span class="md-plain">&nbsp;</span></strong></p>
<h2 class="md-end-block md-heading"><strong><span class="md-plain">费话不多说，直接上干货</span></strong></h2>
<hr />
<p>&nbsp;</p>
<p class="md-end-block md-p"><span style="font-size: 16px;"><strong><em>教程分为多个，且持续更新中，可根据自己的需要选择查看，您也可以通过教程举一反三，尝试网云穿的更多用法，有遇到任何不懂得地方，都可以去网云穿官方论坛反馈，或添加客服QQ、微信反馈。</em></strong></span></p>
<h1><span><em>&nbsp;<strong><span><code>SpringBoot</code><span class="md-plain"> 使用网云穿对外发布<span><code>项目</code></span></span></span></strong></em></span></h1>
<p><span><em><strong><span><span class="md-plain"><span>我的程序运行的jar包，需要发布到外网，但是没有服务器，只能通过穿透来。</span></span></span></strong></em></span></p>
<p><span><em><strong><span><span class="md-plain"><span>下面就是教程</span></span></span></strong></em></span></p>
<p><strong><span class="md-plain"><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224134212398-991524094.png" alt="" /></span></strong></p>
<p>&nbsp;</p>
<h2>&nbsp;1、下载网云穿pc安装包，解压。</h2>
<pre class="brush:csharp;gutter:true;">http://www.xiaomy.net/download/wyc20191223.rar</pre>
<h2><strong><span class="md-plain">2、登录账号（没有的需要自己去官网注册）</span></strong></h2>
<p><strong><span class="md-plain"><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224134445553-1045299813.png" alt="" /></span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><strong>3、查询本机需要映射的IP</strong></h2>
<h2><strong><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224134629799-1322640937.png" alt="" /></strong></h2>
<p>&nbsp;</p>
<h2>&nbsp;<strong>4、配置需要映射的端口信息</strong></h2>
<p><strong>1、点击web</strong></p>
<p><strong><span class="md-plain"><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224134706699-287390854.png" alt="" /></span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;2、点击隧道管理</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224134751099-1839498057.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;3、配置需要穿透的本机IP和端口</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224134936207-2083896837.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><strong>5、启动SpringBoot项目</strong></h2>
<p><strong><span class="md-plain"><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224135045149-192030228.png" alt="" /></span></strong></p>
<p>&nbsp;</p>
<h2>&nbsp;6、返回网云穿Pc端</h2>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224135149697-6454385.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224135212800-230350451.png" alt="" /></p>
<p>&nbsp;</p>
<h1>&nbsp;7、查看效果</h1>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191224135344826-1497513352.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span class="md-plain">完美穿透，真是方便，以后我的电脑都可以搞成服务器了。</span></strong></p>
]]></description></item><item><title> 穿透，让你不再限制内网的约束【远程控制内网电脑】【3389端口】</title><link>http://www.cnblogs.com/heian99/archive/2019/12/20/12075515.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 20 Dec 2019 15:16:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/20/12075515.html</guid><description><![CDATA[<p><strong>内网穿透</strong>，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。就是说<a href="https://baike.baidu.com/item/%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3" data-cke-saved-href="https://baike.baidu.com/item/%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3">映射端口</a>，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。</p>
<h1>问题：</h1>
<p>现在大部分人，工作都在电脑上。但是，家里是WIFI，无法使用电脑带的远程工具。</p>
<p>使用地方工具的话，一直很卡，而且受到很多的限制。所以想搞个穿透来解决。</p>
<h1><strong>解决问题：使用穿透工具解决</strong></h1>
<p><strong>工具推荐：我是用的是网云穿。可以免费申请1M使用。白嫖就行。</strong></p>
<div class="cnblogs_code">
<pre>https:<span style="color: #008000;">//</span><span style="color: #008000;">xiaomy.net/index.html<br /></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>1、下载。这是免安装版本【很nice】</h2>
<p>&nbsp;<span data-cke-copybin-start="1">​<span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="6"><img class="has cke_widget_element" src="https://img-blog.csdnimg.cn/20191214103634441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="800" height="530" data-cke-saved-src="https://img-blog.csdnimg.cn/20191214103634441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20191214103634441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;800&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;530&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span data-cke-copybin-end="1">​</span></span></span></span></span></p>
<p><span data-cke-copybin-start="1">​<span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><img class="has cke_widget_element" src="https://img-blog.csdnimg.cn/20191214104521711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="748" height="392" data-cke-saved-src="https://img-blog.csdnimg.cn/20191214104521711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20191214104521711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;748&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;392&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span data-cke-copybin-end="1">​</span></span></span></span></span></p>
<h2><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1">2、打开【如果没有账号就注册一个】</span></span></span></span></span></h2>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1"><span data-cke-copybin-start="1">​<span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="4"><img class="has cke_widget_element" src="https://img-blog.csdnimg.cn/2019121410442828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="800" height="530" data-cke-saved-src="https://img-blog.csdnimg.cn/2019121410442828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/2019121410442828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;800&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;530&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span data-cke-copybin-end="1">​</span></span></span></span></span></span></span></span></span></span></p>
<h2>3、添加隧道</h2>
<h3>1、先查本机的ip地址</h3>
<p>CMD命令下，输入ipconfig</p>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1"><span data-cke-copybin-start="1">​<span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="3"><img class="has cke_widget_element" src="https://img-blog.csdnimg.cn/20191214104724158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="993" height="519" data-cke-saved-src="https://img-blog.csdnimg.cn/20191214104724158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20191214104724158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;993&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;519&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span data-cke-copybin-end="1">​</span></span></span></span></span></span></span></span></span></span></p>
<p>2、添加隧道的ip和端口</p>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1"><span data-cke-copybin-start="1">​<span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="2"><img class="has cke_widget_element" src="https://img-blog.csdnimg.cn/20191214104856939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="1200" height="445" data-cke-saved-src="https://img-blog.csdnimg.cn/20191214104856939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20191214104856939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;1200&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;445&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span data-cke-copybin-end="1">​</span></span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1">3、启用已经成功</span></span></span></span></span></p>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1"><span data-cke-copybin-start="1">​<span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="1"><img class="has cke_widget_element" src="https://img-blog.csdnimg.cn/20191214104939526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="800" height="530" data-cke-saved-src="https://img-blog.csdnimg.cn/20191214104939526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20191214104939526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;800&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;530&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span data-cke-copybin-end="1">​</span></span></span></span></span></span></span></span></span></span></p>
<h2><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1">4、效果演示【可以正常连接】</span></span></span></span></span></h2>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1"><span data-cke-copybin-start="1">​<span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="0"><img class="has cke_widget_element" src="https://img-blog.csdnimg.cn/20191214105437530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="" width="499" height="502" data-cke-saved-src="https://img-blog.csdnimg.cn/20191214105437530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;https://img-blog.csdnimg.cn/20191214105437530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;499&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;502&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span data-cke-copybin-end="1">​</span></span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1"><strong>可以了，以后在公司，或者其他地方都可以随时远程家里的电脑了【白嫖就是爽】</strong></span></span></span></span></span></p>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1">现在还有web控制器，很方便使用</span></span></span></span></span></p>
<p>&nbsp;</p>
<p><span data-cke-copybin-start="1"><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_focused cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><span class="cke_reset cke_widget_drag_handler_container"><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><span data-cke-copybin-end="1"><img src="https://img2018.cnblogs.com/i-beta/1860862/201912/1860862-20191220231521034-1867247872.png" alt="" /></span></span></span></span></span></p>
]]></description></item><item><title>Docker安装MySQL集群【读写分离】</title><link>http://www.cnblogs.com/heian99/archive/2019/12/19/12104189.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 19 Dec 2019 03:17:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/19/12104189.html</guid><description><![CDATA[
                                            <h2 id="Centos7%E7%B3%BB%E7%BB%9FDocker%E5%AE%89%E8%A3%85" style="margin-left:0cm;"><a href="https://blog.csdn.net/heian_99/article/details/103452223" rel="nofollow">Centos7系统Docker安装</a></h2>

<p id="main-toc"><strong>目录</strong></p>

<p id="Centos7%E7%B3%BB%E7%BB%9FDocker%E5%AE%89%E8%A3%85-toc" style="margin-left:40px;"><a href="#Centos7%E7%B3%BB%E7%BB%9FDocker%E5%AE%89%E8%A3%85" rel="nofollow">Centos7系统Docker安装</a></p>

<p><strong>目录</strong></p>

<p style="margin-left:40px;"><a href="#Centos7%E7%B3%BB%E7%BB%9FDocker%E5%AE%89%E8%A3%85" rel="nofollow">Centos7系统Docker安装</a></p>

<p id="1%E3%80%81%E4%B8%8B%E8%BD%BDmysql%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%B8%8B%E8%BD%BDmysql%E9%95%9C%E5%83%8F" rel="nofollow">1、下载mysql镜像</a></p>

<p id="2%E3%80%81%E5%88%9B%E5%BB%BAMaster%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%90%AF%E5%8A%A8-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9B%E5%BB%BAMaster%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%90%AF%E5%8A%A8" rel="nofollow">2、创建Master实例并启动</a></p>

<p id="%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E" rel="nofollow">参数说明</a></p>

<p id="3%E3%80%81%E5%88%9B%E5%BB%BASlave%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%90%AF%E5%8A%A8-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%88%9B%E5%BB%BASlave%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%90%AF%E5%8A%A8" rel="nofollow">3、创建Slave实例并启动</a></p>

<p id="4%E3%80%81%E6%B7%BB%E5%8A%A0master%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%B7%BB%E5%8A%A0master%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE" rel="nofollow">4、添加master主从复制部分配置</a></p>

<p id="5%E3%80%81%E6%B7%BB%E5%8A%A0master%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%B7%BB%E5%8A%A0master%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE" rel="nofollow">5、添加Slave主从复制部分配置</a></p>

<p id="6%E3%80%81%E4%B8%BAmaster%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E6%9D%A5%E4%BB%96%E7%9A%84%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E4%B8%BAmaster%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E6%9D%A5%E4%BB%96%E7%9A%84%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE" rel="nofollow">6、为master授权用户来他的同步数据</a></p>

<hr id="hr-toc"><hr><p><img alt="" class="has" height="753" src="https://img-blog.csdnimg.cn/20191219104313635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1174"></p>

<h2 id="1%E3%80%81%E4%B8%8B%E8%BD%BDmysql%E9%95%9C%E5%83%8F" style="margin-left:0cm;">1、下载mysql镜像</h2>

<pre class="has"><code> docker search mysql
</code></pre>

<p><img alt="" class="has" height="219" src="https://img-blog.csdnimg.cn/20191219094601685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="830"></p>

<pre class="has"><code> docker pull mysql:5.7
</code></pre>

<p><img alt="" class="has" height="160" src="https://img-blog.csdnimg.cn/20191219094626809.png" width="479"></p>

<pre class="has"><code>docker images
</code></pre>

<p><img alt="" class="has" height="77" src="https://img-blog.csdnimg.cn/20191219094647232.png" width="682"></p>

<h2 id="2%E3%80%81%E5%88%9B%E5%BB%BAMaster%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%90%AF%E5%8A%A8" style="margin-left:0cm;">2、创建Master实例并启动</h2>

<pre class="has"><code class="language-bash">docker run -p 3307:3306 --name mysql-master \
-v /mydata/mysql/master/log:/var/log/mysql \
-v /mydata/mysql/master/data:/var/lib/mysql \
-v /mydata/mysql/master/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7 </code></pre>

<h3 id="%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E" style="margin-left:0cm;"><strong>参数说明</strong></h3>

<ol><li style="margin-left:0cm;">&nbsp; &nbsp; &nbsp; &nbsp;-p 3307:3306：将容器的3306端口映射到主机的3307端口</li>
	<li style="margin-left:0cm;">&nbsp; &nbsp; &nbsp; &nbsp;-v /mydata/mysql/master/conf:/etc/mysql：将配置文件夹挂在到主机</li>
	<li style="margin-left:0cm;">&nbsp; &nbsp; &nbsp; &nbsp;-v /mydata/mysql/master/log:/var/log/mysql：将日志文件夹挂载到主机</li>
	<li style="margin-left:0cm;">&nbsp; &nbsp; &nbsp; &nbsp;-v /mydata/mysql/master/data:/var/lib/mysql/：将配置文件夹挂载到主机</li>
	<li style="margin-left:0cm;">&nbsp; &nbsp; &nbsp; &nbsp;-e MYSQL_ROOT_PASSWORD=root：初始化root用户的密码</li>
</ol><p><img alt="" class="has" height="121" src="https://img-blog.csdnimg.cn/20191219095018294.png" width="550"></p>

<p style="margin-left:0cm;"><strong><em>修改master</em></strong><strong><em>基本配置</em></strong></p>

<pre class="has"><code>vim /mydata/mysql/master/conf/my.cnf</code></pre>

<pre class="has"><code class="language-bash">[client]
default-character-set=utf8
 
[mysql]
default-character-set=utf8
 
[mysqld]
init_connect='SET collation_connection = utf8_unicode_ci'
init_connect='SET NAMES utf8'
character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve
</code></pre>

<p><span style="color:#f33b45;"><strong>注意：skip-name-resolve一定要加，不然连接mysql会超级慢</strong></span></p>

<p><img alt="" class="has" height="202" src="https://img-blog.csdnimg.cn/20191219102412144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="316"></p>

<h2 id="3%E3%80%81%E5%88%9B%E5%BB%BASlave%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%90%AF%E5%8A%A8" style="margin-left:0cm;">3、创建Slave实例并启动</h2>

<pre class="has"><code class="language-bash">docker run -p 3316:3306 --name mysql-slaver-01 \
-v /mydata/mysql/slaver/log:/var/log/mysql \
-v /mydata/mysql/slaver/data:/var/lib/mysql \
-v /mydata/mysql/slaver/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7 
</code></pre>

<p style="margin-left:0cm;"><strong><em>修改slave</em></strong><strong><em>基本配置</em></strong></p>

<pre class="has"><code>vim /mydata/mysql/slaver/conf/my.cnf</code></pre>

<pre class="has"><code>[client]
default-character-set=utf8
 
[mysql]
default-character-set=utf8
 
[mysqld]
init_connect='SET collation_connection = utf8_unicode_ci'
init_connect='SET NAMES utf8'
character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve
</code></pre>

<p><img alt="" class="has" height="273" src="https://img-blog.csdnimg.cn/20191219103328724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="344"></p>

<h2 id="4%E3%80%81%E6%B7%BB%E5%8A%A0master%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE" style="margin-left:0cm;"><strong><em>4、添加master</em></strong><strong><em>主从复制部分配置</em></strong></h2>

<pre class="has"><code>vim /mydata/mysql/master/conf/my.cnf</code></pre>

<pre class="has"><code class="language-bash">server_id=1
log-bin=mysql-bin
read-only=0
binlog-do-db=gmall_ums
binlog-do-db=gmall_pms
binlog-do-db=gmall_oms
binlog-do-db=gmall_sms
binlog-do-db=gmall_cms


replicate-ignore-db=mysql
replicate-ignore-db=sys
replicate-ignore-db=information_schema
replicate-ignore-db=performance_schema
</code></pre>

<p><img alt="" class="has" height="475" src="https://img-blog.csdnimg.cn/20191219104122584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="629"></p>

<p><strong>重启容器</strong></p>

<h2 id="5%E3%80%81%E6%B7%BB%E5%8A%A0master%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE" style="margin-left:0cm;"><strong><em>5、添加</em></strong>Slave<strong><em>主从复制部分配置</em></strong></h2>

<pre class="has"><code>server_id=2
log-bin=mysql-bin
read-only=1
binlog-do-db=gmall_ums
binlog-do-db=gmall_pms
binlog-do-db=gmall_oms
binlog-do-db=gmall_sms
binlog-do-db=gmall_cms


replicate-ignore-db=mysql
replicate-ignore-db=sys
replicate-ignore-db=information_schema
replicate-ignore-db=performance_schema
</code></pre>

<p><img alt="" class="has" height="483" src="https://img-blog.csdnimg.cn/20191219104517664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="690"></p>

<p><strong>重启容器</strong></p>

<p><img alt="" class="has" height="646" src="https://img-blog.csdnimg.cn/20191219104749895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="6%E3%80%81%E4%B8%BAmaster%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E6%9D%A5%E4%BB%96%E7%9A%84%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE" style="margin-left:0cm;">6、为master授权用户来他的同步数据</h2>

<p><img alt="" class="has" height="100" src="https://img-blog.csdnimg.cn/20191219104926649.png" width="1089"></p>

<p><strong>1、进入主库</strong></p>

<pre class="has"><code class="language-bash">docker exec -it 4fdd7f265228 /bin/bash
</code></pre>

<p><img alt="" class="has" height="65" src="https://img-blog.csdnimg.cn/20191219105108322.png" width="499"></p>

<p><strong>2、进入主库mysql数据库</strong></p>

<pre class="has"><code> mysql -u root -p
</code></pre>

<p><img alt="" class="has" height="288" src="https://img-blog.csdnimg.cn/20191219105224448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="676"></p>

<ul><li style="margin-left:0cm;"><strong>&nbsp;1）、授权root可以远程访问（ 主从无关，为了方便我们远程连接mysql）</strong></li>
</ul><pre class="has"><code>grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;</code></pre>

<pre class="has"><code>flush privileges;</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="95" src="https://img-blog.csdnimg.cn/20191219110012867.png" width="761"></p>

<ul><li style="margin-left:0cm;"><strong>&nbsp;&nbsp; 2）、添加用来同步的用户</strong></li>
</ul><pre class="has"><code>&nbsp;&nbsp; GRANT REPLICATION SLAVE ON *.* to 'backup'@'%' identified by '123456';</code></pre>

<p><img alt="" class="has" height="51" src="https://img-blog.csdnimg.cn/20191219110220461.png" width="574"></p>

<ul><li><strong>3）、查看数据库的状态</strong></li>
</ul><pre class="has"><code>   show master status\G;</code></pre>

<p><img alt="" class="has" height="382" src="https://img-blog.csdnimg.cn/20191219110417347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="934"></p>

<p><strong>3、进入从库mysql数据库</strong></p>

<p><img alt="" class="has" height="296" src="https://img-blog.csdnimg.cn/20191219105407554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="600"></p>

<ul><li style="margin-left:0cm;"><strong>&nbsp;1）、授权root可以远程访问（ 主从无关，为了方便我们远程连接mysql）</strong></li>
</ul><pre class="has"><code>grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;</code></pre>

<pre class="has"><code>flush privileges;</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="95" src="https://img-blog.csdnimg.cn/20191219110012867.png" width="761"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<ul><li style="margin-left:0cm;"><strong>&nbsp;2）、设置主库连接</strong></li>
</ul><pre class="has"><code>change master to master_host='192.168.116.129',master_user='backup',master_password='123456',master_log_file='mysql-bin.000001',master_log_pos=0,master_port=3307;</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="120" src="https://img-blog.csdnimg.cn/20191219110811621.png" width="1082"></p>

<ul><li style="margin-left:0cm;"><strong>&nbsp; 3）、启动从库同步</strong></li>
</ul><pre class="has"><code>start slave;</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="83" src="https://img-blog.csdnimg.cn/2019121911090798.png" width="429"></p>

<ul><li style="margin-left:0cm;"><strong>&nbsp;&nbsp;4）、查看从库状态</strong></li>
</ul><pre class="has"><code>&nbsp;&nbsp;&nbsp;&nbsp; show slave status\G;</code></pre>

<p style="margin-left:0cm;">&nbsp;</p>

<p><img alt="" class="has" height="662" src="https://img-blog.csdnimg.cn/20191219110953235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="701"></p>

<p style="margin-left:0cm;">至此主从配置完成；</p>

<p style="margin-left:0cm;"><strong>总结：</strong></p>

<p style="margin-left:0cm;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1）、主从数据库在自己配置文件中声明需要同步哪个数据库，忽略哪个数据库等信息。并且server-id不能一样</strong></p>

<p style="margin-left:0cm;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2）、主库授权某个账号密码来同步自己的数据</strong></p>

<p style="margin-left:0cm;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3）、从库使用这个账号密码连接主库来同步数据</strong></p>

<p style="margin-left:0cm;"><strong>演示效果</strong></p>

<p><img alt="" class="has" height="498" src="https://img-blog.csdnimg.cn/20191219111351514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="894"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Idea SpringBoot 对数据库实例详解</title><link>http://www.cnblogs.com/heian99/archive/2019/12/18/12104190.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 18 Dec 2019 09:45:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/18/12104190.html</guid><description><![CDATA[
                                            <p><img alt="" class="has" height="158" src="https://img-blog.csdnimg.cn/20191218161129253.png" width="557"></p>

<p>SpringBoot 是 SpringMVC 的升级，对于编码、配置、部署和监控，更加简单</p>

<p><strong>微服务</strong></p>

<p>Spring 为 微服务提供了一整套的组件-SpringClound , SpirngBoot 就是该基础。</p>

<p><img alt="" class="has" height="329" src="https://img-blog.csdnimg.cn/20191218161207753.png" width="226"></p>

<h1><strong>第一个SpringBoot程序</strong></h1>

<p>maven配置的中央仓库阿里云镜像</p>

<p>setting.xml</p>

<pre class="has"><code class="language-java">	 &lt;mirror&gt;
      &lt;id&gt;nexus-aliyun&lt;/id&gt;
      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
      &lt;name&gt;Nexus aliyun&lt;/name&gt;
      &lt;url&gt;	https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
    &lt;/mirror&gt;
</code></pre>

<p><strong>使用IDEA创建SpringBoot项目</strong></p>

<p><img alt="" class="has" height="691" src="https://img-blog.csdnimg.cn/20191218161546514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="874"></p>

<p><img alt="" class="has" height="691" src="https://img-blog.csdnimg.cn/20191218161523788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="874"></p>

<p><img alt="" class="has" height="691" src="https://img-blog.csdnimg.cn/20191218161627603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="874"></p>

<p><img alt="" class="has" height="287" src="https://img-blog.csdnimg.cn/20191218161648647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="405"></p>

<p>项目结构为：</p>

<p><img alt="" class="has" height="520" src="https://img-blog.csdnimg.cn/20191218161733175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="527"></p>

<p>项目默认的 maven pom.xml文件</p>

<p>运行SpirngbootdemoApplication的main方法，就能开始运行。</p>

<p>控制台输出：</p>

<p><img alt="" class="has" height="183" src="https://img-blog.csdnimg.cn/20191218161816163.png" width="852"></p>

<p>从这里可以看到 Tomcat 的端口号，因为还没有自定义Controller，所以还没有视图，下面来创建一个输出Hello SpringBoot!的视图。</p>

<p>创建一个HelloController，位于controller包下</p>

<p>HelloController.java</p>

<pre class="has"><code class="language-java">package com.jxust.controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {
  
 @RequestMapping("/hello")
 public String say(){
  return "Hello SpringBoot!";
 }
}</code></pre>

<p>@RestController Spring4 之后新加的注解,原来返回json需要@ResponseBody配合@Controller,现在一个顶俩</p>

<p>在浏览器中输入<a href="http://localhost:8080/hello" rel="nofollow">http://localhost:8080/hello</a>就能输出Hello SpringBoot!这句话。</p>

<p><img alt="" class="has" height="104" src="https://img-blog.csdnimg.cn/20191218161907867.png" width="409"></p>

<p>自定义属性配置</p>

<p>用到的是application.properties这个文件</p>

<p><img alt="" class="has" height="234" src="https://img-blog.csdnimg.cn/2019121816201241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="406"></p>

<p>配置端口号和访问前缀</p>

<p><strong>application.properties</strong></p>

<pre class="has"><code>server.port=8081
server.context-path=/springboot</code></pre>

<p><img alt="" class="has" height="99" src="https://img-blog.csdnimg.cn/20191218162055846.png" width="510"></p>

<p>除了使用.properties格式的文件，还可以使用.yml格式的配置文件(推荐)，更加简便</p>

<p><strong>application.yml</strong></p>

<p>把原来的application.properties文件删除</p>

<p><img alt="" class="has" height="146" src="https://img-blog.csdnimg.cn/2019121816233860.png" width="481"></p>

<p>注意格式，空格不能少</p>

<p>获取配置文件中的属性值</p>

<p>我们也可以在配置文件中，配置数据，在 Controller 中获取,比如：</p>

<pre class="has"><code>server:
  port: 8080
  servlet:
    context-path: /springboot

heian : 乘风破浪</code></pre>

<p>HelloController 获取配置文件中的值</p>

<p>HelloController.java</p>

<pre class="has"><code class="language-java">@RestController
public class HelloController {
    @Value("${heian}")
    private String heian;
    @RequestMapping(value = "/heain",method = RequestMethod.GET)
    public String heian(){
        return heian;
    }
}</code></pre>

<p>返回的为heian的值</p>

<p><img alt="" class="has" height="135" src="https://img-blog.csdnimg.cn/20191218163012391.png" width="362"></p>

<p>配置文件中值配置方式的多样化</p>

<p>配置文件的值可以是多个，也可以是组合，如：</p>

<p><strong>application.yml</strong></p>

<pre class="has"><code class="language-java">name: 乘风
age: 22
或者
name: 乘风
age: 22
content: "name: ${name},age: ${age}"
或者
server:
 port: 8080
 context-path: /springboot
person:
 name: 乘风
 age: 22</code></pre>

<p><strong>前两种配置获取值的方式都是一样的,但是对于这种方式，person 有相应的两个属性，需要这样处理</strong></p>

<p><strong>PersonProperties.java</strong></p>

<pre class="has"><code class="language-java">package com.example.demo.controller;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * @Author:南宫乘风
 * @Date:2019/12/18 16:01
 */
@Component
@ConfigurationProperties(prefix = "person")
public class PersonProperties {
    private String name;
    private String age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }
}
</code></pre>

<p>Alt+insert快捷键提示生成 Getter and Setter</p>

<p>pom.xml需要加入下面的依赖,处理警告</p>

<pre class="has"><code class="language-java">&lt;dependency&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
 &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>

<p><strong>HelloController.java</strong></p>

<pre class="has"><code class="language-java">   @Autowired
    PersonProperties personProperties;

    @RequestMapping(value = "/heian", method = RequestMethod.GET)
    public String hello() {
        return "名字： "+personProperties.getName()+"    年龄： "+personProperties.getAge();
    }</code></pre>

<p><img alt="" class="has" height="156" src="https://img-blog.csdnimg.cn/20191218163405837.png" width="372"></p>

<p>关于配置文件application.yml的多套配置</p>

<p>类似 il8n 文件国际化的配置方式i18n_en_US.properties和i18n_zh_CN.properties</p>

<p>这样能解决，需要频繁修改配置的尴尬</p>

<p><img alt="" class="has" height="169" src="https://img-blog.csdnimg.cn/20191218163423152.png" width="290"></p>

<p>由application.yml配置文件决定使用那套配置文件。</p>

<p><strong>application.yml</strong></p>

<pre class="has"><code class="language-java">spring:
 profiles:
 active: a</code></pre>

<p><strong>application-a.yml</strong></p>

<pre class="has"><code class="language-bash">server:
  port: 8080
  servlet:
    context-path: /springboot

person :
  name : 南宫乘风A
  age : 20</code></pre>

<p><strong>application-b.yml</strong></p>

<pre class="has"><code>server:
  port: 8080
  servlet:
    context-path: /springboot

person :
  name : 南宫乘风B
  age : 22</code></pre>

<h2>SpringBoot增删改查实例</h2>

<p><strong>完整的项目结构</strong></p>

<p><img alt="" class="has" height="676" src="https://img-blog.csdnimg.cn/20191218164100305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="505"></p>

<p>Controller的使用</p>

<ul><li>@Controller 处理http请求</li>
	<li>@RestController Spring4 之后新加的注解，原来返回json需要@ResponseBody配合@Controller</li>
	<li>@RequestMapping 配置url映射</li>
</ul><p>对于 REST 风格的请求</p>

<p><strong>对于 Controller 中的方法上的注解</strong></p>

<pre class="has"><code class="language-java">@RequestMapping(value = “/hello”,method = RequestMethod.GET) 
@RequestMapping(value = “/hello”,method = RequestMethod.POST)
 @RequestMapping(value = “/hello”,method = RequestMethod.DELETE)
 @RequestMapping(value = “/hello”,method = RequestMethod.PUT)
</code></pre>

<p><strong>SpringBoot 对上面的注解进行了简化</strong></p>

<pre class="has"><code class="language-java">@GetMapping(value = “/girls”)
@PostMapping(value = “/girls”) 
@PutMapping(value = “/girls/{id}”) 
@DeleteMapping(value = “/girls/{id}”)
</code></pre>

<p><strong>浏览器需要发送不同方式的请求，可以安装HttpRequester插件，火狐浏览器可以直接搜索该组件安装。</strong></p>

<p><img alt="" class="has" height="283" src="https://img-blog.csdnimg.cn/20191218164425261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="490"></p>

<p><strong>spring-data-jpa</strong></p>

<p>JPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>

<p>Hibernate3.2+、TopLink 10.1.3以及OpenJPA都提供了JPA的实现。</p>

<p>利用JPA创建MySQL数据库</p>

<p><strong>pom.xml加入JPA和MySQL的依赖</strong></p>

<pre class="has"><code class="language-java">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;mysql&lt;/groupId&gt;
   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
  &lt;/dependency&gt;
   &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.38&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>

<p><strong>配置JPA和数据库</strong></p>

<p><strong>application.yml</strong></p>

<pre class="has"><code class="language-java">spring:
  profiles:
  active: a
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url : jdbc:mysql://127.0.0.1:3306/heian
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true</code></pre>

<p>格式很重要</p>

<p>需要自己手动去创建 db_person 数据库</p>

<p>创建与数据表对应的实体类Person</p>

<p><img alt="" class="has" height="43" src="https://img-blog.csdnimg.cn/20191218165229836.png" width="300"></p>

<p><strong>Person.java</strong></p>

<pre class="has"><code class="language-java">package com.example.demo.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

/**
 * @Author:南宫乘风
 * @Date:2019/12/18 16:38
 */
@Entity
public class Person {
    @Id
    @GeneratedValue
    private Integer id;
    private String name;
    private Integer age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
</code></pre>

<p>运行项目后，查看数据库，会自动创建表 person</p>

<p><img alt="" class="has" height="90" src="https://img-blog.csdnimg.cn/20191218165822570.png" width="636"></p>

<p>接下来就可以进行person表的增删改查了</p>

<p><strong>创建控制器PersonController.java</strong></p>

<p>首先创建一个接口PersonMapper，位于dao包下,PersonController调用该接口继承自JpaRepository的方法，来实现和数据库交互</p>

<p>这个PersonMapper接口的功能，与SSM框架中 dao 层接口功能有异曲同工之妙；在SSM框架中，Service层通过该接口，间接执行Mybatis数据库映射文件(.xml)里的相应sql语句，执行数据库增删改查的操作。(Mapper自动实现DAO接口)</p>

<p><strong>PersonMapper.java</strong></p>

<pre class="has"><code class="language-java">package com.example.demo.dao;
import com.example.demo.entity.Person;
import org.springframework.data.jpa.repository.JpaRepository;
/**
 * @Author:南宫乘风
 * @Date:2019/12/18 16:38
 */
public interface PersonMapper extends JpaRepository&lt;Person,Integer&gt; {
}</code></pre>

<p><strong>PersonController.java</strong></p>

<pre class="has"><code class="language-java">package com.example.demo.controller;
import com.example.demo.dao.PersonMapper;
import com.example.demo.entity.Person;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;
/**
 * @Author:南宫乘风
 * @Date:2019/12/18 16:39
 */
@RestController
public class PersonController {
    @Autowired
    PersonMapper personMapper;
    @GetMapping(value = "/person")
    public List&lt;Person&gt; personList(){
        return personMapper.findAll();
    }
}</code></pre>

<p>在数据库中添加两条数据</p>

<p><img alt="" class="has" height="159" src="https://img-blog.csdnimg.cn/20191218170434863.png" width="255"></p>

<p>启动项目执行请求<a href="http://localhost:8081/springboot/person" rel="nofollow">http://localhost:8080/person</a></p>

<p><img alt="" class="has" height="328" src="https://img-blog.csdnimg.cn/20191218170829433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="517"></p>

<p><strong>控制台输出的sql语句：</strong></p>

<p><img alt="" class="has" height="93" src="https://img-blog.csdnimg.cn/20191218170844354.png" width="1200"></p>

<p><strong>其他增删改查的方法</strong></p>

<p><strong>PersonController.java</strong></p>

<pre class="has"><code class="language-java">/**
     * 添加一个人员
     * @param name
     * @param age
     * @return
     */
    @PostMapping(value = "/person")
    public Person add(@RequestParam("name") String name, @RequestParam("age") Integer age) {

        Person person = new Person();
        person.setName(name);
        person.setAge(age);
        return personMapper.save(person);
    }</code></pre>

<p><strong>利用ApiPost测试【已经成功】</strong></p>

<p><img alt="" class="has" height="636" src="https://img-blog.csdnimg.cn/20191218172123678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>更新其他方法</strong></p>
                                    ]]></description></item><item><title>Linux下磁盘实战操作命令</title><link>http://www.cnblogs.com/heian99/archive/2019/12/17/12056340.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 17 Dec 2019 11:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/17/12056340.html</guid><description><![CDATA[
                                            <p>&nbsp; &nbsp; &nbsp; 企业真实场景由于硬盘常年<span style="color:#f33b45;">大量读写</span>，经常会出现<span style="color:#f33b45;">坏盘</span>，需要<span style="color:#f33b45;">更换硬盘</span>。或者由于磁盘空间不足，需添加新硬盘，新添加的硬盘需要经过<span style="color:#f33b45;">格式化</span>、<span style="color:#f33b45;">分区</span>才能被 Linux 系统所使用。</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;虚拟机 CentOS 7 Linux 模拟DELL R730 真实服务器添加一块新硬盘，不需要关机，直接插入用硬盘即可，一般硬盘均支持热插拔功能。企业中添加新硬盘的操作流程如下：</p>

<p>（1） 检测Linux系统识别的硬盘设备，新添加硬盘被识别为/dev/sdb，如果有多块硬盘，会依次识别成/dev/sdc、/dev/sdd 等设备名称</p>

<pre class="has"><code>fdisk -l</code></pre>

<p><br><img alt="" class="has" height="565" src="https://img-blog.csdnimg.cn/20191216205706409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="731"></p>

<p>（2） 基于新硬盘/dev/sdb设备，创建磁盘分区/dev/sdb1</p>

<pre class="has"><code>fdisk /dev/sdb</code></pre>

<p><img alt="" class="has" height="618" src="https://img-blog.csdnimg.cn/20191216230722943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="892"></p>

<p>（3） fdisk 分区命令参数如下，常用参数包括m、n、p、e、d、w。<br><img alt="" class="has" height="369" src="https://img-blog.csdnimg.cn/20191216230850786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="450"></p>

<p><img alt="" class="has" height="408" src="https://img-blog.csdnimg.cn/20191216233226648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="517"></p>

<p>（4） 创建/dev/sdb1 分区方法，fdisk /dev/sdb，然后按 n-p-1-Enter 键+20G-Enter 键-w，最后执行 fdisk –l|tail -10</p>

<p><img alt="" class="has" height="482" src="https://img-blog.csdnimg.cn/20191216233448579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="909"></p>

<p>（5） mkfs.ext4 /dev/sdb1 格式化磁盘分区</p>

<pre class="has"><code>mkfs.ext4 /dev/sdb1
</code></pre>

<p><img alt="" class="has" height="489" src="https://img-blog.csdnimg.cn/20191216233552574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="772"></p>

<p>（6） /dev/sdb1 分区格式化，使用mount 命令挂载到/data/目录</p>

<ol><li>mkdir -p /data/ 创建/data/数据目录</li>
	<li>mount /dev/sdb1 /data 挂载/dev/sdb1 分区至/data/目录</li>
	<li>df -h 查看磁盘分区详情</li>
	<li>echo "mount /dev/sdb1 /data" &gt;&gt;/etc/rc.local 将 挂 载 分 区 命 令 加 入/etc/rc.local 开机启动</li>
</ol><p><img alt="" class="has" height="481" src="https://img-blog.csdnimg.cn/20191216233917643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="805"></p>

<p>（7） 自动挂载分区除了可以加入到/etc/rc.local 开机启动之外，还可以加入到/etc/fstab文件中</p>

<ul><li>/dev/sdb1 /data/ ext4 defaults&nbsp; 0 0</li>
	<li>mount -o rw,remount / 重新挂载/系统，检测/etc/fstab 是否有误</li>
</ul><p><img alt="" class="has" height="432" src="https://img-blog.csdnimg.cn/20191216234434499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1015"></p>

<p><img alt="" class="has" height="383" src="https://img-blog.csdnimg.cn/20191216234810535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="957"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Docker容器数据卷介绍和命令</title><link>http://www.cnblogs.com/heian99/archive/2019/12/17/12056341.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 17 Dec 2019 11:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/17/12056341.html</guid><description><![CDATA[
                                            <h1><span style="color:#f33b45;">是什么</span></h1>

<p><strong>一句话：有点类似我们Redis里面的rdb和aof文件</strong></p>

<p><span style="color:#000000;">先来看看Docker的理念：</span></p>

<p><span style="color:#000000;">* &nbsp;将运用与运行的环境打包形成容器运行&nbsp;，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</span></p>

<p><span style="color:#000000;">* &nbsp;容器之间希望有可能共享数据</span></p>

<p><span style="color:#000000;">Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，</span></p>

<p><span style="color:#000000;">那么当容器删除后，数据自然也就没有了。</span></p>

<p><span style="color:#000000;">为了能保存数据在docker中我们使用卷。</span></p>

<h1><span style="color:#f33b45;">能干嘛</span></h1>

<ol><li><strong>容器的持久化</strong></li>
	<li><strong>容器间继承+共享数据</strong></li>
</ol><p><span style="color:#000000;">卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</span></p>

<p><span style="color:#000000;">&nbsp;卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</span></p>

<p><span style="color:#000000;">特点：</span></p>

<ul><li><span style="color:#000000;">1：数据卷可在容器之间共享或重用数据</span></li>
	<li><span style="color:#000000;">2：卷中的更改可以直接生效</span></li>
	<li><span style="color:#000000;">3：数据卷中的更改不会包含在镜像的更新中</span></li>
	<li><span style="color:#000000;">4：数据卷的生命周期一直持续到没有容器使用它为止</span></li>
</ul><h1><span style="color:#f33b45;">数据卷</span></h1>

<p>&nbsp;</p>

<h2><span style="color:#ffbb66;">直接命令添加</span></h2>

<h3><strong>1、命令</strong></h3>

<pre class="has"><code> docker run -it -v /宿主机绝对路径目录:/容器内目录      镜像名</code></pre>

<pre class="has"><code>docker run -it -v /wei:/wei centos</code></pre>

<h3><img alt="" class="has" height="241" src="https://img-blog.csdnimg.cn/20191212104146330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="857"></h3>

<h3><strong>2、查看数据卷是否挂载成功</strong></h3>

<pre class="has"><code>docker inspect df6f397beedd
</code></pre>

<p><img alt="" class="has" height="316" src="https://img-blog.csdnimg.cn/20191212104551815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="593"></p>

<h3><strong>3、容器和宿主机之间数据共享</strong></h3>

<p><img alt="" class="has" height="261" src="https://img-blog.csdnimg.cn/20191212104652698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h3><strong>4、容器停止退出后，主机修改后数据是否同步【<span style="color:#f33b45;">完全同步</span>】</strong></h3>

<p><img alt="" class="has" height="403" src="https://img-blog.csdnimg.cn/20191212104715515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h3><strong>5、命令(带权限)</strong></h3>

<pre class="has"><code> docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code></pre>

<h3><img alt="" class="has" height="110" src="https://img-blog.csdnimg.cn/20191212105055534.png" width="401"></h3>

<h2><span style="color:#ffbb66;">DockerFile添加</span></h2>

<p><strong>1、根目录下新建mydocker文件夹并进入</strong></p>

<p><strong>2、可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</strong></p>

<p><span style="color:#000000;">VOLUME["/dataVolumeContainer","/dataVolumeContainer2","/dataVolumeContainer3"]</span></p>

<p><span style="color:#000000;">说明：</span></p>

<p><span style="color:#000000;">出于可移植和分享的考虑，<span style="color:#0000ff;">用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。</span></span></p>

<p><span style="color:#000000;">由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</span></p>

<p><strong>3、File构建</strong></p>

<pre class="has"><code class="language-bash"># volume test

FROM centos

VOLUME ["/dataVolumeContainer1","/dataVolumeContainer2"]

CMD echo "finished,--------success1"

CMD /bin/bash</code></pre>

<p><img alt="" class="has" height="222" src="https://img-blog.csdnimg.cn/20191212112407408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="547"></p>

<p><strong>4、build后生成镜像</strong></p>

<pre class="has"><code> docker build --f /root/heian -t heian/centos .</code></pre>

<h3><img alt="" class="has" height="409" src="https://img-blog.csdnimg.cn/20191212112428988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="950"></h3>

<p><strong>5、run容器</strong></p>

<p><img alt="" class="has" height="349" src="https://img-blog.csdnimg.cn/20191212112644761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="937"></p>

<p><strong>6、通过上述步骤，容器内的卷目录地址已经知道对应的主机目录地址哪？？</strong></p>

<p><img alt="" class="has" height="578" src="https://img-blog.csdnimg.cn/20191212113001978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1080"></p>

<h3>7、主机对应默认地址</h3>

<p>数据完全可以同步</p>

<h3><span style="color:#ffbb66;">备注</span></h3>

<p><span style="color:#000000;">Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied</span></p>

<p><span style="color:#000000;">解决办法：在挂载目录后多加一个--privileged=true参数即可</span></p>

<h1><span style="color:#f33b45;">数据卷容器</span></h1>

<h2>是什么</h2>

<p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器</p>

<h2>总体介绍</h2>

<p><strong>1、以上一步新建的镜像heian/centos为模板并运行容器dc01/dc02/dc03</strong></p>

<p><strong>2、它们已经具有容器卷</strong></p>

<ul><li>/dataVolumeContainer1</li>
	<li>/dataVolumeContainer2</li>
</ul><h2>容器间传递共享(--volumes-from)</h2>

<p><strong>1、先启动一个父容器dc01，在dataVolumeContainer2新增内容</strong></p>

<p><img alt="" class="has" height="481" src="https://img-blog.csdnimg.cn/20191212113637576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="798"></p>

<p><strong>2、dc02/dc03继承自dc01</strong></p>

<pre class="has"><code>docker run -it --name dc02 --volumes-from dc01 zzyy/centos</code></pre>

<p>dc02/dc03分别在dataVolumeContainer2各自新增内容</p>

<p><img alt="" class="has" height="512" src="https://img-blog.csdnimg.cn/20191212113748430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1057"></p>

<p><strong>3、回到dc01可以看到02/03各自添加的都能共享了</strong></p>

<p><img alt="" class="has" height="246" src="https://img-blog.csdnimg.cn/20191212113847101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1038"></p>

<p><strong>4、删除dc01，dc02修改后dc03可否访问</strong></p>

<p><img alt="" class="has" height="515" src="https://img-blog.csdnimg.cn/20191212113914777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1036"></p>

<p><strong>5、删除dc02后dc03可否访问</strong></p>

<p><img alt="" class="has" height="284" src="https://img-blog.csdnimg.cn/20191212113937477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1042"></p>

<p><strong>再进一步</strong></p>

<p><img alt="" class="has" height="125" src="https://img-blog.csdnimg.cn/20191212113954142.png" width="755"></p>

<p><strong>6、新建dc04继承dc03后再删除dc03</strong></p>

<p><img alt="" class="has" height="404" src="https://img-blog.csdnimg.cn/20191212114012974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1049"></p>

<p><span style="color:#f33b45;"><strong>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</strong></span></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Docker 镜像介绍和命令</title><link>http://www.cnblogs.com/heian99/archive/2019/12/17/12056342.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 17 Dec 2019 11:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/17/12056342.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:0px;"><a href="#%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">是什么</a></p>

<p id="UnionFS%EF%BC%88%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89-toc" style="margin-left:40px;"><a href="#UnionFS%EF%BC%88%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89" rel="nofollow">UnionFS（联合文件系统）</a></p>

<p id="%C2%A0Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%C2%A0Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86" rel="nofollow">&nbsp;Docker镜像加载原理</a></p>

<p id="%E5%88%86%E5%B1%82%E7%9A%84%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#%E5%88%86%E5%B1%82%E7%9A%84%E9%95%9C%E5%83%8F" rel="nofollow">分层的镜像</a></p>

<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%20Docker%20%E9%95%9C%E5%83%8F%E8%A6%81%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%91%A2-toc" style="margin-left:40px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%20Docker%20%E9%95%9C%E5%83%8F%E8%A6%81%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%91%A2" rel="nofollow">为什么 Docker 镜像要采用这种分层结构呢</a></p>

<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p>

<p id="Docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E8%A1%A5%E5%85%85-toc" style="margin-left:0px;"><a href="#Docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E8%A1%A5%E5%85%85" rel="nofollow">Docker镜像commit操作补充</a></p>

<p id="%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA" rel="nofollow">案例演示</a></p>

<p id="1%E3%80%81%E4%BB%8EHub%E4%B8%8A%E4%B8%8B%E8%BD%BDtomcat%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%B9%B6%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E4%BB%8EHub%E4%B8%8A%E4%B8%8B%E8%BD%BDtomcat%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%B9%B6%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C" rel="nofollow">1、从Hub上下载tomcat镜像到本地并成功运行</a></p>

<p id="2%E3%80%81%E6%95%85%E6%84%8F%E5%88%A0%E9%99%A4%E4%B8%8A%E4%B8%80%E6%AD%A5%E9%95%9C%E5%83%8F%E7%94%9F%E4%BA%A7tomcat%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E6%A1%A3-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E6%95%85%E6%84%8F%E5%88%A0%E9%99%A4%E4%B8%8A%E4%B8%80%E6%AD%A5%E9%95%9C%E5%83%8F%E7%94%9F%E4%BA%A7tomcat%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E6%A1%A3" rel="nofollow">2、故意删除上一步镜像生产tomcat容器的文档</a></p>

<p id="3%E3%80%81commit%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89doc%E7%9A%84tomcat%E6%96%B0%E9%95%9C%E5%83%8F-toc" style="margin-left:80px;"><a href="#3%E3%80%81commit%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89doc%E7%9A%84tomcat%E6%96%B0%E9%95%9C%E5%83%8F" rel="nofollow">3、commit一个没有doc的tomcat新镜像</a></p>

<p id="4.%E5%90%AF%E5%8A%A8%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B0%E9%95%9C%E5%83%8F%E5%B9%B6%E5%92%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#4.%E5%90%AF%E5%8A%A8%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B0%E9%95%9C%E5%83%8F%E5%B9%B6%E5%92%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">4.启动我们的新镜像并和原来的对比</a></p>

<hr id="hr-toc"><h1 id="%E6%98%AF%E4%BB%80%E4%B9%88">是什么</h1>

<p>镜像是一种轻量级、可执行的独立软件包，<span style="color:#ff0000;">用来打包软件运行环境和基于运行环境开发的软件</span>，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>

<h2 id="UnionFS%EF%BC%88%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89">UnionFS（联合文件系统）</h2>

<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<span style="color:#ff0000;">对文件系统的修改作为一次提交来一层层的叠加，</span>同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>

<p><img alt="" class="has" height="314" src="https://img-blog.csdnimg.cn/20191210151957847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="526"></p>

<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>

<h2 id="%C2%A0Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86">&nbsp;Docker镜像加载原理</h2>

<p><span style="color:#000000;">docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</span></p>

<p><span style="color:#000000;">bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，<span style="color:#ff0000;">在Docker镜像的最底层是bootfs。</span>这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</span></p>

<p>rootfs (root file system) ，在bootfs之上<span style="color:#000000;">。</span>包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>

<p><img alt="" class="has" height="440" src="https://img-blog.csdnimg.cn/20191210152138263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="631"></p>

<p><strong>&nbsp;平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</strong></p>

<p><img alt="" class="has" height="161" src="https://img-blog.csdnimg.cn/20191210152231510.png" width="789"></p>

<h2 id="%E5%88%86%E5%B1%82%E7%9A%84%E9%95%9C%E5%83%8F">分层的镜像</h2>

<p><span style="color:#000000;">以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</span></p>

<p><img alt="" class="has" height="283" src="https://img-blog.csdnimg.cn/2019121015252170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="668"></p>

<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%20Docker%20%E9%95%9C%E5%83%8F%E8%A6%81%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%91%A2">为什么 Docker 镜像要采用这种分层结构呢</h2>

<p><span style="color:#000000;">最大的一个好处就是 - 共享资源</span></p>

<p><span style="color:#000000;">&nbsp;比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，</span></p>

<p><span style="color:#000000;">同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</span></p>

<h1 id="%E7%89%B9%E7%82%B9"><span style="color:#f33b45;"><strong>特点</strong></span></h1>

<p>Docker镜像都是只读的<br>
当容器启动时，一个新的可写层被加载到镜像的顶部。<br>
这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>

<h1 id="Docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E8%A1%A5%E5%85%85">Docker镜像commit操作补充</h1>

<p>&nbsp;</p>

<p>docker commit提交容器副本使之成为一个新的镜像</p>

<p>&nbsp;</p>

<p>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名]</p>

<p>&nbsp;</p>

<h2 id="%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA">案例演示</h2>

<h3 id="1%E3%80%81%E4%BB%8EHub%E4%B8%8A%E4%B8%8B%E8%BD%BDtomcat%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%B9%B6%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C">1、从Hub上下载tomcat镜像到本地并成功运行</h3>

<p>&nbsp;</p>

<p><strong>-p 主机端口:docker容器端口【<span style="color:#f33b45;">指定端口</span>】</strong></p>

<pre class="has"><code>docker run -it -p 8080:8080 tomcat</code></pre>

<p><img alt="" class="has" height="395" src="https://img-blog.csdnimg.cn/20191210160132315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="887"></p>

<p><span style="color:#f33b45;"><strong>-P 随机分配端口</strong></span></p>

<pre class="has"><code>docker run -it -P tomcat</code></pre>

<p><img alt="" class="has" height="479" src="https://img-blog.csdnimg.cn/20191212094736722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>i:交互</strong></p>

<p><strong>t:终端</strong></p>

<p>&nbsp;</p>

<h3 id="2%E3%80%81%E6%95%85%E6%84%8F%E5%88%A0%E9%99%A4%E4%B8%8A%E4%B8%80%E6%AD%A5%E9%95%9C%E5%83%8F%E7%94%9F%E4%BA%A7tomcat%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E6%A1%A3">2、故意删除上一步镜像生产tomcat容器的文档</h3>

<p><img alt="" class="has" height="249" src="https://img-blog.csdnimg.cn/20191212095237947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="777"></p>

<p><img alt="" class="has" height="626" src="https://img-blog.csdnimg.cn/20191212095755453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="829"></p>

<p><img alt="" class="has" height="330" src="https://img-blog.csdnimg.cn/20191212095823276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="701"></p>

<h3 id="3%E3%80%81commit%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89doc%E7%9A%84tomcat%E6%96%B0%E9%95%9C%E5%83%8F">3、commit一个没有doc的tomcat新镜像</h3>

<p><strong>也即当前的tomcat运行实例是一个没有文档内容的容器，<br>
以它为模板commit一个没有doc的tomcat新镜像heian/tomcat02</strong></p>

<pre class="has"><code>docker commit -a "wei" -m "del tomcat docs" 63982bc3e2d9 heian/mytomcat:1.2</code></pre>

<p><img alt="" class="has" height="329" src="https://img-blog.csdnimg.cn/20191212101021935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="891"></p>

<h3 id="4.%E5%90%AF%E5%8A%A8%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B0%E9%95%9C%E5%83%8F%E5%B9%B6%E5%92%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%AF%B9%E6%AF%94">4.启动我们的新镜像并和原来的对比</h3>

<p><strong>启动heian/tomcat02，它没有docs</strong></p>

<pre class="has"><code>docker run -it -p 7777:8080 heian/mytomcat:1.2 </code></pre>

<p><img alt="" class="has" height="504" src="https://img-blog.csdnimg.cn/2019121210170761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>新启动原来的tomcat，它有docs</strong></p>

<p><img alt="" class="has" height="249" src="https://img-blog.csdnimg.cn/20191212095237947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="777"></p>
                                    ]]></description></item><item><title>Docker命令总结</title><link>http://www.cnblogs.com/heian99/archive/2019/12/11/12026249.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 11 Dec 2019 14:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/11/12026249.html</guid><description><![CDATA[
                                            <p><img alt="" class="has" height="638" src="https://img-blog.csdnimg.cn/20191210150243559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="900"></p>

<p>&nbsp;</p>

<ul><li><strong><span style="color:#f33b45;">attach </span></strong><span style="color:#000000;">&nbsp;&nbsp; Attach to a running container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 当前 shell 下 attach 连接指定运行镜像</span></li>
	<li><span style="color:#f33b45;"><strong>build &nbsp;</strong></span><span style="color:#000000;">&nbsp;&nbsp; Build an image from a Dockerfile &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 通过 Dockerfile 定制镜像</span></li>
	<li><span style="color:#f33b45;"><strong>commit </strong></span><span style="color:#000000;">&nbsp;&nbsp; Create a new image from a container changes &nbsp; # 提交当前容器为新的镜像</span></li>
	<li><span style="color:#f33b45;"><strong>cp &nbsp;&nbsp;</strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Copy files/folders from the containers filesystem to the host path &nbsp; #从容器中拷贝指定文件或者目录到宿主机中</span></li>
	<li><span style="color:#f33b45;"><strong>create</strong></span><span style="color:#000000;"> &nbsp;&nbsp; Create a new container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 创建一个新的容器，同 run，但不启动容器</span></li>
	<li><span style="color:#f33b45;"><strong>diff </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Inspect changes on a container's filesystem &nbsp; # 查看 docker 容器变化</span></li>
	<li><span style="color:#f33b45;"><strong>events </strong></span><span style="color:#000000;">&nbsp;&nbsp; Get real time events from the server &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 从 docker 服务获取容器实时事件</span></li>
	<li><span style="color:#f33b45;"><strong>exec </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Run a command in an existing container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 在已存在的容器上运行命令</span></li>
	<li><span style="color:#f33b45;"><strong>export </strong></span><span style="color:#000000;">&nbsp;&nbsp; Stream the contents of a container as a tar archive &nbsp; # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></li>
	<li><span style="color:#f33b45;"><strong>history</strong></span><span style="color:#000000;"> &nbsp; Show the history of an image &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 展示一个镜像形成历史</span></li>
	<li><span style="color:#f33b45;"><strong>images</strong></span><span style="color:#000000;"> &nbsp;&nbsp; List images &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 列出系统当前镜像</span></li>
	<li><span style="color:#f33b45;"><strong>import </strong></span><span style="color:#000000;">&nbsp;&nbsp; Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span></li>
	<li><span style="color:#f33b45;"><strong>info &nbsp;</strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp; Display system-wide information &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 显示系统相关信息</span></li>
	<li><span style="color:#f33b45;"><strong>inspect</strong></span><span style="color:#000000;"> &nbsp; Return low-level information on a container &nbsp; # 查看容器详细信息</span></li>
	<li><span style="color:#f33b45;"><strong>kill </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Kill a running container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # kill 指定 docker 容器</span></li>
	<li><span style="color:#f33b45;"><strong>load</strong></span><span style="color:#000000;"> &nbsp;&nbsp;&nbsp;&nbsp; Load an image from a tar archive &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 从一个 tar 包中加载一个镜像[对应 save]</span></li>
	<li><span style="color:#f33b45;"><strong>login</strong></span><span style="color:#000000;"> &nbsp;&nbsp;&nbsp; Register or Login to the docker registry server &nbsp;&nbsp; # 注册或者登陆一个 docker 源服务器</span></li>
	<li><span style="color:#f33b45;"><strong>logout </strong></span><span style="color:#000000;">&nbsp;&nbsp; Log out from a Docker registry server &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;# 从当前 Docker registry 退出</span></li>
	<li><span style="color:#f33b45;"><strong>logs </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Fetch the logs of a container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 输出当前容器日志信息</span></li>
	<li><span style="color:#f33b45;"><strong>port </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Lookup the public-facing port which is NAT-ed to PRIVATE_PORT &nbsp;&nbsp; # 查看映射端口对应的容器内部源端口</span></li>
	<li><span style="color:#f33b45;"><strong>pause </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp; Pause all processes within a container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 暂停容器</span></li>
	<li><span style="color:#f33b45;"><strong>ps &nbsp;</strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List containers &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 列出容器列表</span></li>
	<li><span style="color:#f33b45;"><strong>pull </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Pull an image or a repository from the docker registry server &nbsp; # 从docker镜像源服务器拉取指定镜像或者库镜像</span></li>
	<li><span style="color:#f33b45;"><strong>push </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Push an image or a repository to the docker registry server &nbsp;&nbsp; # 推送指定镜像或者库镜像至docker源服务器</span></li>
	<li><span style="color:#f33b45;"><strong>restart</strong></span><span style="color:#000000;"> &nbsp; Restart a running container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 重启运行的容器</span></li>
	<li><span style="color:#f33b45;"><strong>rm </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remove one or more containers &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 移除一个或者多个容器</span></li>
	<li><span style="color:#f33b45;"><strong>rmi &nbsp;</strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Remove one or more images &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></li>
	<li><span style="color:#f33b45;"><strong>run </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Run a command in a new container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 创建一个新的容器并运行一个命令</span></li>
	<li><span style="color:#f33b45;"><strong>save </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Save an image to a tar archive &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 保存一个镜像为一个 tar 包[对应 load]</span></li>
	<li><span style="color:#f33b45;"><strong>search </strong></span><span style="color:#000000;">&nbsp;&nbsp; Search for an image on the Docker Hub &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 在 docker hub 中搜索镜像</span></li>
	<li><span style="color:#f33b45;"><strong>start </strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp; Start a stopped containers &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 启动容器</span></li>
	<li><span style="color:#f33b45;"><strong>stop</strong></span><span style="color:#000000;"> &nbsp;&nbsp;&nbsp;&nbsp; Stop a running containers &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 停止容器</span></li>
	<li><span style="color:#f33b45;"><strong>tag &nbsp;</strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Tag an image into a repository &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 给源中镜像打标签</span></li>
	<li><span style="color:#f33b45;"><strong>top &nbsp;</strong></span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp; Lookup the running processes of a container &nbsp; # 查看容器中运行的进程信息</span></li>
	<li><span style="color:#f33b45;"><strong>unpause &nbsp; </strong></span><span style="color:#000000;">Unpause a paused container &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 取消暂停容器</span></li>
	<li><span style="color:#f33b45;"><strong>version</strong></span><span style="color:#000000;"> &nbsp; Show the docker version information &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 查看 docker 版本号</span></li>
	<li><span style="color:#f33b45;"><strong>wait &nbsp;&nbsp;&nbsp;&nbsp; </strong></span><span style="color:#000000;">Block until a container stops, then print its exit code &nbsp; # 截取容器停止时的退出状态值</span></li>
</ul>                                    ]]></description></item><item><title>Docker启动守护式容器</title><link>http://www.cnblogs.com/heian99/archive/2019/12/11/12026250.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 11 Dec 2019 14:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/11/12026250.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8" rel="nofollow">启动守护式容器</a></p>

<p id="%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97" rel="nofollow">查看容器日志</a></p>

<p id="docker%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C-toc" style="margin-left:40px;"><a href="#docker%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C" rel="nofollow">docker后台运行</a></p>

<p id="%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B" rel="nofollow">查看容器内运行的进程</a></p>

<p id="%E2%80%8B%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82" rel="nofollow">​查看容器内部细节</a></p>

<p id="%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B9%B6%E4%BB%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92-toc" style="margin-left:40px;"><a href="#%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B9%B6%E4%BB%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92" rel="nofollow">进入正在运行的容器并以命令行交互</a></p>

<p id="%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5-toc" style="margin-left:40px;"><a href="#%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5" rel="nofollow">重新进入</a></p>

<p id="%E4%B8%8A%E8%BF%B0%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#%E4%B8%8A%E8%BF%B0%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%88%AB" rel="nofollow">上述两个区别</a></p>

<p id="%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%86%85%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A-toc" style="margin-left:40px;"><a href="#%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%86%85%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A" rel="nofollow">从容器内拷贝文件到主机上</a></p>

<hr id="hr-toc"><h2 id="%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8"><span style="color:#f33b45;"><strong>启动守护式容器</strong></span></h2>

<pre class="has"><code>docker run -d 容器名</code></pre>

<p><span style="color:#000000;">#使用镜像centos:latest以后台模式启动一个容器</span></p>

<pre class="has"><code>docker run -d centos</code></pre>

<p><span style="color:#000000;">&nbsp;问题：然后docker ps -a 进行查看,&nbsp;<span style="color:#0000ff;">会发现容器已经退出</span></span></p>

<p><img alt="" class="has" height="212" src="https://img-blog.csdnimg.cn/20191210143129964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1037"></p>

<p><span style="color:#000000;">很重要的要说明的一点:&nbsp;<span style="color:#ff0000;">Docker容器后台运行,就必须有一个前台进程.</span></span></p>

<p><span style="color:#000000;">容器运行的命令如果不是那些<span style="color:#ff0000;">一直挂起的命令</span>（比如运行top，tail），就是会自动退出的。</span></p>

<p><span style="color:#000000;">&nbsp;这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如</span></p>

<pre class="has"><code>service nginx start</code></pre>

<p><span style="color:#000000;">但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,</span></p>

<p><span style="color:#000000;">这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.</span></p>

<p><span style="color:#000000;">所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行</span></p>

<h2 id="%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span style="color:#f33b45;"><strong>查看容器日志</strong></span></h2>

<pre class="has"><code>docker logs -f -t --tail 容器ID</code></pre>

<ul><li>* &nbsp; -t 是加入时间戳</li>
	<li>* &nbsp; -f 跟随最新的日志打印</li>
	<li>* &nbsp; --tail 数字 显示最后多少条</li>
</ul><p><img alt="" class="has" height="287" src="https://img-blog.csdnimg.cn/20191210143340560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="786"></p>

<h2 id="docker%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span style="color:#f33b45;">docker后台运行</span></h2>

<pre class="has"><code class="language-bash"> docker run -d centos /bin/sh -c "while true;do echo hello zzyy;sleep 2;done"</code></pre>

<h2 id="%E2%80%8B"><img alt="" class="has" height="275" src="https://img-blog.csdnimg.cn/20191210144121681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="673"></h2>

<h2 id="%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span style="color:#f33b45;"><strong>查看容器内运行的进程</strong></span></h2>

<pre class="has"><code>docker top 容器ID</code></pre>

<h2 id="%E2%80%8B%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><img alt="" class="has" height="147" src="https://img-blog.csdnimg.cn/2019121014422663.png" width="1102"><span style="color:#f33b45;"><strong>查看容器内部细节</strong></span></h2>

<pre class="has"><code>docker inspect 容器ID</code></pre>

<h2><img alt="" class="has" height="518" src="https://img-blog.csdnimg.cn/20191210144339876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="992"></h2>

<h2 id="%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B9%B6%E4%BB%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92"><span style="color:#f33b45;"><strong>进入正在运行的容器并以命令行交互</strong></span></h2>

<pre class="has"><code>docker exec -it 容器ID bashShell</code></pre>

<h2><img alt="" class="has" height="232" src="https://img-blog.csdnimg.cn/20191210145040348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="562"></h2>

<h2 id="%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5"><span style="color:#f33b45;">重新进入</span></h2>

<pre class="has"><code>docker attach 容器ID</code></pre>

<h2><img alt="" class="has" height="208" src="https://img-blog.csdnimg.cn/20191210145325824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="573"></h2>

<h2 id="%E4%B8%8A%E8%BF%B0%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%88%AB">上述两个区别</h2>

<ul><li><span style="color:#3399ea;">attach： 直接进入容器启动命令的终端，不会启动新的进程</span></li>
	<li><span style="color:#3399ea;">exec： 是在容器中打开新的终端，并且可以启动新的进程</span></li>
</ul><h2 id="%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%86%85%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A"><span style="color:#f33b45;"><strong>从容器内拷贝文件到主机上</strong></span></h2>

<pre class="has"><code>docker cp  容器ID:容器内路径 目的主机路径</code></pre>

<p><img alt="" class="has" height="370" src="https://img-blog.csdnimg.cn/20191210150015467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1023"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Docker容器常用命令</title><link>http://www.cnblogs.com/heian99/archive/2019/12/11/12026251.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 11 Dec 2019 14:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/11/12026251.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8" rel="nofollow">新建并启动容器</a></p>

<p id="OPTIONS%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#OPTIONS%E8%AF%B4%E6%98%8E" rel="nofollow">OPTIONS说明</a></p>

<p id="%E5%90%AF%E5%8A%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%B9%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E5%90%AF%E5%8A%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%B9%E5%99%A8" rel="nofollow">启动交互式容器</a></p>

<p id="%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8" rel="nofollow">列出当前所有正在运行的容器</a></p>

<p id="%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8" rel="nofollow">退出容器</a></p>

<p id="exit-toc" style="margin-left:80px;"><a href="#exit" rel="nofollow">exit</a></p>

<p id="ctrl%2BP%2BQ-toc" style="margin-left:80px;"><a href="#ctrl%2BP%2BQ" rel="nofollow">ctrl+P+Q</a></p>

<p id="%E8%BF%9B%E5%85%A5%E5%87%BA%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E8%BF%9B%E5%85%A5%E5%87%BA%E5%AE%B9%E5%99%A8" rel="nofollow">进入出容器</a></p>

<p id="%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8" rel="nofollow">启动容器</a></p>

<p id="%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8" rel="nofollow">停止容器</a></p>

<p id="%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8" rel="nofollow">强制停止容器</a></p>

<p id="%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8" rel="nofollow">删除已停止的容器</a></p>

<p id="%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8" rel="nofollow">一次性删除多个容器</a></p>

<hr id="hr-toc"><p>&nbsp;</p>

<blockquote>
<p><strong>有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示)</strong></p>
</blockquote>

<pre class="has"><code class="language-bash">docker pull centos</code></pre>

<p><img alt="" class="has" height="147" src="https://img-blog.csdnimg.cn/20191209172937238.png" width="714"></p>

<h2 id="%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><strong>新建并启动容器</strong></h2>

<p><strong>docker run [<span style="color:#f33b45;">OPTIONS</span>] IMAGE [<span style="color:#f33b45;">COMMAND</span>] [<span style="color:#f33b45;">ARG</span>...]</strong></p>

<h3 id="OPTIONS%E8%AF%B4%E6%98%8E">OPTIONS说明</h3>

<p><span style="color:#000000;">OPTIONS说明（常用）：有些是一个减号，有些是两个减号</span></p>

<ul><li><span style="color:#000000;">--name="容器新名字": 为容器指定一个名称；</span></li>
	<li><span style="color:#000000;">-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</span></li>
	<li><span style="color:#000000;"><span style="color:#ff0000;">-i：以交互模式运行容器，通常与 -t 同时使用；</span></span></li>
	<li><span style="color:#000000;"><span style="color:#ff0000;">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span></span></li>
	<li><span style="color:#000000;">-P: 随机端口映射；</span></li>
</ul><p>&nbsp;</p>

<ul><li><span style="color:#000000;">-p: 指定端口映射，有以下四种格式</span></li>
	<li><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip:hostPort:containerPort</span></li>
	<li><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip::containerPort</span></li>
	<li><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;hostPort:containerPort</span></span></li>
	<li><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerPort</span></li>
</ul><h3 id="%E5%90%AF%E5%8A%A8%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%B9%E5%99%A8">启动交互式容器</h3>

<p><strong>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</strong></p>

<pre class="has"><code class="language-bash">docker run -it centos /bin/bash </code></pre>

<p><img alt="" class="has" height="72" src="https://img-blog.csdnimg.cn/20191209173613526.png" width="785"></p>

<h2 id="%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8">列出当前所有正在运行的容器</h2>

<p><strong>docker ps [<span style="color:#f33b45;">OPTIONS</span>]</strong></p>

<p><span style="color:#000000;">OPTIONS说明（常用）：</span></p>

<ul><li><span style="color:#000000;">-a :<span style="color:#282828;">列出当前所有</span><span style="color:#ff0000;">正在运行</span><span style="color:#282828;">的容器</span><span style="color:#282828;">+</span><span style="color:#ff0000;">历史上运行过</span><span style="color:#282828;">的（docker ps</span></span><span style="color:#000000;"><span style="color:#282828;">）</span></span><img alt="" class="has" height="150" src="https://img-blog.csdnimg.cn/20191209174141861.png" width="1085"></li>
	<li><span style="color:#000000;">-l :显示最近创建的容器。</span></li>
	<li><span style="color:#000000;">-n：显示最近n个创建的容器。</span></li>
	<li><span style="color:#000000;"><span style="color:#ff0000;">-q :静默模式，只显示容器编号。</span></span></li>
	<li><span style="color:#000000;">--no-trunc :不截断输出</span></li>
</ul><h2 id="%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8">退出容器</h2>

<h3 id="exit">exit</h3>

<ul><li><span style="color:#f33b45;"><strong>容器停止退出</strong></span></li>
</ul><h3 id="ctrl%2BP%2BQ"><strong>ctrl+P+Q</strong></h3>

<ul><li><span style="color:#f33b45;"><strong>容器不停止退出</strong></span></li>
</ul><h2 id="%E8%BF%9B%E5%85%A5%E5%87%BA%E5%AE%B9%E5%99%A8">进入出容器</h2>

<p><strong>docker attach&nbsp;&nbsp;名称</strong></p>

<pre class="has"><code> docker attach edc486762ad2</code></pre>

<p><img alt="" class="has" height="127" src="https://img-blog.csdnimg.cn/20191209180317727.png" width="347"></p>

<h2 id="%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8">启动容器</h2>

<pre class="has"><code>docker start 容器ID或者容器名</code></pre>

<p><strong style="color:#4f4f4f;font-size:24px;font-weight:700;">重启容器</strong></p>

<pre class="has"><code>docker restart 容器ID或者容器名</code></pre>

<h2 id="%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8">停止容器</h2>

<pre class="has"><code>docker stop 容器ID或者容器名</code></pre>

<h2 id="%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8">强制停止容器</h2>

<pre class="has"><code>docker kill 容器ID或者容器名</code></pre>

<h2 id="%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8">删除已停止的容器</h2>

<pre class="has"><code>docker rm 容器ID</code></pre>

<h2 id="%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8">一次性删除多个容器</h2>

<pre class="has"><code>docker rm -f $(docker ps -a -q)</code></pre>

<pre class="has"><code>docker ps -a -q | xargs docker rm</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Docker镜像常用命令</title><link>http://www.cnblogs.com/heian99/archive/2019/12/09/12012605.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 09 Dec 2019 09:25:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/09/12012605.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4" rel="nofollow">帮助命令</a></p>

<p id="%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4" rel="nofollow">镜像命令</a></p>

<p style="margin-left:40px;"><a href="#%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F" rel="nofollow">列出本地主机上的镜像</a></p>

<p style="margin-left:40px;"><a href="#docker%20search%20%E6%9F%90%E4%B8%AAXXX%E9%95%9C%E5%83%8F%E5%90%8D%E5%AD%97" rel="nofollow">docker search 某个XXX镜像名字</a></p>

<p id="docker%20pull%20%E6%9F%90%E4%B8%AAXXX%E9%95%9C%E5%83%8F%E5%90%8D%E5%AD%97-toc" style="margin-left:40px;"><a href="#docker%20pull%20%E6%9F%90%E4%B8%AAXXX%E9%95%9C%E5%83%8F%E5%90%8D%E5%AD%97" rel="nofollow">docker pull 某个XXX镜像名字</a></p>

<p id="%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F" rel="nofollow">删除镜像</a></p>

<hr id="hr-toc"><h2 id="%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4">帮助命令</h2>

<pre class="has"><code>docker version</code></pre>

<p><img alt="" class="has" height="477" src="https://img-blog.csdnimg.cn/20191209110618276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="474"></p>

<pre class="has"><code>docker info</code></pre>

<p><img alt="" class="has" height="488" src="https://img-blog.csdnimg.cn/20191209110738194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="646"></p>

<pre class="has"><code>docker --help</code></pre>

<p><img alt="" class="has" height="327" src="https://img-blog.csdnimg.cn/20191209110801845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="782"></p>

<h2 id="%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4">镜像命令</h2>

<pre class="has"><code>docker images</code></pre>

<h3 id="%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F">列出本地主机上的镜像</h3>

<p><img alt="" class="has" height="137" src="https://img-blog.csdnimg.cn/20191209111049708.png" width="701"></p>

<p><span style="color:#000000;">各个选项说明:</span></p>

<ul><li>REPOSITORY：表示镜像的仓库源</li>
	<li><span style="color:#000000;">TAG：镜像的标签</span></li>
	<li><span style="color:#000000;">IMAGE ID：镜像ID</span></li>
	<li><span style="color:#000000;">CREATED：镜像创建时间</span></li>
	<li><span style="color:#000000;">SIZE：镜像大小</span></li>
</ul><p>&nbsp;</p>

<ul><li><span style="color:#f33b45;">-a :列出本地所有的镜像（含中间映像层）</span><img alt="" class="has" height="75" src="https://img-blog.csdnimg.cn/20191209111417319.png" width="677"></li>
	<li><span style="color:#f33b45;">-q :只显示镜像ID。</span></li>
	<li><img alt="" class="has" height="60" src="https://img-blog.csdnimg.cn/20191209111645528.png" width="348"></li>
	<li><span style="color:#f33b45;">--digests :显示镜像的摘要信息</span><img alt="" class="has" height="92" src="https://img-blog.csdnimg.cn/20191209111612839.png" width="1051"></li>
	<li><span style="color:#f33b45;">--no-trunc :显示完整的镜像信息</span><img alt="" class="has" height="131" src="https://img-blog.csdnimg.cn/20191209111840714.png" width="1075"></li>
</ul><p><span style="color:#000000;">同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</span></p>

<p><span style="color:#000000;">如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</span></p>

<h3 id="docker%20search%20%E6%9F%90%E4%B8%AAXXX%E9%95%9C%E5%83%8F%E5%90%8D%E5%AD%97">docker search 某个XXX镜像名字</h3>

<p><strong>网站</strong></p>

<p><a href="https://hub.docker.com" rel="nofollow">https://hub.docker.com</a></p>

<p><strong>命令</strong></p>

<pre class="has"><code>docker search [OPTIONS] 镜像名字</code></pre>

<p><img alt="" class="has" height="136" src="https://img-blog.csdnimg.cn/20191209112039202.png" width="1013"></p>

<p>OPTIONS说明：</p>

<ul><li>--no-trunc : 显示完整的镜像描述</li>
</ul><p><img alt="" class="has" height="162" src="https://img-blog.csdnimg.cn/20191209112556124.png" width="1037"></p>

<ul><li>-s : 列出收藏数不小于指定值的镜像。</li>
</ul><p><img alt="" class="has" height="192" src="https://img-blog.csdnimg.cn/2019120911251532.png" width="851"></p>

<ul><li>--automated : 只列出 automated build类型的镜像；</li>
</ul><p><img alt="" class="has" height="183" src="https://img-blog.csdnimg.cn/20191209112647955.png" width="1037"></p>

<h2 id="docker%20pull%20%E6%9F%90%E4%B8%AAXXX%E9%95%9C%E5%83%8F%E5%90%8D%E5%AD%97">docker pull 某个XXX镜像名字</h2>

<p><strong>下载镜像</strong></p>

<pre class="has"><code>docker pull 镜像名字[:TAG]</code></pre>

<p><img alt="" class="has" height="224" src="https://img-blog.csdnimg.cn/20191209112916321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="902"></p>

<pre class="has"><code>docker  pull tomcat
</code></pre>

<p><img alt="" class="has" height="265" src="https://img-blog.csdnimg.cn/20191209165858974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="655"></p>

<p><img alt="" class="has" height="199" src="https://img-blog.csdnimg.cn/20191209170037662.png" width="937"></p>

<h2 id="%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><strong>删除镜像</strong></h2>

<p><span style="color:#f33b45;"><strong>docker rmi 某个XXX镜像名字ID</strong></span></p>

<blockquote>
<p><strong>删除单个</strong></p>
</blockquote>

<pre class="has"><code>docker rmi  -f 镜像ID</code></pre>

<p><img alt="" class="has" height="97" src="https://img-blog.csdnimg.cn/20191209170531976.png" width="849"></p>

<blockquote>
<p><strong>删除多个</strong></p>
</blockquote>

<pre class="has"><code>docker rmi -f 镜像名1:TAG 镜像名2:TAG </code></pre>

<pre class="has"><code>docker rmi -f hello-world nginx</code></pre>

<p><img alt="" class="has" height="252" src="https://img-blog.csdnimg.cn/2019120917183790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="776"></p>

<blockquote>
<p><strong>删除全部</strong></p>
</blockquote>

<pre class="has"><code>docker rmi -f $(docker images -qa)</code></pre>

<p><img alt="" class="has" height="478" src="https://img-blog.csdnimg.cn/2019120917232912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="805"></p>
                                    ]]></description></item><item><title>Centos7系统Docker安装</title><link>http://www.cnblogs.com/heian99/archive/2019/12/09/12012606.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 09 Dec 2019 03:05:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/09/12012606.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E5%89%8D%E6%9C%9F%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E6%9C%9F%E8%AF%B4%E6%98%8E" rel="nofollow">前期说明</a></p>

<p id="%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-toc" style="margin-left:0px;"><a href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4" rel="nofollow">安装步骤</a></p>

<p id="1%E3%80%81%E5%AE%98%E7%BD%91%E4%B8%AD%E6%96%87%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%AE%98%E7%BD%91%E4%B8%AD%E6%96%87%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C" rel="nofollow">1、官网中文安装参考手册</a></p>

<p id="2%E3%80%81%E7%A1%AE%E5%AE%9A%E4%BD%A0%E6%98%AFCentOS7%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%A1%AE%E5%AE%9A%E4%BD%A0%E6%98%AFCentOS7%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC" rel="nofollow">2、确定你是CentOS7及以上版本</a></p>

<p id="3%E3%80%81yum%E5%AE%89%E8%A3%85gcc%E7%9B%B8%E5%85%B3-toc" style="margin-left:40px;"><a href="#3%E3%80%81yum%E5%AE%89%E8%A3%85gcc%E7%9B%B8%E5%85%B3" rel="nofollow">3、yum安装gcc相关</a></p>

<p id="4%E3%80%81%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC" rel="nofollow">4、卸载旧版本</a></p>

<p id="5%E3%80%81%E5%AE%89%E8%A3%85%E9%9C%80%E8%A6%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%AE%89%E8%A3%85%E9%9C%80%E8%A6%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85" rel="nofollow">5、安装需要的软件包</a></p>

<p id="6%E3%80%81%E8%AE%BE%E7%BD%AEstable%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E8%AE%BE%E7%BD%AEstable%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93" rel="nofollow">6、设置stable镜像仓库</a></p>

<p id="7%E3%80%81%E6%9B%B4%E6%96%B0yum%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E6%9B%B4%E6%96%B0yum%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%B4%A2%E5%BC%95" rel="nofollow">7、更新yum软件包索引</a></p>

<p style="margin-left:40px;"><a href="#8%E3%80%81%E5%AE%89%E8%A3%85DOCKER-CE" rel="nofollow">8、安装DOCKER-CE</a></p>

<p id="9%E3%80%81%E5%90%AF%E5%8A%A8docker-toc" style="margin-left:40px;"><a href="#9%E3%80%81%E5%90%AF%E5%8A%A8docker" rel="nofollow">9、启动docker</a></p>

<p id="10%E3%80%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#10%E3%80%81%E6%B5%8B%E8%AF%95" rel="nofollow">10、测试</a></p>

<p id="11%E3%80%81%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F-toc" style="margin-left:40px;"><a href="#11%E3%80%81%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F" rel="nofollow">11、配置镜像加速</a></p>

<p id="12%E3%80%81%E5%8D%B8%E8%BD%BD-toc" style="margin-left:40px;"><a href="#12%E3%80%81%E5%8D%B8%E8%BD%BD" rel="nofollow">12、卸载</a></p>

<p id="%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86" rel="nofollow">底层原理</a></p>

<p id="1%E3%80%81Docker%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84-toc" style="margin-left:40px;"><a href="#1%E3%80%81Docker%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84" rel="nofollow">1、Docker是怎么工作的</a></p>

<p id="2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Docker%E6%AF%94%E8%BE%83%E6%AF%94VM%E5%BF%AB-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Docker%E6%AF%94%E8%BE%83%E6%AF%94VM%E5%BF%AB" rel="nofollow">2、为什么Docker比较比VM快</a></p>

<hr id="hr-toc"><h1 id="%E5%89%8D%E6%9C%9F%E8%AF%B4%E6%98%8E"><strong>前期说明</strong></h1>

<p><span style="color:#000000;"><span style="color:#0000ff;"><strong>CentOS Docker 安装</strong></span></span></p>

<p><span style="color:#000000;">Docker支持以下的CentOS版本：</span></p>

<p><span style="color:#000000;">CentOS 7 (64-bit)</span></p>

<p><span style="color:#000000;">CentOS 6.5 (64-bit) 或更高的版本</span></p>

<p><span style="color:#000000;"><span style="color:#0000ff;"><strong>前提条件</strong></span></span></p>

<p><span style="color:#000000;">目前，CentOS 仅发行版本中的内核支持 Docker。</span></p>

<p><span style="color:#000000;">Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。</span></p>

<p><span style="color:#000000;">Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位<span style="color:#ff0000;">、系统内核版本为 2.6.32-431 或者更高版本。</span></span></p>

<p><span style="color:#000000;"><span style="color:#0000ff;"><strong>查看自己的内核</strong></span></span></p>

<p><span style="color:#000000;">uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</span></p>

<p><img alt="" class="has" height="128" src="https://img-blog.csdnimg.cn/2019120909053022.png" width="381"></p>

<p>查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）</p>

<p><img alt="" class="has" height="204" src="https://img-blog.csdnimg.cn/20191209090705982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1106"></p>

<p>Centos7</p>

<p><img alt="" class="has" height="133" src="https://img-blog.csdnimg.cn/20191209090645659.png" width="275"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="183" src="https://img-blog.csdnimg.cn/20191209090811471.png" width="511"><br>
&nbsp;</p>

<h1 id="%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装步骤</h1>

<p>&nbsp;</p>

<h2 id="1%E3%80%81%E5%AE%98%E7%BD%91%E4%B8%AD%E6%96%87%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C">1、官网中文安装参考手册</h2>

<p><a href="https://docs.docker.com/install/linux/docker-ce/centos/" rel="nofollow">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>

<h2 id="2%E3%80%81%E7%A1%AE%E5%AE%9A%E4%BD%A0%E6%98%AFCentOS7%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC">2、确定你是CentOS7及以上版本</h2>

<p><img alt="" class="has" height="132" src="https://img-blog.csdnimg.cn/20191209101910198.png" width="365"></p>

<h2 id="3%E3%80%81yum%E5%AE%89%E8%A3%85gcc%E7%9B%B8%E5%85%B3">3、yum安装gcc相关</h2>

<p><strong>CentOS7能上外网</strong></p>

<p><img alt="" class="has" height="397" src="https://img-blog.csdnimg.cn/20191209102025841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="595"></p>

<pre class="has"><code>yum -y install gcc
yum -y install gcc-c++</code></pre>

<h2 id="4%E3%80%81%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC">4、卸载旧版本</h2>

<pre class="has"><code>yum -y remove docker docker-common docker-selinux docker-engine</code></pre>

<p><strong>2018.3官网版本</strong></p>

<pre class="has"><code>
yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine</code></pre>

<h2 id="5%E3%80%81%E5%AE%89%E8%A3%85%E9%9C%80%E8%A6%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85">5、安装需要的软件包</h2>

<pre class="has"><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre>

<h2 id="6%E3%80%81%E8%AE%BE%E7%BD%AEstable%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93">6、设置stable镜像仓库</h2>

<blockquote>
<p><span style="color:#f33b45;"><strong>大坑</strong></span></p>
</blockquote>

<pre class="has"><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre>

<p><strong>报错：</strong><br><span style="color:#f33b45;">1 &nbsp; [Errno 14] curl#35 - TCP connection reset by peer&nbsp;<br>
2 &nbsp; [Errno 12] curl#35 - Timeout</span><br>
注意：因为这是Docker的官网的，是外国的，所以下载慢。</p>

<p><strong>解决：<span style="color:#f33b45;">推荐使用阿里云源，或者网易的源</span></strong></p>

<blockquote>
<p><span style="color:#f33b45;"><strong>推荐</strong></span></p>
</blockquote>

<pre class="has"><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre>

<p><strong>注意</strong>：<span style="color:#f33b45;"><strong>这里是阿里云的源，国内的，速度很快。</strong></span></p>

<p><img alt="" class="has" height="275" src="https://img-blog.csdnimg.cn/20191209103234127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="842"></p>

<h2 id="7%E3%80%81%E6%9B%B4%E6%96%B0yum%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%B4%A2%E5%BC%95">7、更新yum软件包索引</h2>

<pre class="has"><code>yum makecache fast</code></pre>

<p><img alt="" class="has" height="267" src="https://img-blog.csdnimg.cn/20191209103332400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="624"></p>

<h3 id="8%E3%80%81%E5%AE%89%E8%A3%85DOCKER-CE">8、安装DOCKER-CE</h3>

<pre class="has"><code>yum -y install docker-ce</code></pre>

<h2 id="9%E3%80%81%E5%90%AF%E5%8A%A8docker">9、启动docker</h2>

<pre class="has"><code>systemctl start docker</code></pre>

<h2 id="10%E3%80%81%E6%B5%8B%E8%AF%95">10、测试</h2>

<pre class="has"><code>docker version</code></pre>

<p><img alt="" class="has" height="579" src="https://img-blog.csdnimg.cn/20191209103717137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="612"></p>

<pre class="has"><code>docker run hello-world</code></pre>

<p><img alt="" class="has" height="516" src="https://img-blog.csdnimg.cn/20191209103821938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="562"></p>

<h2 id="11%E3%80%81%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F">11、配置镜像加速</h2>

<p>1、创建目录（docker会自动创建）</p>

<pre class="has"><code>mkdir -p /etc/docker</code></pre>

<p>2、使用阿里云的加速地址</p>

<pre class="has"><code>vim  /etc/docker/daemon.json</code></pre>

<p><img alt="" class="has" height="130" src="https://img-blog.csdnimg.cn/20191209104628821.png" width="507"></p>

<p><img alt="" class="has" height="799" src="https://img-blog.csdnimg.cn/20191209104534262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="956"></p>

<pre class="has"><code>systemctl daemon-reload</code></pre>

<p>3、重启Docker</p>

<pre class="has"><code>systemctl restart docker</code></pre>

<h2 id="12%E3%80%81%E5%8D%B8%E8%BD%BD">12、卸载</h2>

<p>停止Docker</p>

<pre class="has"><code>systemctl stop docker </code></pre>

<p>yum卸载Docker</p>

<pre class="has"><code>yum -y remove docker-ce</code></pre>

<p>rm删除Docker的目录</p>

<pre class="has"><code>rm -rf /var/lib/docker</code></pre>

<h1 id="%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">底层原理</h1>

<h2 id="1%E3%80%81Docker%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84">1、Docker是怎么工作的</h2>

<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器<span style="color:#000000;">。</span><span style="color:#ff0000;">&nbsp;容器，是一个运行时环境，就是我们前面说到的集装箱。</span></p>

<p><img alt="" class="has" height="841" src="https://img-blog.csdnimg.cn/20191209110025739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="854"></p>

<h2 id="2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Docker%E6%AF%94%E8%BE%83%E6%AF%94VM%E5%BF%AB">2、为什么Docker比较比VM快</h2>

<p>(1)docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>

<p>(2)docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p>

<p><img alt="" class="has" height="542" src="https://img-blog.csdnimg.cn/20191209110143217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="796"></p>

<p><img alt="" class="has" height="506" src="https://img-blog.csdnimg.cn/20191209110219865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1077"></p>
                                    ]]></description></item><item><title>Docker组成三要素</title><link>http://www.cnblogs.com/heian99/archive/2019/12/09/12012607.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 09 Dec 2019 00:42:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/09/12012607.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#%E9%95%9C%E5%83%8F" rel="nofollow">镜像</a></p>

<p style="margin-left:40px;"><a href="#%E5%AE%B9%E5%99%A8" rel="nofollow">容器</a></p>

<p style="margin-left:40px;"><a href="#%E4%BB%93%E5%BA%93" rel="nofollow">仓库</a></p>

<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p>

<hr id="hr-toc"><p><strong>Docker的基本组成三要素</strong></p>

<ul><li>
	<p id="%E9%95%9C%E5%83%8F"><strong>镜像</strong></p>
	</li>
	<li>
	<p id="%E5%AE%B9%E5%99%A8"><strong>容器</strong></p>
	</li>
	<li>
	<p id="%E4%BB%93%E5%BA%93"><strong>仓库</strong></p>
	</li>
</ul><h3>镜像</h3>

<div id="inspector">
<div>
<div>
<p>Docker 镜像（Image）就是一个<span style="color:#ff0000;"><strong>只读</strong></span>的模板。镜像可以用来创建 Docker 容器，<span style="color:#ff0000;">一个镜像可以创建很多容器</span>。</p>

<p><img alt="" class="has" height="174" src="https://img-blog.csdnimg.cn/20191209083715214.png" width="744"></p>

<h3><strong>容器</strong></h3>

<ul><li><span style="color:#000000;">Docker 利用容器（Container）独立运行的一个或一组应用。<span style="color:#ff0000;">容器是用镜像创建的运行实例</span>。</span></li>
	<li><span style="color:#000000;">它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</span></li>
	<li><span style="color:#000000;"><span style="color:#ff0000;"><strong><em>可以把容器看做是一个简易版的 Linux 环境</em></strong></span>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</span></li>
	<li><span style="color:#000000;">容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</span></li>
</ul><p>&nbsp;</p>

<h3><strong>仓库</strong></h3>

<p><span style="color:#000000;">仓库（Repository）是<span style="color:#ff0000;">集中存放镜像</span>文件的场所。</span></p>

<p><span style="color:#000000;">仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</span></p>

<p><span style="color:#000000;">仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</span></p>

<p><span style="color:#000000;"><span style="color:#ff0000;">最大的公开仓库是 Docker Hub(https://hub.docker.com/)</span>，</span></p>

<p><span style="color:#000000;">存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等</span></p>

<p>&nbsp;</p>

<h2 id="%E6%80%BB%E7%BB%93">总结</h2>

<p><span style="color:#000000;">需要正确的理解仓储/镜像/容器这几个概念:</span></p>

<ul><li><span style="color:#000000;">&nbsp;Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</span></li>
	<li><span style="color:#000000;">* &nbsp;image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</span></li>
	<li><span style="color:#000000;">* &nbsp;一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</span></li>
	<li><span style="color:#000000;">* 至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</span></li>
</ul><p><img alt="" class="has" height="493" src="https://img-blog.csdnimg.cn/20191209084126705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="894"></p>
</div>
</div>
</div>
                                    ]]></description></item><item><title>Docker简介</title><link>http://www.cnblogs.com/heian99/archive/2019/12/09/12012609.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 09 Dec 2019 00:19:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/09/12012609.html</guid><description><![CDATA[
                                            <p><strong>Docker简介主要从这三方介绍</strong></p>

<ul><li><strong>是什么</strong></li>
	<li><strong>能干嘛</strong></li>
	<li><strong>去哪下</strong></li>
</ul><p id="main-toc"><strong>目录</strong></p>

<p id="%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">是什么</a></p>

<p id="%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89docker%E5%87%BA%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89docker%E5%87%BA%E7%8E%B0" rel="nofollow">问题：为什么会有docker出现</a></p>

<p id="Docker%E7%90%86%E5%BF%B5-toc" style="margin-left:80px;"><a href="#Docker%E7%90%86%E5%BF%B5" rel="nofollow">Docker理念</a></p>

<p id="%E4%B8%80%E5%8F%A5%E8%AF%9D-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E5%8F%A5%E8%AF%9D" rel="nofollow">一句话</a></p>

<p id="%E8%83%BD%E5%B9%B2%E5%98%9B-toc" style="margin-left:40px;"><a href="#%E8%83%BD%E5%B9%B2%E5%98%9B" rel="nofollow">能干嘛</a></p>

<p id="%E4%B9%8B%E5%89%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF-toc" style="margin-left:80px;"><a href="#%E4%B9%8B%E5%89%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF" rel="nofollow">之前的虚拟机技术</a></p>

<p id="%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF-toc" style="margin-left:80px;"><a href="#%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF" rel="nofollow">容器虚拟化技术</a></p>

<p id="%E5%BC%80%E5%8F%91%2F%E8%BF%90%E7%BB%B4%EF%BC%88DevOps%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%BC%80%E5%8F%91%2F%E8%BF%90%E7%BB%B4%EF%BC%88DevOps%EF%BC%89" rel="nofollow">开发/运维（DevOps）</a></p>

<p id="%E4%BC%81%E4%B8%9A%E7%BA%A7-toc" style="margin-left:80px;"><a href="#%E4%BC%81%E4%B8%9A%E7%BA%A7" rel="nofollow">企业级</a></p>

<p id="%E5%8E%BB%E5%93%AA%E4%B8%8B-toc" style="margin-left:40px;"><a href="#%E5%8E%BB%E5%93%AA%E4%B8%8B" rel="nofollow">去哪下</a></p>

<p id="1%E3%80%81%E5%AE%98%E7%BD%91-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%AE%98%E7%BD%91" rel="nofollow">1、官网</a></p>

<p id="2%E3%80%81%E4%BB%93%E5%BA%93-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E4%BB%93%E5%BA%93" rel="nofollow">2、仓库</a></p>

<hr id="hr-toc"><h2 id="%E6%98%AF%E4%BB%80%E4%B9%88">是什么</h2>

<h3 id="%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89docker%E5%87%BA%E7%8E%B0">问题：为什么会有docker出现</h3>

<p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验</p>

<p>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</p>

<p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，<span style="color:#ff0000;">软件可以带环境安装？</span>也就是说，<span style="color:#ff0000;">安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</span></p>

<p><img alt="" class="has" height="546" src="https://img-blog.csdnimg.cn/20191209080436443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1047"></p>

<p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p>

<p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<span style="color:#0000ff;">开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况</span>。Docker镜像的设计，<span style="color:#ff0000;">使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</span></p>

<h3 id="Docker%E7%90%86%E5%BF%B5">Docker理念</h3>

<p><span style="color:#000000;">Docker是基于Go语言实现的云开源项目。</span></p>

<p><span style="color:#000000;">Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到<span style="color:#ff0000;">“一次封装，到处运行”。</span></span></p>

<p><img alt="" class="has" height="433" src="https://img-blog.csdnimg.cn/20191209080611349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="978"></p>

<p>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<span style="color:#ff0000;">只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</span></p>

<h3 id="%E4%B8%80%E5%8F%A5%E8%AF%9D">一句话</h3>

<p>解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>

<p>&nbsp;</p>

<h2 id="%E8%83%BD%E5%B9%B2%E5%98%9B">能干嘛</h2>

<h3 id="%E4%B9%8B%E5%89%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF">之前的虚拟机技术</h3>

<p><span style="color:#000000;">虚拟机（virtual machine）就是带环境安装的一种解决方案。</span></p>

<p><span style="color:#000000;">它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</span></p>

<p><img alt="" class="has" height="551" src="https://img-blog.csdnimg.cn/20191209080815380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="350"></p>

<p><span style="color:#000000;">虚拟机的缺点：</span></p>

<ul><li><span style="color:#000000;">1 &nbsp;&nbsp;&nbsp;资源占用多&nbsp;</span></li>
	<li><span style="color:#000000;">2 &nbsp;&nbsp;&nbsp;冗余步骤多&nbsp;&nbsp;&nbsp;&nbsp;</span></li>
	<li><span style="color:#000000;">&nbsp;3 &nbsp;&nbsp;&nbsp;启动慢</span></li>
</ul><h3 id="%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF">容器虚拟化技术</h3>

<p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>

<p><span style="color:#ff0000;">Linux 容器不是模拟一个完整的操作系统</span>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p>

<p><img alt="" class="has" height="551" src="https://img-blog.csdnimg.cn/20191209080928931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="399"></p>

<p>比较了 Docker 和传统虚拟化方式的不同之处：</p>

<ul><li><span style="color:#000000;">*传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</span></li>
	<li><span style="color:#000000;">*而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，<span style="color:#ff0000;">而且也没有进行硬件虚拟</span>。因此容器要比传统虚拟机更为轻便。</span></li>
	<li><span style="color:#000000;">* 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</span></li>
</ul><h3 id="%E5%BC%80%E5%8F%91%2F%E8%BF%90%E7%BB%B4%EF%BC%88DevOps%EF%BC%89">开发/运维（DevOps）</h3>

<p><strong>一次构建、随处运行</strong></p>

<p><strong>更快速的应用交付和部署</strong></p>

<ul><li>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</li>
</ul><p><strong>更便捷的升级和扩缩容</strong></p>

<ul><li>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</li>
</ul><p><strong>更简单的系统运维</strong></p>

<ul><li>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</li>
</ul><p><strong>更高效的计算资源利用</strong></p>

<ul><li>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</li>
</ul><h3 id="%E4%BC%81%E4%B8%9A%E7%BA%A7">企业级</h3>

<p><strong>新浪</strong></p>

<p><img alt="" class="has" height="1200" src="https://img-blog.csdnimg.cn/20191209082503437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="861"></p>

<p><strong>美团</strong></p>

<p>&nbsp;</p>

<p><strong>蘑</strong><img alt="" class="has" height="1146" src="https://img-blog.csdnimg.cn/20191209082527708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="793"><strong>菇街</strong></p>

<p><img alt="" class="has" height="1099" src="https://img-blog.csdnimg.cn/20191209081543803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="689"></p>

<h2 id="%E5%8E%BB%E5%93%AA%E4%B8%8B">去哪下</h2>

<h3 id="1%E3%80%81%E5%AE%98%E7%BD%91">1、官网</h3>

<p><strong>docker官网：http://www.docker.com</strong></p>

<p><img alt="" class="has" height="914" src="https://img-blog.csdnimg.cn/2019120908175383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>docker中文网站：https://www.docker-cn.com/</strong></p>

<h3 id="2%E3%80%81%E4%BB%93%E5%BA%93">2、仓库</h3>

<p><strong>Docker Hub官网: https://hub.docker.com/</strong></p>

<p><img alt="" class="has" height="534" src="https://img-blog.csdnimg.cn/20191209081817426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Git入门基础教程和SourceTree应用</title><link>http://www.cnblogs.com/heian99/archive/2019/12/05/11996855.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 05 Dec 2019 05:45:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/05/11996855.html</guid><description><![CDATA[
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <div class="htmledit_views" id="content_views">
                                            <p id="main-toc"><strong>目录</strong></p>
</div><p id="-toc">&nbsp;</p>
<p id="%E4%B8%80%E3%80%81Git%E7%9A%84%E5%AE%89%E8%A3%85-toc"><a href="#%E4%B8%80%E3%80%81Git%E7%9A%84%E5%AE%89%E8%A3%85" rel="nofollow" target="_self">一、Git的安装</a></p>
<p id="1.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2-toc"><a href="#1.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">1.1 图形化界面</a></p>
<p id="1.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2-toc"><a href="#1.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">1.2 命令行界面</a></p>
<p id="%E4%BA%8C%E3%80%81%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8F%90%E4%BA%A4-toc"><a href="#%E4%BA%8C%E3%80%81%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8F%90%E4%BA%A4" rel="nofollow" target="_self">二、本地仓库的创建与提交</a></p>
<p id="2.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2-toc"><a href="#2.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">2.1 图形化界面</a></p>
<p id="2.1.1%20%E9%A6%96%E5%85%88%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95-toc"><a href="#2.1.1%20%E9%A6%96%E5%85%88%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95" rel="nofollow" target="_self">2.1.1 首先在电脑上有一个空白目录</a></p>
<p id="2.1.2%20%E6%89%93%E5%BC%80SourceTree-toc"><a href="#2.1.2%20%E6%89%93%E5%BC%80SourceTree" rel="nofollow" target="_self">2.1.2 打开SourceTree</a></p>
<p id="%C2%A02.1.3%20%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%22%E5%85%8B%E9%9A%86%2F%E6%96%B0%E5%BB%BA%22%2C%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93-toc"><a href="#%C2%A02.1.3%20%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%22%E5%85%8B%E9%9A%86%2F%E6%96%B0%E5%BB%BA%22%2C%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">&nbsp;2.1.3 点击左边"克隆/新建",创建本地仓库</a></p>
<p id="%C2%A02.1.4%20%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%22%E5%88%9B%E5%BB%BA%22%E6%8C%89%E9%92%AE-toc"><a href="#%C2%A02.1.4%20%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%22%E5%88%9B%E5%BB%BA%22%E6%8C%89%E9%92%AE" rel="nofollow" target="_self">&nbsp;2.1.4 选择第一步中的空白目录，点击"创建"按钮</a></p>
<p id="%C2%A02.1.5%20%E6%AD%A4%E6%97%B6%E5%B7%A6%E8%BE%B9%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E4%B8%AA%EF%BC%8C%E4%BB%A3%E8%A1%A8%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90-toc"><a href="#%C2%A02.1.5%20%E6%AD%A4%E6%97%B6%E5%B7%A6%E8%BE%B9%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E4%B8%AA%EF%BC%8C%E4%BB%A3%E8%A1%A8%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90" rel="nofollow" target="_self">&nbsp;2.1.5 此时左边会出现这个，代表本地仓库创建完成</a></p>
<p id="%C2%A02.1.6%20%E6%89%93%E5%BC%80%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%9C%A8%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E6%96%87%E4%BB%B6(%E5%86%85%E5%AE%B9%2F%E5%90%8D%E7%A7%B0)%E9%9A%8F%E4%BE%BF%E8%BE%93%E5%85%A5-toc"><a href="#%C2%A02.1.6%20%E6%89%93%E5%BC%80%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%9C%A8%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E6%96%87%E4%BB%B6(%E5%86%85%E5%AE%B9%2F%E5%90%8D%E7%A7%B0)%E9%9A%8F%E4%BE%BF%E8%BE%93%E5%85%A5" rel="nofollow" target="_self">&nbsp;2.1.6 打开空白目录，在空白目录下新建文件，文件(内容/名称)随便输入</a></p>
<p id="%C2%A02.1.7%20%E8%BF%94%E5%9B%9ESourceTree%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%8E%B0%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E4%BD%A0%E5%88%9A%E6%89%8D%E4%BF%AE%E6%94%B9%E6%88%96%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%96%87%E4%BB%B6-toc"><a href="#%C2%A02.1.7%20%E8%BF%94%E5%9B%9ESourceTree%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%8E%B0%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E4%BD%A0%E5%88%9A%E6%89%8D%E4%BF%AE%E6%94%B9%E6%88%96%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%96%87%E4%BB%B6" rel="nofollow" target="_self">&nbsp;2.1.7 返回SourceTree，会发现未暂存文件中有你刚才修改或增加的文件</a></p>
<p id="%C2%A02.1.8%20%E5%8F%B3%E9%94%AE%E2%80%9C%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E6%B7%BB%E5%8A%A0-toc"><a href="#%C2%A02.1.8%20%E5%8F%B3%E9%94%AE%E2%80%9C%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E6%B7%BB%E5%8A%A0" rel="nofollow" target="_self">&nbsp;2.1.8 右键“未暂存文件”中的文件，点击添加</a></p>
<p id="%C2%A02.1.9%20%E4%BC%9A%E5%8F%91%E7%8E%B0%E2%80%9C%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%9B%E5%85%A5%E4%BA%86%E2%80%9C%E5%B7%B2%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD-toc"><a href="#%C2%A02.1.9%20%E4%BC%9A%E5%8F%91%E7%8E%B0%E2%80%9C%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%9B%E5%85%A5%E4%BA%86%E2%80%9C%E5%B7%B2%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD" rel="nofollow" target="_self">&nbsp;2.1.9 会发现“未暂存文件”中的文件进入了“已暂存文件”中</a></p>
<p id="%C2%A02.1.10%20%E5%9C%A8%E4%B8%8B%E6%96%B9%E8%BE%93%E5%85%A5%E2%80%9C%E6%9C%AC%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E6%8F%8F%E8%BF%B0%E2%80%9D%EF%BC%8C%E7%82%B9%E5%87%BB%E2%80%9C%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E2%80%9D-toc"><a href="#%C2%A02.1.10%20%E5%9C%A8%E4%B8%8B%E6%96%B9%E8%BE%93%E5%85%A5%E2%80%9C%E6%9C%AC%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E6%8F%8F%E8%BF%B0%E2%80%9D%EF%BC%8C%E7%82%B9%E5%87%BB%E2%80%9C%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E2%80%9D" rel="nofollow" target="_self">&nbsp;2.1.10 在下方输入“本次提交的描述”，点击“提交按钮”</a></p>
<p id="%C2%A02.1.11%20%E7%82%B9%E5%87%BBmaster%E5%88%86%E6%94%AF%EF%BC%8C%E4%BC%9A%E6%98%BE%E7%A4%BA%E6%9C%AC%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF-toc"><a href="#%C2%A02.1.11%20%E7%82%B9%E5%87%BBmaster%E5%88%86%E6%94%AF%EF%BC%8C%E4%BC%9A%E6%98%BE%E7%A4%BA%E6%9C%AC%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF" rel="nofollow" target="_self">&nbsp;2.1.11 点击master分支，会显示本次提交的详细信息</a></p>
<p id="2.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2-toc"><a href="#2.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">2.2 命令行界面</a></p>
<p id="2.2.1%20%E7%82%B9%E5%87%BBSourceTree%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E2%80%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E2%80%9D%E5%8D%B3%E5%8F%AF%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3-toc"><a href="#2.2.1%20%E7%82%B9%E5%87%BBSourceTree%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E2%80%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E2%80%9D%E5%8D%B3%E5%8F%AF%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3" rel="nofollow" target="_self">2.2.1 点击SourceTree右上角的“命令行模式”即可打开命令行窗口</a></p>
<p id="%C2%A02.2.2%20%E5%91%BD%E4%BB%A4%E8%AF%86%E5%88%AB-toc"><a href="#%C2%A02.2.2%20%E5%91%BD%E4%BB%A4%E8%AF%86%E5%88%AB" rel="nofollow" target="_self">&nbsp;2.2.2 命令识别</a></p>
<p id="%E4%B8%89%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81-toc"><a href="#%E4%B8%89%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81" rel="nofollow" target="_self">三、工作流</a></p>
<p id="3.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2-toc"><a href="#3.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">3.1 图形化界面</a></p>
<p id="3.1.1%20%E9%A6%96%E5%85%88%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95-toc"><a href="#3.1.1%20%E9%A6%96%E5%85%88%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95" rel="nofollow" target="_self">3.1.1 首先在电脑上有一个空白目录</a></p>
<p id="%C2%A03.1.2%20%E6%89%93%E5%BC%80SourceTree-toc"><a href="#%C2%A03.1.2%20%E6%89%93%E5%BC%80SourceTree" rel="nofollow" target="_self">&nbsp;3.1.2 打开SourceTree</a></p>
<p id="3.1.3%20%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%22%E5%85%8B%E9%9A%86%2F%E6%96%B0%E5%BB%BA%22%2C%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93-toc"><a href="#3.1.3%20%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%22%E5%85%8B%E9%9A%86%2F%E6%96%B0%E5%BB%BA%22%2C%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">3.1.3 点击左边"克隆/新建",创建本地仓库</a></p>
<p id="%C2%A03.1.4%20%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%22%E5%88%9B%E5%BB%BA%22%E6%8C%89%E9%92%AE-toc"><a href="#%C2%A03.1.4%20%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%22%E5%88%9B%E5%BB%BA%22%E6%8C%89%E9%92%AE" rel="nofollow" target="_self">&nbsp;3.1.4 选择第一步中的空白目录，点击"创建"按钮</a></p>
<p id="%C2%A03.1.5%20%E6%89%93%E5%BC%80%E5%88%9A%E6%89%8D%E5%88%9B%E5%BB%BA%E7%9A%84demo2%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%9C%A8%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6(%E5%86%85%E5%AE%B9%E8%87%AA%E5%AE%9A)-toc"><a href="#%C2%A03.1.5%20%E6%89%93%E5%BC%80%E5%88%9A%E6%89%8D%E5%88%9B%E5%BB%BA%E7%9A%84demo2%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%9C%A8%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6(%E5%86%85%E5%AE%B9%E8%87%AA%E5%AE%9A)" rel="nofollow" target="_self">&nbsp;3.1.5 打开刚才创建的demo2目录，在里面添加一个文件(内容自定)</a></p>
<p id="3.1.6%20%E6%89%93%E5%BC%80SourceTree%EF%BC%8C%E5%B0%86%E5%88%9A%E6%89%8D%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E8%BF%9B%E6%9A%82%E5%AD%98%E5%8C%BA-toc"><a href="#3.1.6%20%E6%89%93%E5%BC%80SourceTree%EF%BC%8C%E5%B0%86%E5%88%9A%E6%89%8D%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E8%BF%9B%E6%9A%82%E5%AD%98%E5%8C%BA" rel="nofollow" target="_self">3.1.6 打开SourceTree，将刚才修改的文件添加进暂存区</a></p>
<p id="%C2%A03.1.7%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4-toc"><a href="#%C2%A03.1.7%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4" rel="nofollow" target="_self">&nbsp;3.1.7 第一次提交</a></p>
<p id="%C2%A03.1.8%20%E9%9C%80%E6%B1%82%E5%8F%98%E6%9B%B4-toc"><a href="#%C2%A03.1.8%20%E9%9C%80%E6%B1%82%E5%8F%98%E6%9B%B4" rel="nofollow" target="_self">&nbsp;3.1.8 需求变更</a></p>
<p id="%C2%A03.1.9%20%E9%9C%80%E6%B1%82%E6%92%A4%E9%94%80-toc"><a href="#%C2%A03.1.9%20%E9%9C%80%E6%B1%82%E6%92%A4%E9%94%80" rel="nofollow" target="_self">&nbsp;3.1.9 需求撤销</a></p>
<p id="%C2%A03.1.10%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E6%AD%A3%E5%BC%8F%E9%9C%80%E6%B1%82-toc"><a href="#%C2%A03.1.10%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E6%AD%A3%E5%BC%8F%E9%9C%80%E6%B1%82" rel="nofollow" target="_self">&nbsp;3.1.10 第二天正式需求</a></p>
<p id="3.1.11%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%9A%84%E9%9C%80%E6%B1%82%E6%8F%90%E4%BA%A4%E5%88%B0git%E4%BB%93%E5%BA%93-toc"><a href="#3.1.11%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%9A%84%E9%9C%80%E6%B1%82%E6%8F%90%E4%BA%A4%E5%88%B0git%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">3.1.11 第二天的需求提交到git仓库</a></p>
<p id="3.1.12%20%E7%AC%AC%E4%B8%89%E5%A4%A9%E6%92%A4%E9%94%80%E9%9C%80%E6%B1%82-toc"><a href="#3.1.12%20%E7%AC%AC%E4%B8%89%E5%A4%A9%E6%92%A4%E9%94%80%E9%9C%80%E6%B1%82" rel="nofollow" target="_self">3.1.12 第三天撤销需求</a></p>
<p id="%C2%A03.1.13%20%E9%A1%B9%E7%9B%AE%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%86-toc"><a href="#%C2%A03.1.13%20%E9%A1%B9%E7%9B%AE%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%86" rel="nofollow" target="_self">&nbsp;3.1.13 项目不需要了</a></p>
<p id="3.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2-toc"><a href="#3.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">3.2 命令行界面</a></p>
<p id="3.2.1%20%E5%85%88%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9B%AE%E5%BD%95-toc"><a href="#3.2.1%20%E5%85%88%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9B%AE%E5%BD%95" rel="nofollow" target="_self">3.2.1 先有一个空目录</a></p>
<p id="3.2.2%20%E5%9C%A8%E8%AF%A5%E7%A9%BA%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%93%E5%BC%80git_bush-toc"><a href="#3.2.2%20%E5%9C%A8%E8%AF%A5%E7%A9%BA%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%93%E5%BC%80git_bush" rel="nofollow" target="_self">3.2.2 在该空目录下打开git_bush</a></p>
<p id="%C2%A03.2.3%20%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B8%B4%E6%97%B6%E5%8F%98%E6%9B%B4%E9%9C%80%E6%B1%82-toc"><a href="#%C2%A03.2.3%20%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B8%B4%E6%97%B6%E5%8F%98%E6%9B%B4%E9%9C%80%E6%B1%82" rel="nofollow" target="_self">&nbsp;3.2.3 产品经理临时变更需求</a></p>
<p id="3.2.4%20%E5%B0%86%E5%8F%98%E6%9B%B4%E5%90%8E%E7%9A%84%E9%9C%80%E6%B1%82%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA-toc"><a href="#3.2.4%20%E5%B0%86%E5%8F%98%E6%9B%B4%E5%90%8E%E7%9A%84%E9%9C%80%E6%B1%82%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA" rel="nofollow" target="_self">3.2.4 将变更后的需求提交到暂存区</a></p>
<p id="%C2%A03.2.5%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E4%B8%8A%E7%8F%AD%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%A2%AB%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%91%8A%E7%9F%A5%E8%AF%A5%E9%9C%80%E6%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-toc"><a href="#%C2%A03.2.5%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E4%B8%8A%E7%8F%AD%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%A2%AB%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%91%8A%E7%9F%A5%E8%AF%A5%E9%9C%80%E6%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81" rel="nofollow" target="_self">&nbsp;3.2.5 第二天上班之后，被产品经理告知该需求不需要</a></p>
<p id="%C2%A03.2.6%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%BB%93%E6%9D%9F-toc"><a href="#%C2%A03.2.6%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%BB%93%E6%9D%9F" rel="nofollow" target="_self">&nbsp;3.2.6 第二天结束</a></p>
<p id="%C2%A03.2.7%20%E5%B0%86%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E4%BB%93%E5%BA%93-toc"><a href="#%C2%A03.2.7%20%E5%B0%86%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">&nbsp;3.2.7 将第二天的工作内容提交到仓库</a></p>
<p id="%C2%A03.2.8%20%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%AA%81%E7%84%B6%E5%91%8A%E7%9F%A5%E8%BF%99%E4%B8%AA%E9%9C%80%E6%B1%82%E4%B8%8D%E8%A6%81%E4%BA%86-toc"><a href="#%C2%A03.2.8%20%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%AA%81%E7%84%B6%E5%91%8A%E7%9F%A5%E8%BF%99%E4%B8%AA%E9%9C%80%E6%B1%82%E4%B8%8D%E8%A6%81%E4%BA%86" rel="nofollow" target="_self">&nbsp;3.2.8 产品经理突然告知这个需求不要了</a></p>
<p id="%C2%A03.2.9%20%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E9%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%86-toc"><a href="#%C2%A03.2.9%20%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E9%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%86" rel="nofollow" target="_self">&nbsp;3.2.9 这个项目都不需要了</a></p>
<p id="%C2%A03.3%20%E6%80%BB%E7%BB%93-toc"><a href="#%C2%A03.3%20%E6%80%BB%E7%BB%93" rel="nofollow" target="_self">&nbsp;3.3 总结</a></p>
<p id="%C2%A0%E5%9B%9B%E3%80%81%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93-toc"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">&nbsp;四、远程仓库</a></p>
<p id="4.1%20github%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90-toc"><a href="#4.1%20github%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90" rel="nofollow" target="_self">4.1 github密钥生成</a></p>
<p id="4.2%20%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93-toc"><a href="#4.2%20%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">4.2 添加远程仓库</a></p>
<p id="%C2%A04.2.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2-toc"><a href="#%C2%A04.2.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">&nbsp;4.2.1 命令行界面</a></p>
<p id="4.2.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2-toc"><a href="#4.2.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">4.2.2 图形化界面</a></p>
<p id="%C2%A0%E4%BA%94%E3%80%81%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93-toc"><a href="#%C2%A0%E4%BA%94%E3%80%81%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">&nbsp;五、克隆仓库</a></p>
<p id="5.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C-toc"><a href="#5.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C" rel="nofollow" target="_self">5.1 命令行操作</a></p>
<p id="5.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%93%8D%E4%BD%9C-toc"><a href="#5.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%93%8D%E4%BD%9C" rel="nofollow" target="_self">5.2 图形化操作</a></p>
<p id="%C2%A0%E5%85%AD%E3%80%81%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86-toc"><a href="#%C2%A0%E5%85%AD%E3%80%81%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86" rel="nofollow" target="_self">&nbsp;六、标签管理</a></p>
<p id="6.1%20%E6%A0%87%E7%AD%BE%E5%91%BD%E4%BB%A4-toc"><a href="#6.1%20%E6%A0%87%E7%AD%BE%E5%91%BD%E4%BB%A4" rel="nofollow" target="_self">6.1 标签命令</a></p>
<p id="6.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0-toc"><a href="#6.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0" rel="nofollow" target="_self">6.2 命令行方式实现</a></p>
<p id="6.3%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0-toc"><a href="#6.3%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0" rel="nofollow" target="_self">6.3 图形化方式实现</a></p>
<p id="%E4%B8%83%E3%80%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-toc"><a href="#%E4%B8%83%E3%80%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86" rel="nofollow" target="_self">七、分支管理</a></p>
<p id="7.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F-toc"><a href="#7.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F" rel="nofollow" target="_self">7.1 命令行方式</a></p>
<p id="7.1.1%20%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93-toc"><a href="#7.1.1%20%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">7.1.1 提交到本地仓库</a></p>
<p id="%C2%A07.1.2%20%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF-toc"><a href="#%C2%A07.1.2%20%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF" rel="nofollow" target="_self">&nbsp;7.1.2 创建分支</a></p>
<p id="%C2%A07.1.2%20%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF-toc"><a href="#%C2%A07.1.2%20%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF" rel="nofollow" target="_self">&nbsp;7.1.2 删除分支</a></p>
<p id="7.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2-toc"><a href="#7.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2" rel="nofollow" target="_self">7.2 图形化界面</a></p>
<p id="7.2.1%20%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E5%86%85%E5%AE%B9-toc"><a href="#7.2.1%20%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E5%86%85%E5%AE%B9" rel="nofollow" target="_self">7.2.1 首先需要有一个本地目录，里面有一个文件，文件中有内容</a></p>
<p id="%C2%A07.2.2%20%E6%89%93%E5%BC%80SourceTree%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%8C%E5%B9%B6%E5%B0%86%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93-toc"><a href="#%C2%A07.2.2%20%E6%89%93%E5%BC%80SourceTree%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%8C%E5%B9%B6%E5%B0%86%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93" rel="nofollow" target="_self">&nbsp;7.2.2 打开SourceTree创建本地仓库，并将代码提交到本地仓库</a></p>
<p id="7.2.3%20%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF-toc"><a href="#7.2.3%20%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF" rel="nofollow" target="_self">7.2.3 新建分支</a></p>
<p id="7.2.4%20%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF-toc"><a href="#7.2.4%20%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF" rel="nofollow" target="_self">7.2.4 删除分支</a></p>
<p id="%C2%A0%E5%85%AB%E3%80%81%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93-toc"><a href="#%C2%A0%E5%85%AB%E3%80%81%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93" rel="nofollow" target="_self">&nbsp;八、问题归纳总结</a></p>
<p id="8.1%20%E6%8A%A5%E9%94%99-toc"><a href="#8.1%20%E6%8A%A5%E9%94%99" rel="nofollow" target="_self">8.1 报错</a></p>
<p id="8.1.1%20%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%AC%E5%9C%B0%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84ssh%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%8C%89%E7%85%A7%E4%B8%8B%E6%96%B9%E6%AD%A5%E9%AA%A4%E6%9D%A5%E6%B7%BB%E5%8A%A0-toc"><a href="#8.1.1%20%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%AC%E5%9C%B0%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84ssh%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%8C%89%E7%85%A7%E4%B8%8B%E6%96%B9%E6%AD%A5%E9%AA%A4%E6%9D%A5%E6%B7%BB%E5%8A%A0" rel="nofollow" target="_self">8.1.1 如果你本地有远程仓库的ssh的话，按照下方步骤来添加</a></p>
<p id="8.1.2%20%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%AC%E5%9C%B0%E6%B2%A1%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84ssh%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%85%88%E6%9D%A5%E6%B7%BB%E5%8A%A0-toc"><a href="#8.1.2%20%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%AC%E5%9C%B0%E6%B2%A1%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84ssh%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%85%88%E6%9D%A5%E6%B7%BB%E5%8A%A0" rel="nofollow" target="_self">8.1.2 如果你本地没有远程仓库的ssh的话，先来添加</a></p>
<hr id="hr-toc"><h1 id="%E4%B8%80%E3%80%81Git%E7%9A%84%E5%AE%89%E8%A3%85"><a></a>一、Git的安装</h1>
<h2 id="1.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><a></a>1.1 图形化界面</h2>
<p><span><strong>https://pan.baidu.com/s/1oAf6Eu9iha6TPzaGHNsADQ</strong></span></p>
<p>安装过程：</p>
<p>安装完成之后,在<span><strong>C:\Users\Administrator\AppData\Local\Atlassian\SourceTree</strong></span>目录下创建<strong><span>accounts.json</span></strong>文件，里面内容如下：</p>
<pre class="has"><code class="language-javascript hljs"></code><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">[</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-string">"$id"</span>: <span class="hljs-string">"1"</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-string">"$type"</span>: <span class="hljs-string">"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity"</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-string">"Authenticate"</span>: <span class="hljs-literal">true</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-string">"HostInstance"</span>: {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-string">"$id"</span>: <span class="hljs-string">"2"</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-string">"$type"</span>: <span class="hljs-string">"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount"</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-string">"Host"</span>: {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-string">"$id"</span>: <span class="hljs-string">"3"</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-string">"$type"</span>: <span class="hljs-string">"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount"</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-string">"Id"</span>: <span class="hljs-string">"atlassian account"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-string">"BaseUrl"</span>: <span class="hljs-string">"https://id.atlassian.com/"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-string">"Credentials"</span>: {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-string">"$id"</span>: <span class="hljs-string">"4"</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-string">"$type"</span>: <span class="hljs-string">"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account"</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-string">"Username"</span>: <span class="hljs-string">"username@email.com"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-string">"IsDefault"</span>: <span class="hljs-literal">false</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">]</div></div></li></ol><div class="hljs-button {2}"></div></pre>
<p>再次打开SourceTree下载只被SourceTree识别的Git，不需要moun...(会有提示，没有则不用管)</p>
<h2 id="1.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2"><a></a>1.2 命令行界面</h2>
<p><span><strong>https://pan.baidu.com/s/1SPqrbKJLRkzzz2c0jHkuJA</strong></span></p>
<h1 id="%E4%BA%8C%E3%80%81%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8F%90%E4%BA%A4"><a></a>二、本地仓库的创建与提交</h1>
<h2 id="2.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><a></a>2.1 图形化界面</h2>
<h3 id="2.1.1%20%E9%A6%96%E5%85%88%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95"><a></a>2.1.1 首先在电脑上有一个空白目录</h3>
<p><img alt="" class="has" height="32" src="https://img-blog.csdnimg.cn/20191204085509710.png" width="592"></p>
<h3 id="2.1.2%20%E6%89%93%E5%BC%80SourceTree"><a></a>2.1.2 打开SourceTree</h3>
<p><img alt="" class="has" height="504" src="https://img-blog.csdnimg.cn/20191204085610526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="965"></p>
<h3 id="%C2%A02.1.3%20%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%22%E5%85%8B%E9%9A%86%2F%E6%96%B0%E5%BB%BA%22%2C%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93"><a></a>&nbsp;2.1.3 点击左边"克隆/新建",创建本地仓库</h3>
<p><img alt="" class="has" height="678" src="https://img-blog.csdnimg.cn/20191204085642473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h3 id="%C2%A02.1.4%20%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%22%E5%88%9B%E5%BB%BA%22%E6%8C%89%E9%92%AE"><a></a>&nbsp;2.1.4 选择第一步中的空白目录，点击"创建"按钮</h3>
<p><img alt="" class="has" height="298" src="https://img-blog.csdnimg.cn/20191204085708371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="707"></p>
<h3 id="%C2%A02.1.5%20%E6%AD%A4%E6%97%B6%E5%B7%A6%E8%BE%B9%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E4%B8%AA%EF%BC%8C%E4%BB%A3%E8%A1%A8%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90"><a></a>&nbsp;2.1.5 此时左边会出现这个，代表本地仓库创建完成</h3>
<p><img alt="" class="has" height="770" src="https://img-blog.csdnimg.cn/20191204085732705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<p></p>
<h3 id="%C2%A02.1.6%20%E6%89%93%E5%BC%80%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%9C%A8%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E6%96%87%E4%BB%B6(%E5%86%85%E5%AE%B9%2F%E5%90%8D%E7%A7%B0)%E9%9A%8F%E4%BE%BF%E8%BE%93%E5%85%A5"><a></a>&nbsp;2.1.6 打开空白目录，在空白目录下新建文件，文件(内容/名称)随便输入</h3>
<p><img alt="" class="has" height="135" src="https://img-blog.csdnimg.cn/2019120408580358.png" width="642"></p>
<h3 id="%C2%A02.1.7%20%E8%BF%94%E5%9B%9ESourceTree%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%8E%B0%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E4%BD%A0%E5%88%9A%E6%89%8D%E4%BF%AE%E6%94%B9%E6%88%96%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%96%87%E4%BB%B6"><a></a>&nbsp;2.1.7 返回SourceTree，会发现未暂存文件中有你刚才修改或增加的文件</h3>
<p><img alt="" class="has" height="774" src="https://img-blog.csdnimg.cn/20191204085936373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="917"></p>
<h3 id="%C2%A02.1.8%20%E5%8F%B3%E9%94%AE%E2%80%9C%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E6%B7%BB%E5%8A%A0"><a></a>&nbsp;2.1.8 右键“未暂存文件”中的文件，点击添加</h3>
<p><img alt="" class="has" height="778" src="https://img-blog.csdnimg.cn/2019120409000484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="841"></p>
<h3 id="%C2%A02.1.9%20%E4%BC%9A%E5%8F%91%E7%8E%B0%E2%80%9C%E6%9C%AA%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%9B%E5%85%A5%E4%BA%86%E2%80%9C%E5%B7%B2%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6%E2%80%9D%E4%B8%AD"><a></a>&nbsp;2.1.9 会发现“未暂存文件”中的文件进入了“已暂存文件”中</h3>
<p><img alt="" class="has" height="769" src="https://img-blog.csdnimg.cn/20191204090035496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="846"></p>
<h3 id="%C2%A02.1.10%20%E5%9C%A8%E4%B8%8B%E6%96%B9%E8%BE%93%E5%85%A5%E2%80%9C%E6%9C%AC%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E6%8F%8F%E8%BF%B0%E2%80%9D%EF%BC%8C%E7%82%B9%E5%87%BB%E2%80%9C%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E2%80%9D"><a></a>&nbsp;2.1.10 在下方输入“本次提交的描述”，点击“提交按钮”</h3>
<p><img alt="" class="has" height="773" src="https://img-blog.csdnimg.cn/20191204090058115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h3 id="%C2%A02.1.11%20%E7%82%B9%E5%87%BBmaster%E5%88%86%E6%94%AF%EF%BC%8C%E4%BC%9A%E6%98%BE%E7%A4%BA%E6%9C%AC%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><a></a>&nbsp;2.1.11 点击master分支，会显示本次提交的详细信息</h3>
<p><img alt="" class="has" height="769" src="https://img-blog.csdnimg.cn/20191204090124745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<p></p>
<h2 id="2.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2"><a></a>2.2 命令行界面</h2>
<h3 id="2.2.1%20%E7%82%B9%E5%87%BBSourceTree%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E2%80%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E2%80%9D%E5%8D%B3%E5%8F%AF%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3"><a></a>2.2.1 点击SourceTree右上角的“命令行模式”即可打开命令行窗口</h3>
<p><img alt="" class="has" height="770" src="https://img-blog.csdnimg.cn/20191204090159319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<p><img alt="" class="has" height="320" src="https://img-blog.csdnimg.cn/20191204090210498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="580">&nbsp;</p>
<p></p>
<h3 id="%C2%A02.2.2%20%E5%91%BD%E4%BB%A4%E8%AF%86%E5%88%AB"><a></a>&nbsp;2.2.2 命令识别</h3>
<pre class="has"><code class="hljs bash"></code><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-built_in">pwd</span>  查看当前目录</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-built_in">cd</span> .. 返回上一级目录</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">mkdir demo2  新建目录demo2</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-built_in">cd</span> demo2  进入目录</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">ll  展示目录文件</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">ls -a 展示所有文件</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-built_in">echo</span> <span class="hljs-string">"git repo2"</span> &gt;&gt; test.txt  给test.txt追加git repo2</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">cat test.txt   展示当前文件内容</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git add test.txt  添加</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git commit -m <span class="hljs-string">"repo2 first commit"</span>  提交</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git status   查看当前仓库状态</div></div></li></ol><div class="hljs-button {2}"></div></pre>
<p>&nbsp;<img alt="" class="has" height="779" src="https://img-blog.csdnimg.cn/20191204090259541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="582"></p>
<h1 id="%E4%B8%89%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81"><a></a>三、工作流</h1>
<h2 id="3.1%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><a></a>3.1 图形化界面</h2>
<h3 id="3.1.1%20%E9%A6%96%E5%85%88%E5%9C%A8%E7%94%B5%E8%84%91%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95"><a></a>3.1.1 首先在电脑上有一个空白目录</h3>
<p><img alt="" class="has" height="34" src="https://img-blog.csdnimg.cn/20191204090330298.png" width="517"></p>
<h3 id="%C2%A03.1.2%20%E6%89%93%E5%BC%80SourceTree"><a></a>&nbsp;3.1.2 打开SourceTree</h3>
<p><img alt="" class="has" height="504" src="https://img-blog.csdnimg.cn/20191204090354545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="965"></p>
<h3 id="3.1.3%20%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%22%E5%85%8B%E9%9A%86%2F%E6%96%B0%E5%BB%BA%22%2C%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93"><a></a>3.1.3 点击左边"克隆/新建",创建本地仓库</h3>
<p><img alt="" class="has" height="678" src="https://img-blog.csdnimg.cn/20191204090418820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h3 id="%C2%A03.1.4%20%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%22%E5%88%9B%E5%BB%BA%22%E6%8C%89%E9%92%AE"><a></a>&nbsp;3.1.4 选择第一步中的空白目录，点击"创建"按钮</h3>
<p><img alt="" class="has" height="533" src="https://img-blog.csdnimg.cn/20191204090434772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1153"></p>
<p></p>
<h3 id="%C2%A03.1.5%20%E6%89%93%E5%BC%80%E5%88%9A%E6%89%8D%E5%88%9B%E5%BB%BA%E7%9A%84demo2%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%9C%A8%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6(%E5%86%85%E5%AE%B9%E8%87%AA%E5%AE%9A)"><a></a>&nbsp;3.1.5 打开刚才创建的demo2目录，在里面添加一个文件(内容自定)</h3>
<p><img alt="" class="has" height="395" src="https://img-blog.csdnimg.cn/20191204090458269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="767"></p>
<h3 id="3.1.6%20%E6%89%93%E5%BC%80SourceTree%EF%BC%8C%E5%B0%86%E5%88%9A%E6%89%8D%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E8%BF%9B%E6%9A%82%E5%AD%98%E5%8C%BA"><a></a>3.1.6 打开SourceTree，将刚才修改的文件添加进暂存区</h3>
<p><img alt="" class="has" height="768" src="https://img-blog.csdnimg.cn/20191204090519861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1026"></p>
<h3 id="%C2%A03.1.7%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4"><a></a>&nbsp;3.1.7 第一次提交</h3>
<p><img alt="" class="has" height="725" src="https://img-blog.csdnimg.cn/20191204090542741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<p></p>
<h3 id="%C2%A03.1.8%20%E9%9C%80%E6%B1%82%E5%8F%98%E6%9B%B4"><a></a>&nbsp;3.1.8 需求变更</h3>
<blockquote>
<p>背景：开发完成，要下班了，但是临时有个需求变更，将变更后的文件提交的暂存区</p>
</blockquote>
<p></p>
<p>&nbsp;修改内容，添加“需求变更”</p>
<p><img alt="" class="has" height="546" src="https://img-blog.csdnimg.cn/20191204090711553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="735"></p>
<p>&nbsp;将修改后的文件添加到暂存区</p>
<p><img alt="" class="has" height="768" src="https://img-blog.csdnimg.cn/20191204090728248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="823"></p>
<h3 id="%C2%A03.1.9%20%E9%9C%80%E6%B1%82%E6%92%A4%E9%94%80"><a></a>&nbsp;3.1.9 需求撤销</h3>
<blockquote>
<p>背景：第二天上班之后，产品经理说，昨天的需求不需要了</p>
</blockquote>
<p>&nbsp;直接丢弃掉暂存区的文件</p>
<p><img alt="" class="has" height="670" src="https://img-blog.csdnimg.cn/2019120409081420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="877"></p>
<p>此时的需求变更已撤销</p>
<p>&nbsp;<img alt="" class="has" height="386" src="https://img-blog.csdnimg.cn/20191204090834438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="678"></p>
<h3 id="%C2%A03.1.10%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E6%AD%A3%E5%BC%8F%E9%9C%80%E6%B1%82"><a></a>&nbsp;3.1.10 第二天正式需求</h3>
<blockquote>
<p>背景：第二天下班之后，当天的需求已经完成，准备提交到git仓库</p>
</blockquote>
<p>&nbsp;<img alt="" class="has" height="404" src="https://img-blog.csdnimg.cn/20191204090907542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="753"></p>
<h3 id="3.1.11%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%9A%84%E9%9C%80%E6%B1%82%E6%8F%90%E4%BA%A4%E5%88%B0git%E4%BB%93%E5%BA%93"><a></a>3.1.11 第二天的需求提交到git仓库</h3>
<p><img alt="" class="has" height="771" src="https://img-blog.csdnimg.cn/20191204090930595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="898"></p>
<p>&nbsp;<img alt="" class="has" height="769" src="https://img-blog.csdnimg.cn/20191204090940109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h3 id="3.1.12%20%E7%AC%AC%E4%B8%89%E5%A4%A9%E6%92%A4%E9%94%80%E9%9C%80%E6%B1%82"><a></a>3.1.12 第三天撤销需求</h3>
<blockquote>
<p>背景：第三天上班，发现第二天的需求没用，但是已经提交到线上仓库，可以通过重置当前分支到此次提交</p>
</blockquote>
<p><img alt="" class="has" height="653" src="https://img-blog.csdnimg.cn/20191204091010217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="957"></p>
<p>&nbsp;<img alt="" class="has" height="185" src="https://img-blog.csdnimg.cn/20191204091105989.png" width="420"></p>
<h3 id="%C2%A03.1.13%20%E9%A1%B9%E7%9B%AE%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%86"><a></a>&nbsp;3.1.13 项目不需要了</h3>
<p>在工作区直接删除该文件，打开sourceTree，虽然在本地删除了，但是线上仓库还有遗留。</p>
<p>再次打开SourceTree，将动作提交至暂存区，然后再次提交到仓库</p>
<p><img alt="" class="has" height="768" src="https://img-blog.csdnimg.cn/20191204091135761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="890"></p>
<p><img alt="" class="has" height="633" src="https://img-blog.csdnimg.cn/20191204091149620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1036"></p>
<p>到此，仓库才算干净</p>
<h2 id="3.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2"><a></a>3.2 命令行界面</h2>
<h3 id="3.2.1%20%E5%85%88%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9B%AE%E5%BD%95"><a></a>3.2.1 先有一个空目录</h3>
<h3 id="3.2.2%20%E5%9C%A8%E8%AF%A5%E7%A9%BA%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%93%E5%BC%80git_bush"><a></a>3.2.2 在该空目录下打开git_bush</h3>
<p><img alt="" class="has" height="873" src="https://img-blog.csdnimg.cn/20191204091235981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="582"></p>
<h3 id="%C2%A03.2.3%20%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B8%B4%E6%97%B6%E5%8F%98%E6%9B%B4%E9%9C%80%E6%B1%82"><a></a>&nbsp;3.2.3 产品经理临时变更需求</h3>
<p><img alt="" class="has" height="478" src="https://img-blog.csdnimg.cn/20191204091258396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="785"></p>
<h3 id="3.2.4%20%E5%B0%86%E5%8F%98%E6%9B%B4%E5%90%8E%E7%9A%84%E9%9C%80%E6%B1%82%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA"><a></a>3.2.4 将变更后的需求提交到暂存区</h3>
<p><img alt="" class="has" height="329" src="https://img-blog.csdnimg.cn/20191204091325297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="535"></p>
<h3 id="%C2%A03.2.5%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E4%B8%8A%E7%8F%AD%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%A2%AB%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%91%8A%E7%9F%A5%E8%AF%A5%E9%9C%80%E6%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81"><a></a>&nbsp;3.2.5 第二天上班之后，被产品经理告知该需求不需要</h3>
<p><img alt="" class="has" height="274" src="https://img-blog.csdnimg.cn/20191204091345923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="591"></p>
<p>&nbsp;此时的工作区已经干净</p>
<p><img alt="" class="has" height="360" src="https://img-blog.csdnimg.cn/20191204091421824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="924"></p>
<h3 id="%C2%A03.2.6%20%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%BB%93%E6%9D%9F"><a></a>&nbsp;3.2.6 第二天结束</h3>
<p><img alt="" class="has" height="393" src="https://img-blog.csdnimg.cn/20191204091443347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="809"></p>
<h3 id="%C2%A03.2.7%20%E5%B0%86%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E4%BB%93%E5%BA%93"><a></a>&nbsp;3.2.7 将第二天的工作内容提交到仓库</h3>
<p><img alt="" class="has" height="325" src="https://img-blog.csdnimg.cn/20191204091510304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="550"></p>
<h3 id="%C2%A03.2.8%20%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%AA%81%E7%84%B6%E5%91%8A%E7%9F%A5%E8%BF%99%E4%B8%AA%E9%9C%80%E6%B1%82%E4%B8%8D%E8%A6%81%E4%BA%86"><a></a>&nbsp;3.2.8 产品经理突然告知这个需求不要了</h3>
<p><img alt="" class="has" height="449" src="https://img-blog.csdnimg.cn/20191204091530463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="553"></p>
<p>此时的工作区只有第一次提交的信息</p>
<p>&nbsp;<img alt="" class="has" height="328" src="https://img-blog.csdnimg.cn/2019120409155284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="777"></p>
<h3 id="%C2%A03.2.9%20%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E9%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%86"><a></a>&nbsp;3.2.9 这个项目都不需要了</h3>
<p><img alt="" class="has" height="341" src="https://img-blog.csdnimg.cn/2019120409161061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="538"></p>
<h2 id="%C2%A03.3%20%E6%80%BB%E7%BB%93"><a></a>&nbsp;3.3 总结</h2>
<p>&nbsp;<img alt="" class="has" height="389" src="https://img-blog.csdnimg.cn/20191204091630292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="704"></p>
<h1 id="%C2%A0%E5%9B%9B%E3%80%81%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><a></a>&nbsp;四、远程仓库</h1>
<h2 id="4.1%20github%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><a></a>4.1 github密钥生成</h2>
<p><span><strong>https://www.cnblogs.com/xue-shuai/p/11555150.html</strong></span></p>
<h2 id="4.2%20%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><a></a>4.2 添加远程仓库</h2>
<p><img alt="" class="has" height="561" src="https://img-blog.csdnimg.cn/20191204091840136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h3 id="%C2%A04.2.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2"><a></a>&nbsp;4.2.1 命令行界面</h3>
<pre class="has"><code class="hljs css"></code><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">首先添加到本地仓库</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">使用 <span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">remote</span> <span class="hljs-selector-tag">add</span> <span class="hljs-selector-tag">origin</span> <span class="hljs-selector-tag">git</span>@/**********.<span class="hljs-keyword">git</span>  本地仓库关联远程GitHub仓库</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">使用 git push -u origin master    将本地仓库推送到GitHub仓库master分支(-u已经默认将master分支关联)</div></div></li></ol><div class="hljs-button {2}"></div></pre>
<h3 id="4.2.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><a></a>4.2.2 图形化界面</h3>
<p><strong>1）首先先提交到本地仓库</strong></p>
<p><img alt="" class="has" height="639" src="https://img-blog.csdnimg.cn/20191204091954970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="997"></p>
<p><strong>&nbsp;2）将本地仓库与远程仓库关联，右键master分支，点击“创建拉去请求”</strong></p>
<p><img alt="" class="has" height="601" src="https://img-blog.csdnimg.cn/20191204092018821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="709"></p>
<p>&nbsp;添加远程仓库地址</p>
<p><img alt="" class="has" height="340" src="https://img-blog.csdnimg.cn/2019120409203531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="596"></p>
<p></p>
<p></p>
<p>&nbsp;<img alt="" class="has" height="311" src="https://img-blog.csdnimg.cn/20191204092047700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="602"></p>
<p>&nbsp;点击确定</p>
<p><strong>3）出现origin说明本地仓库与远程仓库关联成功</strong></p>
<p><img alt="" class="has" height="268" src="https://img-blog.csdnimg.cn/20191204092126701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="614"></p>
<p><strong>4）推送到远程仓库</strong></p>
<p>右键master，点击推送到origin</p>
<p><img alt="" class="has" height="479" src="https://img-blog.csdnimg.cn/20191204092146665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="555"></p>
<p>&nbsp;直接推送即可</p>
<p><img alt="" class="has" height="506" src="https://img-blog.csdnimg.cn/20191204092208210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="608"></p>
<p></p>
<h1 id="%C2%A0%E4%BA%94%E3%80%81%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93"><a></a>&nbsp;五、克隆仓库</h1>
<h2 id="5.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C"><a></a>5.1 命令行操作</h2>
<p>找一个空目录，输入</p>
<pre class="has"><code class="hljs css"><span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">clone</span> <span class="hljs-selector-tag">git</span>@<span class="hljs-keyword">github</span>*******.<span class="hljs-keyword">git</span></code><div class="hljs-button {2}"></div></pre>
<p>克隆远程仓库到本地</p>
<h2 id="5.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%93%8D%E4%BD%9C"><a></a>5.2 图形化操作</h2>
<p>点击克隆，输入远程仓库地址，找到放置的目录，点击克隆即可</p>
<p><img alt="" class="has" height="770" src="https://img-blog.csdnimg.cn/2019120409231227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<h1 id="%C2%A0%E5%85%AD%E3%80%81%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86"><a></a>&nbsp;六、标签管理</h1>
<h2 id="6.1%20%E6%A0%87%E7%AD%BE%E5%91%BD%E4%BB%A4"><a></a>6.1 标签命令</h2>
<pre class="has"><code class="hljs perl"></code><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git tag     查看所有标签</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git tag name    创建标签</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git tag -a name -<span class="hljs-keyword">m</span> <span class="hljs-string">"comment"</span>    指定提交信息</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git tag -d name    删除标签</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git <span class="hljs-keyword">push</span> origin name    标签发布</div></div></li></ol><div class="hljs-button {2}"></div></pre>
<h2 id="6.2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><a></a>6.2 命令行方式实现</h2>
<p>首先需要在远程GitHub上有一个仓库，并且克隆到本地，在该项目中执行下列命令</p>
<p><img alt="" class="has" height="829" src="https://img-blog.csdnimg.cn/20191204092403849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="544"></p>
<p>查看远程GitHub中的标签</p>
<p><img alt="" class="has" height="464" src="https://img-blog.csdnimg.cn/20191204092422853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1076"></p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="215" src="https://img-blog.csdnimg.cn/20191204092459117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="349"></p>
<p>更换Branches分支为Tags标签，即可查看拥有的标签，可进行版本的查看与切换。</p>
<p><strong>&nbsp;删除远程标签</strong></p>
<p><img alt="" class="has" height="192" src="https://img-blog.csdnimg.cn/20191204092630219.png" width="483"></p>
<h2 id="6.3%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><a></a>6.3 图形化方式实现</h2>
<blockquote>
<p>首先先提交本地仓库到远程仓库，这里就不多说了，详情查看4.2.2</p>
</blockquote><p></p>

<p>&nbsp;推送完成之后，点击标签</p>
<p><img alt="" class="has" height="491" src="https://img-blog.csdnimg.cn/20191204092716688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1200"></p>
<p></p>
<p>填写“标签名称”，选择“指定的提交”，勾选“推送标签”</p>
<p>&nbsp;<img alt="" class="has" height="307" src="https://img-blog.csdnimg.cn/20191204092735610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="662"></p>
<p>选择最新的修改，点击确定</p>
<p><img alt="" class="has" height="618" src="https://img-blog.csdnimg.cn/20191204092754492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1016"></p>
<p></p>
<p>&nbsp;添加标签</p>
<p><img alt="" class="has" height="256" src="https://img-blog.csdnimg.cn/2019120409281845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="601"></p>
<p>&nbsp;添加完成之后即可在GitHub上查看添加成功的标签</p>
<p>&nbsp;<img alt="" class="has" height="576" src="https://img-blog.csdnimg.cn/20191204092842256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="380"></p>
<p>删除标签，在sourceTree中右键所要删除的标签</p>
<p>&nbsp;<img alt="" class="has" height="363" src="https://img-blog.csdnimg.cn/20191204092903466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="530"></p>
<p>勾选“移除所有远程标签”，即可将远程仓库中该标签删除掉</p>
<p>&nbsp;<img alt="" class="has" height="129" src="https://img-blog.csdnimg.cn/20191204092932736.png" width="359"></p>
<h1 id="%E4%B8%83%E3%80%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><a></a>七、分支管理</h1>
<blockquote>
<p>假设需要实现一个功能，但是这个功能需要两周完成，第一周完成了50%，如果直接提交到远程仓库，别人的代码可能会出问题，但是如果等到全部完成在提交，可能进度上会有问题，所以只需要创建一个属于你自己的分支，自己所有的代码在该分支上完成。为保持工作树清洁，所创建的分支在合成到主分支之后，该分支便不再需要，可删除。</p>
</blockquote><p></p>

<p>&nbsp;<img alt="" class="has" height="336" src="https://img-blog.csdnimg.cn/20191204093001498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="848"></p>
<h2 id="7.1%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F"><a></a>7.1 命令行方式</h2>
<p><strong>在一个空目录下打开git bash</strong></p>
<h3 id="7.1.1%20%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93"><a></a>7.1.1 提交到本地仓库</h3>
<p>&nbsp;<img alt="" class="has" height="795" src="https://img-blog.csdnimg.cn/20191204093040907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="561"></p>
<h3 id="%C2%A07.1.2%20%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"><a></a>&nbsp;7.1.2 创建分支</h3>
<p><img alt="" class="has" height="902" src="https://img-blog.csdnimg.cn/20191204093108484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="563"></p>
<p></p>
<h3 id="%C2%A07.1.2%20%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><a></a>&nbsp;7.1.2 删除分支</h3>
<p><img alt="" class="has" height="117" src="https://img-blog.csdnimg.cn/20191204093137477.png" width="513"></p>
<h2 id="7.2%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><a></a>7.2 图形化界面</h2>
<h3 id="7.2.1%20%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E5%86%85%E5%AE%B9"><a></a>7.2.1 首先需要有一个本地目录，里面有一个文件，文件中有内容</h3>
<p><img alt="" class="has" height="202" src="https://img-blog.csdnimg.cn/20191204093201610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="730"></p>
<h3 id="%C2%A07.2.2%20%E6%89%93%E5%BC%80SourceTree%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%8C%E5%B9%B6%E5%B0%86%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93"><a></a>&nbsp;7.2.2 打开SourceTree创建本地仓库，并将代码提交到本地仓库</h3>
<blockquote>
<p>具体就不细说了，详情请看2.1</p>
</blockquote><p></p>

<h3 id="7.2.3%20%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF"><a></a>7.2.3 新建分支</h3>
<p><strong>点击“分支”</strong></p>
<p><img alt="" class="has" height="361" src="https://img-blog.csdnimg.cn/20191204093253299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="869"></p>
<p></p>
<p><strong>&nbsp;输入新的分支名称，点击“创建分支”</strong></p>
<p><img alt="" class="has" height="241" src="https://img-blog.csdnimg.cn/20191204093319465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="623"></p>
<p>&nbsp;<img alt="" class="has" height="424" src="https://img-blog.csdnimg.cn/2019120409334045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="418"></p>
<p><strong>右键仓库，选择“在资源管理器里打开”</strong></p>
<p><img alt="" class="has" height="426" src="https://img-blog.csdnimg.cn/20191204093404373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="349"></p>
<p><strong>在新的分支上添加一些内容</strong></p>
<p><img alt="" class="has" height="272" src="https://img-blog.csdnimg.cn/20191204093423505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="745"></p>
<p>&nbsp;<strong>返回sourceTree，选择“未提交的更改”，将下方的“为暂存文件”提交到本地仓库</strong></p>
<p><img alt="" class="has" height="764" src="https://img-blog.csdnimg.cn/20191204093450907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1037"></p>
<p>&nbsp;<strong>接下来合并分支。双击master分支就会切换至master分支</strong></p>
<p><img alt="" class="has" height="451" src="https://img-blog.csdnimg.cn/20191204093525601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="632"></p>
<p><strong>点击“合并”，选择要合并的分支，勾选“立即提交合并”，点击确定</strong></p>
<p><img alt="" class="has" height="735" src="https://img-blog.csdnimg.cn/20191204093549461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1027"></p>
<p>&nbsp;<strong>此时通过右键该仓库点击“在资源管理器中打开”，查看该文件</strong></p>
<p><img alt="" class="has" height="345" src="https://img-blog.csdnimg.cn/20191204093611795.png" width="296"></p>
<p><strong>&nbsp;我们发现原来futureY中修改的文件已经合并到了master分支上</strong></p>
<p><img alt="" class="has" height="332" src="https://img-blog.csdnimg.cn/20191204093635726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="644"></p>
<h3 id="7.2.4%20%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><a></a>7.2.4 删除分支</h3>
<p><strong>右键要删除的分支名，点击删除futureY</strong></p>
<p><img alt="" class="has" height="406" src="https://img-blog.csdnimg.cn/20191204093657474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="359"></p>
<p><strong>勾选“强制删除”，ok即可删除该分支。</strong></p>
<p><img alt="" class="has" height="160" src="https://img-blog.csdnimg.cn/20191204093717458.png" width="375"></p>
<h1 id="%C2%A0%E5%85%AB%E3%80%81%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93"><a></a>&nbsp;八、问题归纳总结</h1>
<h2 id="8.1%20%E6%8A%A5%E9%94%99"><a></a>8.1 报错</h2>
<blockquote>
<p>如果出现下类问题不要慌，是因为你的git没有ssh密钥与远程仓库关联</p>
</blockquote><p></p>

<p><img alt="" class="has" height="449" src="https://img-blog.csdnimg.cn/20191204093759283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="1003"></p>
<h3 id="8.1.1%20%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%AC%E5%9C%B0%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84ssh%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%8C%89%E7%85%A7%E4%B8%8B%E6%96%B9%E6%AD%A5%E9%AA%A4%E6%9D%A5%E6%B7%BB%E5%8A%A0"><a></a>8.1.1 如果你本地有远程仓库的ssh的话，按照下方步骤来添加</h3>
<p><img alt="" class="has" height="357" src="https://img-blog.csdnimg.cn/20191204093828847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="667"></p>
<p>&nbsp;<img alt="" class="has" height="844" src="https://img-blog.csdnimg.cn/2019120409384427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="556"></p>
<p><strong>会自动帮你提取本地的ssh</strong></p>
<p><img alt="" class="has" height="557" src="https://img-blog.csdnimg.cn/20191204093904891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTgwNDYx,size_16,color_FFFFFF,t_70" width="552"></p>
<h3 id="8.1.2%20%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%AC%E5%9C%B0%E6%B2%A1%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84ssh%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%85%88%E6%9D%A5%E6%B7%BB%E5%8A%A0"><a></a>8.1.2 如果你本地没有远程仓库的ssh的话，先来添加</h3>
<p><span><strong>https://www.cnblogs.com/xue-shuai/p/11555150.html</strong></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>

                                    ]]></description></item><item><title>Nginx 配置高可用的集群</title><link>http://www.cnblogs.com/heian99/archive/2019/12/04/11985499.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 04 Dec 2019 10:05:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/04/11985499.html</guid><description><![CDATA[
                                            <h3><strong>1、什么是 nginx 高可用</strong></h3>

<p><img alt="" class="has" height="394" src="https://img-blog.csdnimg.cn/20191204175854326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1093"></p>

<p><img alt="" class="has" height="405" src="https://img-blog.csdnimg.cn/20191204175949542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="775"></p>

<ul><li>（1）需要两台 nginx 服务器</li>
	<li>（2）需要 keepalived</li>
	<li>（3）需要虚拟 ip&nbsp;</li>
</ul><h3>2、配置高可用的准备工作</h3>

<p><strong>（1）需要两台服务器 192.168.17.129 和 192.168.17.131 </strong></p>

<p><strong>（2）在两台服务器安装 nginx </strong></p>

<p><strong>（3）在两台服务器安装 keepalived&nbsp;</strong></p>

<h3>3、在两台服务器安装 keepalived&nbsp;</h3>

<p><strong>（1）使用 yum 命令进行安</strong></p>

<pre class="has"><code>yum install keepalived –y </code></pre>

<p><img alt="" class="has" height="38" src="https://img-blog.csdnimg.cn/20191204180053392.png" width="509"></p>

<p><strong>（2）安装之后，在 etc 里面生成目录 keepalived，有文件 keepalived.conf&nbsp;</strong></p>

<h3>4、完成高可用配置（主从配置）</h3>

<p><strong>（1）修改/etc/keepalived/keepalivec.conf 配置文件&nbsp;</strong></p>

<pre class="has"><code class="language-bash">global_defs { 
   notification_email { 
     acassen@firewall.loc 
     failover@firewall.loc 
     sysadmin@firewall.loc 
   } 
   notification_email_from Alexandre.Cassen@firewall.loc 
   smtp_server 192.168.17.129 
   smtp_connect_timeout 30 
   router_id LVS_DEVEL 
} 
  
vrrp_script chk_http_port { 
  
   script "/usr/local/src/nginx_check.sh" 
     interval 2      #（检测脚本执行的间隔） 
  
   weight 2 
  
} 
  
vrrp_instance VI_1 {     state BACKUP   # 备份服务器上将 MASTER 改为 BACKUP       interface ens33  //网卡     virtual_router_id 51   # 主、备机的 virtual_router_id 必须相同     priority 90     # 主、备机取不同的优先级，主机值较大，备份机值较小 
    advert_int 1 
  authentication { 
        auth_type PASS 
        auth_pass 1111 
    } 
    virtual_ipaddress {         192.168.17.50 // VRRP H 虚拟地址 
    } 
} </code></pre>

<p><strong>（2）在/usr/local/src 添加检测脚本</strong></p>

<pre class="has"><code class="language-bash">#!/bin/bash
 A=`ps -C nginx –no-header |wc -l` 
 if [ $A -eq 0 ];then
	/usr/local/nginx/sbin/nginx     
	sleep 2     
	if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then
		killall keepalived     
	fi 
fi
</code></pre>

<p><strong>（3）把两台服务器上 nginx 和 keepalived 启动 </strong></p>

<p><strong>启动 nginx：./nginx </strong></p>

<p><strong>启动 keepalived：systemctl start keepalived.service&nbsp;</strong></p>

<p>&nbsp;</p>

<h3>5、最终测试&nbsp;</h3>

<p><strong>（1）在浏览器地址栏输入 虚拟 ip 地址 192.168.17.50 &nbsp;</strong><br>
&nbsp;<img alt="" class="has" height="143" src="https://img-blog.csdnimg.cn/20191204180432921.png" width="574"></p>

<p><img alt="" class="has" height="322" src="https://img-blog.csdnimg.cn/20191204180440295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="679"></p>

<p><strong>（2）把主服务器（192.168.17.129）nginx 和 keepalived 停止，再输入 192.168.17.50&nbsp;</strong></p>

<p><img alt="" class="has" height="156" src="https://img-blog.csdnimg.cn/20191204180459653.png" width="675"></p>

<p><img alt="" class="has" height="289" src="https://img-blog.csdnimg.cn/20191204180508602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="685"></p>
                                    ]]></description></item><item><title>Nginx 配置实例-动静分离</title><link>http://www.cnblogs.com/heian99/archive/2019/12/04/11985500.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 04 Dec 2019 09:57:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/12/04/11985500.html</guid><description><![CDATA[
                                            <h3><strong>1、什么是动静分离&nbsp;</strong></h3>

<p><img alt="" class="has" height="337" src="https://img-blog.csdnimg.cn/20191204175415158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="560"></p>

<p><strong>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏 览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源 设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可， 所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件， 不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一 个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304， 如果有修改，则直接从服务器重新下载，返回状态码 200。&nbsp;</strong></p>

<h3><strong>2、准备工作&nbsp;</strong></h3>

<p><strong>（1）在 liunx 系统中准备静态资源，用于进行访问&nbsp;</strong></p>

<p><img alt="" class="has" height="124" src="https://img-blog.csdnimg.cn/20191204175449565.png" width="311"></p>

<h3><strong>3、具体配置&nbsp;</strong></h3>

<p><strong>（1）在 nginx 配置文件中进行配置&nbsp;</strong></p>

<p><img alt="" class="has" height="282" src="https://img-blog.csdnimg.cn/20191204175522806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="365"></p>

<p>&nbsp;</p>

<h3>4、最终测试&nbsp;</h3>

<p><strong>（1）浏览器中输入地址 http://192.168.17.129/image/01.jpg&nbsp;</strong></p>

<p><img alt="" class="has" height="431" src="https://img-blog.csdnimg.cn/20191204175548402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="543"></p>

<p><img alt="" class="has" height="198" src="https://img-blog.csdnimg.cn/20191204175631237.png" width="561"></p>

<p><strong>（2）在浏览器地址栏输入地址 http://192.168.17.129/www/a.html&nbsp;<br>
&nbsp;</strong><img alt="" class="has" height="158" src="https://img-blog.csdnimg.cn/20191204175646863.png" width="527"><br>
&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>将博客搬至博客园</title><link>http://www.cnblogs.com/heian99/archive/2019/11/30/11972225.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 30 Nov 2019 05:45:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/30/11972225.html</guid><description><![CDATA[
                                            <p>我已经CSDN博客迁移到博客园</p>

<p>博客园地址：<a href="https://www.cnblogs.com/heian99/" rel="nofollow">https://www.cnblogs.com/heian99/</a></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>nginx 配置实例-反向代理</title><link>http://www.cnblogs.com/heian99/archive/2019/11/30/11961932.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 30 Nov 2019 03:55:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/30/11961932.html</guid><description><![CDATA[<div id="article_content" class="article_content clearfix">
                                            <div class="article-copyright">
               
                </span>
                    
                </div>
                                                    <!--一个博主专栏付费入口-->
             
             <!--一个博主专栏付费入口结束-->
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-4a3473df85.css">
                                        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-4a3473df85.css">
                <div class="htmledit_views" id="content_views">
                                            <h2><a name="t0"></a>反向代理实例一&nbsp;</h2>

<p><span style="color:#f33b45;"><strong>虚拟机IP：192.168.116.129</strong></span><br><strong>实现效果：使用 nginx 反向代理，访问 www.123.com 直接跳转到 虚拟机的</strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:8080&nbsp;</strong></p>

<h3><a name="t1"></a><strong>实验代码&nbsp;</strong></h3>

<p><strong>1） 启动一个 tomcat，浏览器地址栏输入 </strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:8080，出现如下界面&nbsp;</strong></p>

<p><img alt="" class="has" height="443" src="https://img-blog.csdnimg.cn/20191128143406253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>2） 通过修改本地 host 文件，将 www.123.com 映射到</strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span></p>

<p><img alt="" class="has" height="336" src="https://img-blog.csdnimg.cn/20191128143641636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1055"></p>

<p><strong>配置完成之后，我们便可以通过 www.123.com:8080 访问到第一步出现的 Tomcat 初始界 面。那么如何只需要输入 www.123.com 便可以跳转到 Tomcat 初始界面呢？便用到 nginx 的反向代理。</strong></p>

<h3><a name="t2"></a>3） 在 nginx.conf 配置文件中增加如下配置&nbsp;</h3>

<p><img alt="" class="has" height="338" src="https://img-blog.csdnimg.cn/20191128143903860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="573"></p>

<p><span style="color:#f33b45;"><strong>注意：修改配置文件后，需要重启nginx</strong></span></p>

<p><strong>如上配置，我们监听 80 端口，访问域名为 www.123.com，不加端口号时默认为 80 端口，故 访问该域名时会跳转到 127.0.0.1:8080 路径上。在浏览器端输入 www.123.com 结果如下：</strong><br>
&nbsp;</p>

<p><img alt="" class="has" height="674" src="https://img-blog.csdnimg.cn/2019112814412660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2><a name="t3"></a>反向代理实例二&nbsp;</h2>

<p><strong>虚拟机ip:<span style="color:#f33b45;">192.168.116.129</span></strong></p>

<p><strong>实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中 nginx 监听端口为 9001，</strong></p>

<p><strong>访问 http://</strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:9001/edu/ 直接跳转到 </strong><span style="color:#f33b45;"><strong>192.168.116.129.</strong></span><strong>0.0.1:8080 </strong></p>

<p><strong>访问 http://</strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:9001/vod/ 直接跳转到 </strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:8082&nbsp;</strong></p>

<p>&nbsp;</p>

<h3><a name="t4"></a>实验代码&nbsp;</h3>

<h3><a name="t5"></a><br>
1、准备工作</h3>

<p><strong>（1）准备两个 tomcat 服务器，一个 8080 端口，一个 8082 端口 </strong></p>

<p><strong>（2）创建文件夹和测试页面&nbsp;</strong></p>

<h2><a name="t6"></a>2、具体配</h2>

<p><strong>修改 nginx 的配置文件 </strong></p>

<p><strong>在 http 块中添加 server{}&nbsp;</strong></p>

<pre class="has" name="code"><code class="language-bash hljs"><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   server{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        listen 9001;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        server_name localhost;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                location ~ /edu/ {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                                proxy_pass http://localhost:8080;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                  location ~ /dev/ {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                                proxy_pass http://localhost:8082;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>

<p><span style="color:#f33b45;"><strong>重启</strong></span></p>

<p><img alt="" class="has" height="290" src="https://img-blog.csdnimg.cn/20191128150902654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="777"></p>

<p><img alt="" class="has" height="265" src="https://img-blog.csdnimg.cn/20191128151024475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="712"></p>

<p>&nbsp;</p>

<h3><a name="t7"></a><span style="color:#f33b45;"><strong>location 指令说明&nbsp;</strong></span></h3>

<p>语法如下：</p>

<p><img alt="" class="has" height="102" src="https://img-blog.csdnimg.cn/2019112815105882.png" width="452"></p>

<ul><li><strong>&nbsp;1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求。&nbsp;</strong></li>
	<li><strong>&nbsp; 2、~：用于表示 uri 包含正则表达式，并且区分大小写。&nbsp;</strong></li>
	<li><strong>&nbsp; 3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。&nbsp;</strong></li>
	<li><strong>&nbsp; 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字 符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。&nbsp;</strong></li>
	<li><strong>&nbsp; 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。&nbsp;</strong></li>
</ul><h3><a name="t8"></a><span style="color:#f33b45;">我改了一行配置，会实现下面修改。</span></h3>

<p>有兴趣的朋友可以试试（猜猜我改的那个地方）</p>

<p><img alt="" class="has" height="260" src="https://img-blog.csdnimg.cn/20191128151354709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="635"></p>

<p><img alt="" class="has" height="229" src="https://img-blog.csdnimg.cn/20191128151434918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="571"></p>

<p>&nbsp;</p>
                                    </div>
                    </div>]]></description></item><item><title>Nginx 简介与安装、常用的命令和配置文件</title><link>http://www.cnblogs.com/heian99/archive/2019/11/29/11957443.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 29 Nov 2019 06:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/29/11957443.html</guid><description><![CDATA[<p>1、nginx 简介<br />（1）介绍 nginx 的应用场景和具体可以做什么事情</p>
<p>（2）介绍什么是反向代理</p>
<p>（3）介绍什么是负载均衡</p>
<p>（4）介绍什么是动静分离</p>
<p>2、nginx 安装<br />（1）介绍 nginx 在 linux 系统中如何进行安装</p>
<p>3、nginx 常用的命令和配置文件<br />（1）介绍 nginx 启动、关闭、重新加载命令</p>
<p>（2）介绍 nginx 的配置文件</p>
<p>&nbsp;</p>
<p>1.1 Nginx 概述<br />Nginx ("engine x") 是一个高性能的 HTTP 和反向代理服务器,特点是占有内存少，并发能 力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等</p>
<p>1.2 Nginx 作为 web 服务器<br />Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、php 等。但是不支持 java。Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发， 性能是其最重要的考量,实现上非常注重效率 ，能经受高负载的考验,有报告表明能支持高 达 50,000 个并发连接数。 https://lnmp.org/nginx.html</p>
<p>1.3 正向代理<br />Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p>
<p>&nbsp;</p>
<p>1.4 反向代理<br />反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201911/1860862-20191129140644906-1632047119.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>1.5 负载均衡</p>
<p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成 本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂 度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易 造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情 况呢？</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机 器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能 满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量 是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能 够满足需求的。那么怎么办呢？</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题 的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解 决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个 java 课程系列服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们 所说的负载均衡</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201911/1860862-20191129140725739-1705674564.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>1.6 动静分离</h3>
<p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速 度。降低原来单个服务器的压力。</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201911/1860862-20191129140738493-1233798149.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>第 2 章 Nginx 安装</h2>
<h3><a name="t10"></a>2.1 进入 nginx 官网，下载</h3>
<p><a href="http://nginx.org/" rel="nofollow">http://nginx.org/</a></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201911/1860862-20191129140754492-604436443.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>2.2 安装 nginx<br />第一步，安装 pcre <br />&nbsp;</p>
<p>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz<br />解压文件，<br />./configure 完成后，回到 pcre 目录下执行 make，<br />再执行 make install<br />第二步，安装 openssl</p>
<p>第三步，安装 zlib</p>
<p>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel<br />第四步，安装 nginx</p>
<p>1、 解压缩 nginx-xx.tar.gz 包。<br />2、 进入解压缩目录，执行./configure。<br />3、 make &amp;&amp; make install<br />查看开放的端口号</p>
<p>firewall-cmd --list-all<br />设置开放的端口号</p>
<p>firewall-cmd --add-service=http &ndash;permanent<br />sudo firewall-cmd --add-port=80/tcp --permanent<br />重启防火墙</p>
<p>firewall-cmd &ndash;reload<br />第 3 章 nginx 常用的命令和配置文件<br />3.1 nginx 常用的命令：<br />（1）启动命令</p>
<p>在/usr/local/nginx/sbin 目录下执行 ./nginx</p>
<p>（2）关闭命令</p>
<p>在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop</p>
<p>（3）重新加载命令</p>
<p>在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload</p>
<p>3.2 nginx.conf 配置文件<br />nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/i-beta/1860862/201911/1860862-20191129140819783-565788297.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;配置文件中有很多#， 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的 内容如下：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1860862/201911/1860862-20191129140838477-865106548.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分：<br />第一部分：全局块<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。</p>
<p>比如上面第一行配置的：</p>
<p>worker_processes  1;<br />这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约</p>
<p>第二部分：events 块<br />比如上面的配置：</p>
<p>events {<br />    worker_connections  1024;<br />}<br />events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</p>
<p>&nbsp;</p>
<p>上述例子就表示每个 work process 支持的最大连接数为 1024.<br />这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。<br />第三部分：http 块</p>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">http {
include mime.types;
default_type application/octet-stream;

#log_format main '$remote_addr - $remote_user [$time_local] "$request" '
# '$status $body_bytes_sent "$http_referer" '
# '"$http_user_agent" "$http_x_forwarded_for"';

#access_log logs/access.log main;

sendfile on;
#tcp_nopush on;

#keepalive_timeout 0;
keepalive_timeout 65;

#gzip on;

server {
listen 80;
server_name localhost;

#charset koi8-r;

#access_log logs/host.access.log main;

location / {
root html;
index index.html index.htm;
}
}
</pre>
</div>
<p>　　</p>
<p><br />这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http 全局块、server 块。</p>
<p>①、http 全局块</p>
<p>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br />②、server 块</p>
<p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。</p>
<p>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。<br />而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。<br />1、全局 server 块</p>
<p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配<br />2、location 块</p>
<p>一个 server 块可以配置多个 location 块。<br />这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>]]></description></item><item><title>nginx 配置实例-负载均衡</title><link>http://www.cnblogs.com/heian99/archive/2019/11/28/11972226.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 28 Nov 2019 10:03:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/28/11972226.html</guid><description><![CDATA[
                                            <h2>1、实现效果</h2>

<p>（1）浏览器地址栏输入地址 http://<span style="color:#f33b45;">www.123.com</span>/edu/a.html，负载均衡效果，平均 8080 和 8081 端口中</p>

<h2>2、准备工作</h2>

<p>（1）准备两台 tomcat 服务器，一台 8080，一台 8082</p>

<p>（2）在两台 tomcat 里面 webapps 目录中，创建名称是 edu 文件夹，在 edu 文件夹中创建 页面 a.html，用于测试&nbsp;</p>

<h2>3、在 nginx 的配置文件中进行负载均衡的配置</h2>

<pre class="has"><code>upstream heian{
   server  localhost:8080;
   server  localhost:8082;
}
</code></pre>

<p><img alt="" class="has" height="226" src="https://img-blog.csdnimg.cn/2019112817574981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="444"></p>

<p><img alt="" class="has" height="202" src="https://img-blog.csdnimg.cn/20191128175948286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="680"></p>

<p><img alt="" class="has" height="177" src="https://img-blog.csdnimg.cn/20191128180003645.png" width="665"></p>

<h2><br>
&nbsp;4、nginx 分配服务器策略</h2>

<p><strong>第一种 轮询（默认）</strong></p>

<ul><li>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</li>
</ul><p><strong>第二种 weight&nbsp;</strong></p>

<ul><li>weight 代表权重默认为 1,权重越高被分配的客户端越</li>
	<li>指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。 例如：&nbsp;</li>
</ul><pre class="has"><code>upstream server_pool{   
 server 192.168.5.21 weight=10;  
   server 192.168.5.22 weight=10;   
  }</code></pre>

<p><strong>3、ip_hash&nbsp;</strong></p>

<ul><li>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 例如：</li>
</ul><p>&nbsp;</p>

<pre class="has"><code>upstream server_pool{    
    ip_hash;   
      server 192.168.5.21:80;  
       server 192.168.5.22:80;     } 
</code></pre>

<p><strong>4、fair（第三方）&nbsp;</strong></p>

<p><strong>按后端服务器的响应时间来分配请求，响应时间短的优先分配</strong></p>

<pre class="has"><code>upstream server_pool{  
  server 192.168.5.21:80; 
    server 192.168.5.22:80;
     fair;  
   }</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>nginx 配置实例-反向代理</title><link>http://www.cnblogs.com/heian99/archive/2019/11/28/11972227.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 28 Nov 2019 07:15:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/28/11972227.html</guid><description><![CDATA[
                                            <h2>反向代理实例一&nbsp;</h2>

<p><span style="color:#f33b45;"><strong>虚拟机IP：192.168.116.129</strong></span><br><strong>实现效果：使用 nginx 反向代理，访问 www.123.com 直接跳转到 虚拟机的</strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:8080&nbsp;</strong></p>

<h3><strong>实验代码&nbsp;</strong></h3>

<p><strong>1） 启动一个 tomcat，浏览器地址栏输入 </strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:8080，出现如下界面&nbsp;</strong></p>

<p><img alt="" class="has" height="443" src="https://img-blog.csdnimg.cn/20191128143406253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>2） 通过修改本地 host 文件，将 www.123.com 映射到</strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span></p>

<p><img alt="" class="has" height="336" src="https://img-blog.csdnimg.cn/20191128143641636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1055"></p>

<p><strong>配置完成之后，我们便可以通过 www.123.com:8080 访问到第一步出现的 Tomcat 初始界 面。那么如何只需要输入 www.123.com 便可以跳转到 Tomcat 初始界面呢？便用到 nginx 的反向代理。</strong></p>

<h3>3） 在 nginx.conf 配置文件中增加如下配置&nbsp;</h3>

<p><img alt="" class="has" height="338" src="https://img-blog.csdnimg.cn/20191128143903860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="573"></p>

<p><span style="color:#f33b45;"><strong>注意：修改配置文件后，需要重启nginx</strong></span></p>

<p><strong>如上配置，我们监听 80 端口，访问域名为 www.123.com，不加端口号时默认为 80 端口，故 访问该域名时会跳转到 127.0.0.1:8080 路径上。在浏览器端输入 www.123.com 结果如下：</strong><br>
&nbsp;</p>

<p><img alt="" class="has" height="674" src="https://img-blog.csdnimg.cn/2019112814412660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2>反向代理实例二&nbsp;</h2>

<p><strong>虚拟机ip:<span style="color:#f33b45;">192.168.116.129</span></strong></p>

<p><strong>实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中 nginx 监听端口为 9001，</strong></p>

<p><strong>访问 http://</strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:9001/edu/ 直接跳转到 </strong><span style="color:#f33b45;"><strong>192.168.116.129.</strong></span><strong>0.0.1:8080 </strong></p>

<p><strong>访问 http://</strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:9001/vod/ 直接跳转到 </strong><span style="color:#f33b45;"><strong>192.168.116.129</strong></span><strong>:8082&nbsp;</strong></p>

<p>&nbsp;</p>

<h3>实验代码&nbsp;</h3>

<h3><br>
1、准备工作</h3>

<p><strong>（1）准备两个 tomcat 服务器，一个 8080 端口，一个 8082 端口 </strong></p>

<p><strong>（2）创建文件夹和测试页面&nbsp;</strong></p>

<h2>2、具体配</h2>

<p><strong>修改 nginx 的配置文件 </strong></p>

<p><strong>在 http 块中添加 server{}&nbsp;</strong></p>

<pre class="has"><code class="language-bash">   server{
        listen 9001;
        server_name localhost;
                location ~ /edu/ {
                                proxy_pass http://localhost:8080;
                        }
                  location ~ /dev/ {
                                proxy_pass http://localhost:8082;
                        }

}
</code></pre>

<p><span style="color:#f33b45;"><strong>重启</strong></span></p>

<p><img alt="" class="has" height="290" src="https://img-blog.csdnimg.cn/20191128150902654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="777"></p>

<p><img alt="" class="has" height="265" src="https://img-blog.csdnimg.cn/20191128151024475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="712"></p>

<p>&nbsp;</p>

<h3><span style="color:#f33b45;"><strong>location 指令说明&nbsp;</strong></span></h3>

<p>语法如下：</p>

<p><img alt="" class="has" height="102" src="https://img-blog.csdnimg.cn/2019112815105882.png" width="452"></p>

<ul><li><strong>&nbsp;1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求。&nbsp;</strong></li>
	<li><strong>&nbsp; 2、~：用于表示 uri 包含正则表达式，并且区分大小写。&nbsp;</strong></li>
	<li><strong>&nbsp; 3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。&nbsp;</strong></li>
	<li><strong>&nbsp; 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字 符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。&nbsp;</strong></li>
	<li><strong>&nbsp; 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。&nbsp;</strong></li>
</ul><h3><span style="color:#f33b45;">我改了一行配置，会实现下面修改。</span></h3>

<p>有兴趣的朋友可以试试（猜猜我改的那个地方）</p>

<p><img alt="" class="has" height="260" src="https://img-blog.csdnimg.cn/20191128151354709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="635"></p>

<p><img alt="" class="has" height="229" src="https://img-blog.csdnimg.cn/20191128151434918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="571"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Nginx 简介与安装、常用的命令和配置文件</title><link>http://www.cnblogs.com/heian99/archive/2019/11/26/11972228.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 26 Nov 2019 12:42:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/26/11972228.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<h2>1、nginx 简介</h2>

<p><strong>（1）介绍 nginx 的应用场景和具体可以做什么事情 </strong></p>

<p><strong>（2）介绍什么是反向代理 </strong></p>

<p><strong>（3）介绍什么是负载均衡 </strong></p>

<p><strong>（4）介绍什么是动静分离 </strong></p>

<h2>2、nginx 安装</h2>

<p><strong>（1）介绍 nginx 在 linux 系统中如何进行安装</strong></p>

<h2>3、nginx 常用的命令和配置文件</h2>

<p><strong>（1）介绍 nginx 启动、关闭、重新加载命令 </strong></p>

<p><strong>（2）介绍 nginx 的配置文件</strong></p>

<p>&nbsp;</p>

<h3>1.1 Nginx 概述</h3>

<p>Nginx ("engine x") 是一个高性能的 HTTP 和反向代理服务器,特点是占有内存少，并发能 力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等</p>

<h3>1.2 Nginx 作为 web 服务器</h3>

<p><strong>Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、php 等。但是不支持 java。Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发， 性能是其最重要的考量,实现上非常注重效率 ，能经受高负载的考验,有报告表明能支持高 达 50,000 个并发连接数。 https://lnmp.org/nginx.html</strong></p>

<h3>1.3 正向代理</h3>

<p><strong>Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</strong></p>

<p><img alt="" class="has" height="385" src="https://img-blog.csdnimg.cn/20191126202429129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="910"></p>

<h3>1.4 反向代理</h3>

<p><strong>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。</strong></p>

<p><img alt="" class="has" height="427" src="https://img-blog.csdnimg.cn/20191126202505208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="784"></p>

<h3>1.5 负载均衡</h3>

<p>&nbsp; &nbsp; &nbsp; &nbsp;客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端。</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成 本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂 度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易 造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情 况呢？</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; 我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机 器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能 满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量 是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能 够满足需求的。那么怎么办呢？</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题 的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解 决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个 java 课程系列服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们 所说的负载均衡</p>

<p><img alt="" class="has" height="458" src="https://img-blog.csdnimg.cn/20191126202642739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="886"></p>

<h3>1.6 动静分离</h3>

<p><strong>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速 度。降低原来单个服务器的压力。</strong></p>

<p><img alt="" class="has" height="428" src="https://img-blog.csdnimg.cn/20191126202715313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="849"></p>

<h2>第 2 章 Nginx 安装</h2>

<h3>2.1 进入 nginx 官网，下载</h3>

<p><a href="http://nginx.org/" rel="nofollow">http://nginx.org/</a></p>

<p><img alt="" class="has" height="717" src="https://img-blog.csdnimg.cn/2019112620300673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h3>2.2 安装 nginx</h3>

<p><strong><span style="color:#f33b45;">第一步，安装 pcre </span></strong><br>
&nbsp;</p>

<pre class="has"><code class="language-bash">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</code></pre>

<ul><li>解压文件，</li>
	<li>./configure 完成后，回到 pcre 目录下执行 make，</li>
	<li>再执行 make install</li>
</ul><p><strong><span style="color:#f33b45;">第二步，安装 openssl </span></strong></p>

<p><strong><span style="color:#f33b45;">第三步，安装 zlib</span></strong></p>

<pre class="has"><code>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</code></pre>

<p><strong><span style="color:#f33b45;">第四步，安装 nginx</span></strong></p>

<ul><li><strong>1、 解压缩 nginx-xx.tar.gz 包。</strong></li>
	<li><strong>2、 进入解压缩目录，执行./configure。</strong></li>
	<li><strong>3、 make &amp;&amp; make install</strong></li>
</ul><p><span style="color:#f33b45;"><strong>查看开放的端口号</strong></span></p>

<ul><li>firewall-cmd --list-all</li>
</ul><p><span style="color:#f33b45;"><strong>设置开放的端口号 </strong></span></p>

<ul><li>firewall-cmd --add-service=http –permanent</li>
	<li>sudo firewall-cmd --add-port=80/tcp --permanent</li>
</ul><p><span style="color:#f33b45;"><strong>重启防火墙</strong></span></p>

<ul><li>firewall-cmd –reload</li>
</ul><h2>第 3 章 nginx 常用的命令和配置文件</h2>

<h3>3.1 nginx 常用的命令：</h3>

<p><span style="color:#f33b45;"><strong>（1）启动命令</strong></span></p>

<p><strong>在/usr/local/nginx/sbin 目录下执行 ./nginx</strong></p>

<p><strong><span style="color:#f33b45;">（2）关闭命令 </span></strong></p>

<p><strong>在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop</strong></p>

<p><span style="color:#f33b45;">（3）重新加载命令</span></p>

<p><strong>在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload</strong></p>

<h3>3.2 nginx.conf 配置文件</h3>

<p><strong>nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改</strong></p>

<p><img alt="" class="has" height="416" src="https://img-blog.csdnimg.cn/20191126203613627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="743"></p>

<p><span style="color:#f33b45;"><strong>配置文件中有很多#， 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的 内容如下：</strong></span></p>

<p><img alt="" class="has" height="643" src="https://img-blog.csdnimg.cn/20191126203700973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="863"></p>

<h3>根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分：</h3>

<h3><span style="color:#f33b45;">第一部分：全局块</span></h3>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong> 从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。</strong></p>

<p>比如上面第一行配置的：</p>

<pre class="has"><code>worker_processes  1;</code></pre>

<p><strong>这是 Nginx 服务器并发处理服务的关键配置，<span style="color:#f33b45;">worker_processes 值越大，可以支持的并发处理量也越多</span>，但是 会<span style="color:#7c79e5;">受到硬件、软件等设备的制约</span></strong></p>

<h3><span style="color:#f33b45;">第二部分：events 块</span></h3>

<p>比如上面的配置：</p>

<pre class="has"><code>events {
    worker_connections  1024;
}
</code></pre>

<p><strong>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</strong></p>

<p>&nbsp;</p>

<ul><li><strong>上述例子就表示每个 work process 支持的最大连接数为 1024. </strong></li>
	<li><strong>这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</strong></li>
</ul><h3><span style="color:#f33b45;">第三部分：http 块</span></h3>

<pre class="has"><code>http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }
}</code></pre>

<p><strong>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括<span style="color:#f33b45;"> http 全局块、server 块。</span></strong></p>

<p><strong><span style="color:#f33b45;">①、http 全局块</span></strong></p>

<ul><li>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</li>
</ul><p><strong><span style="color:#f33b45;">②、server 块</span></strong></p>

<p><strong>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。</strong></p>

<ul><li>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。</li>
	<li>而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</li>
</ul><p><strong>1、全局 server 块</strong></p>

<ul><li>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配</li>
</ul><p><strong>2、location 块</strong></p>

<ul><li>一个 server 块可以配置多个 location 块。</li>
</ul><p><strong>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</strong></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>kibana和中文分词器analysis-ik的安装使用</title><link>http://www.cnblogs.com/heian99/archive/2019/11/26/11972229.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 26 Nov 2019 01:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/26/11972229.html</guid><description><![CDATA[
                                            <h2><a href="https://blog.csdn.net/heian_99/article/details/102835825" rel="nofollow">Centos7安装elasticSearch6</a></h2>

<p><strong>上面讲述了elasticSearch6的安装和使用教程。</strong></p>

<p><strong>下面讲一下elasticsearch6的管理工具Kibana。</strong></p>

<p><strong>Kibana是一个开源的分析和可视化平台，设计用于和Elasticsearch一起工作。</strong></p>

<p><strong>你用Kibana来搜索，查看，并和存储在Elasticsearch索引中的数据进行交互。</strong></p>

<p><strong>你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。</strong></p>

<p><strong>Kibana使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示Elasticsearch查询的变化</strong></p>

<h2>Kibana安装教程</h2>

<h3 style="margin-left:0cm;">1、拷贝kibana-5.6.4-linux-x86_64.tar 到/opt下</h3>

<h3 style="margin-left:0cm;">2、解压缩</h3>

<h3 style="margin-left:0cm;">3、进入kibana主目录的config目录下</h3>

<p style="margin-left:0cm;"><img alt="" class="has" height="398" src="https://img-blog.csdnimg.cn/20191126094059392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="743"></p>

<h3 style="margin-left:0cm;">4、修改配置文件</h3>

<pre class="has"><code>vim  kibana.yml</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="591" src="https://img-blog.csdnimg.cn/20191126094152322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="765"></p>

<h3 style="margin-left:0cm;">5、启动，在 kibana主目录bin目录下执行</h3>

<pre class="has"><code>nohup  ./kibana  &amp;</code></pre>

<h3 style="margin-left:0cm;">6、然后ctrl+c退出</h3>

<p style="margin-left:0cm;"><strong>执行ps -ef </strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="48" src="https://img-blog.csdnimg.cn/20191126094246102.png" width="1060"></strong></p>

<p style="margin-left:0cm;"><strong>如上图,1757号进程就是kibana的进程</strong></p>

<h3 style="margin-left:0cm;">7、用浏览器打开</h3>

<p style="margin-left:0cm;"><img alt="" class="has" height="489" src="https://img-blog.csdnimg.cn/20191126094331706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1154"></p>

<p style="margin-left:0cm;">点击左边菜单DevTools</p>

<p style="margin-left:0cm;">在Console中</p>

<p style="margin-left:0cm;">执行 get _cluster/health&nbsp;&nbsp;&nbsp;</p>

<p style="margin-left:0cm;">右边的结果中，status为yellow或者green。</p>

<p style="margin-left:0cm;">表示es启动正常，并且与kibana连接正常。</p>

<p style="margin-left:0cm;">&nbsp;</p>

<h2 style="margin-left:0cm;">analysis-ik安装教程【简单】</h2>

<h3>1、上传文件到服务器</h3>

<h3>2、解压</h3>

<h3>3、移动到ElasticSearch6下的plugins</h3>

<h3>4、重新启动就可以了</h3>

<p><img alt="" class="has" height="405" src="https://img-blog.csdnimg.cn/20191126094814987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1045"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>qos-server can not bind localhost:22222, dubbo version: 2.6.0, current host: 127.0.0.1【问题解决】</title><link>http://www.cnblogs.com/heian99/archive/2019/11/19/11972230.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 19 Nov 2019 08:33:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/19/11972230.html</guid><description><![CDATA[
                                            <p>好吧，这个问题比较low，但是记录一下，以免后期遗忘。</p>

<p>说白了，这个问题就是端口被占用了。</p>

<p>问题：</p>

<pre class="has"><code>qos-server can not bind localhost:22222, dubbo version: 2.6.0, current host: 127.0.0.1
java.net.BindException: Address already in use: bind</code></pre>

<p>看翻译：【22222端口被占用】</p>

<p><img alt="" class="has" height="274" src="https://img-blog.csdnimg.cn/20191119163341972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>解决办法：</p>

<p><a href="https://blog.csdn.net/heian_99/article/details/103089408" rel="nofollow">解决端口被占用的问题（80、222222、3306）等等</a></p>

<p>查看占用程序的pid</p>

<pre class="has"><code>netstat -ano | findstr 22222</code></pre>

<p>通过pid，停止程序</p>

<pre class="has"><code>taskkill /f /pid 20720</code></pre>

<p>看截图：</p>

<p><img alt="" class="has" height="219" src="https://img-blog.csdnimg.cn/2019111916364082.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="684"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Dubbo启动，调用方法失败【问题：调用超时】</title><link>http://www.cnblogs.com/heian99/archive/2019/11/19/11972231.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 19 Nov 2019 08:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/19/11972231.html</guid><description><![CDATA[
                                            <p>今天，启动dubbo，开始写项目。</p>

<p>在一个调用dubbo里面的一个方法时，程序一直调用，每次显示报红。</p>

<p>很难搞。</p>

<p>问题代码</p>

<pre class="has"><code class="language-html">com.alibaba.dubbo.rpc.RpcException:
 Failed to invoke the method getAllSku in the service com.atguigu.gmall.service.
SkuService. Tried 3 times of the providers 
[192.168.116.1:53684] (1/1) from the registry 47.98.231.26:2181
 on the consumer 192.168.116.1 using the dubbo version 2.6.0. Last error is:
 Invoke remote method timeout. method: getAllSku,
 provider: dubbo://192.168.116.1:53684/com.atguigu.gmall.service</code></pre>

<p>这么烦，已经搞崩心态了</p>

<p>扔百度翻译去。</p>

<p>【bug，真TM智障】</p>

<p>靠，方法调用超时。</p>

<p><img alt="" class="has" height="595" src="https://img-blog.csdnimg.cn/20191119161554665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>解决办法：</p>

<pre class="has"><code># 设置超时时间
spring.dubbo.consumer.timeout=600000
# 设置是否检查服务存在
spring.dubbo.consumer.check=false
</code></pre>

<p>可以了，终于找出bug了。真是不容易</p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="810" src="https://img-blog.csdnimg.cn/20191119161735417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1039"></p>
                                    ]]></description></item><item><title>Tests in error:BlogApplicationTests.initializationError » IllegalState Unable to find a @Spri...【解决】</title><link>http://www.cnblogs.com/heian99/archive/2019/11/18/11972232.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 18 Nov 2019 01:39:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/18/11972232.html</guid><description><![CDATA[
                                            <p>刚刚写完一个项目，准备打包，却发现无法打包。</p>

<p><img alt="" class="has" height="435" src="https://img-blog.csdnimg.cn/20191118093843838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>然后认真排查了一下问题。发现少引入了一个插件。</p>

<pre class="has"><code class="language-java">			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
				&lt;configuration&gt;
					&lt;skip&gt;true&lt;/skip&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
</code></pre>

<p>引入这个插件就可以完美运行打包了。</p>

<p><img alt="" class="has" height="871" src="https://img-blog.csdnimg.cn/20191118094122154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>解决端口被占用的问题（80、8080、3306）等等</title><link>http://www.cnblogs.com/heian99/archive/2019/11/15/11972233.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 15 Nov 2019 09:38:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/15/11972233.html</guid><description><![CDATA[
                                            <h3><strong>作为一个程序员</strong></h3>

<h3><strong>经常会遇到端口被占用的问题，而无法启动项目。</strong></h3>

<h3><strong>这个事情让人很烦。【<span style="color:#f33b45;">两种解决办法</span>】</strong></h3>

<h3>1、首先，需要确定那个端口被占用</h3>

<p>示例：8080端口被占用【<span style="color:#f33b45;">命令查看程序占用的pid</span>】</p>

<pre class="has"><code>netstat -ano | findstr 8080</code></pre>

<h3><img alt="" class="has" height="263" src="https://img-blog.csdnimg.cn/20191115174235815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="692"></h3>

<h3>2、通过CMD命令利用PID可以杀掉占用的程序</h3>

<pre class="has"><code>taskkill /f /pid 92076</code></pre>

<p><img alt="" class="has" height="72" src="https://img-blog.csdnimg.cn/20191115174602412.png" width="673"></p>

<h3>3、通过CMD查出那个凶手占用端口的名称</h3>

<pre class="has"><code>tasklist|findstr "80"</code></pre>

<p><img alt="" class="has" height="133" src="https://img-blog.csdnimg.cn/20191115174859601.png" width="785"></p>

<h3>4、通过凶手的名称，杀掉程序</h3>

<pre class="has"><code>taskkill /f /im 程序名</code></pre>

<p><img alt="" class="has" height="80" src="https://img-blog.csdnimg.cn/20191115175229237.png" width="649"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Java使用MD5加密算法，实现等登陆功能</title><link>http://www.cnblogs.com/heian99/archive/2019/11/14/11972234.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 14 Nov 2019 09:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/14/11972234.html</guid><description><![CDATA[
                                            <h2>Java实现MD5加密</h2>

<p>为了保护有些数据，就需要采取一些手段来进行数据的加密，防止被别人破解。</p>

<h2>MD5简介</h2>

<p>md5的全称是<strong>md5信息摘要算法（英文：MD5 Message-Digest Algorithm ）</strong>，一种被广泛使用的密码散列函数，可以产生一个128位（16字节，1字节8位）的散列值（常见的是用32位的16进制表示，比如：0caa3b23b8da53f9e4e041d95dc8fa2c），用于确保信息传输的完整一致。</p>

<h2>功能实现</h2>

<h3>1、MD5的工具类</h3>

<pre class="has"><code class="language-java">
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
/**
 * 南宫乘风
 */
public class MD5Utils {
    /**
     * MD5加密类
     * @param str 要加密的字符串
     * @return    加密后的字符串
     */
    public static String code(String str){
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(str.getBytes());
            byte[]byteDigest = md.digest();
            int i;
            StringBuffer buf = new StringBuffer("");
            for (int offset = 0; offset &lt; byteDigest.length; offset++) {
                i = byteDigest[offset];
                if (i &lt; 0)
                    i += 256;
                if (i &lt; 16)
                    buf.append("0");
                buf.append(Integer.toHexString(i));
            }
            //32位加密
            return buf.toString();
            // 16位的加密
            //return buf.toString().substring(8, 24);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 测试方法
     * @param args
     */
    public static void main(String[] args) {
        System.out.println(code("111111"));
    }
}
</code></pre>

<p>最下面这个是测试方法</p>

<p><img alt="" class="has" height="528" src="https://img-blog.csdnimg.cn/20191114175329182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1151"></p>

<h3>2、项目中调用</h3>

<p>我在项目的接口中调用MD5的方法</p>

<pre class="has"><code class="language-java">public User checkUser(String username, String password) {
        User user = userRepository.findByUsernameAndPassword(username, MD5Utils.code(password));
        return user;
    }</code></pre>

<p><span style="color:#f33b45;"><strong>解析</strong></span>：这就是用户登录把密码传递过来，进行MD5加密后，在和数据库中的密码进行对比（<span style="color:#f33b45;">数据库中的密码是MD5格式存储的</span>）</p>

<p><img alt="" class="has" height="64" src="https://img-blog.csdnimg.cn/20191114175653987.png" width="418"></p>

<h3>3、思路拓展（防止重要信息被盗用）</h3>

<ol><li>账号注册</li>
	<li>密码登录</li>
	<li>信息保护</li>
	<li>资料加密</li>
</ol><p>等等，许多的功能都可以用到这样的方法来进行加密。</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>SpringBoot使用Hibernate，实现自动创建数据库表【博客数据库设计】</title><link>http://www.cnblogs.com/heian99/archive/2019/11/11/11972235.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 11 Nov 2019 09:37:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/11/11/11972235.html</guid><description><![CDATA[
                                            <p>我们准备设计博客，那就要设计数据库。</p>

<p>我们可以使用Hibernate来自动生成数据库。</p>

<p>博客数据库的结构：</p>

<p>实体类：</p>

<ul><li>博客 Blog</li>
	<li>博客分类 Type</li>
	<li>博客标签 Tag</li>
	<li>博客评论 Comment</li>
	<li>用户 User</li>
</ul><p></p>

<p>&nbsp;</p>

<p></p>

<p><img alt="" class="has" height="342" src="https://img-blog.csdnimg.cn/20191111173830884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="435"></p>

<p><img alt="" class="has" height="307" src="https://img-blog.csdnimg.cn/20191111173940592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="551"></p>

<p><img alt="" class="has" height="721" src="https://img-blog.csdnimg.cn/20191111174002272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="825"></p>

<p><img alt="" class="has" height="291" src="https://img-blog.csdnimg.cn/20191111174020749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="799"></p>

<p><img alt="" class="has" height="662" src="https://img-blog.csdnimg.cn/20191111174033932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="780"></p>

<p><img alt="" class="has" height="484" src="https://img-blog.csdnimg.cn/20191111174045756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="732"></p>

<p><img alt="" class="has" height="663" src="https://img-blog.csdnimg.cn/20191111174057964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="771"></p>

<p><img alt="" class="has" height="566" src="https://img-blog.csdnimg.cn/20191111174110775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="901"></p>

<p>项目截图：</p>

<p><img alt="" class="has" height="840" src="https://img-blog.csdnimg.cn/20191111173550825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p>首先，在pom.xml中添加以下的一些依赖:</p>

<pre class="has"><code class="language-java">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>这样就可以使用Hibernate框架了，下面实现自动创建数据库表的功能:</p>

<p>打开application.properties文件添加以下的代码:</p>

<pre class="has"><code class="language-java">  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
</code></pre>

<p><img alt="" class="has" height="619" src="https://img-blog.csdnimg.cn/20191111174335474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p>这里除了update参数外还有其他的参数，这里解释一下:<br>
&nbsp;//1：value="create-drop" 表示当JPA应用的时候自动创建表，在解应用的时候删除相应的表，这个在做测试的时候比较有用，但在开发过程中不这么用<br>
//2：value="create"这个在每次应用启动的时候都会创建数据库表（会删除以前数据库里的数据。<br>
//3：value="update" 这个属性的作用是a:每次只会更新数据库表里的信息</p>

<p>下面是创建实体类的代码:</p>

<h3>Blog</h3>

<pre class="has"><code class="language-java">package com.lrm.po;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Entity
@Table(name = "t_blog")
public class Blog {
    @Id
    @GeneratedValue
    private Long id;

    private String title;

    private String content;

    private String firstPicture;

    private String flag;

    private Integer views;

    private boolean appreciation;

    private boolean shareStatement;

    private boolean commentabled;

    private boolean published;

    private boolean recommend;

    private Date createTime;

    private Date updateTime;

    @ManyToOne
    private Type type;
    @ManyToMany(cascade = {CascadeType.PERSIST})
    private List&lt;Tag&gt; tags=new ArrayList&lt;&gt;();
    @ManyToOne
    private User user;

    @OneToMany(mappedBy = "blog")
    private List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();
    public Blog() {

    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getFirstPicture() {
        return firstPicture;
    }

    public void setFirstPicture(String firstPicture) {
        this.firstPicture = firstPicture;
    }

    public String getFlag() {
        return flag;
    }

    public void setFlag(String flag) {
        this.flag = flag;
    }

    public Integer getViews() {
        return views;
    }

    public void setViews(Integer views) {
        this.views = views;
    }

    public boolean isAppreciation() {
        return appreciation;
    }

    public void setAppreciation(boolean appreciation) {
        this.appreciation = appreciation;
    }

    public boolean isShareStatement() {
        return shareStatement;
    }

    public void setShareStatement(boolean shareStatement) {
        this.shareStatement = shareStatement;
    }

    public boolean isCommentabled() {
        return commentabled;
    }

    public void setCommentabled(boolean commentabled) {
        this.commentabled = commentabled;
    }

    public boolean isPublished() {
        return published;
    }

    public void setPublished(boolean published) {
        this.published = published;
    }

    public boolean isRecommend() {
        return recommend;
    }

    public void setRecommend(boolean recommend) {
        this.recommend = recommend;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    public Date getUpdateTime() {
        return updateTime;
    }

    public void setUpdateTime(Date updateTime) {
        this.updateTime = updateTime;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public List&lt;Tag&gt; getTags() {
        return tags;
    }

    public void setTags(List&lt;Tag&gt; tags) {
        this.tags = tags;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public List&lt;Comment&gt; getComments() {
        return comments;
    }

    public void setComments(List&lt;Comment&gt; comments) {
        this.comments = comments;
    }

    @Override
    public String toString() {
        return "Blog{" +
                "id=" + id +
                ", title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", firstPicture='" + firstPicture + '\'' +
                ", flag='" + flag + '\'' +
                ", views=" + views +
                ", appreciation=" + appreciation +
                ", shareStatement=" + shareStatement +
                ", commentabled=" + commentabled +
                ", published=" + published +
                ", recommend=" + recommend +
                ", createTime=" + createTime +
                ", updateTime=" + updateTime +
                '}';
    }
}
</code></pre>

<h3>Comment</h3>

<pre class="has"><code class="language-java">package com.lrm.po;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;


@Entity
@Table(name = "t_comment")
public class Comment {

    @Id
    @GeneratedValue
    private Long id;
    private String nickname;
    private String email;
    private String content;
    private String avatar;
    @Temporal(TemporalType.TIMESTAMP)
    private Date createTime;

    @ManyToOne
    private Blog blog;

    @OneToMany(mappedBy = "parentComment")
    private List&lt;Comment&gt; replyComments = new ArrayList&lt;&gt;();

    @ManyToOne
    private Comment parentComment;

    public Comment() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNickname() {
        return nickname;
    }

    public void setNickname(String nickname) {
        this.nickname = nickname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getAvatar() {
        return avatar;
    }

    public void setAvatar(String avatar) {
        this.avatar = avatar;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    public Blog getBlog() {
        return blog;
    }

    public void setBlog(Blog blog) {
        this.blog = blog;
    }

    public List&lt;Comment&gt; getReplyComments() {
        return replyComments;
    }

    public void setReplyComments(List&lt;Comment&gt; replyComments) {
        this.replyComments = replyComments;
    }

    public Comment getParentComment() {
        return parentComment;
    }

    public void setParentComment(Comment parentComment) {
        this.parentComment = parentComment;
    }

    @Override
    public String toString() {
        return "Comment{" +
                "id=" + id +
                ", nickname='" + nickname + '\'' +
                ", email='" + email + '\'' +
                ", content='" + content + '\'' +
                ", avatar='" + avatar + '\'' +
                ", createTime=" + createTime +
                '}';
    }
}
</code></pre>

<h3>Tag</h3>

<pre class="has"><code class="language-java">package com.lrm.po;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "t_tag")
public class Tag {

    @Id
    @GeneratedValue
    private Long id;
    private String name;

    @ManyToMany(mappedBy = "tags")
    private List&lt;Blog&gt; blogs = new ArrayList&lt;&gt;();

    public Tag() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List&lt;Blog&gt; getBlogs() {
        return blogs;
    }

    public void setBlogs(List&lt;Blog&gt; blogs) {
        this.blogs = blogs;
    }

    @Override
    public String toString() {
        return "Tag{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
</code></pre>

<h3>Type</h3>

<pre class="has"><code class="language-java">package com.lrm.po;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "t_type")
public class Type {
    @Id
    @GeneratedValue
    private long id;

    private String name;

    @OneToMany(mappedBy = "type")
    private List&lt;Blog&gt; blogs = new ArrayList&lt;&gt;();

    public Type() {
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List&lt;Blog&gt; getBlogs() {
        return blogs;
    }

    public void setBlogs(List&lt;Blog&gt; blogs) {
        this.blogs = blogs;
    }

    @Override
    public String toString() {
        return "Type{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
</code></pre>

<h3>User</h3>

<pre class="has"><code class="language-java">package com.lrm.po;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Created by limi on 2017/10/14.
 */
@Entity
@Table(name = "t_user")
public class User {

    @Id
    @GeneratedValue
    private Long id;
    private String nickname;
    private String username;
    private String password;
    private String email;
    private String avatar;
    private Integer type;
    @Temporal(TemporalType.TIMESTAMP)
    private Date createTime;
    @Temporal(TemporalType.TIMESTAMP)
    private Date updateTime;

    @OneToMany(mappedBy = "user")
    private List&lt;Blog&gt; blogs = new ArrayList&lt;&gt;();

    public User() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNickname() {
        return nickname;
    }

    public void setNickname(String nickname) {
        this.nickname = nickname;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getAvatar() {
        return avatar;
    }

    public void setAvatar(String avatar) {
        this.avatar = avatar;
    }

    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    public Date getUpdateTime() {
        return updateTime;
    }

    public void setUpdateTime(Date updateTime) {
        this.updateTime = updateTime;
    }


    public List&lt;Blog&gt; getBlogs() {
        return blogs;
    }

    public void setBlogs(List&lt;Blog&gt; blogs) {
        this.blogs = blogs;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", nickname='" + nickname + '\'' +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", email='" + email + '\'' +
                ", avatar='" + avatar + '\'' +
                ", type=" + type +
                ", createTime=" + createTime +
                ", updateTime=" + updateTime +
                '}';
    }
}
</code></pre>

<p>OK，既然，实体类已将创建完毕，运行接口。就可以生成数据库。但是前提，你是配置数据库</p>

<pre class="has"><code class="language-java">spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8
    username: root
    password: root</code></pre>

<p><img alt="" class="has" height="351" src="https://img-blog.csdnimg.cn/20191111174826317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1041"></p>

<h2>测试结果：</h2>

<p><img alt="" class="has" height="172" src="https://img-blog.csdnimg.cn/20191111175030797.png" width="1078"></p>

<p><img alt="" class="has" height="796" src="https://img-blog.csdnimg.cn/20191111175120678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="914"></p>

<p>真的很nice，确实是一波骚操作。</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Centos7安装elasticSearch6</title><link>http://www.cnblogs.com/heian99/archive/2019/10/31/11972236.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 31 Oct 2019 05:07:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/31/11972236.html</guid><description><![CDATA[
                                            <p style="text-indent:33px;">&nbsp;</p>

<h1 id="%C2%A0%20%C2%A0%20Elasticsearch6.0"><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong>Elasticsearch6.0</h1>

<h2 id="1%E3%80%81Elasticsearch%EF%BC%9A">1、Elasticsearch：</h2>

<p style="margin-left:0cm;">Elasticsearch是一个基于<a href="https://lucene.apache.org/core/" rel="nofollow"><span style="color:#4183c4;">Apache Lucene(TM)</span></a>的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p>

<p style="margin-left:0cm;"><strong>特点：</strong></p>

<ol><li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>
	<li>分布式的实时分析<span style="color:#ff0000;">搜索引擎</span><span style="color:#ff0000;">--</span><span style="color:#ff0000;">做不规则查询</span></li>
	<li>可以扩展到上百台服务器，处理PB级<span style="color:#ff0000;">结构化或非结构化</span>数据</li>
</ol><p style="margin-left:0cm;">Elasticsearch也使用<span style="color:#ff0000;">Java</span>开发并使用<span style="color:#ff0000;">Lucene</span>作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<span style="color:#ff0000;">RESTful API</span>来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>

<p style="margin-left:0cm;">ES能做什么？</p>

<p style="margin-left:0cm;">全文检索（全部字段）、模糊查询（搜索）、数据分析（提供分析语法，例如聚合）</p>

<h2 id="2%E3%80%81Elasticsearch%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" style="margin-left:0cm;">2、Elasticsearch使用案例</h2>

<p style="margin-left:0cm;">（1）2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”</p>

<p style="margin-left:0cm;">（2）维基百科：启动以elasticsearch为基础的核心搜索架构SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”</p>

<p style="margin-left:0cm;">（3）百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据</p>

<p style="margin-left:0cm;">（4）新浪使用ES 分析处理32亿条实时日志</p>

<p style="margin-left:0cm;">（5）阿里使用ES 构建挖财自己的日志采集和分析体系</p>

<h2 id="3%E3%80%81%E5%90%8C%E7%B1%BB%E4%BA%A7%E5%93%81" style="margin-left:0cm;">3、同类产品</h2>

<p style="margin-left:0cm;">Solr、ElasticSearch、Hermes（腾讯）（实时检索分析）</p>

<ol><li>Solr、ES</li>
</ol><p style="margin-left:0cm;">1.&nbsp;源自搜索引擎，侧重<span style="color:#ff0000;">搜索与全文检索</span>。</p>

<p style="margin-left:0cm;">2.&nbsp;数据规模从几百万到千万不等，数据量过亿的集群特别少。</p>

<p style="margin-left:0cm;">有可能存在个别系统数据量过亿，但这并不是普遍现象（就像Oracle的表里的数据规模有可能超过Hive里一样，但需要小型机）。</p>

<ol><li>Hermes</li>
</ol><p style="margin-left:0cm;">1.&nbsp;一个基于大索引技术的海量数据实时检索分析平台。侧<span style="color:#ff0000;">重数据分析</span>。</p>

<p style="margin-left:0cm;">2.&nbsp;数据规模从几亿到万亿不等。最小的表也是千万级别。</p>

<p style="margin-left:0cm;">在&nbsp;腾讯17&nbsp;台TS5机器，就可以处理每天450亿的数据(每条数据1kb左右)，数据可以保存一个月之久。</p>

<ol><li>Solr、ES区别</li>
</ol><p style="margin-left:0cm;">全文检索、搜索、分析。基于lucene</p>

<ol><li>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</li>
	<li>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</li>
	<li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</li>
	<li>Solr 在<span style="color:#ff0000;">传统</span>的搜索应用中表现好于 Elasticsearch，但在处理<span style="color:#ff0000;">实时</span>搜索应用时效率明显低于 Elasticsearch-----附近的人</li>
</ol><p style="margin-left:0cm;"><span style="color:#ff0000;">Lucene</span><span style="color:#ff0000;">是一个</span><a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81/114160" rel="nofollow"><span style="color:#ff0000;">开放源代码</span></a><span style="color:#ff0000;">的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分</span><a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/11046544" rel="nofollow"><span style="color:#ff0000;">文本分析</span></a><span style="color:#ff0000;">引擎</span></p>

<p style="margin-left:0cm;"><span style="color:#ff0000;">搜索引擎产品简介</span></p>

<h2 id="1%20%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">1 搜索引擎</h2>

<p>elasticSearch6（和elasticSearch5的区别在于，root用户权限、一个库能否建立多个表）</p>

<p><span style="color:#f33b45;">&nbsp;软件链接：https://www.lanzous.com/i73b6pc</span></p>

<h2 id="2%20%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">2 搜索引擎</h2>

<p><img alt="" class="has" height="63" src="https://img-blog.csdnimg.cn/20191031131720954.png" width="603"></p>

<p>文本搜索(以空间换时间算法)</p>

<p>于同类产品相比(solr、hermes),和solr一样都是基于lucene(apache)，默认以集群方式工作</p>

<p>&nbsp;</p>

<p>搜索引擎(以百度和goole为例)的工作原理是什么？</p>

<p>a 爬虫</p>

<p>b 分析</p>

<p>c 查询</p>

<p>&nbsp;</p>

<h2 id="3%20elasticSearch(%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E)%E7%9A%84%E7%AE%97%E6%B3%95">3 elasticSearch(搜索引擎)的算法</h2>

<p>倒排索引(在内容上建立索引，用内容去匹配索引)</p>

<p>Btree（balance tree b-tree）</p>

<p>B+tree</p>

<p><img alt="" class="has" height="327" src="https://img-blog.csdnimg.cn/20191031131745628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="445"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<h2 id="%E2%80%8B" style="margin-left:0cm;"><img alt="" class="has" height="183" src="https://img-blog.csdnimg.cn/20191031131755825.png" width="489"></h2>

<h2 style="margin-left:0cm;">&nbsp;</h2>

<h2 id="4%E3%80%81Elasticsearch%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B" style="margin-left:0cm;">4、Elasticsearch安装教程</h2>

<h3 id="1%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" style="margin-left:0cm;">1、准备工作</h3>

<p style="margin-left:0cm;">安装Centos7、建议内存2G以上、安装java1.8环境</p>

<h3 id="2%E3%80%81%E8%AE%BE%E7%BD%AEIP%E5%9C%B0%E5%9D%80%EF%BC%88%E8%A6%81%E6%9C%89%E5%9B%BA%E5%AE%9A%E7%9A%84IP%EF%BC%89" style="margin-left:0cm;">2、设置IP地址（要有固定的IP）</h3>

<p style="margin-left:0cm;"><img alt="" class="has" height="349" src="https://img-blog.csdnimg.cn/2019103113141044.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="939"></p>

<h3 id="3%E3%80%81Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85" style="margin-left:0cm;">3、Java环境安装</h3>

<ol><li>解压安装包</li>
</ol><pre class="has"><code class="language-bash">[root@localhost jdk1.8]# tar -zxvf jdk-8u171-linux-x64.tar.gz</code></pre>

<p style="margin-left:0cm;">2、在文件最后添加</p>

<pre class="has"><code class="language-bash">export JAVA_HOME=/opt/es/jdk1.8.0_152
export JRE_HOME=$JAVA_HOME/jre
export CLASSPATH=.:$JAVA_HOME/LIB:$JRE_HOME/LIB:$CLASSPATH
export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="240" src="https://img-blog.csdnimg.cn/20191031131609666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1083"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">3、查看java安装成功</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="138" src="https://img-blog.csdnimg.cn/20191031131643951.png" width="583"></p>

<h3 id="4%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" style="margin-left:0cm;">4、配置文件</h3>

<p><strong>elasticSearch.yml（集群配置文件）、jvm.Opitons(jvm配置文件)</strong></p>

<p>&nbsp;</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="125" src="https://img-blog.csdnimg.cn/20191031131858380.png" width="665"></p>

<h3 id="5%E3%80%81%20%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%20%EF%BC%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%92%8C%E8%A7%A3%E5%8E%8B">5、 创建目录 ，上传文件和解压</h3>

<p>创建</p>

<pre class="has"><code>mkdir -p /opt/es</code></pre>

<p>&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<p>上传</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="88" src="https://img-blog.csdnimg.cn/20191031132009311.png" width="636"></p>

<p>解压</p>

<pre class="has"><code class="language-bash">tar -zxvf elasticsearch-6.3.1.tar.gz </code></pre>

<h3 id="6%E3%80%81%20%E9%85%8D%E7%BD%AE">6、 配置</h3>

<p style="margin-left:0cm;">&nbsp;</p>

<p>es使用最大线程数、最大内存数、<span style="color:#f33b45;">访问的最大文件数</span></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="182" src="https://img-blog.csdnimg.cn/20191031132100145.png" width="625"></p>

<h3 id="%E9%9C%80%E8%A6%81%E6%94%B9%E6%88%90%E5%85%B6%E4%BB%96%E9%9D%9E%E7%94%A8%E6%88%B7%E5%90%AF%E5%8A%A8">需要改成其他非用户启动</h3>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="331" src="https://img-blog.csdnimg.cn/20191031132129272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="959"></p>

<p>创建新用户</p>

<pre class="has"><code>[root@wei bin]# adduser es</code></pre>

<p style="margin-left:0cm;">&nbsp;</p>

<p>切换es用户下（成功）</p>

<pre class="has"><code>[root@wei bin]# su es
[es@wei bin]$ </code></pre>

<h3 id="7%E3%80%81%E5%90%AF%E5%8A%A8">7、启动</h3>

<p style="margin-left:0cm;">&nbsp;</p>

<p>Es的权限问题：</p>

<p>首先用root用户解压</p>

<p>然后用root用户授权</p>

<p><strong>整个文件夹全部授权（R：表示循环授权）</strong></p>

<pre class="has"><code>[root@wei es]# chmod 777 -R elasticsearch-6.3.1</code></pre>

<p><strong>启动后配置</strong></p>

<p><strong>elasticSearch.yml、jvm.Opitons</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p><strong>es使用的jvm的内存大小</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="438" src="https://img-blog.csdnimg.cn/20191031132345612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="661"></p>

<p><strong>elasticSearch.yml中配置es的host地址(配成本机地址，允许访问)</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="177" src="https://img-blog.csdnimg.cn/201910311323576.png" width="645"></p>

<p><strong>配置完毕启动es(必须切换到非root用户下)</strong></p>

<p><img alt="" class="has" height="98" src="https://img-blog.csdnimg.cn/20191031132407722.png" width="484"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<h3 id="8%E3%80%81%E5%90%AF%E5%8A%A8%E5%90%8E%E4%BC%9A%E6%8A%A5%E9%94%99(linux%E7%9A%84%E9%BB%98%E8%AE%A4%E7%BA%BF%E7%A8%8B%E6%95%B0%E3%80%81%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%95%B0%E3%80%81%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98%E6%95%B0%E9%83%BD%E4%B8%8D%E5%A4%9F)"><strong>8、启动后会报错(linux的默认线程数、最大文件数、最大内存数都不够)</strong></h3>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="136" src="https://img-blog.csdnimg.cn/20191031132431335.png" width="753"></p>

<h3 id="9%E3%80%81%20%E4%BF%AE%E6%94%B9linux%E7%9A%84%E9%85%8D%E7%BD%AE(%E9%85%8D%E5%90%88es%E7%9A%84%E5%90%AF%E5%8A%A8%E9%9C%80%E6%B1%82)">9、 修改linux的配置(配合es的启动需求)</h3>

<p><strong>两处修改</strong></p>

<p><strong>A修改linux的limits配置文件，设置内存线程和文件</strong></p>

<p><img alt="" class="has" height="262" src="https://img-blog.csdnimg.cn/20191031132456546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="633"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<pre class="has"><code>* hard nofile 655360
* soft nofile 131072
* hard nproc 4096
* soft nproc 2048</code></pre>

<p><strong>B修改linux的sysctl配置文件，配置系统使用内存</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="469" src="https://img-blog.csdnimg.cn/20191031132529900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="779"></p>

<pre class="has"><code>vm.max_map_count=655360
fs.file-max=655360</code></pre>

<h3>整个es的配置有四处文件需要修改</h3>

<p>&nbsp;</p>

<ul><li><strong>elasticSearch.yml es的启动host地址</strong></li>
	<li><strong>jvm.options配置es的虚拟机内存</strong></li>
	<li><strong>limits.conf配置linux的线程内存和文件</strong></li>
	<li><strong>sysctl.conf配置系统允许的软件运行内存</strong></li>
</ul><h3></h3>

<h3>&nbsp;</h3>

<h3 id="10%E3%80%81%E6%88%90%E5%8A%9F%E8%AE%BF%E9%97%AE">10、成功访问</h3>

<p><img alt="" class="has" height="567" src="https://img-blog.csdnimg.cn/20191031132604889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="940"></p>

<p>&nbsp;</p>

<h3 style="margin-left:0cm;">&nbsp;</h3>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Redsi缓存问题（穿透，击穿，雪崩）以及解决办法（分布式锁）【高并发问题】</title><link>http://www.cnblogs.com/heian99/archive/2019/10/31/11972237.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 31 Oct 2019 03:52:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/31/11972237.html</guid><description><![CDATA[
                                            <h1><strong>Redsi常见问题</strong></h1>

<p><strong>缓存在高平发和安全压力下的一些问题</strong></p>

<hr><h2><strong>缓存击穿</strong></h2>

<p>是某一个热点key在高并发访问的情况下，突然失效，导致大量的并发大金mysql数据库的情况</p>

<hr><h2><strong>缓存穿透</strong></h2>

<p>是利用redis和mysql的机制（redis缓存一旦不存在，就访问mysql），直接让过缓存访问mysql，而制造的db请求压力</p>

<p>一般在代码中防止</p>

<p><strong>解决： 为防止缓存穿透，将null或者空字符串设置给redis</strong></p>

<hr><h2><strong>缓存雪崩</strong></h2>

<p>缓存是采用了相同的过期时间，导致缓存在某一时刻同时全部失效，导致的db崩溃</p>

<p><strong>解决：设计不同的缓存失效时间</strong></p>

<hr><h2><strong>如何解决缓存击穿的问题 ？</strong></h2>

<p><strong>分布式锁</strong></p>

<p>&nbsp;</p>

<p></p>

<p></p>

<p><img alt="" class="has" height="409" src="https://img-blog.csdnimg.cn/20191031115359988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="555"></p>

<p><strong>穿透：利用不存在的key去攻击mysql数据库</strong></p>

<p><strong>雪崩：缓存中的很多key失效，导致数据库负载过重宕机</strong></p>

<p><strong>击穿：在正常的访问情况下，如果缓存失效，如果保护mysql，重启缓存的过程</strong></p>

<p></p>

<p><strong>使用redis数据库的<span style="color:#f33b45;">分布式锁</span>，解决mysql的访问压力问题</strong></p>

<p>&nbsp;</p>

<p><strong></strong></p>

<p>&nbsp;</p>

<h2>第一种分布式锁：redis自带一个分布式锁，set px nx</h2>

<p></p>

<p><img alt="" class="has" height="328" src="https://img-blog.csdnimg.cn/20191031115500254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="631"></p>

<p><img alt="" class="has" height="238" src="https://img-blog.csdnimg.cn/20191031115514354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="738"></p>

<p>用完之后需要删除，不然别人不能访问。</p>

<p></p>

<p><img alt="" class="has" height="128" src="https://img-blog.csdnimg.cn/20191031115530184.png" width="670"></p>

<p><strong>错误自旋代码（B为孤儿线程）</strong></p>

<p></p>

<p></p>

<p></p>

<p><img alt="" class="has" height="357" src="https://img-blog.csdnimg.cn/20191031115559125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="791"></p>

<p><strong>正确自旋代码</strong></p>

<p></p>

<p></p>

<p></p>

<p><img alt="" class="has" height="652" src="https://img-blog.csdnimg.cn/20191031115645341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="970"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><u><strong>问题1 如果在redis中的锁已经过期了，然后锁过期的那个请求又执行完毕，回来删锁,删除了其他线程的锁，怎么办？</strong></u></p>

<p>&nbsp;</p>

<p><u><strong>问题2 如果碰巧在查询redis锁还没删除的时候，正在网络传输时，锁过期了，怎么办？</strong></u></p>

<pre class="has"><code class="language-java">String script ="if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
jedis.eval(script, Collections.singletonList("lock"),Collections.singletonList(token));
</code></pre>

<p></p>

<p><img alt="" class="has" height="178" src="https://img-blog.csdnimg.cn/20191031115747596.png" width="659"></p>

<h2>第二种分布式锁：redisson框架，一个redis的带有juc的lock功能的客户端（既有jedis的功能，又有juc的功能）</h2>

<h2></h2>

<p><img alt="" class="has" height="260" src="https://img-blog.csdnimg.cn/20191031115806435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="735"></p>

<h3>整合</h3>

<p><strong>引入pom</strong></p>

<p></p>

<pre class="has"><code class="language-java">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.redisson&lt;/groupId&gt;
    &lt;artifactId&gt;redisson&lt;/artifactId&gt;
    &lt;version&gt;3.10.5&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

<p><strong>配置</strong></p>

<p></p>

<pre class="has"><code class="language-java">spring.redis.host=192.168.159.130
spring.redis.port=6379</code></pre>

<p><strong>配置类</strong></p>

<pre class="has"><code class="language-java">@Configuration
public class GmallRedissonConfig {
    @Value("${spring.redis.host}")
    private String host;
    @Value("${spring.redis.port}")
    private String port;
    @Bean
    public RedissonClient redissonClient(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://"+host+":"+port);
        RedissonClient redisson = Redisson.create(config);
        return redisson;
    }
}</code></pre>

<p><span style="color:#f33b45;">Redisson实现了juc的lock锁，并且可以在分布式的redis环境下使用</span></p>

<p></p>

<p><img alt="" class="has" height="145" src="https://img-blog.csdnimg.cn/20191031115927845.png" width="632"></p>

<p><img alt="" class="has" height="201" src="https://img-blog.csdnimg.cn/20191031115935544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="651"></p>

<h3>添加gmall-redisson-text</h3>

<h3></h3>

<p>把需要的依赖添加的pom上</p>

<h3><img alt="" class="has" height="352" src="https://img-blog.csdnimg.cn/20191031120001347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="645"></h3>

<p><strong>配置application.properties</strong></p>

<p>&nbsp;</p>

<p><strong></strong></p>

<p>&nbsp;</p>

<pre class="has"><code># 服务端口
server.port=8082
# 日志级别
logging.level.root=info</code></pre>

<p><strong>RedissonController</strong></p>

<p></p>

<pre class="has"><code class="language-java">package com.atguigu.gmallredisson.redissonTest;
import com.atguigu.gmall.util.RedisUtil;
import org.apache.commons.lang3.StringUtils;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import redis.clients.jedis.Jedis;
@Controller
public class RedissonController {
    @Autowired
    RedisUtil redisUtil;
    @Autowired
    RedissonClient redissonClient;
    @RequestMapping("testRedisson")
    @ResponseBody
    public String testRedisson(){
        Jedis jedis = redisUtil.getJedis();
        RLock lock = redissonClient.getLock("lock");// 声明锁
        lock.lock();//上锁
        try {
            String v = jedis.get("k");
            if (StringUtils.isBlank(v)) {
                v = "1";
            }
            System.out.println("-&gt;" + v);
            jedis.set("k", (Integer.parseInt(v) + 1) + "");
        }finally {
            jedis.close();
            lock.unlock();// 解锁
    }
        return "success";
    }
}</code></pre>

<h3>设置非单例模式启动</h3>

<p></p>

<p><img alt="" class="has" height="316" src="https://img-blog.csdnimg.cn/20191031120107992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="641"></p>

<p>点击取消单一示例</p>

<p><img alt="" class="has" height="439" src="https://img-blog.csdnimg.cn/20191031120121350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="632"></p>

<h3>启动3个示例，端口分别为8080,8081,8082</h3>

<p></p>

<p><img alt="" class="has" height="150" src="https://img-blog.csdnimg.cn/20191031120134626.png" width="638"></p>

<h3>配置nginx</h3>

<p><img alt="" class="has" height="309" src="https://img-blog.csdnimg.cn/20191031122011693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="653"></p>

<h3></h3>

<h2>&nbsp;下载安装apache测试工具(apache)</h2>

<p></p>

<h3>1 下载地址</h3>

<p><a href="https://www.apachehaus.com/cgi-bin/download.plx" rel="nofollow">https://www.apachehaus.com/cgi-bin/download.plx</a></p>

<p><img alt="" class="has" height="153" src="https://img-blog.csdnimg.cn/20191031122042471.png" width="645"></p>

<p></p>

<h3>2 安装即解压</h3>

<p><img alt="" class="has" height="55" src="https://img-blog.csdnimg.cn/20191031122109583.png" width="249"></p>

<h3>3 修改apache服务的配置文件(服务器的根目录)</h3>

<p><img alt="" class="has" height="244" src="https://img-blog.csdnimg.cn/20191031122126492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="634"></p>

<p></p>

<p>修改服务的根目录路径：</p>

<p><img alt="" class="has" height="82" src="https://img-blog.csdnimg.cn/20191031122137776.png" width="425"></p>

<h3>4 启动服务</h3>

<p>查看443端口是否被占用</p>

<pre class="has"><code>D:\ap\Apache24\bin&gt;netstat -ano | findstr "443"</code></pre>

<p><img alt="" class="has" height="357" src="https://img-blog.csdnimg.cn/20191031124243606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="612"></p>

<p>没有被占用，启动httpd.exe</p>

<pre class="has"><code>D:\ap\Apache24\bin&gt;httpd.exe</code></pre>

<h3>5 压测命令(另起cmd输入命令)</h3>

<p>D:\apache24\bin&gt;ab -c 200 -n 1000 http:nginx负载均衡/压力方法</p>

<p>测试：</p>

<pre class="has"><code>D:\ap\Apache24\bin&gt;ab -c 100 -n 10000 http://www.der-matech.com.cn/</code></pre>

<p></p>

<p><img alt="" class="has" height="145" src="https://img-blog.csdnimg.cn/20191031124434597.png" width="612"></p>

<pre class="has"><code class="language-java">public String testRedisson(){
    Jedis jedis = redisUtil.getJedis();
    RLock lock = redissonClient.getLock("lock");// 声明锁

    lock.lock();//上锁
    try {
        String v = jedis.get("k");
        if (StringUtils.isBlank(v)) {
            v = "1";
        }
        System.out.println("-&gt;" + v);
        jedis.set("k", (Integer.parseInt(v) + 1) + "");
    }finally {
        jedis.close();
        lock.unlock();// 解锁
    }
    return "success";
}</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h3></h3>

<p></p>
                                    ]]></description></item><item><title>Redis缓存实战教程</title><link>http://www.cnblogs.com/heian99/archive/2019/10/28/11972238.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 28 Oct 2019 01:54:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/28/11972238.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="Redis%E7%BC%93%E5%AD%98-toc" style="margin-left:0px;"><a href="#Redis%E7%BC%93%E5%AD%98" rel="nofollow">Redis缓存</a></p>

<p id="%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98Redis%E8%A7%A3%E5%86%B3%E9%A6%96%E9%A1%B5%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98Redis%E8%A7%A3%E5%86%B3%E9%A6%96%E9%A1%B5%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98" rel="nofollow">使用缓存Redis解决首页并发问题</a></p>

<p id="1%E3%80%81%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1" rel="nofollow">1、缓存使用的简单设计</a></p>

<p id="2%E3%80%81Redis%E7%9A%84%E6%95%B4%E5%90%88%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#2%E3%80%81Redis%E7%9A%84%E6%95%B4%E5%90%88%E6%AD%A5%E9%AA%A4" rel="nofollow">2、Redis的整合步骤</a></p>

<p id="A%20%E5%B0%86Redis%E6%95%B4%E5%90%88%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%88Redis%2BSpring%EF%BC%89-toc" style="margin-left:80px;"><a href="#A%20%E5%B0%86Redis%E6%95%B4%E5%90%88%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%88Redis%2BSpring%EF%BC%89" rel="nofollow">A 将Redis整合到项目中（Redis+Spring）</a></p>

<p id="B%20%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AD%96%E8%B6%8A-toc" style="margin-left:40px;"><a href="#B%20%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AD%96%E8%B6%8A" rel="nofollow">B 设计一个数据存储策越</a></p>

<p id="3%E3%80%81Redis%E7%9A%84%E6%95%B4%E5%90%88%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#3%E3%80%81Redis%E7%9A%84%E6%95%B4%E5%90%88%E8%BF%87%E7%A8%8B" rel="nofollow">3、Redis的整合过程</a></p>

<p style="margin-left:40px;">&nbsp;</p>

<p id="1%E3%80%81%E5%BC%95%E5%85%A5pom%E4%BE%9D%E8%B5%96%E4%BF%A1%E6%81%AF%EF%BC%88%E5%B0%86%E6%9C%AC%E5%B7%A5%E7%A8%8B%E6%89%80%E6%9C%89%E7%9A%84Redis%E7%BB%9F%E4%B8%80%E6%94%BE%E5%85%A5service-util%E9%87%8C%EF%BC%89-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%BC%95%E5%85%A5pom%E4%BE%9D%E8%B5%96%E4%BF%A1%E6%81%AF%EF%BC%88%E5%B0%86%E6%9C%AC%E5%B7%A5%E7%A8%8B%E6%89%80%E6%9C%89%E7%9A%84Redis%E7%BB%9F%E4%B8%80%E6%94%BE%E5%85%A5service-util%E9%87%8C%EF%BC%89" rel="nofollow">1、引入pom依赖信息（将本工程所有的Redis统一放入service-util里）</a></p>

<p id="2%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AARedis%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E7%94%A8%E6%9D%A5%E5%B0%86Redis%E7%9A%84%E6%B1%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0spring%E5%AE%B9%E5%99%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AARedis%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E7%94%A8%E6%9D%A5%E5%B0%86Redis%E7%9A%84%E6%B1%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0spring%E5%AE%B9%E5%99%A8%EF%BC%89" rel="nofollow">2、写一个Redis的工具类（用来将Redis的池初始化到spring容器）</a></p>

<p id="3%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AAspring%E6%95%B4%E5%90%88Redis%E7%9A%84%E9%85%8D%E7%BD%AE%E7%B1%BB-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AAspring%E6%95%B4%E5%90%88Redis%E7%9A%84%E9%85%8D%E7%BD%AE%E7%B1%BB" rel="nofollow">3、写一个spring整合Redis的配置类</a></p>

<p id="4%E3%80%81%E6%AF%8F%E9%9A%94%E5%BC%95%E7%94%A8%E5%B7%A5%E7%A8%8B%E5%BC%95%E5%85%A5service-util%E5%90%8E%EF%BC%8C%E5%8D%95%E7%8B%AC%E9%85%8D%E7%BD%AE%E5%8F%AA%E8%83%BD%E7%9A%84redis%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E6%AF%8F%E9%9A%94%E5%BC%95%E7%94%A8%E5%B7%A5%E7%A8%8B%E5%BC%95%E5%85%A5service-util%E5%90%8E%EF%BC%8C%E5%8D%95%E7%8B%AC%E9%85%8D%E7%BD%AE%E5%8F%AA%E8%83%BD%E7%9A%84redis%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">4、每隔引用工程引入service-util后，单独配置只能的redis的配置文件</a></p>

<p style="margin-left:80px;">&nbsp;</p>

<p id="%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81" rel="nofollow">代码</a></p>

<p id="%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C" rel="nofollow">查询结果</a></p>

<p id="%E6%9F%A5%E7%9C%8BRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E7%9C%8BRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">查看Redis数据库的数据</a></p>

<p style="margin-left:40px;">&nbsp;</p>

<hr id="hr-toc"><h1 id="Redis%E7%BC%93%E5%AD%98">Redis缓存</h1>

<p>重点要讲的是另外一个层面：尽量避免直接查询数据库。</p>

<p>解决办法就是：<span style="color:#f33b45;">缓存</span></p>

<p>缓存可以理解是数据库的一道保护伞，任何请求只要能在缓存中命中，都不会直接访问数据库。而缓存的处理性能是数据库10-100倍。</p>

<h2 id="%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98Redis%E8%A7%A3%E5%86%B3%E9%A6%96%E9%A1%B5%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98">使用缓存Redis解决首页并发问题</h2>

<ol><li>用户第一次请求到redis</li>
	<li>如果redis没有数据，redis会请求mysql</li>
	<li>mysql会把数据返回给用户，同时会传到redis上</li>
	<li>第二次用户访问时，redis有数据，就不需要访问mysql。节省时间，降低消耗</li>
</ol><p>&nbsp;</p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="262" src="https://img-blog.csdnimg.cn/2019102809542253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="630"></p>

<h2 id="1%E3%80%81%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1">1、缓存使用的简单设计</h2>

<p><img alt="" class="has" height="265" src="https://img-blog.csdnimg.cn/20191028095442596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="592"></p>

<ol><li><span style="color:#f33b45;">连接缓存</span></li>
	<li><span style="color:#f33b45;">查询缓存</span></li>
	<li><span style="color:#f33b45;">如果缓存没有，查询mysql</span></li>
	<li><span style="color:#f33b45;">mysql查询结果存入redis</span></li>
</ol><p>&nbsp;</p>

<h2 id="2%E3%80%81Redis%E7%9A%84%E6%95%B4%E5%90%88%E6%AD%A5%E9%AA%A4">2、Redis的整合步骤</h2>

<p>&nbsp;</p>

<h3 id="A%20%E5%B0%86Redis%E6%95%B4%E5%90%88%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%88Redis%2BSpring%EF%BC%89">A 将Redis整合到项目中（Redis+Spring）</h3>

<p>&nbsp;</p>

<p><img alt="" class="has" height="276" src="https://img-blog.csdnimg.cn/20191028095521514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="640"></p>

<h2 id="B%20%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AD%96%E8%B6%8A">B 设计一个数据存储策越</h2>

<p>&nbsp;</p>

<p>企业中的存储策越（核心是：如何设计k）</p>

<p>数据对象名：数据对象id：对象属性</p>

<p>User:123:password 用户ID为123的密码</p>

<p>User:123:userename 用户ID为123的名字</p>

<p>&nbsp;</p>

<h2 id="3%E3%80%81Redis%E7%9A%84%E6%95%B4%E5%90%88%E8%BF%87%E7%A8%8B">3、Redis的整合过程</h2>

<h2>&nbsp;</h2>

<h3 id="1%E3%80%81%E5%BC%95%E5%85%A5pom%E4%BE%9D%E8%B5%96%E4%BF%A1%E6%81%AF%EF%BC%88%E5%B0%86%E6%9C%AC%E5%B7%A5%E7%A8%8B%E6%89%80%E6%9C%89%E7%9A%84Redis%E7%BB%9F%E4%B8%80%E6%94%BE%E5%85%A5service-util%E9%87%8C%EF%BC%89">1、引入pom依赖信息（将本工程所有的Redis统一放入service-util里）</h3>

<p>&nbsp;</p>

<pre class="has"><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

<p>创建两个类RedisConfig和RedisUtil</p>

<p>RedisConfig负责在spring容器启动时自动注入，而RedisUtil就是被注入的工具类以供其他模块调用。</p>

<h3 id="2%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AARedis%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E7%94%A8%E6%9D%A5%E5%B0%86Redis%E7%9A%84%E6%B1%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0spring%E5%AE%B9%E5%99%A8%EF%BC%89">2、写一个Redis的工具类（用来将Redis的池初始化到spring容器）</h3>

<p><strong>RedisUtil</strong></p>

<pre class="has"><code class="language-java">public class RedisUtil {

    private  JedisPool jedisPool;

    public void initPool(String host,int port ,int database){
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(200);
        poolConfig.setMaxIdle(30);
        poolConfig.setBlockWhenExhausted(true);
        poolConfig.setMaxWaitMillis(10*1000);
        poolConfig.setTestOnBorrow(true);
        jedisPool=new JedisPool(poolConfig,host,port,20*1000);
    }

    public Jedis getJedis(){
        Jedis jedis = jedisPool.getResource();
        return jedis;
    }

}</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h3 id="3%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AAspring%E6%95%B4%E5%90%88Redis%E7%9A%84%E9%85%8D%E7%BD%AE%E7%B1%BB">3、写一个spring整合Redis的配置类</h3>

<p>将Redis的链接池创建到spring的容器中</p>

<p><strong>RedisConfig</strong></p>

<p>&nbsp;</p>

<pre class="has"><code class="language-java">@Configuration
public class RedisConfig {

    //读取配置文件中的redis的ip地址
    @Value("${spring.redis.host:disabled}")
    private String host;

    @Value("${spring.redis.port:0}")
    private int port;

    @Value("${spring.redis.database:0}")
    private int database;

    @Bean
    public RedisUtil getRedisUtil(){
        if(host.equals("disabled")){
            return null;
        }
        RedisUtil redisUtil=new RedisUtil();
        redisUtil.initPool(host,port,database);
        return redisUtil;
    }

}</code></pre>

<h3 id="4%E3%80%81%E6%AF%8F%E9%9A%94%E5%BC%95%E7%94%A8%E5%B7%A5%E7%A8%8B%E5%BC%95%E5%85%A5service-util%E5%90%8E%EF%BC%8C%E5%8D%95%E7%8B%AC%E9%85%8D%E7%BD%AE%E5%8F%AA%E8%83%BD%E7%9A%84redis%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">4、每隔引用工程引入service-util后，单独配置只能的redis的配置文件</h3>

<h3>&nbsp;</h3>

<p>Service-util的配置文件没有作用</p>

<p>同时，任何模块想要调用redis都必须在application.properties配置，否则不会进行注入</p>

<pre class="has"><code class="language-java">#Redis配置
//读取配置文件中的redis的ip地址
spring.redis.host=192.168.1.111
#Redis端口号
spring.redis.port=6379
#数据库
spring.redis.database=0</code></pre>

<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>

<p>这是从数据库调用mysql，查询数据</p>

<pre class="has"><code class="language-java"> /**
     * 从数据库调用
     *
     * @param skuId
     * @return
     */
    public PmsSkuInfo getSkuByIdFromDb(String skuId) {
        //sku的商品对象
        PmsSkuInfo pmsSkuInfo = new PmsSkuInfo();
        pmsSkuInfo.setId(skuId);
        PmsSkuInfo skuInfo = pmsSkuInfoMapper.selectOne(pmsSkuInfo);

        try {
            //sku的图片集合
            PmsSkuImage pmsSkuImage = new PmsSkuImage();
            List&lt;PmsSkuImage&gt; pmsSkuImages = pmsSkuImageMapper.select(pmsSkuImage);
            skuInfo.setSkuImageList(pmsSkuImages);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return skuInfo;

    }</code></pre>

<p>这个是Redis的代码，判断redis中是否有数据，</p>

<p>如果没有，就调用上面的代码，查询mysql数据库。返回结果，在写入redis数据库中。</p>

<p>如果有，直接调用redis数据库中的数据。</p>

<pre class="has"><code class="language-java">/**
     * 商品详细图
     * 主要是item前端的东西，调用此处的服务，方便
     * 使用Redis缓存，解决高并发
     *
     * @param skuId
     * @return
     */
    @Override
    public PmsSkuInfo getSkuById(String skuId) {

        PmsSkuInfo pmsSkuInfo = new PmsSkuInfo();

        //链接缓存
        Jedis jedis = redisUtil.getJedis();

        //查询缓存
        String skuKey = "sky:" + skuId + ":info";
        String skuJson = jedis.get("skuKey");
        //可以吧json的字符串转换成jav的对象类
        if (StringUtils.isNotBlank(skuJson)) {// if (skuJson!=null&amp;&amp;!skuJson.equals(""))
            pmsSkuInfo = JSON.parseObject(skuJson, PmsSkuInfo.class);
        } else {
            //如果缓存没有，查询mysql
            pmsSkuInfo = getSkuByIdFromDb(skuId);

            if (pmsSkuInfo != null) {
                //mysql查询结果存入redis
                jedis.set("sku" + skuId + ":info", JSON.toJSONString(pmsSkuInfo));
            }
        }


        jedis.close();

        return pmsSkuInfo;
    }</code></pre>

<h2 id="%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C">查询结果</h2>

<p><img alt="" class="has" height="941" src="https://img-blog.csdnimg.cn/20191028100509713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<h2 id="%E6%9F%A5%E7%9C%8BRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE">查看Redis数据库的数据</h2>

<p>&nbsp;</p>

<p><img alt="" class="has" height="800" src="https://img-blog.csdnimg.cn/20191028100711216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2>&nbsp;</h2>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Redis安装教程</title><link>http://www.cnblogs.com/heian99/archive/2019/10/26/11972239.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 26 Oct 2019 09:26:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/26/11972239.html</guid><description><![CDATA[
                                            <h1 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0">&nbsp; &nbsp; &nbsp;</h1>

<p id="main-toc"><strong>目录</strong></p>

<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc" style="margin-left:0px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0" rel="nofollow">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</a></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20Redis%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20Redis%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B" rel="nofollow">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Redis安装教程</a></p>

<p id="redis%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#redis%E4%BB%8B%E7%BB%8D" rel="nofollow">redis介绍</a></p>

<p id="redis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%83-toc" style="margin-left:40px;"><a href="#redis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%83" rel="nofollow">redis的应用场景 </a></p>

<p id="yum%E5%AE%89%E8%A3%85redis-toc" style="margin-left:40px;"><a href="#yum%E5%AE%89%E8%A3%85redis" rel="nofollow">yum安装redis</a></p>

<p id="%E5%AE%89%E8%A3%85-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85" rel="nofollow">安装</a></p>

<p id="%E5%AE%89%E8%A3%85%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1" rel="nofollow">安装完毕后，使用下面的命令启动redis服务</a></p>

<p id="%E8%BF%9B%E5%85%A5redis%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E8%BF%9B%E5%85%A5redis%E6%9C%8D%E5%8A%A1" rel="nofollow">进入redis服务</a></p>

<p id="%E4%BF%AE%E6%94%B9redis%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%86%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E4%BF%AE%E6%94%B9redis%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%86%E7%A0%81" rel="nofollow">修改redis默认端口和密码</a></p>

<p id="%E6%9F%A5%E7%9C%8BRedis%E8%BF%9B%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%E6%9F%A5%E7%9C%8BRedis%E8%BF%9B%E7%A8%8B" rel="nofollow">查看Redis进程</a></p>

<p id="%E9%87%8D%E5%90%AFredis%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E9%87%8D%E5%90%AFredis%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">重启redis服务器</a></p>

<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%99%BB%E5%BD%95Redis%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%99%BB%E5%BD%95Redis%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 登录Redis服务器</a></p>

<p id="%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E8%AF%AD%E6%B3%95" rel="nofollow">语法</a></p>

<p style="margin-left:80px;"><a href="#%E8%AF%AD%E6%B3%95" rel="nofollow">语法</a></p>

<hr id="hr-toc"><h1>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</h1>

<h1>&nbsp;</h1>

<h1 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20Redis%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Redis安装教程</h1>

<h2 id="redis%E4%BB%8B%E7%BB%8D">redis介绍</h2>

<p><strong>redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止redis支持的键值数据类型如下字符串、列表（lists）、集合（sets）、有序集合（sorts sets）、哈希表（hashs）</strong></p>

<h2 id="redis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%83">redis的应用场景 </h2>

<ul><li>缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）</li>
	<li>分布式集群架构中的session分离。</li>
	<li>聊天室的在线好友列表。</li>
	<li>任务队列。（秒杀、抢购、12306等等） </li>
	<li>应用排行榜。 </li>
	<li>网站访问统计。 </li>
	<li>数据过期处理（可以精确到毫秒）</li>
</ul><h2 id="yum%E5%AE%89%E8%A3%85redis">yum安装redis</h2>

<h3 id="%E5%AE%89%E8%A3%85">安装</h3>

<pre class="has"><code>#检查是否有redis yum 源
yum install redis
#下载fedora的epel仓库
yum install epel-release
#安装redis数据库
yum install redis</code></pre>

<h3 id="%E5%AE%89%E8%A3%85%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1">安装完毕后，使用下面的命令启动redis服务</h3>

<pre class="has"><code class="language-bash"># 启动redis
service redis start
# 停止redis
service redis stop
# 查看redis运行状态
service redis status
# 查看redis进程
ps -ef | grep redis</code></pre>

<h3 id="%E8%BF%9B%E5%85%A5redis%E6%9C%8D%E5%8A%A1">进入redis服务</h3>

<pre class="has"><code># 进入本机redis
redis-cli
# 列出所有key
keys *</code></pre>

<h3 id="%E4%BF%AE%E6%94%B9redis%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%86%E7%A0%81">修改redis默认端口和密码</h3>

<p>1、打开配置文件</p>

<pre class="has"><code class="language-bash">vi /etc/redis.conf</code></pre>

<p>2、修改默认端口，查找 port 6379 修改为相应端口即可</p>

<p>3、修改默认密码，查找 requirepass foobared 将 foobared 修改为你的密码</p>

<p>4、使用配置文件启动 redis</p>

<p>&nbsp;</p>

<pre class="has"><code># 查找Redis配置（注意不是安装目录下的redis.conf）
# 打开第五步设计的Redis配置，默认为：/etc/redis/6379.conf
# 修改配置文件如下几项，其它保持不变
daemonize yes
#bind 127.0.0.1 （注释，不限制IP）
protected-mode no
将 requirepass foobared前的“#”去掉，密码改为你想要设置的密码（我设置为123456）

# 重启服务
[root@172 redis-3.2.11]# service redis_6379 restart
Stopping ...
Redis stopped
Starting Redis server...

# 开放6379端口
firewall-cmd --zone=public --add-port=6379/tcp --permanent
# 重启防火墙，否则开放端口不起作用
firewall-cmd --reload</code></pre>

<h3 id="%E6%9F%A5%E7%9C%8BRedis%E8%BF%9B%E7%A8%8B">查看Redis进程</h3>

<pre class="has"><code>ps -ef|grep redis</code></pre>

<h3 id="%E9%87%8D%E5%90%AFredis%E6%9C%8D%E5%8A%A1%E5%99%A8">重启redis服务器</h3>

<pre class="has"><code>systemctl restart redis</code></pre>

<p>&nbsp;</p>

<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%99%BB%E5%BD%95Redis%E6%9C%8D%E5%8A%A1%E5%99%A8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 登录Redis服务器</h2>

<p><strong>Redis 命令用于在 redis 服务上执行操作。</strong></p>

<p><strong>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</strong></p>

<h3 id="%E8%AF%AD%E6%B3%95">语法</h3>

<p>Redis 客户端的基本语法为：</p>

<pre class="has"><code>$ redis-cli</code></pre>

<p><strong>本地登录</strong></p>

<pre class="has"><code>redis-cli</code></pre>

<p><img alt="" class="has" height="183" src="https://img-blog.csdnimg.cn/20191026172949550.png" width="512"></p>

<p>&nbsp;</p>

<p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是&nbsp;redis-cli&nbsp;命令。</p>

<h3>语法</h3>

<pre class="has"><code>$ redis-cli -h host -p port -a password</code></pre>

<p><strong>远程登录</strong></p>

<pre class="has"><code>redis-cli -h 192.168.116.129 -p 6379
192.168.116.129:6379&gt; keys *
1) "hello"
</code></pre>

<p><img alt="" class="has" height="104" src="https://img-blog.csdnimg.cn/20191026173208728.png" width="481"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p></p>
                                    ]]></description></item><item><title>CentOS 7上安装Docker</title><link>http://www.cnblogs.com/heian99/archive/2019/10/26/11972240.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 26 Oct 2019 01:37:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/26/11972240.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:40px;">&nbsp;</p>

<p id="%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4" rel="nofollow">安装步骤</a></p>

<p id="1%E3%80%81%E6%9F%A5%E7%9C%8BDocker%E7%9A%84%E7%89%88%E6%9C%AC-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%9F%A5%E7%9C%8BDocker%E7%9A%84%E7%89%88%E6%9C%AC" rel="nofollow">1、查看Docker的版本</a></p>

<p id="%E2%80%8B-toc" style="margin-left:40px;"><a href="#%E2%80%8B" rel="nofollow">​</a></p>

<p id="2%E3%80%81%E5%AE%89%E8%A3%85%20Docker-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%AE%89%E8%A3%85%20Docker" rel="nofollow">2、安装 Docker</a></p>

<p id="3%E3%80%81%E5%90%AF%E5%8A%A8Docker-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%90%AF%E5%8A%A8Docker" rel="nofollow">3、启动Docker</a></p>

<p id="4%E3%80%81%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E5%90%AF%E5%90%AF%E5%8A%A8-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E5%90%AF%E5%90%AF%E5%8A%A8" rel="nofollow">4、设置为开启启动</a></p>

<p id="5%E3%80%81%E6%9F%A5%E7%9C%8BDocker%E5%AE%89%E8%A3%85%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%9F%A5%E7%9C%8BDocker%E5%AE%89%E8%A3%85%E4%BF%A1%E6%81%AF" rel="nofollow">5、查看Docker安装信息</a></p>

<p id="6%E3%80%81%E4%BD%BF%E7%94%A8Docker%20%E4%B8%AD%E5%9B%BD%E5%8A%A0%E9%80%9F%E5%99%A8-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E4%BD%BF%E7%94%A8Docker%20%E4%B8%AD%E5%9B%BD%E5%8A%A0%E9%80%9F%E5%99%A8" rel="nofollow">6、使用Docker 中国加速器</a></p>

<hr id="hr-toc"><h2 id="%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装步骤</h2>

<p>安装操作系统，最小化安装（mini）</p>

<p>禁用Selinux, 修改/etc/selinux/config 文件，将SELINUX=enforcing改为SELINUX=disabled，重启机器即可</p>

<h2 id="1%E3%80%81%E6%9F%A5%E7%9C%8BDocker%E7%9A%84%E7%89%88%E6%9C%AC">1、查看Docker的版本</h2>

<pre class="has"><code>[root@wei ~]# yum list docker
</code></pre>

<h2 id="%E2%80%8B"><img alt="" class="has" height="165" src="https://img-blog.csdnimg.cn/20191026094216908.png" width="1024"></h2>

<h2 id="2%E3%80%81%E5%AE%89%E8%A3%85%20Docker">2、安装 Docker</h2>

<pre class="has"><code>[root@wei ~]# yum install -y docker
</code></pre>

<p><img alt="" class="has" height="313" src="https://img-blog.csdnimg.cn/20191026094413199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1052"></p>

<h2 id="3%E3%80%81%E5%90%AF%E5%8A%A8Docker">3、启动Docker</h2>

<pre class="has"><code class="language-bash">[root@wei ~]# systemctl start docker
</code></pre>

<h2 id="4%E3%80%81%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E5%90%AF%E5%90%AF%E5%8A%A8">4、设置为开启启动</h2>

<pre class="has"><code class="language-bash">[root@wei ~]# systemctl enable docker
</code></pre>

<h2 id="5%E3%80%81%E6%9F%A5%E7%9C%8BDocker%E5%AE%89%E8%A3%85%E4%BF%A1%E6%81%AF">5、查看Docker安装信息</h2>

<pre class="has"><code class="language-bash">[root@wei ~]# docker version
</code></pre>

<p><img alt="" class="has" height="392" src="https://img-blog.csdnimg.cn/20191026094834789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1033"></p>

<h2 id="6%E3%80%81%E4%BD%BF%E7%94%A8Docker%20%E4%B8%AD%E5%9B%BD%E5%8A%A0%E9%80%9F%E5%99%A8">6、使用Docker 中国加速器</h2>

<p>由于网络原因，我们在pull Image 的时候，从Docker Hub上下载会很慢。</p>

<p>修改文件</p>

<pre class="has"><code>vi  /etc/docker/daemon.json
#添加后：
{
    "registry-mirrors": ["https://registry.docker-cn.com"],
    "live-restore": true
}</code></pre>

<p>重起docker服务</p>

<pre class="has"><code>systemctl restart docker</code></pre>
                                    ]]></description></item><item><title>Docker简介</title><link>http://www.cnblogs.com/heian99/archive/2019/10/26/11972242.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 26 Oct 2019 01:21:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/26/11972242.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:40px;">&nbsp;</p>

<p id="Docker%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#Docker%E4%BB%8B%E7%BB%8D" rel="nofollow">Docker介绍</a></p>

<p id="Docker%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;"><a href="#Docker%E4%BC%98%E7%82%B9" rel="nofollow">Docker优点</a></p>

<p id="%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%BA%E7%82%B9" rel="nofollow">虚拟机缺点</a></p>

<p id="%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA" rel="nofollow">容器和虚拟机</a></p>

<p id="Docker%E4%BA%A7%E7%94%9F%E7%9A%84%E7%9B%AE%E7%9A%84%E5%B0%B1%E6%98%AF%E8%A7%A3%E5%86%B3%E4%BB%A5%E4%B8%8B%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#Docker%E4%BA%A7%E7%94%9F%E7%9A%84%E7%9B%AE%E7%9A%84%E5%B0%B1%E6%98%AF%E8%A7%A3%E5%86%B3%E4%BB%A5%E4%B8%8B%E9%97%AE%E9%A2%98" rel="nofollow">Docker产生的目的就是解决以下问题</a></p>

<p id="Docker%E7%9A%84%E7%94%A8%E9%80%94-toc" style="margin-left:40px;"><a href="#Docker%E7%9A%84%E7%94%A8%E9%80%94" rel="nofollow">Docker的用途</a></p>

<p id="Docker%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#Docker%E9%95%9C%E5%83%8F" rel="nofollow">Docker镜像</a></p>

<p id="Docker%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#Docker%E5%AE%B9%E5%99%A8" rel="nofollow">Docker容器</a></p>

<p id="%E4%BB%93%E5%BA%93-toc" style="margin-left:40px;"><a href="#%E4%BB%93%E5%BA%93" rel="nofollow">仓库</a></p>

<hr id="hr-toc"><h2 id="Docker%E4%BB%8B%E7%BB%8D">Docker介绍</h2>

<p>Docker 是一个<strong><span style="color:#f33b45;">开源</span></strong>的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个<strong><span style="color:#f33b45;">可移植的镜像</span></strong>中，然后发布到任何流行的 <strong><span style="color:#f33b45;">Linux</span></strong>或<span style="color:#f33b45;"><strong>Windows</strong></span> 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>

<h2 id="Docker%E4%BC%98%E7%82%B9">Docker优点</h2>

<blockquote>
<ul><li><strong><span style="color:#f33b45;">灵活</span></strong>：即使是复杂的应用程序也可封装。</li>
	<li><span style="color:#f33b45;"><strong>轻量级</strong></span>：容器利用并共享主机内核。</li>
	<li><span style="color:#f33b45;"><strong>便携式</strong></span>：您可以在本地构建，部署到云上并在任何地方运行。</li>
	<li><span style="color:#f33b45;"><strong>可扩展性</strong></span>：您可以增加和自动分发容器副本。</li>
	<li><span style="color:#f33b45;"><strong>可堆叠</strong></span>：您可以垂直堆叠服务并及时并及时堆叠服务。</li>
</ul></blockquote>

<h2 id="%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%BA%E7%82%B9">虚拟机缺点</h2>

<blockquote>
<ul><li><strong><span style="color:#f33b45;">资源占用多</span>：</strong>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有1M，虚拟机依然需要几百MB的内容才能运行。</li>
	<li><strong><span style="color:#f33b45;">冗余步骤多</span>：</strong>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</li>
	<li><strong><span style="color:#f33b45;">启动慢</span>：</strong>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用陈故乡才能真正运行。</li>
</ul></blockquote>

<h2 id="%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA">容器和虚拟机</h2>

<blockquote>
<p>一个容器中运行原生Linux和共享主机与其它容器的内核，它<span style="color:#f33b45;"><strong>运行一个独立的进程</strong></span>，<span style="color:#f33b45;"><strong>不占用任何其它可执行文件的内存</strong></span>，使其轻量化。</p>

<p>相比之下，虚拟机(VM)运行一个完整的“客户”操作系统，通过虚拟机管理程序虚拟访问主机资源。一般来说，虚拟机提供的环境比大多数应用程序需要的资源多</p>
</blockquote>

<p><img alt="" class="has" height="591" src="https://img-blog.csdnimg.cn/20191026091838731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="Docker%E4%BA%A7%E7%94%9F%E7%9A%84%E7%9B%AE%E7%9A%84%E5%B0%B1%E6%98%AF%E8%A7%A3%E5%86%B3%E4%BB%A5%E4%B8%8B%E9%97%AE%E9%A2%98">Docker产生的目的就是解决以下问题</h2>

<blockquote>
<ol><li><span style="color:#f33b45;"><strong>环境管理复杂</strong></span>：从各种OS到各个中间件再到各种App,一款产品能够成功发布，作为开发者需要关心的东西太多，且难于管理，这个问题在软件兴业中普遍存在并需要直接面对。Docker可以简化部署多种应用实例工作，比如Web应用、后台应用、数据库应用、大数据应用比如Hadoop集群、消息队列等等都可以打包成一个image部署。</li>
	<li><span style="color:#f33b45;"><strong>云时代的到来</strong></span>：AWS的成功，引到开发者将应用转移到云上，解决来硬件管理的问题，然而软件配置和管理香瓜的问题依然存在。Docker的出现正好能帮助软件开发着开阔思路，尝试新的软件管理的方法解决这个问题。</li>
	<li>虚拟化手段的变化：云时代采用标配硬件来降低成本，采用虚拟化手段来满足用户按需分配的资源需求以及保证可用性和隔离性。然而无论是KVM还是Xen，在Docker看来都是在浪费资源，又难于管理，更加轻量级大LXC更加灵活和快速：</li>
	<li><span style="color:#f33b45;"><strong>LXC的便携性</strong></span>：LXC在Linux 2.6的Kernel里就已经存在了，但是其设计之初并非为云计算考虑，缺少标准化的描述手段和容器的可便携性，决定其构建出的环境难于分发和标准化管理(相对于KVM之类的image和sanpshot的概念)。Docker就在这个问题上作出了实质性的创新方法。</li>
</ol></blockquote>

<h2 id="Docker%E7%9A%84%E7%94%A8%E9%80%94">Docker的用途</h2>

<p>Docker的主要用途，目前又三大类：</p>

<blockquote>
<ul><li><strong><span style="color:#f33b45;">提供了一次性的环境</span>：</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li>
	<li><strong><span style="color:#f33b45;">提供弹性的云服务</span>：</strong>因为Docker容器可以随开随关，很适合动态扩容和所容。</li>
	<li><strong><span style="color:#f33b45;">组建微服务架构</span>：</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li>
</ul></blockquote>

<h2 id="Docker%E9%95%9C%E5%83%8F">Docker镜像</h2>

<blockquote>
<pre>操作系统分为<strong><span style="color:#f33b45;">内核</span></strong>和<span style="color:#f33b45;"><strong>用户空间</strong></span>，对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像(Image),就相当于是一个root文件系统。
Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</pre>
</blockquote>

<h2 id="Docker%E5%AE%B9%E5%99%A8">Docker容器</h2>

<blockquote>
<p>镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>
容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立宿主的系统下操作一样。这种特性使容器封装的应用比直接在宿主运行更加安全。<br>
前面讲过镜像使用的是分层储存，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，可以称这个味容器运行时读写而准备的存储层为容器存储层。<br>
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。<br>
按照Docker最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(volume)、或者绑定宿主目录，在这些位置的读写会跳过存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。<br>
数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
</blockquote>

<h2 id="%E4%BB%93%E5%BA%93">仓库</h2>

<blockquote>
<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。<br>
一个Docker Registry中可以包含多个仓库(Repository);每个仓库可以包含多个标签(tag)；每个标签对应一个镜像。<br>
通常，一个仓库会包含一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件那个版本的镜像。如果不给出标签，将以laest作为默认标签。<br>
以ubuntu镜像为例，ubuntu是仓库的名字，其包含有不同的版本标签，如，14.04,16.04。我们可以通过ubuntu:14.04或者ubuntu:16.04来具体指定所需要哪个版本的镜像。如果忽略了标签，比如ubuntu,那将视为ubuntu:latest。<br>
仓库名经常以两段式路径形式出现，比如jwilder/nginx-proxy,前者意味着Docker Registry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体Docker Registry的软件或服务。</p>
</blockquote>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p></p>
                                    ]]></description></item><item><title>SpringBoot整合Fastdfs，实现图片上传（IDEA）</title><link>http://www.cnblogs.com/heian99/archive/2019/10/10/11972243.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 10 Oct 2019 07:10:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/10/11972243.html</guid><description><![CDATA[
                                            <h2><strong>我们部署Fastdfs，就是为了实现文件的上传。</strong></h2>

<h2><strong>现在使用idea整合Fastdfs，实现图片上传</strong></h2>

<p><img alt="" class="has" height="331" src="https://img-blog.csdnimg.cn/20191010151000258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="594"></p>

<h1><strong>部署环境：<a href="https://blog.csdn.net/heian_99/article/details/102477556" rel="nofollow">Centos7部署分布式文件存储(Fastdfs)</a></strong></h1>

<h2 style="margin-left:0cm;">利用Java客户端调用FastDFS</h2>

<p style="margin-left:0cm;">服务器安装完毕后，咱们通过Java调用fastdfs</p>

<p style="margin-left:0cm;"><strong>加载Maven</strong><strong>依赖</strong></p>

<p style="margin-left:0cm;">fastdfs 没有在中心仓库中提供获取的依赖坐标。</p>

<p style="margin-left:0cm;">只能自己通过源码方式编译，打好jar 包，安装到本地仓库。</p>

<p style="margin-left:0cm;">官方仓库地址：</p>

<p style="margin-left:0cm;"><a href="https://github.com/happyfish100/fastdfs-client-java" rel="nofollow"><span style="color:#075db3;">https://github.com/happyfish100/fastdfs-client-java</span></a></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="157" src="https://img-blog.csdnimg.cn/20191010151121745.png" width="554"></p>

<p style="margin-left:0cm;">直接用idea 直接把这个源码作为模块导入工程</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="231" src="https://img-blog.csdnimg.cn/20191010151144279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="583"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">别的不用改，只把pom.xml中的版本改成1.27。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="312" src="https://img-blog.csdnimg.cn/20191010151328841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="985"></p>

<p style="margin-left:0cm;">然后右边 执行install 就好了</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="287" src="https://img-blog.csdnimg.cn/20191010151340328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="477"></p>

<p style="margin-left:0cm;">安装好了 ，别的模块就可以直接使用这个坐标了。</p>

<pre class="has"><code class="language-java">    &lt;dependency&gt;
            &lt;groupId&gt;org.csource&lt;/groupId&gt;
            &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;
            &lt;version&gt;1.27-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>

<p style="margin-left:0cm;">而这个fastdfs-client-java模块可以从idea 中删除。</p>

<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">然后可以进行一下上传的测试</span></strong></h3>

<p><img alt="" class="has" height="710" src="https://img-blog.csdnimg.cn/20191010151556854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<pre class="has"><code class="language-java">package com.atguigu.gmall.manage;

import org.csource.common.MyException;
import org.csource.fastdfs.ClientGlobal;
import org.csource.fastdfs.StorageClient;
import org.csource.fastdfs.TrackerClient;
import org.csource.fastdfs.TrackerServer;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.io.IOException;

@RunWith(SpringRunner.class)
@SpringBootTest
public class GmallManageWebApplicationTests {


    @Test
    public void contextLoads() throws IOException, MyException {

        //配置fdfs的全局连接地址
        String tracker = GmallManageWebApplicationTests.class.getResource("/tracker.conf").getPath();//获取配置文件路径

        ClientGlobal.init(tracker);

        TrackerClient trackerClient = new TrackerClient();
        //获得一个trackerserver的实例
        TrackerServer trackerServer = trackerClient.getConnection();
        //通过tracker获得storage客户端
        StorageClient storageClient = new StorageClient(trackerServer, null);

        String[] uploadInfos = storageClient.upload_file("g:/9.gif", "gif", null);

        String url="http://192.168.116.129";

        for (String uploadInfo : uploadInfos){
            url+="/"+uploadInfo;

        }
        System.out.println(url);
    }
}
</code></pre>

<h3 style="margin-left:0cm;"><strong>加入tracker.conf文件</strong></h3>

<p style="margin-left:0cm;"><img alt="" class="has" height="139" src="https://img-blog.csdnimg.cn/20191010151700924.png" width="357"></p>

<pre class="has"><code class="language-java">tracker_server=192.168.67.162:22122

# 连接超时时间，针对socket套接字函数connect，默认为30秒
connect_timeout=30000

# 网络通讯超时时间，默认是60秒
network_timeout=60000
</code></pre>

<p style="margin-left:0cm;">打印结果</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="630" src="https://img-blog.csdnimg.cn/20191010151830915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">这个打印结果实际上就是我们访问的路径，加上服务器地址我们可以拼接成一个字符串</p>

<p style="margin-left:0cm;"><a href="http://192.168.116.129/group1/M00/00/00/wKh0gV2dHmGAFpUzAA7-f54U48M105.gif" rel="nofollow">http://192.168.116.129/group1/M00/00/00/wKh0gV2dHmGAFpUzAA7-f54U48M105.gif</a></p>

<p style="margin-left:0cm;">直接放到浏览器去访问</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="793" src="https://img-blog.csdnimg.cn/20191010151956264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1160"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>
                                    ]]></description></item><item><title>Centos7部署分布式文件存储(Fastdfs)</title><link>http://www.cnblogs.com/heian99/archive/2019/10/10/11972244.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 10 Oct 2019 03:18:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/10/11972244.html</guid><description><![CDATA[
                                            <p><img alt="" class="has" height="450" src="https://img-blog.csdnimg.cn/20191010122208663.gif" width="800"></p>

<p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="FastDFS%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#FastDFS%E4%BB%8B%E7%BB%8D" rel="nofollow">FastDFS介绍</a></p>

<p id="%E6%A5%BC%E4%B8%BB%E7%9B%AE%E6%A0%87%EF%BC%9A%E5%89%8D%E5%8F%AFH5%E6%92%A9%E5%A6%B9%EF%BC%8C%E5%90%8E%E5%8F%AFLinux%E6%90%9E%E8%BF%90%E7%BB%B4-toc" style="margin-left:0px;"><a href="#%E6%A5%BC%E4%B8%BB%E7%9B%AE%E6%A0%87%EF%BC%9A%E5%89%8D%E5%8F%AFH5%E6%92%A9%E5%A6%B9%EF%BC%8C%E5%90%8E%E5%8F%AFLinux%E6%90%9E%E8%BF%90%E7%BB%B4" rel="nofollow">楼主目标：前可H5撩妹，后可Linux搞运维</a></p>

<p id="%E7%8E%AF%E5%A2%83%EF%BC%9ACentos7-toc" style="margin-left:40px;"><a href="#%E7%8E%AF%E5%A2%83%EF%BC%9ACentos7" rel="nofollow">环境：Centos7</a></p>

<p id="%E8%BD%AF%E4%BB%B6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%BD%AF%E4%BB%B6%EF%BC%9A" rel="nofollow">软件：</a></p>

<p id="%E8%BD%AF%E4%BB%B6%E9%93%BE%E6%8E%A5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%BD%AF%E4%BB%B6%E9%93%BE%E6%8E%A5%EF%BC%9A" rel="nofollow">软件链接：</a></p>

<p id="%E5%AE%89%E8%A3%85%E5%89%8D%E6%89%80%E6%9C%89%E5%87%86%E5%A4%87%EF%BC%8C%E4%B8%8A%E4%BC%A0%E8%BD%AF%E4%BB%B6%E5%88%B0Centos7%E4%B8%8A%E7%9A%84%2Fopt%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%8B-toc" style="margin-left:40px;"><a href="#%E5%AE%89%E8%A3%85%E5%89%8D%E6%89%80%E6%9C%89%E5%87%86%E5%A4%87%EF%BC%8C%E4%B8%8A%E4%BC%A0%E8%BD%AF%E4%BB%B6%E5%88%B0Centos7%E4%B8%8A%E7%9A%84%2Fopt%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%8B" rel="nofollow">安装前所有准备，上传软件到Centos7上的/opt的目录下</a></p>

<p id="%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E8%BD%AF%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%BA%93(%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87)-toc" style="margin-left:40px;"><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E8%BD%AF%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%BA%93(%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87)" rel="nofollow">安装依赖软件和类库(安装前的准备)</a></p>

<p id="1%C2%A0%20fdfs%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93-toc" style="margin-left:40px;"><a href="#1%C2%A0%20fdfs%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93" rel="nofollow">1&nbsp; fdfs的依赖库</a></p>

<p id="A%20%E8%A7%A3%E5%8E%8BLibfastcommon-toc" style="margin-left:80px;"><a href="#A%20%E8%A7%A3%E5%8E%8BLibfastcommon" rel="nofollow">A 解压Libfastcommon</a></p>

<p id="B%20%E8%BF%9B%E5%85%A5Libfastcommon%E7%9B%AE%E5%BD%95%E4%B8%8B-toc" style="margin-left:80px;"><a href="#B%20%E8%BF%9B%E5%85%A5Libfastcommon%E7%9B%AE%E5%BD%95%E4%B8%8B" rel="nofollow">B 进入Libfastcommon目录下</a></p>

<p id="C%20make%E7%BC%96%E8%AF%91-toc" style="margin-left:80px;"><a href="#C%20make%E7%BC%96%E8%AF%91" rel="nofollow">C make编译</a></p>

<p id="D%20make%20install%20%E5%AE%89%E8%A3%85-toc" style="margin-left:80px;"><a href="#D%20make%20install%20%E5%AE%89%E8%A3%85" rel="nofollow">D make install 安装</a></p>

<p id="E%20libfastcommon.so%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%B0%2Fusr%2Flib%2F-toc" style="margin-left:80px;"><a href="#E%20libfastcommon.so%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%B0%2Fusr%2Flib%2F" rel="nofollow">E libfastcommon.so复制文件到/usr/lib/</a></p>

<p id="2%20fastdfs%E8%BD%AF%E4%BB%B6(tracker%E3%80%81storage)-toc" style="margin-left:40px;"><a href="#2%20fastdfs%E8%BD%AF%E4%BB%B6(tracker%E3%80%81storage)" rel="nofollow">2 fastdfs软件(tracker、storage)</a></p>

<p id="A%20%E6%96%B0%E5%BB%BA%E7%9B%AE%E5%BD%95mkdir%20%2Fopt%2Ffastdfs-toc" style="margin-left:80px;"><a href="#A%20%E6%96%B0%E5%BB%BA%E7%9B%AE%E5%BD%95mkdir%20%2Fopt%2Ffastdfs" rel="nofollow">A 新建目录mkdir /opt/fastdfs</a></p>

<p id="B%20%E8%A7%A3%E5%8E%8BFastDFS_v5.05.tar.gz-toc" style="margin-left:80px;"><a href="#B%20%E8%A7%A3%E5%8E%8BFastDFS_v5.05.tar.gz" rel="nofollow">B 解压FastDFS_v5.05.tar.gz</a></p>

<p id="C%20%E8%BF%9B%E5%85%A5%E8%A7%A3%E5%8E%8B%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#C%20%E8%BF%9B%E5%85%A5%E8%A7%A3%E5%8E%8B%E7%9B%AE%E5%BD%95" rel="nofollow">C 进入解压目录</a></p>

<p id="D%20make%E7%BC%96%E8%AF%91-toc" style="margin-left:80px;"><a href="#D%20make%E7%BC%96%E8%AF%91" rel="nofollow">D make编译</a></p>

<p id="E%20make%20install%20%E5%AE%89%E8%A3%85-toc" style="margin-left:80px;"><a href="#E%20make%20install%20%E5%AE%89%E8%A3%85" rel="nofollow">E make install 安装</a></p>

<p id="F%20%E8%BF%9B%E5%85%A5conf%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E5%B0%86%E6%96%87%E4%BB%B6%E9%83%BD%E6%8B%B7%E8%B4%9D%E5%88%B0%2Fetc%2Ffdfs%E4%B8%8Bcp%C2%A0%20*%C2%A0%20%2Fetc%2Ffdfs%2F%EF%BC%88%E5%AE%89%E8%A3%85%E6%97%B6%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%89-toc" style="margin-left:80px;"><a href="#F%20%E8%BF%9B%E5%85%A5conf%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E5%B0%86%E6%96%87%E4%BB%B6%E9%83%BD%E6%8B%B7%E8%B4%9D%E5%88%B0%2Fetc%2Ffdfs%E4%B8%8Bcp%C2%A0%20*%C2%A0%20%2Fetc%2Ffdfs%2F%EF%BC%88%E5%AE%89%E8%A3%85%E6%97%B6%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%89" rel="nofollow">F 进入conf配置目录将文件都拷贝到/etc/fdfs下cp&nbsp; *&nbsp; /etc/fdfs/（安装时自动生成）</a></p>

<p id="G%20%E8%BF%9B%E5%85%A5%2Fetc%2Ffdfs%2F%EF%BC%8C%E9%85%8D%E7%BD%AEtracker.conf-toc" style="margin-left:80px;"><a href="#G%20%E8%BF%9B%E5%85%A5%2Fetc%2Ffdfs%2F%EF%BC%8C%E9%85%8D%E7%BD%AEtracker.conf" rel="nofollow">G 进入/etc/fdfs/，配置tracker.conf</a></p>

<p id="H%20storage%E7%9A%84%E9%85%8D%E7%BD%AE(storage%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%89%E8%A3%85tracker%E6%97%B6%E5%B7%B2%E7%BB%8F%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85)-toc" style="margin-left:80px;"><a href="#H%20storage%E7%9A%84%E9%85%8D%E7%BD%AE(storage%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%89%E8%A3%85tracker%E6%97%B6%E5%B7%B2%E7%BB%8F%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85)" rel="nofollow">H storage的配置(storage不需要安装，因为安装tracker时已经同时安装)</a></p>

<p id="3%20%E9%85%8D%E7%BD%AEtracker%E5%92%8Cstorage%E7%9A%84%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-toc" style="margin-left:40px;"><a href="#3%20%E9%85%8D%E7%BD%AEtracker%E5%92%8Cstorage%E7%9A%84%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" rel="nofollow">3 配置tracker和storage的启动服务</a></p>

<p id="%E9%85%8D%E7%BD%AEtracker%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E9%85%8D%E7%BD%AEtracker%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" rel="nofollow">配置tracker启动服务</a></p>

<p id="%E9%85%8D%E7%BD%AEstorage%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E9%85%8D%E7%BD%AEstorage%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" rel="nofollow">配置storage启动服务</a></p>

<p id="%E5%B0%86%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%8A%A0%E5%85%A5linux%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E5%B0%86%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%8A%A0%E5%85%A5linux%E6%9C%8D%E5%8A%A1" rel="nofollow">将启动脚本加入linux服务</a></p>

<p id="%E2%80%8B-toc" style="margin-left:80px;"><a href="#%E2%80%8B" rel="nofollow">​</a></p>

<p id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" rel="nofollow">启动服务</a></p>

<p id="%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%8A%B6%E6%80%81-toc" style="margin-left:80px;"><a href="#%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%8A%B6%E6%80%81" rel="nofollow">检查服务启动状态</a></p>

<p style="margin-left:40px;"><a href="#%E2%80%8B" rel="nofollow">​</a></p>

<p id="4%20%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%BC%A0-toc" style="margin-left:40px;"><a href="#4%20%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%BC%A0" rel="nofollow">4 测试上传</a></p>

<p id="%E4%BF%AE%E6%94%B9%2Fetc%2Ffdfs%2Fclient.conf-toc" style="margin-left:80px;"><a href="#%E4%BF%AE%E6%94%B9%2Fetc%2Ffdfs%2Fclient.conf" rel="nofollow">修改/etc/fdfs/client.conf</a></p>

<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0FastDFS%E6%95%B4%E5%90%88nginx-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0FastDFS%E6%95%B4%E5%90%88nginx" rel="nofollow">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;FastDFS整合nginx</a></p>

<p id="%C2%A05%C2%A0%E5%AE%89%E8%A3%85nginx%E6%95%B4%E5%90%88%E6%8F%92%E4%BB%B6fastdfs-nginx-module-toc" style="margin-left:40px;"><a href="#%C2%A05%C2%A0%E5%AE%89%E8%A3%85nginx%E6%95%B4%E5%90%88%E6%8F%92%E4%BB%B6fastdfs-nginx-module" rel="nofollow">&nbsp;5&nbsp;安装nginx整合插件fastdfs-nginx-module</a></p>

<p id="A%20%E8%A7%A3%E5%8E%8BFastDFS-nginx-module%E6%8F%92%E4%BB%B6-toc" style="margin-left:80px;"><a href="#A%20%E8%A7%A3%E5%8E%8BFastDFS-nginx-module%E6%8F%92%E4%BB%B6" rel="nofollow">A 解压FastDFS-nginx-module插件</a></p>

<p id="B%20%E4%BF%AE%E6%94%B9%E6%8F%92%E4%BB%B6%E8%AF%BB%E5%8F%96fdfs%E7%9A%84%E7%9B%AE%E5%BD%95%EF%BC%88%E6%8F%92%E4%BB%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89-toc" style="margin-left:80px;"><a href="#B%20%E4%BF%AE%E6%94%B9%E6%8F%92%E4%BB%B6%E8%AF%BB%E5%8F%96fdfs%E7%9A%84%E7%9B%AE%E5%BD%95%EF%BC%88%E6%8F%92%E4%BB%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89" rel="nofollow">B 修改插件读取fdfs的目录（插件自己的配置文件）</a></p>

<p id="C%20%E5%B0%86FastDFS-nginx-module%E6%8F%92%E4%BB%B6%E6%95%B4%E5%90%88fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E5%88%B0fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E4%B8%8B(%E6%95%B4%E5%90%88fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)-toc" style="margin-left:80px;"><a href="#C%20%E5%B0%86FastDFS-nginx-module%E6%8F%92%E4%BB%B6%E6%95%B4%E5%90%88fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E5%88%B0fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E4%B8%8B(%E6%95%B4%E5%90%88fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)" rel="nofollow">C 将FastDFS-nginx-module插件整合fdfs的配置文件拷贝到fdfs的配置目录下(整合fdfs的配置文件)</a></p>

<p id="D%20%E4%BF%AE%E6%94%B9%2Fetc%2Ffdfs%2Fmod_fastdfs.conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#D%20%E4%BF%AE%E6%94%B9%2Fetc%2Ffdfs%2Fmod_fastdfs.conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">D 修改/etc/fdfs/mod_fastdfs.conf配置文件</a></p>

<p id="6%20%E5%AE%89%E8%A3%85nginx-toc" style="margin-left:40px;"><a href="#6%20%E5%AE%89%E8%A3%85nginx" rel="nofollow">6 安装nginx</a></p>

<p id="%E5%88%9B%E5%BB%BAnginx%2Fclient%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BAnginx%2Fclient%E7%9B%AE%E5%BD%95" rel="nofollow">创建nginx/client目录</a></p>

<p id="%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%EF%BC%9A" rel="nofollow">安装环境：</a></p>

<p id="%E8%A7%A3%E5%8E%8Bnginx-toc" style="margin-left:80px;"><a href="#%E8%A7%A3%E5%8E%8Bnginx" rel="nofollow">解压nginx</a></p>

<p id="%E8%BF%9B%E5%85%A5nginx%E7%9B%AE%E5%BD%95%20%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83-toc" style="margin-left:80px;"><a href="#%E8%BF%9B%E5%85%A5nginx%E7%9B%AE%E5%BD%95%20%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83" rel="nofollow">进入nginx目录 配置安装环境</a></p>

<p id="%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F-toc" style="margin-left:80px;"><a href="#%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F" rel="nofollow">配置成功</a></p>

<p id="%E7%BC%96%E8%AF%91-toc" style="margin-left:80px;"><a href="#%E7%BC%96%E8%AF%91" rel="nofollow">编译</a></p>

<p id="%E5%AE%89%E8%A3%85-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85" rel="nofollow">安装</a></p>

<p id="%E7%BC%96%E8%BE%91nginx.conf-toc" style="margin-left:80px;"><a href="#%E7%BC%96%E8%BE%91nginx.conf" rel="nofollow">编辑nginx.conf</a></p>

<p id="%E5%90%AF%E5%8A%A8nginx-toc" style="margin-left:80px;"><a href="#%E5%90%AF%E5%8A%A8nginx" rel="nofollow">启动nginx</a></p>

<p id="%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8-toc" style="margin-left:80px;"><a href="#%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8" rel="nofollow">设置开机启动</a></p>

<p id="%E9%9C%80%E8%A6%81%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99-toc" style="margin-left:80px;"><a href="#%E9%9C%80%E8%A6%81%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99" rel="nofollow">需要关闭防火墙</a></p>

<p id="%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%E6%B5%8B%E8%AF%95" rel="nofollow">测试</a></p>

<p id="%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E9%93%BE%E6%8E%A5" rel="nofollow">浏览器打开链接</a></p>

<p id="%E5%AE%8C%E7%BE%8E%E6%88%90%E5%8A%9F%EF%BC%8COK%E4%BA%86-toc" style="margin-left:40px;"><a href="#%E5%AE%8C%E7%BE%8E%E6%88%90%E5%8A%9F%EF%BC%8COK%E4%BA%86" rel="nofollow">完美成功，OK了</a></p>

<p style="margin-left:40px;"><a href="#%E6%A5%BC%E4%B8%BB%E7%9B%AE%E6%A0%87%EF%BC%9A%E5%89%8D%E5%8F%AFH5%E6%92%A9%E5%A6%B9%EF%BC%8C%E5%90%8E%E5%8F%AFLinux%E6%90%9E%E8%BF%90%E7%BB%B4" rel="nofollow">楼主目标：前可H5撩妹，后可Linux搞运维</a></p>

<hr id="hr-toc"><h1 id="FastDFS%E4%BB%8B%E7%BB%8D">FastDFS介绍</h1>

<p>FastDFS是一个开源的轻量级<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1250388" rel="nofollow">分布式文件系统</a>，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等</p>

<h1 id="%E6%A5%BC%E4%B8%BB%E7%9B%AE%E6%A0%87%EF%BC%9A%E5%89%8D%E5%8F%AFH5%E6%92%A9%E5%A6%B9%EF%BC%8C%E5%90%8E%E5%8F%AFLinux%E6%90%9E%E8%BF%90%E7%BB%B4"><span style="color:#f33b45;">楼主目标：前可H5撩妹，后可Linux搞运维</span></h1>

<p><span style="color:#f33b45;"><img alt="" class="has" height="485" src="https://img-blog.csdnimg.cn/20191010122004230.gif" width="500"></span></p>

<p>OK，废话不多说开始部署</p>

<p><img alt="" class="has" height="304" src="https://img-blog.csdnimg.cn/2019101012205732.gif" width="540"></p>

<h2 id="%E7%8E%AF%E5%A2%83%EF%BC%9ACentos7">环境：Centos7</h2>

<h2 id="%E8%BD%AF%E4%BB%B6%EF%BC%9A">软件：</h2>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FastDFS_v5.05.tar.gz</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;fastdfs-nginx-module_v1.16.tar.gz</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;libfastcommonV1.0.7.tar.gz</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nginx-1.12.2.tar.gz</p>

<h2 id="%E8%BD%AF%E4%BB%B6%E9%93%BE%E6%8E%A5%EF%BC%9A">软件链接：</h2>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="https://www.lanzous.com/b0c1xw7hi" rel="nofollow">https://www.lanzous.com/b0c1xw7hi</a></p>

<h2 id="%E5%AE%89%E8%A3%85%E5%89%8D%E6%89%80%E6%9C%89%E5%87%86%E5%A4%87%EF%BC%8C%E4%B8%8A%E4%BC%A0%E8%BD%AF%E4%BB%B6%E5%88%B0Centos7%E4%B8%8A%E7%9A%84%2Fopt%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%8B">安装前所有准备，上传软件到Centos7上的/opt的目录下</h2>

<p><img alt="" class="has" height="172" src="https://img-blog.csdnimg.cn/20191010112815711.png" width="794"></p>

<h2 id="%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E8%BD%AF%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%BA%93(%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87)">安装依赖软件和类库(安装前的准备)</h2>

<pre class="has"><code>yum install gcc-c++ -y</code></pre>

<pre class="has"><code>yum -y install zlib zlib-devel pcre pcre-devel gcc gcc-c++ openssl openssl-devel libevent libevent-devel perl unzip net-tools wget</code></pre>

<pre class="has"><code>yum install perl*</code></pre>

<p>&nbsp;</p>

<h2 id="1%C2%A0%20fdfs%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93" style="margin-left:0cm;">1&nbsp; fdfs的依赖库</h2>

<p style="margin-left:0cm;"><strong>Libfastcommon安装过程</strong></p>

<h3 id="A%20%E8%A7%A3%E5%8E%8BLibfastcommon" style="margin-left:0cm;"><strong>A 解压Libfastcommon</strong></h3>

<pre class="has"><code>tar -zxvf libfastcommon
</code></pre>

<h3 id="B%20%E8%BF%9B%E5%85%A5Libfastcommon%E7%9B%AE%E5%BD%95%E4%B8%8B">B 进入<strong>Libfastcommon目录下</strong></h3>

<pre class="has"><code class="language-cpp">cd Libfastcommon</code></pre>

<h3 id="C%20make%E7%BC%96%E8%AF%91">C make编译</h3>

<pre class="has"><code>make</code></pre>

<h3 id="D%20make%20install%20%E5%AE%89%E8%A3%85">D make install 安装</h3>

<pre class="has"><code>make install</code></pre>

<h3 id="E%20libfastcommon.so%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%B0%2Fusr%2Flib%2F">E libfastcommon.so复制文件到/usr/lib/</h3>

<pre class="has"><code>cp /usr/lib64/libfastcommon.so /usr/lib/</code></pre>

<p><img alt="" class="has" height="295" src="https://img-blog.csdnimg.cn/20191010113311486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="737"></p>

<h2 id="2%20fastdfs%E8%BD%AF%E4%BB%B6(tracker%E3%80%81storage)" style="margin-left:0cm;">2 fastdfs软件(tracker、storage)</h2>

<p style="margin-left:0cm;"><strong>配置tracker</strong></p>

<p style="margin-left:0cm;"><strong>配置storage</strong></p>

<p style="margin-left:0cm;"><strong>(依赖于：Gcc、libevent、perl)</strong></p>

<h3 id="A%20%E6%96%B0%E5%BB%BA%E7%9B%AE%E5%BD%95mkdir%20%2Fopt%2Ffastdfs" style="margin-left:0cm;">A 新建目录mkdir /opt/fastdfs</h3>

<pre class="has"><code>mkdir /opt/fastdfs</code></pre>

<h3 id="B%20%E8%A7%A3%E5%8E%8BFastDFS_v5.05.tar.gz" style="margin-left:0cm;">B 解压FastDFS_v5.05.tar.gz</h3>

<pre class="has"><code>tar -zxvf FastDFS_v5.05.tar.gz
</code></pre>

<h3 id="C%20%E8%BF%9B%E5%85%A5%E8%A7%A3%E5%8E%8B%E7%9B%AE%E5%BD%95" style="margin-left:0cm;">C 进入解压目录</h3>

<pre class="has"><code>cd &nbsp;FastDFS</code></pre>

<h3 id="D%20make%E7%BC%96%E8%AF%91">D make编译</h3>

<pre class="has"><code> ./make.sh</code></pre>

<h3 id="E%20make%20install%20%E5%AE%89%E8%A3%85" style="margin-left:0cm;">E make install 安装</h3>

<pre class="has"><code>./make.sh install</code></pre>

<h3 id="F%20%E8%BF%9B%E5%85%A5conf%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E5%B0%86%E6%96%87%E4%BB%B6%E9%83%BD%E6%8B%B7%E8%B4%9D%E5%88%B0%2Fetc%2Ffdfs%E4%B8%8Bcp%C2%A0%20*%C2%A0%20%2Fetc%2Ffdfs%2F%EF%BC%88%E5%AE%89%E8%A3%85%E6%97%B6%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%89" style="margin-left:0cm;">F 进入conf配置目录将文件都拷贝到/etc/fdfs下cp&nbsp; *&nbsp; /etc/fdfs/（安装时自动生成）</h3>

<pre class="has"><code>cd conf
cp&nbsp; *&nbsp; /etc/fdfs/</code></pre>

<h3 id="G%20%E8%BF%9B%E5%85%A5%2Fetc%2Ffdfs%2F%EF%BC%8C%E9%85%8D%E7%BD%AEtracker.conf" style="margin-left:0cm;">G 进入/etc/fdfs/，配置tracker.conf</h3>

<p style="margin-left:0cm;">vim /etc/fdfs/tracker.conf ，设置软件数据和日志目录</p>

<p><img alt="" class="has" height="67" src="https://img-blog.csdnimg.cn/20191010113936545.png" width="472"></p>

<h3 id="H%20storage%E7%9A%84%E9%85%8D%E7%BD%AE(storage%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%89%E8%A3%85tracker%E6%97%B6%E5%B7%B2%E7%BB%8F%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85)" style="margin-left:0cm;">H storage的配置(storage不需要安装，因为安装tracker时已经同时安装)</h3>

<p style="margin-left:0cm;">vim /etc/fdfs/storage.conf</p>

<p style="margin-left:0cm;">软件目录</p>

<p><img alt="" class="has" height="55" src="https://img-blog.csdnimg.cn/20191010114000411.png" width="408"></p>

<p style="margin-left:0cm;">Storage存储文件的目录（<span style="color:#ff0000;">新建</span><span style="color:#ff0000;">mkdir /opt/fastdfs/fdfs_storage</span>）</p>

<pre class="has"><code>mkdir /opt/fastdfs/fdfs_storage</code></pre>

<p><img alt="" class="has" height="35" src="https://img-blog.csdnimg.cn/20191010114026869.png" width="315"></p>

<p style="margin-left:0cm;">Storage的trackerip</p>

<p><img alt="" class="has" height="48" src="https://img-blog.csdnimg.cn/20191010114046968.png" width="300"></p>

<h2 id="3%20%E9%85%8D%E7%BD%AEtracker%E5%92%8Cstorage%E7%9A%84%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" style="margin-left:0cm;">3 配置tracker和storage的启动服务</h2>

<h3 id="%E9%85%8D%E7%BD%AEtracker%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" style="margin-left:0cm;">配置tracker启动服务</h3>

<p style="margin-left:0cm;"><strong>进入/etc/init.d启动脚本目录，默认fastdfs已经生成</strong></p>

<p><strong><img alt="" class="has" height="64" src="https://img-blog.csdnimg.cn/2019101011411693.png" width="625"></strong></p>

<p style="margin-left:0cm;"><strong>Vi fdfs_trackerd脚本文件</strong></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="416" src="https://img-blog.csdnimg.cn/20191010114133681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="404"></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="186" src="https://img-blog.csdnimg.cn/20191010114142245.png" width="356"></p>

<p style="margin-left:0cm;"><strong>因为启动脚本还在安装目录下，所以我们新建/usr/local/fdfs目录，并且将启动脚本cp到该目录</strong></p>

<pre class="has"><code>mkdir /usr/local/fdfs</code></pre>

<p style="margin-left:0cm;"><strong>进入安装目录/opt/FastDFs</strong></p>

<pre class="has"><code>cd /opt/FastDFs
cp restart.sh  /usr/local/fdfs/
cp stop.sh  /usr/local/fdfs/
</code></pre>

<h3 id="%E9%85%8D%E7%BD%AEstorage%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" style="margin-left:0cm;">配置storage启动服务</h3>

<p style="margin-left:0cm;">(restart和stop脚本已经拷贝到/usr/local/fdfs下，所以storage只需要配置/etc/init.d/fdfs_storage脚本就可以了)</p>

<p>vim&nbsp;/etc/init.d/fdfs_storage</p>

<p><img alt="" class="has" height="264" src="https://img-blog.csdnimg.cn/2019101011443811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="426"></p>

<p><img alt="" class="has" height="186" src="https://img-blog.csdnimg.cn/20191010114443611.png" width="356"></p>

<h3 id="%E5%B0%86%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E5%8A%A0%E5%85%A5linux%E6%9C%8D%E5%8A%A1" style="margin-left:0cm;">将启动脚本加入linux服务</h3>

<pre class="has"><code>cd /etc/init.d/

chkconfig --add fdfs_trackerd 
chkconfig --add fdfs_storaged </code></pre>

<h3 id="%E2%80%8B"><img alt="" class="has" height="98" src="https://img-blog.csdnimg.cn/20191010114921821.png" width="602"></h3>

<h3 id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">启动服务</h3>

<pre class="has"><code>service fdfs_trackerd start

 service fdfs_storaged start
</code></pre>

<p><img alt="" class="has" height="84" src="https://img-blog.csdnimg.cn/20191010114915388.png" width="714"></p>

<h3 id="%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%8A%B6%E6%80%81" style="margin-left:0cm;">检查服务启动状态</h3>

<pre class="has"><code>ps -ef |grep fdfs
</code></pre>

<h2 style="margin-left:0cm;"><img alt="" class="has" height="142" src="https://img-blog.csdnimg.cn/20191010115124913.png" width="735"></h2>

<h2 id="4%20%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%BC%A0" style="margin-left:0cm;">4 测试上传</h2>

<p style="margin-left:0cm;"><strong>FastDFS安装成功可通过/usr/bin/fdfs_test测试上传、下载等操作。</strong></p>

<h3 id="%E4%BF%AE%E6%94%B9%2Fetc%2Ffdfs%2Fclient.conf" style="margin-left:0cm;">修改/etc/fdfs/client.conf</h3>

<pre class="has"><code>[root@localhost ~]# vim /etc/fdfs/client.conf


base_path=/opt/fastdfs
tracker_server=192.168.67.163:22122
</code></pre>

<p>&nbsp;</p>

<p><img alt="" class="has" height="139" src="https://img-blog.csdnimg.cn/20191010115221436.png" width="477"></p>

<p style="margin-left:0cm;">比如将/root下的图片上传到FastDFS中：</p>

<pre class="has"><code>/usr/bin/fdfs_test /etc/fdfs/client.conf upload preview.jpg 
</code></pre>

<p><img alt="" class="has" height="590" src="https://img-blog.csdnimg.cn/20191010115644743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="835"></p>

<p style="margin-left:0cm;">对应的上传路径：</p>

<p style="margin-left:0cm;">/opt/fastdfs/fdfs_storage/data /00/00/wKhDo1qipbiAJC6iAAB1tayPlqs094_big.jpg</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="105" src="https://img-blog.csdnimg.cn/20191010115809831.png" width="635"></p>

<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0FastDFS%E6%95%B4%E5%90%88nginx" style="margin-left:0cm;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong><span style="color:#f33b45;">FastDFS整合nginx</span></strong></h2>

<p>&nbsp;</p>

<h2 id="%C2%A05%C2%A0%E5%AE%89%E8%A3%85nginx%E6%95%B4%E5%90%88%E6%8F%92%E4%BB%B6fastdfs-nginx-module" style="margin-left:0cm;">&nbsp;5&nbsp;安装nginx整合插件fastdfs-nginx-module</h2>

<h3 id="A%20%E8%A7%A3%E5%8E%8BFastDFS-nginx-module%E6%8F%92%E4%BB%B6" style="margin-left:0cm;">A 解压FastDFS-nginx-module插件</h3>

<pre class="has"><code>tar -zxvf fastdfs-nginx-module_v1.16.tar.gz 
</code></pre>

<h3 id="B%20%E4%BF%AE%E6%94%B9%E6%8F%92%E4%BB%B6%E8%AF%BB%E5%8F%96fdfs%E7%9A%84%E7%9B%AE%E5%BD%95%EF%BC%88%E6%8F%92%E4%BB%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89" style="margin-left:0cm;">B 修改插件读取fdfs的目录（插件自己的配置文件）</h3>

<p style="margin-left:0cm;">Vi <span style="color:#ff0000;">fastdfs-nginx-module/src/config</span></p>

<h1 style="margin-left:0cm;"><strong><span style="color:#ff0000;">删除圈中里面的local，就上面两个就可以了</span></strong></h1>

<p style="margin-left:0cm;"><img alt="" class="has" height="156" src="https://img-blog.csdnimg.cn/20191010120246253.png" width="737"></p>

<h3 id="C%20%E5%B0%86FastDFS-nginx-module%E6%8F%92%E4%BB%B6%E6%95%B4%E5%90%88fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E5%88%B0fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E4%B8%8B(%E6%95%B4%E5%90%88fdfs%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)" style="margin-left:0cm;">C 将FastDFS-nginx-module插件整合fdfs的配置文件拷贝到fdfs的配置目录下(整合fdfs的配置文件)</h3>

<p style="margin-left:0cm;">FastDFS-nginx-module/src下的mod_fastdfs.conf拷贝至/etc/fdfs/下(<span style="color:#ff0000;">这里面是两个路径</span>)</p>

<pre class="has"><code>cp /opt/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/
</code></pre>

<h3 id="D%20%E4%BF%AE%E6%94%B9%2Fetc%2Ffdfs%2Fmod_fastdfs.conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" style="margin-left:0cm;">D 修改/etc/fdfs/mod_fastdfs.conf配置文件</h3>

<p style="margin-left:0cm;">软件安装目录</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="61" src="https://img-blog.csdnimg.cn/20191010120610455.png" width="375"></p>

<p style="margin-left:0cm;">Tracker_server地址</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="42" src="https://img-blog.csdnimg.cn/20191010120627188.png" width="609"></p>

<p style="margin-left:0cm;">Web的url是否包含group的路径名</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="91" src="https://img-blog.csdnimg.cn/20191010120641476.png" width="737"></p>

<p style="margin-left:0cm;">上传文件存储目录</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="114" src="https://img-blog.csdnimg.cn/20191010120653805.png" width="551"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<h2 id="6%20%E5%AE%89%E8%A3%85nginx" style="margin-left:0cm;">6 安装nginx</h2>

<h3 id="%E5%88%9B%E5%BB%BAnginx%2Fclient%E7%9B%AE%E5%BD%95">创建nginx/client目录</h3>

<pre class="has"><code> mkdir -p /var/temp/nginx/client</code></pre>

<h3 id="%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%EF%BC%9A">安装环境：</h3>

<p style="margin-left:0cm;">安装pcre库</p>

<p style="margin-left:0cm;">yum -y install pcre-devel</p>

<p style="margin-left:0cm;">安装zlib库</p>

<p style="margin-left:0cm;">yum install -y zlib-devel</p>

<p>&nbsp;</p>

<h3 id="%E8%A7%A3%E5%8E%8Bnginx">解压nginx</h3>

<pre class="has"><code>tar -zxvf nginx-1.12.2.tar.gz</code></pre>

<h3 id="%E8%BF%9B%E5%85%A5nginx%E7%9B%AE%E5%BD%95%20%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83">进入nginx目录 配置安装环境</h3>

<p style="margin-left:0cm;">添加fastdfs-nginx-module模块</p>

<p style="margin-left:0cm;">cd nginx-1.8.0</p>

<pre class="has"><code>./configure \
--prefix=/usr/local/nginx \
--pid-path=/var/run/nginx/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/temp/nginx/client \
--http-proxy-temp-path=/var/temp/nginx/proxy \
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
--http-scgi-temp-path=/var/temp/nginx/scgi \
--add-module=/opt/fastdfs-nginx-module/src
</code></pre>

<p><img alt="" class="has" height="230" src="https://img-blog.csdnimg.cn/20191010121106744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h3 id="%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F" style="margin-left:0cm;">配置成功</h3>

<p><img alt="" class="has" height="337" src="https://img-blog.csdnimg.cn/20191010121136244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h3 id="%E7%BC%96%E8%AF%91" style="margin-left:0cm;">编译</h3>

<pre class="has"><code>make</code></pre>

<h3 id="%E5%AE%89%E8%A3%85" style="margin-left:0cm;">安装</h3>

<pre class="has"><code>make install</code></pre>

<p style="margin-left:0cm;">&nbsp;</p>

<h3 id="%E7%BC%96%E8%BE%91nginx.conf" style="margin-left:0cm;">编辑nginx.conf</h3>

<p style="margin-left:0cm;">vim /usr/local/nginx/conf/nginx.conf</p>

<p><img alt="" class="has" height="223" src="https://img-blog.csdnimg.cn/20191010121214375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></p>

<h3 id="%E5%90%AF%E5%8A%A8nginx" style="margin-left:0cm;">启动nginx</h3>

<pre class="has"><code>/usr/local/nginx/sbin/nginx</code></pre>

<h3 id="%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8" style="margin-left:0cm;">设置开机启动</h3>

<p style="margin-left:0cm;">&nbsp;vim /etc/rc.d/rc.local</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="118" src="https://img-blog.csdnimg.cn/2019101012125111.png" width="554"></p>

<p>&nbsp;</p>

<h3 id="%E9%9C%80%E8%A6%81%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99" style="margin-left:0cm;">需要关闭防火墙</h3>

<pre class="has"><code>service iptables stop</code></pre>

<p style="margin-left:0cm;">永久关闭 chkconfig&nbsp; iptables &nbsp;off</p>

<h2 id="%E6%B5%8B%E8%AF%95" style="margin-left:0cm;">测试</h2>

<pre class="has"><code>/usr/bin/fdfs_test /etc/fdfs/client.conf upload preview.jpg </code></pre>

<p><img alt="" class="has" height="550" src="https://img-blog.csdnimg.cn/20191010121425114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="755"></p>

<h3 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E9%93%BE%E6%8E%A5">浏览器打开链接</h3>

<p><img alt="" class="has" height="957" src="https://img-blog.csdnimg.cn/20191010121521544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="%E5%AE%8C%E7%BE%8E%E6%88%90%E5%8A%9F%EF%BC%8COK%E4%BA%86">完美成功，OK了</h2>

<h2><span style="color:#f33b45;">楼主目标：前可H5撩妹，后可Linux搞运维</span></h2>

<p><img alt="" class="has" height="450" src="https://img-blog.csdnimg.cn/20191010121801942.gif" width="800"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Java前后端的跨域问题</title><link>http://www.cnblogs.com/heian99/archive/2019/10/08/11972245.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 08 Oct 2019 09:54:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/10/08/11972245.html</guid><description><![CDATA[
                                            <h3 style="margin-left:0cm;"><strong>1 前端127.0.0.1:8888</strong></h3>

<h3 style="margin-left:0cm;"><strong>2 后端127.0.0.1:8080</strong></h3>

<h3 style="margin-left:0cm;"><span style="color:#f33b45;"><strong>前端和后端因为来自不同的网域，所以在http的安全协议策略下，不信任</strong></span></h3>

<h3 style="margin-left:0cm;"><strong><img alt="" class="has" height="145" src="https://img-blog.csdnimg.cn/20191008175356195.png" width="737"></strong></h3>

<h3 style="margin-left:0cm;"><strong>3 解决方案，在springmvc的控制层加入<code><span style="color:#ff0000;">@CrossOrigin</span>跨域访问的注解</code></strong></h3>

<h3 style="margin-left:0cm;"><strong><img alt="" class="has" src="https://img-blog.csdnimg.cn/20191008175549870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"><img alt="" class="has" height="207" src="https://img-blog.csdnimg.cn/20191008175422648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="737"></strong></h3>

<h3 style="margin-left:0cm;"><strong><img alt="" class="has" height="248" src="https://img-blog.csdnimg.cn/20191008175637625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="657"></strong></h3>

<p style="margin-left:0cm;">&nbsp;</p>
                                    ]]></description></item><item><title>Centos7安装dubbo与zookeeper服务配置</title><link>http://www.cnblogs.com/heian99/archive/2019/09/28/11972246.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 28 Sep 2019 06:17:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/28/11972246.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E7%8E%AF%E5%A2%83%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%8E%AF%E5%A2%83%EF%BC%9A%C2%A0" rel="nofollow">环境：&nbsp;</a></p>

<p id="%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85jdk%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88*%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85jdk%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88*%EF%BC%89%C2%A0" rel="nofollow">第一步：安装jdk，并且配置环境变量</a></p>

<p id="%C2%A01.%E8%A7%A3%E5%8E%8Bjdk%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A01.%E8%A7%A3%E5%8E%8Bjdk%EF%BC%9A" rel="nofollow">&nbsp;1.解压jdk：</a></p>

<p id="2.%E6%8F%90%E5%8F%96%E6%9D%83%E9%99%90%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.%E6%8F%90%E5%8F%96%E6%9D%83%E9%99%90%EF%BC%9A" rel="nofollow">2.配置环境变量：</a></p>

<p id="4.%E4%BF%9D%E5%AD%98%E5%B9%B6%E4%BD%BF%E6%96%87%E4%BB%B6%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88%EF%BC%9A-toc" style="margin-left:80px;"><a href="#4.%E4%BF%9D%E5%AD%98%E5%B9%B6%E4%BD%BF%E6%96%87%E4%BB%B6%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88%EF%BC%9A" rel="nofollow">3.保存并使文件立即生效：</a></p>

<p id="5.%E7%AB%8B%E5%8D%B3%E9%87%8D%E5%90%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E8%BF%9B%E8%A1%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85-toc" style="margin-left:80px;"><a href="#5.%E7%AB%8B%E5%8D%B3%E9%87%8D%E5%90%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E8%BF%9B%E8%A1%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85" rel="nofollow">4.立即重启虚拟机，进行下面的安装</a></p>

<p id="%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83zookeeper%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83zookeeper%C2%A0" rel="nofollow">第二步：安装注册中心zookeeper&nbsp;</a></p>

<p id="1.%E8%A7%A3%E5%8E%8Bzookeeper%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%E8%A7%A3%E5%8E%8Bzookeeper%EF%BC%9A" rel="nofollow">1.解压zookeeper：</a></p>

<p id="2.%E5%9C%A8zookeeper%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%88%9B%E5%BB%BAdata%E5%92%8Clogs%E7%9B%AE%E5%BD%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.%E5%9C%A8zookeeper%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%88%9B%E5%BB%BAdata%E5%92%8Clogs%E7%9B%AE%E5%BD%95%EF%BC%9A" rel="nofollow">2.在zookeeper目录下创建data和logs目录：</a></p>

<p id="3.%E5%B0%86%2Fusr%2Flocal%2Fzookeeper3.4.6%2Fzookeeper-3.4.6%2Fconf%20%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%20zoo_sample.cfg%E6%8B%B7%E8%B4%9D%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.%E5%B0%86%2Fusr%2Flocal%2Fzookeeper3.4.6%2Fzookeeper-3.4.6%2Fconf%20%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%20zoo_sample.cfg%E6%8B%B7%E8%B4%9D%EF%BC%9A" rel="nofollow">3.将/usr/local/zookeeper3.4.6/zookeeper-3.4.6/conf 目录下的 zoo_sample.cfg拷贝：</a></p>

<p id="4.%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#4.%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A" rel="nofollow">4.修改配置文件：</a></p>

<p id="5.%E5%9C%A8zookeeper%E7%9A%84%E5%88%9A%E5%BB%BA%E7%AB%8B%E7%9A%84data%E6%96%87%E4%BB%B6%E5%AE%B6%E4%B8%8B%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%BC%96%E8%BE%91myid%E6%96%87%E4%BB%B6%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%86%99%E5%85%A51%EF%BC%88%E6%88%91%E8%BF%99%E9%87%8C%E6%98%AF%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%EF%BC%89-toc" style="margin-left:80px;"><a href="#5.%E5%9C%A8zookeeper%E7%9A%84%E5%88%9A%E5%BB%BA%E7%AB%8B%E7%9A%84data%E6%96%87%E4%BB%B6%E5%AE%B6%E4%B8%8B%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%BC%96%E8%BE%91myid%E6%96%87%E4%BB%B6%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%86%99%E5%85%A51%EF%BC%88%E6%88%91%E8%BF%99%E9%87%8C%E6%98%AF%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%EF%BC%89" rel="nofollow">​</a></p>

<p id="6.%E5%9C%A8vi%20%2Fetc%2Fprofile%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0zookeeper%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#6.%E5%9C%A8vi%20%2Fetc%2Fprofile%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0zookeeper%E9%85%8D%E7%BD%AE" rel="nofollow">5.在vi /etc/profile末尾添加zookeeper配置</a></p>

<p id="7.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88%EF%BC%9A-toc" style="margin-left:80px;"><a href="#7.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88%EF%BC%9A" rel="nofollow">6.配置文件立即生效：</a></p>

<p id="8.%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#8.%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95" rel="nofollow">7.关闭防火墙，并且启动测试</a></p>

<p id="%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85dubbo-admin-war%E5%92%8Ctomcat%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85dubbo-admin-war%E5%92%8Ctomcat%C2%A0" rel="nofollow">第三步：安装dubbo-admin-war和tomcat&nbsp;</a></p>

<p id="1.%E8%A7%A3%E5%8E%8Btomcat%3A-toc" style="margin-left:80px;"><a href="#1.%E8%A7%A3%E5%8E%8Btomcat%3A" rel="nofollow">1.解压tomcat:</a></p>

<p id="2.%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D%E4%B8%BA%3Adubbo-admin-tomcat-toc" style="margin-left:80px;"><a href="#2.%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D%E4%B8%BA%3Adubbo-admin-tomcat" rel="nofollow">2.解压dubbo文件</a></p>

<p id="3.%E7%A7%BB%E9%99%A4dubbo-admin-tomcat%2Fwebapps%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.%E7%A7%BB%E9%99%A4dubbo-admin-tomcat%2Fwebapps%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%9A" rel="nofollow">3.进入tomcat的conf目录下修改server.xml</a></p>

<p id="4.%E4%B8%8A%E4%BC%A0%E5%B9%B6%E4%B8%94%E8%A7%A3%E5%8E%8Bdubbo-tomcat-2.5.3.war%2C%E5%B9%B6%E4%B8%94%E6%8A%8A%E7%9B%AE%E5%BD%95%E5%91%BD%E5%90%8Droot-toc" style="margin-left:80px;"><a href="#4.%E4%B8%8A%E4%BC%A0%E5%B9%B6%E4%B8%94%E8%A7%A3%E5%8E%8Bdubbo-tomcat-2.5.3.war%2C%E5%B9%B6%E4%B8%94%E6%8A%8A%E7%9B%AE%E5%BD%95%E5%91%BD%E5%90%8Droot" rel="nofollow">4.修改server.xml</a></p>

<p id="5.%E9%85%8D%E7%BD%AEdubbo.properties-toc" style="margin-left:80px;"><a href="#5.%E9%85%8D%E7%BD%AEdubbo.properties" rel="nofollow">5.启动tomcat服务，进入tomcat的bin下</a></p>

<p id="6.%E5%90%AF%E5%8A%A8zookeeper%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%BF%9B%E5%85%A5zookeeper%E7%9A%84bin%E4%B8%8B-toc" style="margin-left:80px;"><a href="#6.%E5%90%AF%E5%8A%A8zookeeper%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%BF%9B%E5%85%A5zookeeper%E7%9A%84bin%E4%B8%8B" rel="nofollow">6.启动zookeeper服务，进入zookeeper的bin下</a></p>

<p id="%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%EF%BC%9A%C2%A0" rel="nofollow">第四步：在浏览器中输入地址显示如下：&nbsp;</a></p>

<hr id="hr-toc"><hr><h2 id="%E7%8E%AF%E5%A2%83%EF%BC%9A%C2%A0">环境：&nbsp;</h2>

<p><br>
1.centos7&nbsp;<br>
2.jdk-7u76-linux-x64.tar.gz&nbsp;<br>
2.tomcat:apache-tomcat-7.0.59.tar.gz&nbsp;<br>
3.zookeeper-3.4.6.tar.gz&nbsp;<br>
4.dubbo-admin-2.5.3.war</p>

<p><img alt="" class="has" height="646" src="https://img-blog.csdnimg.cn/20190928141819246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="908"></p>

<p>具体的流程：&nbsp;</p>

<h2 id="%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85jdk%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88*%EF%BC%89%C2%A0"><br>
第一步：安装jdk，并且配置环境变量</h2>

<p><br>
xshell5命令:</p>

<h3 id="%C2%A01.%E8%A7%A3%E5%8E%8Bjdk%EF%BC%9A">&nbsp;<br>
1.解压jdk：</h3>

<pre class="has"><code>tar zxvf  jdk-7u76-linux-x64.tar.gz</code></pre>

<h3 id="2.%E6%8F%90%E5%8F%96%E6%9D%83%E9%99%90%EF%BC%9A">2.配置环境变量：</h3>

<p>/opt/jdk1.8.0_152&nbsp; :为jdk解压的路径</p>

<p><img alt="" class="has" height="128" src="https://img-blog.csdnimg.cn/20191008212949409.png" width="416"></p>

<pre class="has"><code>[root@localhost~]# vi  /etc/profile </code></pre>

<pre class="has"><code>export JAVA_HOME=/opt/jdk1.8.0_152
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$JAVA_HOME/bin:$PATH</code></pre>

<h3 id="4.%E4%BF%9D%E5%AD%98%E5%B9%B6%E4%BD%BF%E6%96%87%E4%BB%B6%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88%EF%BC%9A">3.保存并使文件立即生效：</h3>

<pre class="has"><code>保存：点击ESC键，并且输入:wq;
立即生效：source /etc/profile</code></pre>

<h3 id="5.%E7%AB%8B%E5%8D%B3%E9%87%8D%E5%90%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E8%BF%9B%E8%A1%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85">4.立即重启虚拟机，进行下面的安装</h3>

<pre class="has"><code>shutdown -r now</code></pre>

<h2 id="%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83zookeeper%C2%A0">第二步：安装注册中心zookeeper&nbsp;</h2>

<h3 id="1.%E8%A7%A3%E5%8E%8Bzookeeper%EF%BC%9A"><br>
1.解压zookeeper：</h3>

<pre class="has"><code>tar zxvf zookeeper-3.4.6.tar.gz </code></pre>

<h3 id="2.%E5%9C%A8zookeeper%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%88%9B%E5%BB%BAdata%E5%92%8Clogs%E7%9B%AE%E5%BD%95%EF%BC%9A">2.在zookeeper目录下创建data和logs目录：</h3>

<pre class="has"><code>mkdir data

</code></pre>

<h3 id="3.%E5%B0%86%2Fusr%2Flocal%2Fzookeeper3.4.6%2Fzookeeper-3.4.6%2Fconf%20%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%20zoo_sample.cfg%E6%8B%B7%E8%B4%9D%EF%BC%9A">3.将/usr/local/zookeeper3.4.6/zookeeper-3.4.6/conf 目录下的 zoo_sample.cfg拷贝：</h3>

<pre class="has"><code> cp zoo_sample.cfg zoo.cfg</code></pre>

<h3 id="4.%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A">4.修改配置文件：</h3>

<pre class="has"><code>vi zoo.cfg</code></pre>

<h3 id="5.%E5%9C%A8zookeeper%E7%9A%84%E5%88%9A%E5%BB%BA%E7%AB%8B%E7%9A%84data%E6%96%87%E4%BB%B6%E5%AE%B6%E4%B8%8B%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%BC%96%E8%BE%91myid%E6%96%87%E4%BB%B6%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%86%99%E5%85%A51%EF%BC%88%E6%88%91%E8%BF%99%E9%87%8C%E6%98%AF%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%EF%BC%89"><img alt="" class="has" height="465" src="https://img-blog.csdnimg.cn/20191008213223570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="697"></h3>

<h3 id="6.%E5%9C%A8vi%20%2Fetc%2Fprofile%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0zookeeper%E9%85%8D%E7%BD%AE">5.在vi /etc/profile末尾添加zookeeper配置</h3>

<pre class="has"><code>export ZOOKEEPER_HOME=/opt/zookeeper-3.4.11
export PATH=$ZOOKEEPER_HOME/bin:$PATH
</code></pre>

<h3 id="7.%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88%EF%BC%9A">6.配置文件立即生效：</h3>

<pre class="has"><code>source /etc/profile</code></pre>

<h3 id="8.%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95">7.关闭防火墙，并且启动测试</h3>

<pre class="has"><code>systemctl stop firewalld.service
在zookeeper的bin目录下执行： ./zkServer.sh start</code></pre>

<h2 id="%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85dubbo-admin-war%E5%92%8Ctomcat%C2%A0">第三步：安装dubbo-admin-war和tomcat&nbsp;</h2>

<h3 id="1.%E8%A7%A3%E5%8E%8Btomcat%3A"><br>
1.解压tomcat:</h3>

<pre class="has"><code>tar zxvf apache-tomcat-7.0.59.tar.gz&nbsp;</code></pre>

<h3 id="2.%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D%E4%B8%BA%3Adubbo-admin-tomcat">2.解压dubbo文件</h3>

<pre class="has"><code>unzip dubbo-admin-2.6.0.war -d dubbo
</code></pre>

<h3 id="3.%E7%A7%BB%E9%99%A4dubbo-admin-tomcat%2Fwebapps%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%9A">3.进入tomcat的conf目录下修改server.xml</h3>

<p><img alt="" class="has" height="294" src="https://img-blog.csdnimg.cn/20191008213748704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="691"></p>

<h3 id="4.%E4%B8%8A%E4%BC%A0%E5%B9%B6%E4%B8%94%E8%A7%A3%E5%8E%8Bdubbo-tomcat-2.5.3.war%2C%E5%B9%B6%E4%B8%94%E6%8A%8A%E7%9B%AE%E5%BD%95%E5%91%BD%E5%90%8Droot">4.修改server.xml</h3>

<p><img alt="" class="has" height="330" src="https://img-blog.csdnimg.cn/20191008213844490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="721"></p>

<pre class="has"><code>&lt;Context path="/dubbo" docBase="/opt/dubbo" debug="0" privileged="true" /&gt;

</code></pre>

<h3 id="5.%E9%85%8D%E7%BD%AEdubbo.properties"><br>
5.启动tomcat服务，进入tomcat的bin下</h3>

<pre class="has"><code>startup.sh</code></pre>

<h3 id="6.%E5%90%AF%E5%8A%A8zookeeper%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%BF%9B%E5%85%A5zookeeper%E7%9A%84bin%E4%B8%8B">6.启动zookeeper服务，进入zookeeper的bin下</h3>

<p>&nbsp;</p>

<pre class="has"><code>bash zkServer.sh start

bash zkServer.sh status
</code></pre>

<p>&nbsp;</p>

<h2 id="%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%EF%BC%9A%C2%A0">第四步：在浏览器中输入地址显示如下：&nbsp;</h2>

<p>账号：root</p>

<p>密码：root</p>

<p><img alt="" class="has" height="306" src="https://img-blog.csdnimg.cn/20190928142526505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="696" src="https://img-blog.csdnimg.cn/20190928142559185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                                    ]]></description></item><item><title>dubbo与zookeeper的关系</title><link>http://www.cnblogs.com/heian99/archive/2019/09/28/11972247.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 28 Sep 2019 05:59:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/28/11972247.html</guid><description><![CDATA[
                                            <h1><strong>dubbo与zookeeper的关系</strong></h1>

<p>dubbo是动物..zookeeper是动物园的管理员！</p>

<p>&nbsp;按我的理解，您可以把dubbo服务想象成学校里的一个学生，并且对应有一个学号，zookeeper则是想象成一个教务网管理系统。我们可以通过教务网管理系统，查找到对应的学生。我们首先通过注册入学，将学生和学号对应绑定。</p>

<p>比方说项目是一个分布式的项目，web层与 service层被拆分了开来， 部署在不同的tomcat中， 我在web层 需要调用 service层的接口，但是两个运行在不同tomcat下的服务无法直接互调接口，那么就可以通过zookeeper和dubbo实现。 我们通过dubbo 建立ItemService这个服务，并且到zookeeper上面注册，填写对应的zookeeper服务所在 的IP及端口号。【按照我上面的比喻就是，学生注册入学（接口是学号，学生本人是impl实现），填写学校教务网网址（就是zookeeper）】</p>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTE4MzE2MS8yMDE3MDYvMTE4MzE2MS0yMDE3MDYyNTIwMDU1MDY5NS0xNDMwODM1OTgzLnBuZw?x-oss-process=image/format,png"></p>

<p>&nbsp;</p>

<p>Dubbo建议使用Zookeeper作为服务的注册中心。</p>

<p>1.&nbsp;&nbsp; Zookeeper的作用：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。当然也可以 通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器挂掉调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。 zookeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的ip和服务对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码 的情况通过添加机器来提高运算能力。通过添加新的机器向zookeeper注册服务，服务的提供者多了能服务的客户就多了。<br>
&nbsp;</p>

<p>&nbsp;</p>

<p>2.&nbsp; dubbo：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，dubbo提供一个框架解决这个问题。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意这里的dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的注册中心，储存所有服务的元数据，你可以用zk，也可以用别的，只是大家都用zk。<br><img alt="" class="has" src="https://img-blog.csdnimg.cn/2019092814092149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"><br>
3. zookeeper和dubbo的关系：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dubbo的将注册中心进行抽象，是得它可以外接不同的存储媒介给注册中心提供服务，有ZooKeeper，Memcached，Redis等。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 引入了ZooKeeper作为存储媒介，也就把ZooKeeper的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个ZooKeeper群配合相应的Web应用就可以很容易达到负载均衡；资源同步，单单有负载均衡还不 够，节点之间的数据和资源需要同步，ZooKeeper集群就天然具备有这样的功能；命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。 其他特性还有Mast选举，分布式锁等。</p>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTE4MzE2MS8yMDE3MDYvMTE4MzE2MS0yMDE3MDYyNTIwMDM0NzQ0NS0zODMzNzIwNDQucG5n?x-oss-process=image/format,png"></p>
                                    ]]></description></item><item><title>IEDA创建Springboot项目</title><link>http://www.cnblogs.com/heian99/archive/2019/09/26/11972248.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 26 Sep 2019 09:53:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/26/11972248.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 随着技术的更新对于开发速度的追求，我们越来越不能忍受的是Spring框架对于集成开发以后大量的配置问题。所以SprigBoot应运而生，SpringBoot框架其实就是在Spring框架的外边包裹上了一层纸，包括减少配置文件，内置Tomcat服务器等等。在这里我们就使用IDEA工具为代表讲解一下SpringBoot在开发过程中会使用到的开发技术。官方推荐的编辑器是STS，STS就是对Eclipes做了封装，其实没有什么具体的改变，所以这里就是用更加快捷方便的开发工具IDEA，没有多大的影响。</p>

<p>　　创建项目：</p>

<p><img alt="" class="has" height="469" src="https://img-blog.csdnimg.cn/20190926172148611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="741"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="686" src="https://img-blog.csdnimg.cn/20190926172321309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="855"></p>

<p>接下来就是给项目命名了，我偷懒了选择默认吧 (=v=)</p>

<p>web项目开发就少不了它啦</p>

<p>项目名称、项目位置</p>

<p><img alt="" class="has" height="674" src="https://img-blog.csdnimg.cn/20190926172658850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="855"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="672" src="https://img-blog.csdnimg.cn/20190926172717916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="851"></p>

<p><img alt="" class="has" height="682" src="https://img-blog.csdnimg.cn/20190926172807660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="849"></p>

<p><img alt="" class="has" height="675" src="https://img-blog.csdnimg.cn/20190926172824831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="829"></p>

<p>点击Finish后，idea就帮我们创建项目</p>

<p>目录结构</p>

<p><img alt="" class="has" height="731" src="https://img-blog.csdnimg.cn/20190926172915881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="826"></p>

<p>java ----源码，要注意的是Application要放在当前工程groupId下，举个栗子（=.=）</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;com.example&lt;/groupId&gt;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以上面的 DemoApplication 位置是要放在 com.example 目录下</p>

<p>resource</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----static ：web的静态资源</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----templates ：页面模板（.html / .ftl）</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----application.properties ：配置文件 ，不过常用的是以 .yml 为后缀，application.yml</p>

<p>接下来写一个简单的测试代码</p>

<p>UserController.java</p>

<pre class="has"><code class="language-java">package com.demo.ssm.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
@RequestMapping("")
public class UserController {

    @RestController

    public class TestController {

        @RequestMapping("/test")

        public String hello() {
            System.out.println("TestController的方法被调用了");
            return "welcome to the new age !";
        }
    }
}
</code></pre>

<p><br>
因为Springboot 内嵌 web 服务器（有很多，可根据情况所需配置），默认是 Tomcat，因此直接运行 Application类</p>

<p>application.properties<br>
&nbsp;<br>
&nbsp;</p>

<pre class="has"><code># 服务端口
server.port=8080



# 日志级别
logging.level.root=error</code></pre>

<p>&nbsp;</p>

<p><img alt="" class="has" height="632" src="https://img-blog.csdnimg.cn/20190926175206200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>打开浏览器，在地址栏输入请求URL</p>

<p><img alt="" class="has" height="353" src="https://img-blog.csdnimg.cn/20190926173926857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="901"></p>

<p>控制台输出</p>

<p><img alt="" class="has" height="426" src="https://img-blog.csdnimg.cn/20190926174413567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="914"></p>

<p><br>
打开浏览器，在地址栏输入请求URL</p>

<p>控制台输出</p>

<p>没有spring繁琐的配置，也不用部署到Tomcat，开发也可以如此快捷方便。</p>
                                    ]]></description></item><item><title>ezdml设计数据库</title><link>http://www.cnblogs.com/heian99/archive/2019/09/26/11972249.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 26 Sep 2019 09:06:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/26/11972249.html</guid><description><![CDATA[
                                            <h1 style="margin-left:0cm;">&nbsp;数据结构和设计的介绍</h1>

<h1 style="margin-left:0cm;"><span style="color:#f33b45;">ezdml软件：</span><a href="https://www.lanzous.com/i6ew2pe" rel="nofollow">https://www.lanzous.com/i6ew2pe</a></h1>

<h2 style="margin-left:0cm;">1 用ezdml设计数据表然后导出到mysql数据库中</h2>

<h2 style="margin-left:0cm;">点击生成模型</h2>

<p style="margin-left:0cm;"><img alt="" class="has" height="402" src="https://img-blog.csdnimg.cn/20190926170431455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="737"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<h2 style="margin-left:0cm;">2 选择库</h2>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="472" src="https://img-blog.csdnimg.cn/20190926170441217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="737"></p>

<h2 style="margin-left:0cm;">3 点击开始生成</h2>

<p><img alt="" class="has" height="414" src="https://img-blog.csdnimg.cn/20190926170501884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="639"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<h2 style="margin-left:0cm;">&nbsp;</h2>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Centos7下zabbix安装与部署</title><link>http://www.cnblogs.com/heian99/archive/2019/09/24/11972251.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 24 Sep 2019 02:47:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/24/11972251.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="Centos7%E4%B8%8Bzabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2-toc" style="margin-left:0px;"><a href="#Centos7%E4%B8%8Bzabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2" rel="nofollow">Centos7下zabbix安装与部署</a></p>

<p id="1.Zabbix%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.Zabbix%E4%BB%8B%E7%BB%8D" rel="nofollow">1.Zabbix介绍</a></p>

<p id="2.LAMP%2FLNMP%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#2.LAMP%2FLNMP%E4%BB%8B%E7%BB%8D" rel="nofollow">2.LAMP/LNMP介绍</a></p>

<p id="3.Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2-toc" style="margin-left:40px;"><a href="#3.Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2" rel="nofollow">3.Zabbix安装与部署</a></p>

<p id="1%E3%80%81%E4%B8%B4%E6%97%B6%E5%85%B3%E9%97%AD-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E4%B8%B4%E6%97%B6%E5%85%B3%E9%97%AD" rel="nofollow">1、临时关闭</a></p>

<p id="2%E3%80%81%E6%B0%B8%E4%B9%85%E5%85%B3%E9%97%AD-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E6%B0%B8%E4%B9%85%E5%85%B3%E9%97%AD" rel="nofollow">2、永久关闭</a></p>

<p id="3%20%E3%80%81%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83-toc" style="margin-left:80px;"><a href="#3%20%E3%80%81%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83" rel="nofollow">3 、安装环境</a></p>

<p id="4%E3%80%81%E5%AE%89%E8%A3%85zabbix-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%AE%89%E8%A3%85zabbix" rel="nofollow">4、安装zabbix</a></p>

<h1>&nbsp;</h1>

<h1><span style="color:#3399ea;">Centos7下zabbix安装与部署</span></h1>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODcyNjEwLzIwMTkwNC84NzI2MTAtMjAxOTA0MjIxNTU2NDcwNzUtNjYxNjUwNDI3LnBuZw?x-oss-process=image/format,png"></p>

<p>&nbsp;</p>

<h2 id="1.Zabbix%E4%BB%8B%E7%BB%8D"><a name="sg1"></a>1.Zabbix介绍</h2>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODcyNjEwLzIwMTgwNS84NzI2MTAtMjAxODA1MjEyMzE5MDgyNjEtMTgwNDI4Njg4My5wbmc?x-oss-process=image/format,png"></p>

<ul><li>
	<p>zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。</p>
	</li>
	<li>
	<p>zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。</p>
	</li>
	<li>
	<p>zabbix由2部分构成，zabbix server与可选组件zabbix agent。</p>
	</li>
	<li>
	<p>zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。</p>
	</li>
</ul><p>&nbsp;</p>

<h2 id="2.LAMP%2FLNMP%E4%BB%8B%E7%BB%8D"><a name="sg2"></a>2.LAMP/LNMP介绍</h2>

<ul><li>
	<p>LAMP：Linux+Apache+Mysql/MariaDB+Perl/PHP/Python一组常用来搭建动态网站或者服务器的开源软件，本身都是各自独立的程序，但是因为常被放在一起使用，拥有了越来越高的兼容度，共同组成了一个强大的Web应用程序平台。</p>
	</li>
	<li>LNMP：LNMP指的是一个基于CentOS/Debian编写的Nginx、PHP、MySQL、phpMyAdmin、eAccelerator一键安装包。可以在VPS、独立主机上轻松的安装LNMP生产环境。</li>
	<li>
	<p>L：linux</p>
	</li>
	<li>
	<p>A：apache</p>
	</li>
	<li>
	<p>N：nginx</p>
	</li>
	<li>
	<p>M：mysql,mariaDB</p>
	</li>
	<li>
	<p>P：php,python,perl</p>
	</li>
</ul><p>&nbsp;</p>

<p>&nbsp;</p>

<h2 id="3.Zabbix%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2"><a name="sg3"></a>3.Zabbix安装与部署</h2>

<p id="Zabbix%E7%9A%84%E5%AE%89%E8%A3%85">Zabbix的安装</p>

<pre><code class="language-html hljs">关闭SeLinux

临时关闭：setenforce 0</code></pre>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODcyNjEwLzIwMTgwNS84NzI2MTAtMjAxODA1MjIxMDU3MDc3NzQtNjQxMDM0MzA5LnBuZw?x-oss-process=image/format,png"></p>

<pre><code class="language-html hljs">永久关闭：vi /etc/selinux/config</code></pre>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODcyNjEwLzIwMTgwNS84NzI2MTAtMjAxODA1MjIxMDU3MjA2ODMtMTg2Njc2ODI2Ni5wbmc?x-oss-process=image/format,png"></p>

<p>关闭防火墙</p>

<h3 id="1%E3%80%81%E4%B8%B4%E6%97%B6%E5%85%B3%E9%97%AD">1、临时关闭</h3>

<pre><code class="language-html hljs">systemctl stop firewalld.service</code></pre>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODcyNjEwLzIwMTgwNS84NzI2MTAtMjAxODA1MjIxMDU4MTg0MjgtNDcyMTk3NDEyLnBuZw?x-oss-process=image/format,png"></p>

<h3 id="2%E3%80%81%E6%B0%B8%E4%B9%85%E5%85%B3%E9%97%AD">2、永久关闭</h3>

<pre><code class="language-html hljs">systemctl disable firewalld.service</code></pre>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODcyNjEwLzIwMTgwNS84NzI2MTAtMjAxODA1MjIxMDU4NTM5MjAtMTMwMTE5Mjk5Mi5wbmc?x-oss-process=image/format,png"></p>

<h3 id="3%20%E3%80%81%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83">3 、安装环境</h3>

<p>LAMP&nbsp;</p>

<p>大家可以看下面的博客，安装LAMP环境</p>

<p><a href="https://blog.csdn.net/heian_99/article/details/101203824" rel="nofollow">Linux(Centos7)搭建LAMP(Apache+PHP+Mysql环境)</a></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h3 id="4%E3%80%81%E5%AE%89%E8%A3%85zabbix">4、安装zabbix</h3>

<p>(1)下载包</p>

<pre class="has"><code>rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm</code></pre>

<p><img alt="" class="has" height="199" src="https://img-blog.csdnimg.cn/20190924100954220.png" width="785"></p>

<p>(2)安装zabbix的包</p>

<pre class="has"><code>yum install -y zabbix-server-mysql zabbix-get zabbix-web zabbix-web-mysql zabbix-agent zabbix-sender</code></pre>

<p><img alt="" class="has" height="602" src="https://img-blog.csdnimg.cn/20190924101027169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="762"></p>

<p>4、创建一个zabbix库并设置为utf8的字符编码格式</p>

<pre class="has"><code>create database zabbix character set utf8 collate utf8_bin;</code></pre>

<p><img alt="" class="has" height="303" src="https://img-blog.csdnimg.cn/20190924101126621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="668"></p>

<p><img alt="" class="has" height="308" src="https://img-blog.csdnimg.cn/20190924101400438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="553"></p>

<p>创建账户并且授权设置密码</p>

<pre class="has"><code>grant all privileges on zabbix.* to zabbix@localhost identified by 'zabbix';</code></pre>

<p>给来自loclhost的用户zabbxi分配可对数据库zabbix所有表进行所有操作的权限，并且设定密码为zabbix</p>

<p><img alt="" class="has" height="86" src="https://img-blog.csdnimg.cn/20190924101441698.png" width="630"></p>

<p>刷新</p>

<pre><code class="language-html hljs">flush privileges;</code></pre>

<p><img alt="" class="has" height="101" src="https://img-blog.csdnimg.cn/20190924101452792.png" width="512"></p>

<p>exit退出</p>

<p>5、导入表</p>

<p>切换到此目录下</p>

<pre class="has"><code>cd /usr/share/doc/zabbix-server-mysql-3.2.10/</code></pre>

<p><img alt="" class="has" height="103" src="https://img-blog.csdnimg.cn/20190924101533563.png" width="494"></p>

<p>进行解压</p>

<pre><code class="language-html hljs">gunzip create.sql.gz</code></pre>

<p><img alt="" class="has" height="81" src="https://img-blog.csdnimg.cn/20190924101622255.png" width="480"></p>

<p>对表进行导入</p>

<pre class="has"><code>[root@wei zabbix-server-mysql-3.4.15]# mysql -u zabbix -p zabbix
Enter password: 
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 10
Server version: 5.6.45 MySQL Community Server (GPL)

Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| zabbix             |
+--------------------+
2 rows in set (0.00 sec)

mysql&gt; use zabbix;
Database changed
mysql&gt; source create.sql
</code></pre>

<p><img alt="" class="has" height="554" src="https://img-blog.csdnimg.cn/20190924102103971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="875"></p>

<p>6、配置zabbix server配置文件</p>

<p>配置文件目录</p>

<pre class="has"><code>cd /etc/zabbix</code></pre>

<p>&nbsp;</p>

<p>对zabbix_server.conf进行配置</p>

<p><img alt="" class="has" height="112" src="https://img-blog.csdnimg.cn/20190924102153566.png" width="624"></p>

<p><img alt="" class="has" height="821" src="https://img-blog.csdnimg.cn/20190924102728969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="688"></p>

<p>运行zabbix-server服务</p>

<p>开机自启zabbix-server服务</p>

<p><img alt="" class="has" height="168" src="https://img-blog.csdnimg.cn/20190924102933145.png" width="785"></p>

<p>7、配置php</p>

<pre class="has"><code>cd /etc/httpd/conf.d</code></pre>

<p><img alt="" class="has" height="84" src="https://img-blog.csdnimg.cn/20190924103011857.png" width="711"></p>

<p>配置时间</p>

<pre class="has"><code>vim zabbix.conf</code></pre>

<p><img alt="" class="has" height="380" src="https://img-blog.csdnimg.cn/20190924103139266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="520"></p>

<pre class="has"><code>Systemctl restart httpd</code></pre>

<p><img alt="" class="has" height="374" src="https://img-blog.csdnimg.cn/20190924103306743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="773"></p>

<p>8、登陆zabbix网址设置</p>

<p>192.168.85.11/zabbix</p>

<p>&nbsp;<img alt="" class="has" height="755" src="https://img-blog.csdnimg.cn/20190924103349762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="701" src="https://img-blog.csdnimg.cn/2019092410341084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>password是我们设置的数据库密码zabbix</p>

<p><img alt="" class="has" height="784" src="https://img-blog.csdnimg.cn/20190924103431161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="749" src="https://img-blog.csdnimg.cn/20190924103503374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="736" src="https://img-blog.csdnimg.cn/20190924103518782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="703" src="https://img-blog.csdnimg.cn/20190924103533263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong><span style="color:#f33b45;">登陆账户是Admin</span></strong></p>

<p><strong><span style="color:#f33b45;">密码是zabbix</span></strong></p>

<p><img alt="" class="has" height="520" src="https://img-blog.csdnimg.cn/20190924103554857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="474"></p>

<p>9、设置中文</p>

<p><img alt="" class="has" height="924" src="https://img-blog.csdnimg.cn/20190924103618782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="731" src="https://img-blog.csdnimg.cn/20190924103718245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="783" src="https://img-blog.csdnimg.cn/20190924103738136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>10、对服务器自身进行监控</p>

<p><img alt="" class="has" height="676" src="https://img-blog.csdnimg.cn/20190924103858939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>11、解决中文乱码无法显示的问题</p>

<p><img alt="" class="has" height="710" src="https://img-blog.csdnimg.cn/2019092410410690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODcyNjEwLzIwMTgwNS84NzI2MTAtMjAxODA1MjIxNTM4NDE3MjUtMjA5MzI2NjkzOS5wbmc?x-oss-process=image/format,png"></p>

<p>从我们电脑win7里面找到黑体右键复制到桌面然后拉到zabbix服务器上面</p>

<p>直接修改字体名字</p>

<p>切换到这个目录下面: /usr/share/zabbix/fonts</p>

<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODcyNjEwLzIwMTgwNS84NzI2MTAtMjAxODA1MjIxNTM4NTY2NDQtMTU5ODMyMjU2Mi5wbmc?x-oss-process=image/format,png"></p>

<p>现在的中文字体是显示正常的了</p>

<p><img alt="" class="has" height="707" src="https://img-blog.csdnimg.cn/20190924104635322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                                    ]]></description></item><item><title>Centos7安装宝塔控制面板</title><link>http://www.cnblogs.com/heian99/archive/2019/09/24/11972252.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 24 Sep 2019 01:42:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/24/11972252.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B" rel="nofollow">宝塔面板安装和使用图文教程</a></p>

<p id="1%2C%E9%80%9A%E8%BF%87ssh%E5%B7%A5%E5%85%B7%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#1%2C%E9%80%9A%E8%BF%87ssh%E5%B7%A5%E5%85%B7%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">1,通过ssh工具登录服务器</a></p>

<p id="2%EF%BC%8C%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF" rel="nofollow">2，安装宝塔面板</a></p>

<p id="2%EF%BC%8C%E7%99%BB%E5%BD%95%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E7%99%BB%E5%BD%95%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF" rel="nofollow">2，登录宝塔面板</a></p>

<p id="3%EF%BC%8C%E8%AE%BE%E7%BD%AE%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF-toc" style="margin-left:40px;"><a href="#3%EF%BC%8C%E8%AE%BE%E7%BD%AE%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF" rel="nofollow">3，设置宝塔面板</a></p>

<p id="3.1%EF%BC%8C%E9%A6%96%E5%85%88%E6%88%91%E4%BB%AC%E8%BF%9B%E5%85%A5%E9%9D%A2%E6%9D%BF%E8%AE%BE%E7%BD%AE-toc" style="margin-left:80px;"><a href="#3.1%EF%BC%8C%E9%A6%96%E5%85%88%E6%88%91%E4%BB%AC%E8%BF%9B%E5%85%A5%E9%9D%A2%E6%9D%BF%E8%AE%BE%E7%BD%AE" rel="nofollow">3.1，首先我们进入面板设置</a></p>

<p id="3.2%EF%BC%8C%E6%9B%B4%E6%94%B9%E9%9D%A2%E6%9D%BF%E7%AB%AF%E5%8F%A3-toc" style="margin-left:80px;"><a href="#3.2%EF%BC%8C%E6%9B%B4%E6%94%B9%E9%9D%A2%E6%9D%BF%E7%AB%AF%E5%8F%A3" rel="nofollow">3.2，更改面板端口</a></p>

<p id="3.3%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D-toc" style="margin-left:80px;"><a href="#3.3%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D" rel="nofollow">3.3，绑定域名</a></p>

<p id="3.4%EF%BC%8C%E7%BB%91%E5%AE%9Aip-toc" style="margin-left:80px;"><a href="#3.4%EF%BC%8C%E7%BB%91%E5%AE%9Aip" rel="nofollow">3.4，绑定ip</a></p>

<p id="3.5%EF%BC%8C%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E9%9D%A2%E6%9D%BF%E7%94%A8%E6%88%B7%E5%92%8C%E5%AF%86%E7%A0%81-toc" style="margin-left:80px;"><a href="#3.5%EF%BC%8C%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E9%9D%A2%E6%9D%BF%E7%94%A8%E6%88%B7%E5%92%8C%E5%AF%86%E7%A0%81" rel="nofollow">3.5，更改默认的面板用户和密码</a></p>

<p id="3.5%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%AE%9D%E5%A1%94%E8%B4%A6%E5%8F%B7-toc" style="margin-left:80px;"><a href="#3.5%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%AE%9D%E5%A1%94%E8%B4%A6%E5%8F%B7" rel="nofollow">3.5，绑定宝塔账号</a></p>

<p id="3.6%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-toc" style="margin-left:80px;"><a href="#3.6%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F" rel="nofollow">3.6，绑定微信小程序</a></p>

<p id="4%EF%BC%8C%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#4%EF%BC%8C%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE" rel="nofollow">4，宝塔面板安全设置</a></p>

<p id="5%EF%BC%8C%E5%AE%89%E8%A3%85%E9%9D%A2%E6%9D%BF%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#5%EF%BC%8C%E5%AE%89%E8%A3%85%E9%9D%A2%E6%9D%BF%E7%8E%AF%E5%A2%83" rel="nofollow">5，安装面板环境</a></p>

<p id="6%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99-toc" style="margin-left:40px;"><a href="#6%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99" rel="nofollow">6，创建网站</a></p>

<p id="7%EF%BC%8C%E8%B4%AD%E4%B9%B0%E6%8F%92%E4%BB%B6-toc" style="margin-left:40px;"><a href="#7%EF%BC%8C%E8%B4%AD%E4%B9%B0%E6%8F%92%E4%BB%B6" rel="nofollow">7，购买插件</a></p>

<p id="8%EF%BC%8C%E5%8D%87%E7%BA%A7%E4%B8%BA%E4%B8%93%E4%B8%9A%E7%89%88-toc" style="margin-left:40px;"><a href="#8%EF%BC%8C%E5%8D%87%E7%BA%A7%E4%B8%BA%E4%B8%93%E4%B8%9A%E7%89%88" rel="nofollow">8，升级为专业版</a></p>

<p id="%E6%9C%80%E5%90%8E%E7%A5%9D%E5%A4%A7%E5%AE%B6%E9%83%BD%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%EF%BC%81%E6%9C%80%E8%BF%91%E5%AE%9D%E5%A1%94%E5%81%9A%E6%8E%A8%E5%B9%BF%E6%B4%BB%E5%8A%A8%EF%BC%8C%E5%B8%8C%E6%9C%9B%E5%A4%A7%E5%AE%B6%E5%B8%AE%E5%BF%99%E8%80%81%E6%9D%A8%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BF%9E%E6%8E%A5%EF%BC%81-toc" style="margin-left:40px;">&nbsp;</p>

<hr id="hr-toc"><h1 id="%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B">宝塔面板安装和使用图文教程</h1>

<p>&nbsp;</p>

<p>如果你要安装宝塔linux面板,你要准备好一个纯净版的linux操作系统，没有安装过其它环境带的Apache/Nginx/php/MySQL（已有环境不可安装）。支持的操作系统有CentOS，Ubuntu、Debian、Fedora。这里给大家演示的是centos7.5。</p>

<h2 id="1%2C%E9%80%9A%E8%BF%87ssh%E5%B7%A5%E5%85%B7%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8">1,通过ssh工具登录服务器</h2>

<p>这里推荐大家使用xshell进行登录。注意要开放ssh连接的端口，一般默认是22，为了网站安全推荐大家更换ssh登录端口。设置为不常用的端口。<img alt="" class="has" height="682" src="https://img-blog.csdnimg.cn/2019092409444732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="662"></p>

<p>输入账号和密码，注意密码在输入时是不显示的，大家不要以为密码没输入。</p>

<h2 id="2%EF%BC%8C%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF">2，安装宝塔面板</h2>

<p>执行以下代码进行安装宝塔6.9免费版。宝塔6.9版本已经很稳定了，推荐大家直接安装6.9版本（注意：宝塔linux6.0版本是基于centos7开发的，务必使用centos7.x 系统）</p>

<pre>

<code class="language-html hljs">&nbsp;</code></pre>

<ol><li>
	<pre class="has"><code>[root@wei ~]# yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh
</code></pre>

	<p>&nbsp;</p>
	</li>
</ol><p>如果大家系统是centos7以下的大家还是乖乖使用宝塔5.9的安装脚本（Centos官方已宣布在2020年停止对Centos6的维护更新，推荐大家装系统直接安装centos7）</p>

<pre>

<code class="language-html hljs">&nbsp;</code></pre>

<ol><li>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh</li>
</ol><p>回车进行安装。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180923232554.png" rel="nofollow"><img alt="" class="has" height="91" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTIzMjMyNTU0LnBuZw?x-oss-process=image/format,png" width="823"></a></p>

<p>输入y，并回车。接下来便是等待宝塔面板进行安装。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180923232950.png" rel="nofollow"><img alt="" class="has" height="218" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTIzMjMyOTUwLnBuZw?x-oss-process=image/format,png" width="824"></a></p>

<p>我们得到登录宝塔面板的URL,账号和密码。</p>

<h2 id="2%EF%BC%8C%E7%99%BB%E5%BD%95%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF">2，登录宝塔面板</h2>

<p>安装完成宝塔面板后，我们就可以在浏览器中访问了。复制Bt-panel中的URL到浏览器上访问。注意要打开服务器上的8888端口，关于如何打开服务器端口，你可以在本站中搜索答案。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180923233955.png" rel="nofollow"><img alt="宝塔面板安装和使用图文教程" class="has" height="92" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc2hvcnRwaXhlbC5haS9zcGFpL3dfNzQ4K3FfbG9zc2xlc3MrcmV0X2ltZyt0b193ZWJwL2h0dHBzOi8vd3d3Lmxhb3lhbmdibG9nLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS8yMDE4MDkyMzIzMzk1NS5wbmc?x-oss-process=image/format,png" width="869"></a><a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180923233704.png" rel="nofollow"><img alt="" class="has" height="608" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTIzMjMzNzA0LnBuZw?x-oss-process=image/format,png" width="775"></a></p>

<p>输入默认的账号和密码进行登录。</p>

<h2 id="3%EF%BC%8C%E8%AE%BE%E7%BD%AE%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF">3，设置宝塔面板</h2>

<p>登陆后进入宝塔面板我们可以看到如下图所示，你可以选择LNMP或者LAMP进行安装。看大家网站需要什么环境进行选择。如果是生产环境推荐大家使用编译安装，如果只是测试环境选择极速安装。两者的区别是编译安装慢但稳定，极速安装虽然慢但是没编译安装稳定。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180923234416.png" rel="nofollow"><img alt="" class="has" height="477" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTIzMjM0NDE2LTEwMjR4NDc3LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>推荐大家首次进入宝塔面板前不要进行环境的安装，因为在安装环境不能更改宝塔面板的设置。推荐大家先更改宝塔面板的默认设置，编译安装环境将近一个小时。在这段时间里我们先将宝塔面板设置好提高面板的安全性。</p>

<h3 id="3.1%EF%BC%8C%E9%A6%96%E5%85%88%E6%88%91%E4%BB%AC%E8%BF%9B%E5%85%A5%E9%9D%A2%E6%9D%BF%E8%AE%BE%E7%BD%AE">3.1，首先我们进入面板设置</h3>

<p><a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180923235657.png" rel="nofollow"><img alt="" class="has" height="486" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTIzMjM1NjU3LTEwMjR4NDg2LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<h3 id="3.2%EF%BC%8C%E6%9B%B4%E6%94%B9%E9%9D%A2%E6%9D%BF%E7%AB%AF%E5%8F%A3">3.2，更改面板端口</h3>

<p>将端口更改为不常用的端口。</p>

<h3 id="3.3%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D">3.3，绑定域名</h3>

<p>你可以绑定一个域名绑定完域名后只能通过你绑定的域名来访问面板。</p>

<h3 id="3.4%EF%BC%8C%E7%BB%91%E5%AE%9Aip">3.4，绑定ip</h3>

<p>如果你有固定的ip，你可绑定ip访问，绑定了ip访问你只能通过绑定得这个ip进行访问。如果你是家用电脑就不要绑定ip了，因为家用电脑的ip是动态的。这就会造成ip发生改变面板访问不了。</p>

<h3 id="3.5%EF%BC%8C%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84%E9%9D%A2%E6%9D%BF%E7%94%A8%E6%88%B7%E5%92%8C%E5%AF%86%E7%A0%81">3.5，更改默认的面板用户和密码</h3>

<p>更改宝塔安装完成时的默认用户名和密码，设置一个自己能记住的用户名和密码，密码不要太简单了。</p>

<h3 id="3.5%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%AE%9D%E5%A1%94%E8%B4%A6%E5%8F%B7">3.5，绑定宝塔账号</h3>

<p>如果你有宝塔账号你可以绑定下，没有的话可以去宝塔官网申请。宝塔账号在购买付费插件，开通专业版时要用到。要去注册账号</p>

<h3 id="3.6%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F">3.6，绑定微信小程序</h3>

<p>由于微信小程序是付费插件，你只有购买了或者开通专业版才能使用。微信小程序能够监控服务器，方便用户随时查看服务器状态。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924002728.png" rel="nofollow"><img alt="" class="has" height="521" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDAyNzI4LTEwMjR4NTIxLnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<h2 id="4%EF%BC%8C%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE">4，宝塔面板安全设置</h2>

<p>在这里你可以开启和禁用一些端口。推荐大家更改ssh端口，和禁用ping。更改FTP端口。更改phpadmin默认端口。不常用的端口可以把它关闭，等要使用了在开启。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924004619.png" rel="nofollow"><img alt="" class="has" height="292" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDA0NjE5LTEwMjR4MjkyLnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>&nbsp;</p>

<h2 id="5%EF%BC%8C%E5%AE%89%E8%A3%85%E9%9D%A2%E6%9D%BF%E7%8E%AF%E5%A2%83">5，安装面板环境</h2>

<p>在软件管理选择你所需要的网站环境进行安装。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924002833.png" rel="nofollow"><img alt="" class="has" height="482" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDAyODMzLTEwMjR4NDgyLnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>在这里老杨选择LNMP进行安装，即Linux+Nginx+Mysql+Php。</p>

<h2 id="6%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99">6，创建网站</h2>

<p>等网站环境安装完成后便可以创建网站，有两种方法可以创建网站。第一种直接在选择网站，选择添加站点，进行创建网站。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924005213.png" rel="nofollow"><img alt="" class="has" height="359" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDA1MjEzLTEwMjR4MzU5LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>第二种在软件管理中的宝塔插件中安装宝塔一键部署源码插件进行创建网站。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924004255.png" rel="nofollow"><img alt="" class="has" height="408" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDA0MjU1LTEwMjR4NDA4LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<h2 id="7%EF%BC%8C%E8%B4%AD%E4%B9%B0%E6%8F%92%E4%BB%B6">7，购买插件</h2>

<p>如果你在使用过程中需要用到某款插件你可以到软件管理&gt;付费插件进行购买。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924005542.png" rel="nofollow"><img alt="" class="has" height="456" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDA1NTQyLTEwMjR4NDU2LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>选择购买时间进行购买。</p>

<h2 id="8%EF%BC%8C%E5%8D%87%E7%BA%A7%E4%B8%BA%E4%B8%93%E4%B8%9A%E7%89%88">8，升级为专业版</h2>

<p>如果你在使用过程中需要使用到多款付费插件推荐大家升级专业版。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924005822.png" rel="nofollow"><img alt="" class="has" height="416" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDA1ODIyLTEwMjR4NDE2LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>选择时间并进行支付。</p>

<p>如果你有账号有购买过专业版你可以选择代金劵进行支付。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924010421.png" rel="nofollow"><img alt="" class="has" height="388" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDEwNDIxLTEwMjR4Mzg4LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p><a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924010655.png" rel="nofollow"><img alt="" class="has" height="448" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDEwNjU1LTEwMjR4NDQ4LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>刷新下面板在到期时间可以看到永久授权四个字。<a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924010814.png" rel="nofollow"><img alt="" class="has" height="185" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDEwODE0LTEwMjR4MTg1LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>如果升级不成功可以ssh登录到服务器执行升级代码进行升级。</p>

<pre>

<code class="language-html hljs">&nbsp;</code></pre>

<ol><li>wget -O update.sh http://download.bt.cn/install/update_pro.sh &amp;&amp; bash update.sh pro</li>
</ol><p><a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924011530.png" rel="nofollow"><img alt="" class="has" height="344" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDExNTMwLnBuZw?x-oss-process=image/format,png" width="818"></a></p>

<p>或者进入文件管理器，打开终端，粘贴升级代码，然后点击“发送”，手动升级到专业版。</p>

<p><a href="https://www.laoyangblog.com/wp-content/uploads/2018/09/20180924011916.png" rel="nofollow"><img alt="" class="has" height="438" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGFveWFuZ2Jsb2cuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE4LzA5LzIwMTgwOTI0MDExOTE2LTEwMjR4NDM4LnBuZw?x-oss-process=image/format,png" width="1024"></a></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux(Centos7)搭建LAMP(Apache+PHP+Mysql环境)</title><link>http://www.cnblogs.com/heian99/archive/2019/09/23/11972253.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 23 Sep 2019 06:13:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/23/11972253.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p style="margin-left:0px;">&nbsp;</p>

<p style="margin-left:0px;">&nbsp;</p>

<p id="Linux%E6%90%AD%E5%BB%BALAMP(Apache%2BPHP%2BMysql%E7%8E%AF%E5%A2%83)Centos7-toc" style="margin-left:0px;"><a href="#Linux%E6%90%AD%E5%BB%BALAMP(Apache%2BPHP%2BMysql%E7%8E%AF%E5%A2%83)Centos7" rel="nofollow">Linux搭建LAMP(Apache+PHP+Mysql环境)Centos7</a></p>

<p id="%E4%B8%80%E3%80%81%20%E6%A3%80%E6%9F%A5%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%20%E6%A3%80%E6%9F%A5%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83" rel="nofollow">一、 检查系统环境</a></p>

<p id="1%E3%80%81%E7%A1%AE%E8%AE%A4centos%E7%89%88%E6%9C%AC-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E7%A1%AE%E8%AE%A4centos%E7%89%88%E6%9C%AC" rel="nofollow">1、确认centos版本</a></p>

<p id="2%E3%80%81%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E8%BF%87apache-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E8%BF%87apache" rel="nofollow">2、检查是否安装过apache</a></p>

<p id="3%E3%80%81%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E8%BF%87Mysql-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E8%BF%87Mysql" rel="nofollow">3、检查是否安装过Mysql</a></p>

<p id="4%E3%80%81%E6%B8%85%E7%90%86Mysql%E7%97%95%E8%BF%B9-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E6%B8%85%E7%90%86Mysql%E7%97%95%E8%BF%B9" rel="nofollow">4、清理Mysql痕迹</a></p>

<p id="5%E3%80%81%E5%8D%B8%E8%BD%BDApache%E5%8C%85-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%8D%B8%E8%BD%BDApache%E5%8C%85" rel="nofollow">5、卸载Apache包</a></p>

<p id="%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85Apache%E3%80%81PHP%E3%80%81Mysql-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85Apache%E3%80%81PHP%E3%80%81Mysql" rel="nofollow">二、安装Apache、PHP、Mysql</a></p>

<p id="1%E3%80%81%E5%AE%89%E8%A3%85apache-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%AE%89%E8%A3%85apache" rel="nofollow">1、安装apache</a></p>

<p id="2%E3%80%81%E5%AE%89%E8%A3%85Php-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%AE%89%E8%A3%85Php" rel="nofollow">2、安装Php</a></p>

<p id="3%E3%80%81%E5%AE%89%E8%A3%85php-fpm-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%AE%89%E8%A3%85php-fpm" rel="nofollow">3、安装php-fpm</a></p>

<p id="4%E3%80%81%E5%AE%89%E8%A3%85Mysql-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%AE%89%E8%A3%85Mysql" rel="nofollow">4、安装Mysql</a></p>

<p id="5%E3%80%81%E5%AE%89%E8%A3%85%20mysql-server-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%AE%89%E8%A3%85%20mysql-server" rel="nofollow">5、安装 mysql-server</a></p>

<p id="6%E3%80%81%E5%AE%89%E8%A3%85%20php-mysql-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E5%AE%89%E8%A3%85%20php-mysql" rel="nofollow">6、安装 php-mysql</a></p>

<p id="%E4%B8%89%E3%80%81%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E5%8C%85-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E5%8C%85" rel="nofollow">三、安装基本常用扩展包</a></p>

<p id="1%E3%80%81%E5%AE%89%E8%A3%85Apache%E6%89%A9%E5%B1%95%E5%8C%85-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%AE%89%E8%A3%85Apache%E6%89%A9%E5%B1%95%E5%8C%85" rel="nofollow">1、安装Apache扩展包</a></p>

<p id="2%E3%80%81%E5%AE%89%E8%A3%85PHP%E6%89%A9%E5%B1%95%E5%8C%85-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%AE%89%E8%A3%85PHP%E6%89%A9%E5%B1%95%E5%8C%85" rel="nofollow">2、安装PHP扩展包</a></p>

<p id="3%E3%80%81%E5%AE%89%E8%A3%85Mysql%E6%89%A9%E5%B1%95%E5%8C%85-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%AE%89%E8%A3%85Mysql%E6%89%A9%E5%B1%95%E5%8C%85" rel="nofollow">3、安装Mysql扩展包</a></p>

<p id="%E5%9B%9B%E3%80%81%E9%85%8D%E7%BD%AEApache%E3%80%81mysql%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E9%85%8D%E7%BD%AEApache%E3%80%81mysql%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8" rel="nofollow">四、配置Apache、mysql开机启动</a></p>

<p id="%E4%BA%94%E3%80%81%E9%85%8D%E7%BD%AEMysql-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E9%85%8D%E7%BD%AEMysql" rel="nofollow">五、配置Mysql</a></p>

<p id="%E5%85%AD%E3%80%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83" rel="nofollow">六、测试环境</a></p>

<p style="margin-left:40px;">&nbsp;</p>

<hr id="hr-toc"><h1>&nbsp;</h1>

<h1>&nbsp;</h1>

<h1 id="Linux%E6%90%AD%E5%BB%BALAMP(Apache%2BPHP%2BMysql%E7%8E%AF%E5%A2%83)Centos7">Linux搭建LAMP(Apache+PHP+Mysql环境)Centos7</h1>

<p>&nbsp;</p>

<p><strong>LAMP</strong>是指一组通常一起使用来运行动态网站或者服务器的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6" rel="nofollow">自由软件</a>名称首字母缩写：</p>

<ul><li>
	<p><a href="https://baike.baidu.com/item/Linux" rel="nofollow"><strong>L</strong>inux</a>，<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" rel="nofollow">操作系统</a></p>
	</li>
	<li>
	<p><a href="https://baike.baidu.com/item/Apache" rel="nofollow"><strong>A</strong>pache</a>，网页服务器</p>
	</li>
	<li>
	<p><a href="https://baike.baidu.com/item/MariaDB" rel="nofollow"><strong>M</strong>ariaDB</a>或<a href="https://baike.baidu.com/item/MySQL" rel="nofollow"><strong>M</strong>ySQL</a>，<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" rel="nofollow">数据库管理系统</a>（或者<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">数据库服务器</a>）</p>
	</li>
	<li>
	<p><a href="https://baike.baidu.com/item/PHP" rel="nofollow"><strong>P</strong>HP</a>、<a href="https://baike.baidu.com/item/Perl" rel="nofollow"><strong>P</strong>erl</a>或<a href="https://baike.baidu.com/item/Python" rel="nofollow"><strong>P</strong>ython</a>，<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80" rel="nofollow">脚本语言</a></p>
	</li>
</ul><p>&nbsp;</p>

<h2 id="%E4%B8%80%E3%80%81%20%E6%A3%80%E6%9F%A5%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83">一、 检查系统环境</h2>

<h3 id="1%E3%80%81%E7%A1%AE%E8%AE%A4centos%E7%89%88%E6%9C%AC"><br>
1、确认centos版本</h3>

<pre class="has"><code>[root@wei ~]# cat /etc/redhat-release 
CentOS Linux release 7.4.1708 (Core) </code></pre>

<p><img alt="" class="has" height="124" src="https://img-blog.csdnimg.cn/20190923142303573.png" width="352"></p>

<h3 id="2%E3%80%81%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E8%BF%87apache"><br>
2、检查是否安装过apache</h3>

<pre class="has"><code>
[root@wei ~]# rpm -qa |grep httpd
</code></pre>

<p><br>
或者：</p>

<p>apachectl -v<br>
或者：</p>

<p>httpd -v&nbsp;</p>

<h3 id="3%E3%80%81%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E8%BF%87Mysql"><br>
3、检查是否安装过Mysql</h3>

<pre class="has"><code>
[root@wei ~]# rpm -qa | mysql
</code></pre>

<h3 id="4%E3%80%81%E6%B8%85%E7%90%86Mysql%E7%97%95%E8%BF%B9"><br><br>
4、清理Mysql痕迹</h3>

<pre class="has"><code>[root@wei ~]# yum remove mysql
已加载插件：fastestmirror
参数 mysql 没有匹配
不删除任何软件包
[root@wei ~]# rm -rf /etc/my.cnf
</code></pre>

<h3 id="5%E3%80%81%E5%8D%B8%E8%BD%BDApache%E5%8C%85"><br>
5、卸载Apache包</h3>

<pre class="has"><code>[root@wei ~]# rpm -e httpd --nodeps

</code></pre>

<p><br><span style="color:#f33b45;">注意：如果是新的系统或者你从来没有尝试安装过，则以上步骤省略。</span></p>

<p>&nbsp;</p>

<h2 id="%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85Apache%E3%80%81PHP%E3%80%81Mysql">二、安装Apache、PHP、Mysql</h2>

<h3 id="1%E3%80%81%E5%AE%89%E8%A3%85apache"><br>
1、安装apache</h3>

<pre class="has"><code>[root@wei ~]# yum install httpd -y 

</code></pre>

<p><br>
直到返回</p>

<p>安装完成</p>

<p><img alt="" class="has" height="389" src="https://img-blog.csdnimg.cn/20190923143215324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="792"><br>
&nbsp;<br>
查看安装httpd</p>

<pre class="has"><code>[root@wei ~]# rpm -qa |grep httpd
httpd-tools-2.4.6-90.el7.centos.x86_64
httpd-2.4.6-90.el7.centos.x86_64
</code></pre>

<p><br>
表示安装成功！</p>

<h3 id="2%E3%80%81%E5%AE%89%E8%A3%85Php"><br>
2、安装Php</h3>

<p>&nbsp;</p>

<p>[root@localhost ~]# yum -y install php<br>
直到返回：</p>

<p><img alt="" class="has" height="416" src="https://img-blog.csdnimg.cn/20190923143401301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="771"><br>
&nbsp;<br>
查看安装php的软件</p>

<pre class="has"><code>[root@wei ~]# rpm -qa |grep php
php-common-5.4.16-46.el7.x86_64
php-5.4.16-46.el7.x86_64
php-cli-5.4.16-46.el7.x86_64
</code></pre>

<h3 id="3%E3%80%81%E5%AE%89%E8%A3%85php-fpm"><br>
3、安装php-fpm</h3>

<pre class="has"><code>[root@wei ~]# yum -y install php-fpm</code></pre>

<p><br>
直到返回：</p>

<p><img alt="" class="has" height="499" src="https://img-blog.csdnimg.cn/20190923143517305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="789"></p>

<h3 id="4%E3%80%81%E5%AE%89%E8%A3%85Mysql">4、安装Mysql</h3>

<pre class="has"><code>[root@wei ~]# yum -y install mysql
</code></pre>

<p><br>
直到返回：</p>

<blockquote>
<p><img alt="" class="has" height="387" src="https://img-blog.csdnimg.cn/20190923143654589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="814">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;<br><span style="color:#f33b45;">Complete!<br>
7.2版本的Centos已经把mysql更名为mariadb，表示安装成功！</span></p>
</blockquote>

<h3 id="5%E3%80%81%E5%AE%89%E8%A3%85%20mysql-server">5、安装 mysql-server</h3>

<pre class="has"><code>[root@wei ~]# yum -y install mysql-server
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.tuna.tsinghua.edu.cn
没有可用软件包 mysql-server。
错误：无须任何处理
</code></pre>

<p><br><span style="color:#f33b45;">返回错误！！！</span><br><span style="color:#7c79e5;">分析解决方案</span></p>

<p>&nbsp;</p>

<blockquote>
<ul><li>CentOS 7+ 版本将MySQL数据库软件从默认的程序列表中移除，用mariadb代替了，entos7配置教程上，大多都是安装mariadb，因为centos7默认将mariadb视作mysql。</li>
	<li>因为mysql被oracle收购后，原作者担心mysql闭源，所以又写了一个mariadb，这个数据库可以理解为mysql的分支。如果需要安装mariadb，只需通过yum就可。</li>
</ul></blockquote>

<p><span style="color:#f33b45;">有两种解决方案：</span></p>

<blockquote>
<p>一是安装mariadb</p>

<p>[root@localhost ~]# yum install -y mariadb&nbsp;</p>

<p>&nbsp;</p>

<p>二是从官网下载mysql-server</p>
</blockquote>

<p><strong>采用第二种方案：</strong></p>

<pre class="has"><code>[root@wei ~]# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</code></pre>

<pre class="has"><code>[root@wei ~]# rpm -ivh mysql-community-release-el7-5.noarch.rpm 
</code></pre>

<pre class="has"><code>[root@wei ~]# yum -y install wget</code></pre>

<p><span style="color:#f33b45;"><strong>下载中.......</strong></span></p>

<p><img alt="" class="has" height="353" src="https://img-blog.csdnimg.cn/20190923144254472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="801"><br><br><span style="color:#f33b45;"><strong>安装成功！！！</strong></span></p>

<p><img alt="" class="has" height="241" src="https://img-blog.csdnimg.cn/20190923144604448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="790"></p>

<h3 id="6%E3%80%81%E5%AE%89%E8%A3%85%20php-mysql"><br>
6、安装 php-mysql</h3>

<pre class="has"><code>[root@wei ~]# yum -y install php-mysql
</code></pre>

<p><br>
直到返回：</p>

<p><img alt="" class="has" height="302" src="https://img-blog.csdnimg.cn/2019092314464018.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="809"><br>
安装成功！！！</p>

<h2 id="%E4%B8%89%E3%80%81%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E5%8C%85">三、安装基本常用扩展包</h2>

<h3 id="1%E3%80%81%E5%AE%89%E8%A3%85Apache%E6%89%A9%E5%B1%95%E5%8C%85"><br>
1、安装Apache扩展包</h3>

<pre class="has"><code>[root@wei ~]# yum -y install httpd-manual mod_ssl mod_perl mod_auth_mysql&nbsp;
</code></pre>

<p><img alt="" class="has" height="232" src="https://img-blog.csdnimg.cn/20190923144740866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="813"><br>
安装成功！！！</p>

<h3 id="2%E3%80%81%E5%AE%89%E8%A3%85PHP%E6%89%A9%E5%B1%95%E5%8C%85"><br>
2、安装PHP扩展包</h3>

<pre class="has"><code>[root@wei ~]# yum -y install php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc php-devel
</code></pre>

<p><img alt="" class="has" height="253" src="https://img-blog.csdnimg.cn/20190923144817774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="799"><br>
安装成功！！！</p>

<h3 id="3%E3%80%81%E5%AE%89%E8%A3%85Mysql%E6%89%A9%E5%B1%95%E5%8C%85">3、安装Mysql扩展包</h3>

<pre class="has"><code>[root@wei ~]# yum -y install mysql-connector-odbc mysql-devel libdbi-dbd-mysql
</code></pre>

<p><img alt="" class="has" height="203" src="https://img-blog.csdnimg.cn/20190923144847427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="827"><br>
安装成功！！！</p>

<h2 id="%E5%9B%9B%E3%80%81%E9%85%8D%E7%BD%AEApache%E3%80%81mysql%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8">四、配置Apache、mysql开机启动</h2>

<p><br>
重启Apache、mysql服务(注意这里和centos6有区别,Cenots7+不能使用6的方式)</p>

<p>systemctl start httpd.service #启动apache<br>
systemctl stop httpd.service #停止apache<br>
systemctl restart httpd.service #重启apache<br>
systemctl enable httpd.service #设置apache开机启动<br>
如果是采用方法一安装的mariadb,安装完成以后使用下面的命令开启数据库服务：</p>

<p>#启动MariaDB</p>

<pre class="has"><code>[root@wei~]# systemctl start mariadb.service &nbsp;&nbsp;</code></pre>

<p>#停止MariaDB</p>

<pre class="has"><code>[root@wei~]# systemctl stop mariadb.service &nbsp;&nbsp;</code></pre>

<p>#重启MariaDB</p>

<pre class="has"><code>[root@wei~]# systemctl restart mariadb.service &nbsp;</code></pre>

<p>#设置开机启动</p>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei~]# systemctl enable mariadb.service &nbsp;</code></pre>

<p><br>
重启对应服务</p>

<p>service mysqld restart<br>
&nbsp;<br>
service php-fpm start<br>
&nbsp;<br>
service httpd restart</p>

<h2 id="%E4%BA%94%E3%80%81%E9%85%8D%E7%BD%AEMysql"><br>
五、配置Mysql</h2>

<p><span style="color:#f33b45;"><strong>注意：要启动mysql才能进去</strong></span><br>
初次安装mysql是没有密码的,我们要设置密码，mysql的默认账户为root</p>

<p>设置 MySQL 数据 root 账户的密码：</p>

<pre class="has"><code>[root@wei etc]# mysql -u root -p
</code></pre>

<p><img alt="" class="has" height="358" src="https://img-blog.csdnimg.cn/20190923145806809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="885"></p>

<h2 id="%E5%85%AD%E3%80%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83">六、测试环境</h2>

<p><span style="color:#f33b45;"><strong>注意：要启动httpd才能进去</strong></span></p>

<p><img alt="" class="has" height="234" src="https://img-blog.csdnimg.cn/20190923150046879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="792"><br><strong>1、我们在浏览器地址栏输入http://localhost/如下图，说明我们的apache测试成功</strong></p>

<p><img alt="" class="has" height="749" src="https://img-blog.csdnimg.cn/20190923150114452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>2、测试PHP</strong></p>

<p><br>
进入apache的web根目录：/var/www/html 中写一个最简单的php测试页面</p>

<pre class="has"><code>[root@wei ~]# cd /var/www/html/
[root@wei html]# vi phpinfo.php
</code></pre>

<p><br>
&nbsp;<br>
3、进入到了控制模式之后按键盘字母 i 进入到编辑模式，将如下代码输入到文件中</p>

<pre class="has"><code>&lt;?php
echo "&lt;title&gt;Phpinfo Test.php&lt;/title&gt;";
phpinfo()
?&gt;</code></pre>

<p><br>
按 esc 退出编辑模式，回到控制模式，输入 :wq 然后回车，</p>

<p>重启apache服务器</p>

<pre class="has"><code>[root@wei html]# systemctl restart httpd
</code></pre>

<p>在浏览器中输入服地址http://localhost/phpinfo.php</p>

<p>出现下图则成功。</p>

<p><img alt="" class="has" height="905" src="https://img-blog.csdnimg.cn/2019092315073758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2>&nbsp;</h2>
                                    ]]></description></item><item><title>Maven+SSM框架，实现单表简单的增删改查</title><link>http://www.cnblogs.com/heian99/archive/2019/09/16/11972255.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 16 Sep 2019 11:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/16/11972255.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="1.%E5%88%9B%E5%BB%BAweb%20Maven%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#1.%E5%88%9B%E5%BB%BAweb%20Maven%E9%A1%B9%E7%9B%AE" rel="nofollow">1.创建web Maven项目</a></p>

<p id="2.%E5%88%9B%E5%BB%BAjava%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E5%92%8Cresources%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.%E5%88%9B%E5%BB%BAjava%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E5%92%8Cresources%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6" rel="nofollow">2.创建java源码文件和resources资源文件</a></p>

<p id="2.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9Ajdbc.properties-toc" style="margin-left:80px;"><a href="#2.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9Ajdbc.properties" rel="nofollow">3.创建数据库配置文件：jdbc.properties</a></p>

<p id="3.%E9%A1%B9%E7%9B%AE%E6%80%BB%E4%BD%93%E7%9B%AE%E5%BD%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.%E9%A1%B9%E7%9B%AE%E6%80%BB%E4%BD%93%E7%9B%AE%E5%BD%95%EF%BC%9A" rel="nofollow">4.项目总体目录：</a></p>

<p id="4.%E6%B7%BB%E5%8A%A0spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9AapplicationContext.xml-toc" style="margin-left:80px;"><a href="#4.%E6%B7%BB%E5%8A%A0spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9AapplicationContext.xml" rel="nofollow">5.添加spring配置文件：applicationContext.xml</a></p>

<p id="5.%E6%B7%BB%E5%8A%A0springMVC%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9AspringMVC.xml-toc" style="margin-left:80px;"><a href="#5.%E6%B7%BB%E5%8A%A0springMVC%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9AspringMVC.xml" rel="nofollow">6.添加springMVC配置文件：springMVC.xml</a></p>

<p id="7.%E4%BF%AE%E6%94%B9web.xml-toc" style="margin-left:80px;"><a href="#7.%E4%BF%AE%E6%94%B9web.xml" rel="nofollow">7.修改web.xml</a></p>

<p id="8.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E8%A1%A8-toc" style="margin-left:80px;"><a href="#8.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E8%A1%A8" rel="nofollow">8.创建数据库相关表</a></p>

<p id="7.%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BApojo%E7%B1%BB%EF%BC%9AUser.java-toc" style="margin-left:80px;"><a href="#7.%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BApojo%E7%B1%BB%EF%BC%9AUser.java" rel="nofollow">9.根据数据库表创建pojo类：User.java</a></p>

<p id="10.%E7%BC%96%E5%86%99dao%E5%B1%82-%3Emapper%E6%8E%A5%E5%8F%A3%E5%92%8Cxml%E6%96%87%E4%BB%B6%20%EF%BC%9AUserMapper.java%E3%80%81UserMapper.xml-toc" style="margin-left:80px;"><a href="#10.%E7%BC%96%E5%86%99dao%E5%B1%82-%3Emapper%E6%8E%A5%E5%8F%A3%E5%92%8Cxml%E6%96%87%E4%BB%B6%20%EF%BC%9AUserMapper.java%E3%80%81UserMapper.xml" rel="nofollow">10.编写dao层-&gt;mapper接口和xml文件 ：UserMapper.java、UserMapper.xml</a></p>

<p id="11.%E7%BC%96%E5%86%99service%E5%B1%82-%3EUserService.java%E3%80%81UserServiceImpl.java-toc" style="margin-left:80px;"><a href="#11.%E7%BC%96%E5%86%99service%E5%B1%82-%3EUserService.java%E3%80%81UserServiceImpl.java" rel="nofollow">11.编写service层-&gt;UserService.java、UserServiceImpl.java</a></p>

<p id="12.%E7%BC%96%E5%86%99controller%E5%B1%82-%3EUserController.java-toc" style="margin-left:80px;"><a href="#12.%E7%BC%96%E5%86%99controller%E5%B1%82-%3EUserController.java" rel="nofollow">12.编写controller层-&gt;UserController.java</a></p>

<p id="13.%E5%9C%A8jsp%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%88%9B%E5%BB%BAedit.jsp%E5%92%8Cview.jsp-toc" style="margin-left:80px;"><a href="#13.%E5%9C%A8jsp%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%88%9B%E5%BB%BAedit.jsp%E5%92%8Cview.jsp" rel="nofollow">13.在jsp文件夹下创建edit.jsp和view.jsp</a></p>

<p id="14.%E9%85%8D%E7%BD%AEtomcat%EF%BC%8C%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%AE%B0%E5%BE%97%E5%8A%A0%E8%BD%BD%E9%A1%B9%E7%9B%AE%E5%90%8D%EF%BC%89-toc" style="margin-left:80px;"><a href="#14.%E9%85%8D%E7%BD%AEtomcat%EF%BC%8C%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%AE%B0%E5%BE%97%E5%8A%A0%E8%BD%BD%E9%A1%B9%E7%9B%AE%E5%90%8D%EF%BC%89" rel="nofollow">14.配置tomcat，启动服务器（记得加载项目名）</a></p>

<p id="15.%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%88%E5%B7%B2%E7%BB%8F%E6%88%90%E5%8A%9F%EF%BC%89-toc" style="margin-left:80px;"><a href="#15.%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%88%E5%B7%B2%E7%BB%8F%E6%88%90%E5%8A%9F%EF%BC%89" rel="nofollow">15.查看运行结果（已经成功）</a></p>

<p id="16.%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81-toc" style="margin-left:80px;"><a href="#16.%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81" rel="nofollow">16.项目源码</a></p>

<hr id="hr-toc"><p>前言：学习maven后，感觉很厉害就搭建个项目小项目玩玩。</p>

<p>功能：实现表的增删改查</p>

<p>工具：IDEA&nbsp; &nbsp; jdk 1.8&nbsp; &nbsp;mysql&nbsp;&nbsp;</p>

<p>整体项目结构：</p>

<p><img alt="" class="has" height="947" src="https://img-blog.csdnimg.cn/2019091620011890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="510"></p>

<h3 id="1.%E5%88%9B%E5%BB%BAweb%20Maven%E9%A1%B9%E7%9B%AE">1.创建web Maven项目</h3>

<p><img alt="" class="has" height="972" src="https://img-blog.csdnimg.cn/20190916195653894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1109"></p>

<p><img alt="" class="has" height="819" src="https://img-blog.csdnimg.cn/2019091619584781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1082"></p>

<p><img alt="" class="has" height="815" src="https://img-blog.csdnimg.cn/20190916195913390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1078"></p>

<p><img alt="" class="has" height="812" src="https://img-blog.csdnimg.cn/20190916195940401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1070"></p>

<p>，接下来在pom文件加入项目所需依赖：</p>

<pre class="has"><code class="language-java"> &lt;dependencies&gt;
    &lt;!--Spring框架核心库 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring Web --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--连接驱动--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;5.1.46&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--数据源--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;druid&lt;/artifactId&gt;
      &lt;version&gt;1.1.10&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- mybatis ORM框架 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.4.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--mybatis-spring适配器 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
      &lt;version&gt;1.3.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--整合mybatis如果不加这个包会报错 java.lang.NoClassDefFoundError: org/springframewor--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--测试--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.12&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--引入JSTL标签--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;jstl&lt;/artifactId&gt;
      &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;taglibs&lt;/groupId&gt;
      &lt;artifactId&gt;standard&lt;/artifactId&gt;
      &lt;version&gt;1.1.2&lt;/version&gt;
    &lt;/dependency&gt;

  &lt;/dependencies&gt;
</code></pre>

<h3 id="2.%E5%88%9B%E5%BB%BAjava%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E5%92%8Cresources%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><a name="t1"></a>2.创建java源码文件和resources资源文件</h3>

<p><img alt="" class="has" height="170" src="https://img-blog.csdnimg.cn/20190916200434156.png" width="667"></p>

<p><img alt="" class="has" height="1025" src="https://img-blog.csdnimg.cn/20190916200522425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="648"></p>

<h3 id="2.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9Ajdbc.properties"><a></a>3.创建数据库配置文件：jdbc.properties</h3>

<p>resources目录下添加：jdbc.properties</p>

<pre class="has"><code class="language-sql">#数据库配置文件
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=root</code></pre>

<h3 id="3.%E9%A1%B9%E7%9B%AE%E6%80%BB%E4%BD%93%E7%9B%AE%E5%BD%95%EF%BC%9A"><a name="t2"></a>4.项目总体目录：</h3>

<p>先给出项目总体目录</p>

<p>创建好java目录下的分层的包，resources下创建存放mapper的包，WEB-INF下创建jsp放跳转的页面（下面的配置文件中会配置这些路径）</p>

<p><img alt="" class="has" height="788" src="https://img-blog.csdnimg.cn/20190916200721919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="523"></p>

<h3 id="4.%E6%B7%BB%E5%8A%A0spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9AapplicationContext.xml"><a name="t3"></a>5.添加spring配置文件：applicationContext.xml</h3>

<p>resources目录下添加：applicationContext.xml</p>

<pre class="has"><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

    &lt;!-- 导入数据库配置文件 --&gt;
    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;
    &lt;!-- 扫描包  这里的包需要根据自己java目录下的包名修改 --&gt;
    &lt;context:component-scan base-package="com.demo.service" /&gt;
    &lt;!-- 配置数据库连接池 --&gt;
    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;
        &lt;!-- 基本属性 url、user、password --&gt;
        &lt;property name="url" value="${jdbc.url}" /&gt;
        &lt;property name="username" value="${jdbc.username}" /&gt;
        &lt;property name="password" value="${jdbc.password}" /&gt;

    &lt;/bean&gt;

    &lt;!--Mybatis的SessionFactory配置--&gt;
    &lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
        &lt;property name="typeAliasesPackage" value="com.demo.pojo" /&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;property name="mapperLocations" value="classpath:mapper/*.xml"/&gt;

    &lt;/bean&gt;

    &lt;!--Mybatis的Mapper文件识别--&gt;
    &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;
        &lt;property name="basePackage" value="com.demo.dao"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>

<h3 id="5.%E6%B7%BB%E5%8A%A0springMVC%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9AspringMVC.xml"><a name="t4"></a>6.添加springMVC配置文件：springMVC.xml</h3>

<p>resources目录下添加：springMVC.xml，并且根据文件中‘视图定位’的配置，所以在WEB-INF下创建jsp文件夹</p>

<pre class="has"><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd"&gt;


    &lt;context:component-scan base-package="com.demo.controller" /&gt;
    &lt;!--
        配置如果没有&lt;mvc:annotation-driven/&gt;，
        那么所有的Controller可能就没有解析，所有当有请求时候都没有匹配的处理请求类，
        就都去&lt;mvc:default-servlet-handler/&gt;即default servlet处理了。
        添加上&lt;mvc:annotation-driven/&gt;后，
        相应的do请求被Controller处理，而静态资源因为没有相应的Controller就会被default servlet处理。
        总之没有相应的Controller就会被default servlet处理就ok了。
    --&gt;
    &lt;mvc:annotation-driven /&gt;
    &lt;!--开通静态资源的访问--&gt;
    &lt;mvc:default-servlet-handler /&gt;

    &lt;!-- 视图定位 --&gt;
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
        &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt;
        &lt;property name="prefix" value="/WEB-INF/view/" /&gt;
        &lt;property name="suffix" value=".jsp" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>

<h3 id="7.%E4%BF%AE%E6%94%B9web.xml"><a name="t5"></a>7.修改web.xml</h3>

<pre class="has"><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://java.sun.com/xml/ns/javaee"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
         version="2.5"&gt;

  &lt;!-- spring的配置文件--&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;

  &lt;!--中文过滤器--&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

  &lt;!-- spring mvc核心：分发servlet --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- spring mvc的配置文件 --&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre>

<h3 id="8.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E8%A1%A8"><a name="t6"></a>8.创建数据库相关表</h3>

<p>&nbsp;</p>

<pre class="has"><code>/*
 Navicat Premium Data Transfer

 Source Server         : phpStudy
 Source Server Type    : MySQL
 Source Server Version : 50553
 Source Host           : localhost:3306
 Source Schema         : test

 Target Server Type    : MySQL
 Target Server Version : 50553
 File Encoding         : 65001

 Date: 16/09/2019 19:46:40
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET gbk COLLATE gbk_chinese_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET gbk COLLATE gbk_chinese_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 9 CHARACTER SET = gbk COLLATE = gbk_chinese_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'cheng', '128946');
INSERT INTO `user` VALUES (3, 'eff', 'f');
INSERT INTO `user` VALUES (4, 'fwefw', 'wef');
INSERT INTO `user` VALUES (8, 'fwef', '13');

SET FOREIGN_KEY_CHECKS = 1;</code></pre>

<h3 id="7.%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BApojo%E7%B1%BB%EF%BC%9AUser.java">9.根据数据库表创建pojo类：User.java</h3>

<p>pojo的编写规则：数据库字段对应类字段，字段类型要一直 。</p>

<pre class="has"><code class="language-java">package com.demo.pojo;

import java.io.Serializable;

public class User implements Serializable {

    private Integer id;
    private String name;
    private String password;

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name == null ? null : name.trim();
    }
}
</code></pre>

<h3 id="10.%E7%BC%96%E5%86%99dao%E5%B1%82-%3Emapper%E6%8E%A5%E5%8F%A3%E5%92%8Cxml%E6%96%87%E4%BB%B6%20%EF%BC%9AUserMapper.java%E3%80%81UserMapper.xml">10.编写dao层-&gt;mapper接口和xml文件 ：UserMapper.java、UserMapper.xml</h3>

<p>UserMapper.xml放在resources\mapper下，UserMapper.java放在com.demo.dao这个包下：</p>

<p>注意namespace="com.demo.dao.UserMapper"，这里一定写对应的mapper接口具体路径</p>

<p>UserMapper接口的编写规则：</p>

<p>&nbsp; (1）方法名和对应的mapper配置文件中查询语句的id相同</p>

<p>（2）返回类型和resultType的类型一致，没有就是void。</p>

<p>（3）方法中的参数列表中的类型和parameterType一致。</p>

<p>（4）mapper配置文件的namespace对应mapper接口类的全路径。</p>

<p>&nbsp;</p>

<p>UserMapper.java</p>

<pre class="has"><code class="language-java">package com.demo.dao;

import com.demo.pojo.User;

import java.util.List;

public interface UserMapper {

    List&lt;User&gt; list();

    void del(int id);

    void update(User user);

    void add(User user);

    User get(int id);

}</code></pre>

<p>&nbsp;</p>

<p>UserMapper.xml</p>

<p>&nbsp;</p>

<pre class="has"><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;
&lt;mapper namespace="com.demo.dao.UserMapper" &gt;

    &lt;select id="list" resultType="user"&gt;
    select * from user
  &lt;/select&gt;

    &lt;update id="update" parameterType="user"&gt;
     update user set name=#{name} ,password=#{password} where id=#{id}
  &lt;/update&gt;

    &lt;insert id="add" parameterType="user"&gt;
     insert into user values (null,#{name},#{password});
  &lt;/insert&gt;

    &lt;delete id="del"&gt;
    delete from user where id=#{id}
  &lt;/delete&gt;

    &lt;select id="get" resultType="user"&gt;
    select * from user where id =#{id}
  &lt;/select&gt;

&lt;/mapper&gt;</code></pre>

<p>&nbsp;</p>

<h3 id="11.%E7%BC%96%E5%86%99service%E5%B1%82-%3EUserService.java%E3%80%81UserServiceImpl.java"><a name="t9"></a>11.编写service层-&gt;UserService.java、UserServiceImpl.java</h3>

<p>&nbsp;</p>

<p>UserService.java</p>

<pre class="has"><code class="language-java">package com.demo.service;

import com.demo.pojo.User;

import java.util.List;

public interface UserService {

    List&lt;User&gt; list();
    void del(int id);
    void update(User user);
    void add(User user);
    User get(int id);

}</code></pre>

<p>&nbsp;</p>

<p>UserServiceImpl.java</p>

<p>&nbsp;</p>

<pre class="has"><code>package com.demo.service.impl;

import com.demo.dao.UserMapper;
import com.demo.pojo.User;
import com.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserServiceImpl implements UserService{

    @Autowired
    UserMapper userMapper;
    public List&lt;User&gt; list() {
        return userMapper.list();
    }
    public void add(User user) {
        userMapper.add(user);
    }
    public void del(int id) {
        userMapper.del(id);
    }
    public void update(User user) {
        userMapper.update(user);
    }
    public User get(int id) {
        return userMapper.get(id);
    }


}</code></pre>

<h3 id="12.%E7%BC%96%E5%86%99controller%E5%B1%82-%3EUserController.java"><a name="t10"></a>12.编写controller层-&gt;UserController.java</h3>

<pre class="has"><code class="language-java">package com.demo.controller;

import com.demo.pojo.User;
import com.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.List;

@Controller
@RequestMapping("")
public class UserController {

    @Autowired
    UserService userService;
    @RequestMapping("list")
    public String list(Model model){
        List&lt;User&gt; us= userService.list();
        model.addAttribute("us", us);
        return "view";
    }
    @RequestMapping("add")
    public String add(User user,Model model){
        userService.add(user);
        return "redirect:list";
    }
    @RequestMapping("del")
    public String del(int id){
        userService.del(id);
        return "redirect:list";
    }
    @RequestMapping("editUI")
    public String editUI(int id,Model model){
        User user = userService.get(id);
        model.addAttribute("user",user);
        return "edit";
    }
    @RequestMapping("update")
    public String update(User user){
        userService.update(user);
        return "redirect:list";
    }

}</code></pre>

<h3 id="13.%E5%9C%A8jsp%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%88%9B%E5%BB%BAedit.jsp%E5%92%8Cview.jsp"><a name="t11"></a>13.在jsp文件夹下创建edit.jsp和view.jsp</h3>

<p>edit.jsp</p>

<pre class="has"><code class="language-java">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        #edit{width:300px;height:500px;margin: 100px auto}
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="edit"&gt;
    &lt;form action="/update"&gt;
        姓名：&lt;input type="text" name="name" value="${user.name}"/&gt;&lt;br/&gt;
        密码：&lt;input type="text" name="password" value="${user.password}"/&gt;&lt;br/&gt;
        &lt;input type="hidden" value="${user.id}" name="id"&gt;
        &lt;button type="submit" value=""&gt;修改&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>view.jsp</p>

<pre class="has"><code class="language-java">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        table,table tr th, table tr td { border:1px solid rgba(41, 36, 35, 0.96); }
        #mytable{width:300px;margin: 100px auto}
        #add{width:300px;height:500px;margin: 100px auto}
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="list"&gt;
    &lt;table id="mytable"&gt;
        &lt;thead&gt;
        &lt;th&gt;id&lt;/th&gt;
        &lt;th&gt;名字&lt;/th&gt;
        &lt;th&gt;密码&lt;/th&gt;
        &lt;th&gt;修改&lt;/th&gt;
        &lt;th&gt;删除&lt;/th&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        &lt;c:forEach items="${us}" var="user"&gt;
            &lt;tr&gt;
                &lt;td&gt;${user.id}&lt;/td&gt;
                &lt;td&gt;${user.name}&lt;/td&gt;
                &lt;td&gt;${user.password}&lt;/td&gt;
                &lt;td&gt;&lt;a href="editUI?id=${user.id}"&gt;edit&lt;/a&gt; &lt;/td&gt;
                &lt;td&gt;&lt;a href="del?id=${user.id}"&gt;delete&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/c:forEach&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;

&lt;div id="add"&gt;
    &lt;form action="/add"&gt;
        姓名：&lt;input type="text" name="name" value=""/&gt;&lt;br/&gt;
        密码：&lt;input type="text" name="password" value=""/&gt;&lt;br/&gt;
        &lt;button type="submit"&gt;添加&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;


&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>最后把index.jsp内容修改为:</p>

<pre class="has"><code class="language-java">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;%
    response.sendRedirect(request.getContextPath()+"/list");
%&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<h3 id="14.%E9%85%8D%E7%BD%AEtomcat%EF%BC%8C%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%AE%B0%E5%BE%97%E5%8A%A0%E8%BD%BD%E9%A1%B9%E7%9B%AE%E5%90%8D%EF%BC%89"><a name="t12"></a>14.配置tomcat，启动服务器（记得加载项目名）</h3>

<p><img alt="" class="has" height="1040" src="https://img-blog.csdnimg.cn/20190916201828767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<h3 id="15.%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%88%E5%B7%B2%E7%BB%8F%E6%88%90%E5%8A%9F%EF%BC%89">15.查看运行结果（已经成功）</h3>

<p><img alt="" class="has" height="608" src="https://img-blog.csdnimg.cn/20190916201954460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1081"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="173" src="https://img-blog.csdnimg.cn/20190916202024955.png" width="590"></p>

<h3 id="16.%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81">16.项目源码</h3>

<p>源码+sql：<a href="https://www.lanzous.com/i679e2d" rel="nofollow">https://www.lanzous.com/i679e2d</a></p>

<p>如果有什么问题，可以私聊我，看见解决</p>

<p>欢迎不会的可以相互交流。</p>

<p>交流群：629383010（免费）</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Python的爬虫利器之urllib</title><link>http://www.cnblogs.com/heian99/archive/2019/09/07/11972256.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 07 Sep 2019 08:52:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/07/11972256.html</guid><description><![CDATA[
                                            <h1>&nbsp;</h1>

<h1 id="urllib%E5%8C%85%C2%A0">urllib包&nbsp;</h1>

<p><br>
urllib是一个包含几个模块来处理请求的库：&nbsp;<br>
- urllib.request发送http请求&nbsp;<br>
- urllib.error处理请求过程中出现的异常&nbsp;<br>
- urllib.parse解析url&nbsp;<br>
- urllib.robotparser解析robots.txt文件</p>

<p>一般我们爬虫只需要常用的几个，下面只列出比较常用的函数</p>

<pre>我们使用urllib模块，那就要引用模块
</pre>

<pre class="has"><code class="language-python">import urllib.request</code></pre>

<h2 id="urlreteieve%EF%BC%9A%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%BD%91%E9%A1%B5%E5%88%B0%E6%9C%AC%E5%9C%B0">urlreteieve：直接下载网页到本地</h2>

<h3 id="%E6%A0%BC%E5%BC%8F">格式</h3>

<p><br>
urlreteieve（网址，本地的文件）</p>

<p>示例：</p>

<pre class="has"><code class="language-python">import urllib.request
urllib.request.urlretrieve("https://read.douban.com/provider/all","F:/test/down.html")
print("下载完成")</code></pre>

<p><img alt="" class="has" height="282" src="https://img-blog.csdnimg.cn/20190907165836862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="973"></p>

<h2 id="urlcleanup%EF%BC%9A%E6%B8%85%E6%A5%9A%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98">urlcleanup：清楚系统缓存</h2>

<pre class="has"><code class="language-python">import urllib.request
urllib.request.urlcleanup()
urllib.request.urlretrieve("https://read.douban.com/provider/all","F:/test/down.html")
print("下载完成")</code></pre>

<h2 id="info()%20%EF%BC%9A%E7%9C%8B%E7%9B%B8%E5%BA%94%E6%83%85%E5%86%B5%E7%9A%84%E7%AE%80%E4%BB%8B"><br>
info() ：看相应情况的简介</h2>

<pre class="has"><code class="language-python">import urllib.request
file=urllib.request.urlopen("https://read.douban.com/provider/all")
print(file.info())</code></pre>

<p><img alt="" class="has" height="766" src="https://img-blog.csdnimg.cn/20190907170116450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<h2 id="getcode()%20%E8%BF%94%E5%9B%9E%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96%E7%8A%B6%E6%80%81%E7%A0%81">getcode() 返回网页爬取状态码</h2>

<p><img alt="" class="has" height="362" src="https://img-blog.csdnimg.cn/20190907170401163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<h2 id="geturl()%C2%A0%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%AE%BF%E9%97%AE%E7%9A%84%E7%BD%91%E9%A1%B5%E7%9A%84url">geturl()&nbsp; 获取当前访问的网页的url</h2>

<p><img alt="" class="has" height="389" src="https://img-blog.csdnimg.cn/20190907170456988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                                    ]]></description></item><item><title>Python的正则表达式</title><link>http://www.cnblogs.com/heian99/archive/2019/09/07/11972257.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 07 Sep 2019 08:37:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/07/11972257.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="-toc" style="margin-left:0px;">&nbsp;</p>

<p id="%23%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%23%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow"># 正则表达式</a></p>

<p id="%23%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90-toc" style="margin-left:40px;"><a href="#%23%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90" rel="nofollow">#普通字符作为原子</a></p>

<p id="%23%E9%9D%9E%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90-toc" style="margin-left:40px;"><a href="#%23%E9%9D%9E%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90" rel="nofollow">#非打印字符作为原子</a></p>

<p id="%23%20%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90%EF%BC%88%E4%BD%9C%E7%94%A8%E9%9D%9E%E5%B8%B8%E5%A4%A7%EF%BC%89-toc" style="margin-left:40px;"><a href="#%23%20%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90%EF%BC%88%E4%BD%9C%E7%94%A8%E9%9D%9E%E5%B8%B8%E5%A4%A7%EF%BC%89" rel="nofollow"># 通用字符作为原子（作用非常大）</a></p>

<p id="%23%20%E5%8E%9F%E5%AD%90%E8%A1%A8(%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%AD%90%E7%BB%84%E6%88%90%E4%B8%80%E4%B8%AA)-toc" style="margin-left:40px;"><a href="#%23%20%E5%8E%9F%E5%AD%90%E8%A1%A8(%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%AD%90%E7%BB%84%E6%88%90%E4%B8%80%E4%B8%AA)" rel="nofollow"># 原子表(几个原子组成一个)</a></p>

<p id="%23%20%E5%85%83%E5%AD%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%23%20%E5%85%83%E5%AD%97%E7%AC%A6" rel="nofollow"># 元字符</a></p>

<p id="%23%20%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%23%20%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6" rel="nofollow"># 模式修正符</a></p>

<p id="%23%20%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%23%20%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F" rel="nofollow"># 贪婪模式和懒惰模式</a></p>

<p id="%23%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%23%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0" rel="nofollow"># 正则表达式函数</a></p>

<p id="%23%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8C%B9%E9%85%8D.com%E5%92%8C.cn%E7%BD%91%E5%9D%80%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B-toc" style="margin-left:40px;"><a href="#%23%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8C%B9%E9%85%8D.com%E5%92%8C.cn%E7%BD%91%E5%9D%80%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B" rel="nofollow">#示例：匹配.com和.cn网址​​​​​</a></p>

<p id="%23%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8C%B9%E9%85%8D%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81-toc" style="margin-left:40px;"><a href="#%23%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8C%B9%E9%85%8D%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81" rel="nofollow">#示例：匹配电话号码</a></p>

<hr id="hr-toc"><h1 id="%23%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"># 正则表达式</h1>

<p>&nbsp;</p>

<pre class="has"><code>import re
str ="weidongliang"</code></pre>

<h2 id="%23%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90"><br>
#普通字符作为原子</h2>

<pre class="has"><code class="language-python">pat ="wei"
rsr=re.search(pat,str)
print(rsr)</code></pre>

<h2 id="%23%E9%9D%9E%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90"><br>
#非打印字符作为原子</h2>

<p><br>
#\n:换行符&nbsp;&nbsp; \t：制表符</p>

<pre class="has"><code class="language-python">str ='''baidusdfs
baidu
'''
pat="\n"
rest=re.search(pat,str)
print(rest)</code></pre>

<h2 id="%23%20%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%AD%90%EF%BC%88%E4%BD%9C%E7%94%A8%E9%9D%9E%E5%B8%B8%E5%A4%A7%EF%BC%89"><br>
# 通用字符作为原子（作用非常大）<br>
&nbsp;</h2>

<ol><li>\w:匹配任何字母，数字，下划线</li>
	<li>\W:除匹配任何字母，数字，下划线</li>
	<li>\d:十进制数字</li>
	<li>\D:除十进制数字</li>
	<li>\s:空白字符</li>
	<li>\S:除空白字符</li>
</ol><p>&nbsp;</p>

<pre class="has"><code class="language-python">string="taobao4 59454baidu"
pat="\w\d\s\d\d"
print(re.search(pat,string))</code></pre>

<h2 id="%23%20%E5%8E%9F%E5%AD%90%E8%A1%A8(%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%AD%90%E7%BB%84%E6%88%90%E4%B8%80%E4%B8%AA)"># 原子表(几个原子组成一个)</h2>

<pre class="has"><code class="language-python">string="taobao4 59454baidu"
pat="tao[zub]ao"
pat="tao[^zuq]ao"
print(re.search(pat,string))</code></pre>

<h2 id="%23%20%E5%85%83%E5%AD%97%E7%AC%A6"># 元字符<br>
&nbsp;</h2>

<ol><li>. :出换行外任意一个字符</li>
	<li>^ ：开始位置</li>
	<li>$ :结束位置</li>
	<li>* ：0\1\多次</li>
	<li>？：0\1次</li>
	<li>+ ：1\多次</li>
	<li>{n} ：恰好n次</li>
	<li>{n,} ：至少n次</li>
	<li>{n，m}：至少n，最多m</li>
	<li>|&nbsp; ：模式选择符</li>
	<li>() :模式单元</li>
</ol><pre class="has"><code class="language-python">wei="taoyun14524baidu"
pat="tao.un"
pat="bai..$"
ce=re.search(pat,wei)
print(ce)</code></pre>

<h2 id="%23%20%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6"># 模式修正符<br>
&nbsp;</h2>

<ol><li>I 匹配时忽悠大小写 *</li>
	<li>M 多行匹配 *</li>
	<li>L 本地化识别匹配</li>
	<li>U Unicode</li>
	<li>S 让.匹配包括换行符 *</li>
</ol><pre class="has"><code class="language-python">str="Python"
pat="pyt"
ce=re.search(pat,str,re.I)
print(ce)</code></pre>

<h2 id="%23%20%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F"># 贪婪模式和懒惰模式</h2>

<p><br>
# 默认是贪婪模式</p>

<pre class="has"><code class="language-python">str="pythony"
pat="p.*y" #贪婪模式，模糊
pat2="p.*?y" #懒惰模式，精准
ce=re.search(pat,str,re.I)
ce2=re.search(pat2,str,re.I)
print(ce)
print(ce2)</code></pre>

<h2 id="%23%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0"># 正则表达式函数</h2>

<p><br>
#1，match 重头开始匹配</p>

<pre class="has"><code class="language-python">str="poyajgsdabskjdbaiush"
pat="p.*?y"
ce=re.match(pat,str,re.I)
print(ce)</code></pre>

<p>#2，search&nbsp; 任何地方都可以匹配</p>

<p>#3，全局匹配函数</p>

<pre class="has"><code class="language-python">str="efdrpoyajgspnyskjdbapyth"
pat="p.*?y"
</code></pre>

<p><br>
# 全局匹配格式re.compile(正则表达式).findall(数据)</p>

<pre class="has"><code class="language-python">ce=re.compile(pat).findall(str)
print(ce)</code></pre>

<p>&nbsp;</p>

<h2 id="%23%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8C%B9%E9%85%8D.com%E5%92%8C.cn%E7%BD%91%E5%9D%80%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B">#示例：匹配.com和.cn网址<br>
​​​​​</h2>

<pre class="has"><code class="language-python">string="&lt;a href='http://www.baidu.com'&gt;百度&lt;/a&gt;"
pat="[a-zA-Z]+://[^\s]*[.com|.cn]"
ce=re.search(pat,string)
print(ce)</code></pre>

<h2 id="%23%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8C%B9%E9%85%8D%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81">#示例：匹配电话号码</h2>

<pre class="has"><code class="language-python">string="adsgdiasdiauhdaj012-754745745dasd0773-46853415adasda"
pat="\d{4}-\d{7}|\d{3}-\d{8}"
ce=re.compile(pat).findall(string)
print(ce)
</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Python的异常处理</title><link>http://www.cnblogs.com/heian99/archive/2019/09/05/11972258.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 05 Sep 2019 06:14:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/05/11972258.html</guid><description><![CDATA[
                                            <h2>异常处理<br>
由于我经常爬虫，会因为网络，字符编码集等原因让程序崩溃，从而导致代码停止。</h2>

<h2>为了解决这个问题，我们可以使用异常处理，从而使程序跳过异常，保证程序可以不停止运行。</h2>

<h2>异常处理的格式（这个是最常见的一种，也是最实用的一种）</h2>

<pre class="has"><code class="language-python">try：
&nbsp; &nbsp; 程序
except Exception as 异常名称：
&nbsp; &nbsp; 异常处理部分</code></pre>

<h2><br><br>
示例</h2>

<pre class="has"><code class="language-python">try:
&nbsp; &nbsp; for i in range(0,10):
&nbsp; &nbsp; &nbsp; &nbsp; print(i)
&nbsp; &nbsp; &nbsp; &nbsp; if(i==4):
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(ij)
&nbsp; &nbsp; &nbsp; &nbsp; print("hello")
except Exception as err:
&nbsp; &nbsp; print(err)


</code></pre>

<h2><img alt="" class="has" height="174" src="https://img-blog.csdnimg.cn/20190905142127445.png" width="315"></h2>

<h2>异常处理过后</h2>

<pre class="has"><code class="language-python">#让异常后的程序继续
for i in range(0,10):
&nbsp; &nbsp; try:
&nbsp; &nbsp; &nbsp; &nbsp; print(i)
&nbsp; &nbsp; &nbsp; &nbsp; if(i==4):
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(ij)
&nbsp; &nbsp; except Exception as err:
&nbsp; &nbsp; &nbsp; &nbsp; print(err)</code></pre>

<p><img alt="" class="has" height="182" src="https://img-blog.csdnimg.cn/20190905142156476.png" width="356"></p>
                                    ]]></description></item><item><title>Python的类和对象</title><link>http://www.cnblogs.com/heian99/archive/2019/09/05/11972259.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 05 Sep 2019 05:58:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/05/11972259.html</guid><description><![CDATA[
                                            <h2>类和对象<br><br>
class 类名<br>
&nbsp; &nbsp; 类里面的东西<br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;</h2>

<pre class="has"><code class="language-python">class c1:
&nbsp; &nbsp; pass</code></pre>

<h2><br>
实例化一个类</h2>

<pre class="has"><code class="language-python">a=c1()</code></pre>

<h2><br>
构造函数 （构造方法）<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #self：在类中的方法必须加上seif参数<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#__init__(self,参数)</h2>

<h2><br>
构造函数实际意义：初始化</h2>

<pre class="has"><code class="language-python">class c2:
&nbsp; &nbsp; def __init__(self):
&nbsp; &nbsp; &nbsp; &nbsp; print("南宫乘风")</code></pre>

<h2>给类加上参数：给构造方法加上参数</h2>

<pre class="has"><code class="language-python">class c3:
&nbsp; &nbsp; def __init__(self,name,job):
&nbsp; &nbsp; &nbsp; &nbsp; print("我的名字"+name+"工作是"+job)</code></pre>

<h2><br>
&nbsp; &nbsp;&nbsp;<br>
属性：类里面的变量：self.属性名</h2>

<pre class="has"><code class="language-python">class c4:
&nbsp; &nbsp; def __init__(self,name,job):
&nbsp; &nbsp; &nbsp; &nbsp; self.myname=name
&nbsp; &nbsp; &nbsp; &nbsp; self.myjob=job</code></pre>

<h2>方法：类里面的函数：def 方法名（self，参数）</h2>

<pre class="has"><code class="language-python">class c5:
&nbsp; &nbsp; def fun1(self,name):
&nbsp; &nbsp; &nbsp; &nbsp; print ("hello"+name)</code></pre>

<pre class="has"><code class="language-python">class c6:
&nbsp; &nbsp; def __init__(self,name):
&nbsp; &nbsp; &nbsp; &nbsp; self.myname=name
&nbsp; &nbsp; def fun2(self):
&nbsp; &nbsp; &nbsp; &nbsp; print ("hello"+self.myname)</code></pre>

<h2><br>
继承（单继承，多继承）</h2>

<p>#某一个家庭有父亲，母亲，儿子，女儿<br>
#父亲可以说话，母亲可以写字<br>
#儿子继承了父亲，女儿同时继承了父母,并且可听东西<br>
#小儿子继承了父亲，但是优化了父亲的说话能力</p>

<pre class="has"><code class="language-python">#父亲类
class father():
&nbsp; &nbsp; def speak(self):
&nbsp; &nbsp; &nbsp; &nbsp; print("I can speak")
#单继承：class子类（父亲）

#儿子类
class son(father):
&nbsp; &nbsp; pass

#母亲类
class mother():
&nbsp; &nbsp; def write(self):
&nbsp; &nbsp; &nbsp; &nbsp; print("I can write")
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
#多继承
#女儿类
class daugther(father,mother):
&nbsp; &nbsp; def listen(self):
&nbsp; &nbsp; &nbsp; &nbsp; print("I can listen")

#重载：（重载）
#小儿子类
class son2(father):
&nbsp; &nbsp; def speak(self):
&nbsp; &nbsp; &nbsp; &nbsp; print("I can speak2")</code></pre>

<p><br>
&nbsp;</p>
                                    ]]></description></item><item><title>Python乘法口诀表</title><link>http://www.cnblogs.com/heian99/archive/2019/09/05/11972260.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 05 Sep 2019 05:55:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/05/11972260.html</guid><description><![CDATA[
                                            <h1>乘法口诀表</h1>

<pre class="has"><code class="language-python">print("乘法口诀表")

for i in range(1,10):
&nbsp; &nbsp; for j in range(1,i+1):
&nbsp; &nbsp; &nbsp; &nbsp; print(str(i)+str("*")+str(j)+"="+str(i*j),end=" ")
&nbsp; &nbsp; print()&nbsp;</code></pre>

<h1><img alt="" class="has" height="142" src="https://img-blog.csdnimg.cn/20190905135657950.png" width="554"><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
逆向乘法口诀表</h1>

<pre class="has"><code class="language-python">print("逆向乘法口诀表")

for i in range(9,0,-1):
&nbsp; &nbsp; for j in range(i,0,-1):
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(str(i)+str("*")+str(j)+"="+str(i*j),end=" ")
&nbsp; &nbsp; print()
</code></pre>

<p><img alt="" class="has" height="167" src="https://img-blog.csdnimg.cn/20190905135644667.png" width="467"></p>
                                    ]]></description></item><item><title>Python的文件操作</title><link>http://www.cnblogs.com/heian99/archive/2019/09/05/11972261.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 05 Sep 2019 05:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/09/05/11972261.html</guid><description><![CDATA[
                                            <h2>#文件操作<br>
#打开<br>
#open("文件地址"，"操作形式’)</h2>

<h2><span style="color:#f33b45;">常用四种操作模式</span><br>
'''<br>
w：写入<br>
r：读取<br>
b：二进制<br>
a+:追加<br>
'''</h2>

<pre class="has"><code class="language-python">fh=open("E:/Code/Python/python.txt","r")
date=fh.read()</code></pre>

<h2>#文件读取</h2>

<pre class="has"><code class="language-python">date=fh.read()</code></pre>

<h2><br>
#读取一行类容</h2>

<pre class="has"><code class="language-python">line=fh.readline()</code></pre>

<h2>#关闭文件</h2>

<pre class="has"><code class="language-python">fh.close()</code></pre>

<h2>#文件写入<br>
&nbsp;</h2>

<pre class="has"><code class="language-python">date="一起去学习"
fh2=open("E:/Code/Python/python2.txt","w")
fh2.write(date)
fh2.close()
</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>三层架构介绍和MVC设计模型介绍</title><link>http://www.cnblogs.com/heian99/archive/2019/08/30/11972262.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 30 Aug 2019 07:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/08/30/11972262.html</guid><description><![CDATA[
                                            <p></p>

<h1>springmvc是什么?</h1>

<p>Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层</p>

<p>进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。</p>

<h1>服务器端分成三层框架</h1>

<p>&nbsp;</p>

<p>表现层：SpringMVC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;包含JSP和Servlet等与WEB相关的内容</p>

<p>&nbsp;</p>

<p>业务层：Spring框架&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;业务层中不包含JavaWeb API，它只关心业务逻辑</p>

<p>&nbsp;</p>

<p>持久层：MyBatis&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;封装了对数据库的访问细节</p>

<p><img alt="" class="has" height="352" src="https://img-blog.csdnimg.cn/20190830145419312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1189"></p>

<h1>MVC设计模型</h1>

<p><img alt="" class="has" height="347" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNzc0MzI1LzIwMTYwMy83NzQzMjUtMjAxNjAzMjkxNDUyMjMzOTQtMjQ4MDMyODIuZ2lm" width="440"></p>

<p>MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式：</p>

<ul><li>
	<p>Model（模型）表示应用程序核心（比如数据库记录列表）。</p>
	</li>
	<li>
	<p>View（视图）显示数据（数据库记录）。</p>
	</li>
	<li>
	<p>Controller（控制器）处理输入（写入数据库记录）。</p>
	</li>
</ul><p>MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。</p>

<p><strong>Model（模型）</strong>是应用程序中用于处理应用程序数据逻辑的部分。<br>
　　通常模型对象负责在数据库中存取数据。</p>

<p><strong>View（视图）</strong>是应用程序中处理数据显示的部分。<br>
　　通常视图是依据模型数据创建的。</p>

<p><strong>Controller（控制器）</strong>是应用程序中处理用户交互的部分。<br>
　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>spring的组件使用</title><link>http://www.cnblogs.com/heian99/archive/2019/08/21/11972263.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 21 Aug 2019 07:07:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/08/21/11972263.html</guid><description><![CDATA[
                                            <h3><img alt="" class="has" height="1044" src="https://img-blog.csdnimg.cn/20190821150448606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></h3>

<h3>源代码下载：<a href="https://www.lanzous.com/i5p4mvc" rel="nofollow">https://www.lanzous.com/i5p4mvc</a></h3>

<p>&nbsp;</p>

<h3>&nbsp;* 组件扫描<br>
* @Component：表示这个类需要在应用程序中被创建<br>
* @ComponentScan：自动发现应用程序中被创建的类<br>
*<br>
* 自动装配<br>
* @Autowired：自动满足bean之间的依赖<br>
*<br>
* 定义配置类<br>
* @Configuration：表示当前类是一个配置类</h3>

<h1>&nbsp;</h1>

<h3>&nbsp;</h3>

<h3>* @Autowired的使用方法<br>
* 1：用在构造函数上（多种依赖的情况下）<br>
* 2：用在成员变量上<br>
* 3：用在setter方法上<br>
* 4：用在任意方法上</h3>

<p>&nbsp;</p>

<h3>* 使用单元测试的方案<br>
*<br>
* 引入Spring单元测试模块<br>
* maven：junit，spring-test<br>
*<br>
* @RunWith(SpringJUnit4ClassRunner.class) 加载配置类<br>
* @ContextConfiguration(class=AppConfig.class)</h3>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>IDEA使用maven搭建spring项目</title><link>http://www.cnblogs.com/heian99/archive/2019/08/21/11972264.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 21 Aug 2019 06:33:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/08/21/11972264.html</guid><description><![CDATA[
                                            <h1>spring框架</h1>

<p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p>

<p>◆目的：解决企业应用开发的复杂性</p>

<p>◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</p>

<p>◆范围：任何Java应用</p>

<p>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p>

<h2>优点</h2>

<p>◆JAVA EE应该更加容易使用。</p>

<p>◆面向对象的设计比任何实现技术（比如JAVA EE）都重要。</p>

<p>◆面向接口编程，而不是针对类编程。Spring将使用接口的复杂度降低到零。（面向接口编程有哪些复杂度？）</p>

<p>◆代码应该易于测试。Spring框架会帮助你，使代码的测试更加简单。</p>

<p>◆JavaBean提供了应用程序配置的最好方法。</p>

<p>◆在Java中，已检查异常（Checked exception）被过度使用。框架不应该迫使你捕获不能恢复的异常。</p>

<h1 id="ide建立spring项目">IDEA使用maven搭建spring项目</h1>

<p>idea建立spring项目相当方便 , 可以自动生成spring配置文件 , 和自动导入Spring所需jar包.</p>

<p>File—&gt;new—&gt;project—&gt;Maven</p>

<p><img alt="" class="has" height="584" src="https://img-blog.csdnimg.cn/20190821140319989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="856"></p>

<p>选择本地的jdk，下一步</p>

<p><img alt="" class="has" height="591" src="https://img-blog.csdnimg.cn/2019082114041686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="860"></p>

<p>可以根据自己需求填写（没有什么限制）</p>

<p><img alt="" class="has" height="577" src="https://img-blog.csdnimg.cn/20190821140455640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="846"></p>

<p>选择项目存储的位置，在点击完成就可以。此时一个Maven已经建立成功。</p>

<p>下面，根据自己的需求添加spring依赖和jar包</p>

<p>在pom.xml的文件下添加依赖</p>

<p><img alt="" class="has" height="889" src="https://img-blog.csdnimg.cn/20190821140837927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<pre class="has"><code class="language-java">    &lt;dependencies&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;
        &lt;!--spring的核心依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;4.3.13.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--log4j的日志文件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.12&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>

<h3>加入这段代码，idea的右下角会出现让你导包的选项，你可以点击第一个，导入jar包</h3>

<p>好的，现在spring的核心包已经导入，下面开始练习。</p>

<p>整体项目结果图</p>

<p><img alt="" class="has" height="1032" src="https://img-blog.csdnimg.cn/20190821141957186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>首先，建两个类</p>

<p>MessagesService&nbsp; ：消息</p>

<p>MessagePrinter&nbsp; &nbsp;：&nbsp; &nbsp;打印机</p>

<p>就是使用打印机打印消息，就这么简单。</p>

<p>也就是要MessagePrinter这个类调用MessagesService 类来输出消息。</p>

<p>MessagesService&nbsp;</p>

<pre class="has"><code class="language-java">package hello;


/**
 * 打印
 */
public class MessagesService {
//    无参构造函数
    public MessagesService() {
        super();
        System.out.println("MessageService..");
    }

    public String getMessage(){
      return "Hello Word";
    }
}
</code></pre>

<p>MessagePrinter&nbsp; &nbsp;</p>

<pre class="has"><code class="language-java">package hello;


/**
 * 打印机
 */
public class MessagePrinter {
    /**
     * 无参构造函数
     */
    public MessagePrinter() {
        super();
        System.out.println("MessagePinter..");
    }

    /**
     * 建立和MessageService的关联关系
     */
    private MessagesService service;

    /**
     * 设置service的值
     * @param service
     */
    public void setService(MessagesService service) {
        this.service = service;
    }


    public void printMessage(){
        System.out.println(this.service.getMessage());
    }
}
</code></pre>

<h1><span style="color:#f33b45;">（1）使用传统的调用方法</span></h1>

<p>创建Application类。</p>

<p>Application</p>

<pre class="has"><code class="language-java">package hello;
public class Application {
    public static void main(String[] args) {
        System.out.println("appliction");
        //创建打印机对象
        MessagePrinter printer=new MessagePrinter();
        //创建消息服务对象
        MessagesService service=new MessagesService();
        //设置打印机对象的service属性
        printer.setService(service);
        printer.printMessage();
    }
}
</code></pre>

<p>&nbsp;</p>

<p>点击绿色图标，点击第一个运行<img alt="" class="has" height="487" src="https://img-blog.csdnimg.cn/20190821142248147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1191"></p>

<p>运行结构</p>

<p><img alt="" class="has" height="334" src="https://img-blog.csdnimg.cn/20190821142338614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="734"></p>

<p>已经成功运行，并输出。</p>

<h1><span style="color:#f33b45;">（2）spring的方法来进行调用</span></h1>

<p>&nbsp;</p>

<p>在resources下建立applicationContext.xml配置文件</p>

<p>applicationContext.xml</p>

<pre class="has"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
    &lt;bean id="service" class="hello.MessagesService"&gt;&lt;/bean&gt;
    &lt;bean id="printer" class="hello.MessagePrinter"&gt;
        &lt;property name="service" ref="service"&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>

<p>在java的hello下创建Applicationspring类</p>

<p>Applicationspring</p>

<pre class="has"><code class="language-java">package hello;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Applicationspring {
    public static void main(String[] args) {
        System.out.println("applictionspring");
        //初始化spring容器
        ApplicationContext context;
        context = new ClassPathXmlApplicationContext("applicationContext.xml");
        //从容器中获取MessagePrinter对象
        MessagePrinter printer=context.getBean(MessagePrinter.class);
        printer.printMessage();

    }
}
</code></pre>

<p>点击运行<img alt="" class="has" height="378" src="https://img-blog.csdnimg.cn/20190821142948796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="909"></p>

<p>结果</p>

<p><img alt="" class="has" height="261" src="https://img-blog.csdnimg.cn/20190821143010129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="914"></p>

<p>（3）添加log4j.properties日志</p>

<p>log4j.properties</p>

<pre class="has"><code class="language-java">log4j.rootCategory=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %t %c{2}:%L - %m%n

log4j.category.org.springframework.beans.factory=DEBUG</code></pre>

<p>再次运行，会出现各种相关的日志</p>

<p><img alt="" class="has" height="821" src="https://img-blog.csdnimg.cn/20190821143159923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>
                                    ]]></description></item><item><title>MarkdownPad 2破解</title><link>http://www.cnblogs.com/heian99/archive/2019/05/18/11972265.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 18 May 2019 13:47:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/05/18/11972265.html</guid><description><![CDATA[
                                            <p><strong><em>MarkdownPad 2</em>&nbsp;是一款较不错的Markdown编辑器，可快速将文本转换为美观的HTML/XHTML的网页格式代码，且操作方便，用户可以通过键盘快捷键和工具栏按钮来使用或者移除Markdown格式，左右栏的分割方式令用户可以实时看到 HTML 格式的 Markdown 文档。如果你喜欢在简书、CSDN等平台发表文章，也想掌握这门简单的轻量级的标记语言Markdown，又担心离线无处编辑，欢迎尝试。</strong></p>

<p><img alt="" class="has" height="1080" src="https://img-blog.csdnimg.cn/20190518214441339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>具体方法和资源如下：</strong><br>
step1.解压MarkdownPad 2<br><br><br><span style="color:#444444;">地址：</span><a href="https://www.lanzous.com/i47m59c" rel="nofollow">https://www.lanzous.com/i47m59c</a><br><br>
step2.找到根目录下MarkdownPad 2应用程序，运行并<a class="relatedlink" href="https://www.52pojie.cn/" rel="nofollow">破解</a></p>

<pre class="has"><code>Email address :
 Soar360@live.com  
 
License key : 
GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==
</code></pre>

<p><img alt="" class="has" height="708" src="https://img-blog.csdnimg.cn/201905182145251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="915"></p>

<p>step3.如果是win10还需要安装一个组件 awesomium_v1.6.6_sdk_win，否则会出现错误提示<br><br><br>
下载地址：<a href="https://pan.baidu.com/s/1qY7LKba#%23step" rel="nofollow">https://pan.baidu.com/s/1qY7LKba##step</a><br><br>
step4:最后重启MarkdownPad 2就可以用了!<br><br><br>
注：如果是英文版，可到tools-&gt;options修改，再重启即可</p>
                                    ]]></description></item><item><title>Centos7部署ejforum论坛（Java+tomcat+mysql）</title><link>http://www.cnblogs.com/heian99/archive/2019/05/14/11972266.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 14 May 2019 15:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/05/14/11972266.html</guid><description><![CDATA[
                                            <p>前面搭建Java环境和tomcat环境。</p>

<p>下面进行实战，搭建ejforum论坛</p>

<p>ejforum论坛源码：<a href="https://www.lanzous.com/i45rcoh" rel="nofollow">https://www.lanzous.com/i45rcoh</a></p>

<h1><a href="https://blog.csdn.net/heian_99/article/details/89326404" rel="nofollow">Centos7安装MySQL数据库</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/90215703" rel="nofollow">Centos7安装JDK环境配置</a></h1>

<h1><a href="https://blog.csdn.net/heian_99/article/details/90216301" rel="nofollow">Centos7安装和配置Tomcat8</a></h1>

<p>ok，下面进行论坛搭建</p>

<p>前提：以上三个配置已经搭建完成。</p>

<p>（1）使用mysql创建数据库</p>

<pre class="has"><code>mysql&gt; create database ejforum;
Query OK, 1 row affected (0.00 sec)

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| ejforum            |
| mysql              |
| performance_schema |
+--------------------+
4 rows in set (0.00 sec)

mysql&gt; GRANT all ON ejforum.* TO "ejforum"@"localhost" IDENTIFIED BY "ejforum";
Query OK, 0 rows affected (0.00 sec)

mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p><img alt="" class="has" height="643" src="https://img-blog.csdnimg.cn/20190514230654545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="806"></p>

<p>&nbsp;</p>

<p>（2）安装mysql连接器（驱动包）下载地址：<a href="https://dev.mysql.com/downloads/connector/j/5.1.html" rel="nofollow">https://dev.mysql.com/downloads/connector/j/5.1.html</a></p>

<p><img alt="" class="has" height="1050" src="https://img-blog.csdnimg.cn/20190514232635203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei mysql-connector-java-5.1.47]# tar zxf mysql-connector-java-5.1.47.tar.gz  

[root@wei mysql-connector-java-5.1.47]# ls
build.xml  mysql-connector-java-5.1.47-bin.jar  README.txt
CHANGES    mysql-connector-java-5.1.47.jar      src
COPYING    README
[root@wei mysql-connector-java-5.1.47]# cp mysql-connector-java-5.1.47.jar /usr/local/tomcat/lib/
</code></pre>

<p>（3）解压ejforum压缩包，并拷贝到网站的目录</p>

<pre class="has"><code>[root@wei ejforum-2.3]# rm -rf /usr/local/tomcat/webapps/ROOT/*

[root@wei ~]# unzip ejforum2.3.zip 
</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>
[root@wei ~]# cd ejforum-2.3/
[root@wei ejforum-2.3]# ls
ejforum  install
[root@wei ~]# cd ejforum
[root@wei ejforum-2.3]# cp -r * /usr/local/tomcat/webapps/ROOT/
</code></pre>

<p>（4）编辑WEB-INF文件，指定连接MYSQL数据库用户</p>

<pre class="has"><code>[root@wei ejforum]# vim /usr/local/tomcat/webapps/ROOT/WEB-INF/conf/config.xml 
[root@wei conf]# pwd
/usr/local/tomcat/webapps/ROOT/WEB-INF/conf
</code></pre>

<pre class="has"><code>    DB Connection Pool - Mysql
        &lt;database maxActive="10" maxIdle="10" minIdle="2" maxWait="10000" 
                          username="ejforum" password="ejforum" 
                          driverClassName="com.mysql.jdbc.Driver" 
                          url="jdbc:mysql://localhost:3306/ejforum?characterEncoding=gbk&amp;amp;autoReconnect=true&amp;amp;autoReconnectForPools=true&amp;amp;zeroDateTimeBehavior=convertToNull"
                          sqlAdapter="sql.MysqlAdapter"/&gt;

</code></pre>

<p>&nbsp;</p>

<p><img alt="" class="has" height="682" src="https://img-blog.csdnimg.cn/20190514234222299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1014"></p>

<p>（5）重启tomcat服务</p>

<pre class="has"><code>[root@wei conf]# /usr/local/tomcat/bin/shutdown.sh 
Using CATALINA_BASE:   /usr/local/tomcat
Using CATALINA_HOME:   /usr/local/tomcat
Using CATALINA_TMPDIR: /usr/local/tomcat/temp
Using JRE_HOME:        /usr/java/jdk-12.0.1
Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar
NOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED
[root@wei conf]# /usr/local/tomcat/bin/startup.sh 
Using CATALINA_BASE:   /usr/local/tomcat
Using CATALINA_HOME:   /usr/local/tomcat
Using CATALINA_TMPDIR: /usr/local/tomcat/temp
Using JRE_HOME:        /usr/java/jdk-12.0.1
Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar
Tomcat started.</code></pre>

<p><img alt="" class="has" height="464" src="https://img-blog.csdnimg.cn/20190514234408841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="916"></p>
                                    ]]></description></item><item><title>Centos7安装和配置Tomcat8</title><link>http://www.cnblogs.com/heian99/archive/2019/05/14/11972267.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 14 May 2019 14:32:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/05/14/11972267.html</guid><description><![CDATA[
                                            <p><strong>第一步：下载Tomcat8压缩包</strong></p>

<p>进入&nbsp;<a href="http://tomcat.apache.org/download-80.cgi" rel="nofollow">http://tomcat.apache.org/download-80.cgi</a></p>

<p><img alt="" class="has" src="https://images2015.cnblogs.com/blog/812323/201707/812323-20170703223844956-1669877808.png"></p>

<p>下载tar.gz压缩包</p>

<p>&nbsp;</p>

<p><strong>第二步：用xshell工具把压缩包上传到/home/data/下</strong></p>

<p><img alt="" class="has" height="208" src="https://img-blog.csdnimg.cn/20190514220711262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="418"></p>

<p><strong>第三步：解压以及新建目录</strong></p>

<pre class="has"><code>[root@wei data]# tar -zxvf apache-tomcat-8.5.40.tar.gz 
</code></pre>

<p><img alt="" class="has" height="169" src="https://img-blog.csdnimg.cn/20190514220856119.png" width="581"></p>

<p>我们新建/home/tomcat/目录 把tomcat剪切进去</p>

<p><img alt="" class="has" height="171" src="https://img-blog.csdnimg.cn/20190514221042961.png" width="648"></p>

<p>&nbsp;</p>

<p><strong>第四步：配置tomcat server.xml</strong></p>

<p>server.xml可以配置端口，编码以及配置项目等等，我们这里就配置一个端口，把默认的8080</p>

<p>vi /home/tomcat/apache-tomcat-8.5.16/conf/server.xml</p>

<p><img alt="" class="has" height="493" src="https://img-blog.csdnimg.cn/20190514223020657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="759"></p>

<p><strong>第五步：配置防火墙，开放8080端口</strong></p>

<p>firewall-cmd --zone=public --add-port=8080/tcp --permanent</p>

<p>firewall-cmd --reload</p>

<p><strong>第六步：启动tomcat</strong></p>

<pre class="has"><code>[root@wei home]# /home/tomcat/apache-tomcat-8.5.40/bin/startup.sh 
</code></pre>

<p><img alt="" class="has" height="256" src="https://img-blog.csdnimg.cn/20190514221310361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="788"></p>

<p>下面是tomcat启动的界面（端口8080）</p>

<p><img alt="" class="has" height="788" src="https://img-blog.csdnimg.cn/20190514222917412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>下面是httpd启动的界面（端口80）</p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="808" src="https://img-blog.csdnimg.cn/20190514221502916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Centos7安装JDK环境配置</title><link>http://www.cnblogs.com/heian99/archive/2019/05/14/11972268.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 14 May 2019 13:52:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/05/14/11972268.html</guid><description><![CDATA[
                                            <p>作为一名程序员，各种环境搭建都要会。</p>

<p>下面介绍关于Linux操作系统之centos7（64位）安装JDK以及环境配置。</p>

<p>下面开始学习吧</p>

<h1>查看并卸载CentOS自带的OpenJDK</h1>

<ul><li>
	<h2>&nbsp;安装好的CentOS会自带OpenJdk,用命令 java -version ，会有下面的信息：</h2>
	</li>
</ul><pre class="has"><code>&nbsp; &nbsp; java version "1.6.0"
&nbsp; &nbsp;OpenJDK Runtime Environment (build 1.6.0-b09)
&nbsp; &nbsp;OpenJDK 64-Bit Server VM (build 1.6.0-b09, mixed mode)</code></pre>

<p>最好还是先卸载掉openjdk,在安装sun公司的jdk.</p>

<ul><li>
	<h2>先查看 rpm -qa | grep java</h2>
	</li>
</ul><p>显示如下信息：</p>

<pre class="has"><code>&nbsp; &nbsp; java-1.4.2-gcj-compat-1.4.2.0-40jpp.115
&nbsp; &nbsp; java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5</code></pre>

<p>卸载：</p>

<pre class="has"><code>&nbsp; &nbsp; rpm -e --nodeps java-1.4.2-gcj-compat-1.4.2.0-40jpp.115
&nbsp; &nbsp; rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5</code></pre>

<p><strong>STEP 1：</strong></p>

<p>现在JDK12都出来了，所以我们也要紧跟着技术的潮流走。</p>

<p>所有下载的jdk-12.0.1_linux-x64_bin.rpm</p>

<p>官网链接：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" rel="nofollow">JDK官网下载</a></p>

<p><img alt="" class="has" height="822" src="https://img-blog.csdnimg.cn/20190514213931610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1015"></p>

<p>&nbsp;</p>

<p>选择与自己系统相匹配的版本，我的是Centos7 64位的，所以如果是我的是jdk-12.0.1_linux-x64_bin.rpm</p>

<p>&nbsp;</p>

<p><strong>STEP 2：</strong></p>

<p>利用Xshell工具进行Linux命令处理，进行安装。</p>

<p><img alt="" class="has" height="141" src="https://img-blog.csdnimg.cn/20190514214220477.png" width="607"></p>

<p>进行rpm安装jdk</p>

<pre class="has"><code>[root@wei ~]# rpm -ivh jdk-12.0.1_linux-x64_bin.rpm </code></pre>

<p><img alt="" class="has" height="171" src="https://img-blog.csdnimg.cn/20190514214307395.png" width="860"></p>

<p>下面以及安装成功过jdk。</p>

<p>注意：安装成功，但是环境变量没有配置，需要配置环境变量。</p>

<p>（1）找到jdk安装路径</p>

<pre class="has"><code>[root@wei ~]# cd /usr/java/jdk-12.0.1/
[root@wei jdk-12.0.1]# ls
bin  conf  include  jmods  legal  lib  man  release
[root@wei jdk-12.0.1]# pwd
/usr/java/jdk-12.0.1
</code></pre>

<p><img alt="" class="has" height="175" src="https://img-blog.csdnimg.cn/2019051421453052.png" width="732"></p>

<p>（2）复制路径，开始配置环境变量（/usr/java/jdk-12.0.1）</p>

<p>编辑：/etc/profile文件，在最后面加入下面的代码</p>

<pre class="has"><code>export JAVA_HOME=/usr/java/jdk-12.0.1
export PATH=$PATH:JAVA_HOME/bin
</code></pre>

<pre class="has"><code>[root@wei jdk-12.0.1]# source /etc/profile
</code></pre>

<p>（3）保存，重新加载配置文件</p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="166" src="https://img-blog.csdnimg.cn/20190514214834746.png" width="750"></p>

<p>（4）查看jdk的配置信息，看是否配置完成</p>

<pre class="has"><code>[root@wei jdk-12.0.1]# java -version
</code></pre>

<p><img alt="" class="has" height="151" src="https://img-blog.csdnimg.cn/20190514214924827.png" width="696"></p>

<p>&nbsp;</p>

<h3><strong>ok，jdk已经成功安装成功。恭喜你有学会一个新的技能。</strong></h3>

<h3><strong>加油。</strong></h3>
                                    ]]></description></item><item><title>Python基础知识</title><link>http://www.cnblogs.com/heian99/archive/2019/05/12/11972269.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 12 May 2019 13:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/05/12/11972269.html</guid><description><![CDATA[
                                            <h1>一、python的优缺点</h1>

<h2>　　优点：</h2>

<ol><li>优美、清晰、简单</li>
	<li>高级语言</li>
	<li>开发效率高</li>
	<li>可移植性、可拓展性、可嵌入性</li>
</ol><h2>　　缺点：</h2>

<ol><li>运行速度慢</li>
	<li>代码不能加密</li>
	<li>线程不能利用多CPU</li>
</ol><h1>二、python2与python3的区别</h1>

<h2>　　代码：</h2>

<ol><li>python2：代码混乱，重复代码较多，冗余</li>
	<li>python3：代码崇尚优美、清晰、简单</li>
</ol><h2>　　print：</h2>

<ol><li>python2：print是一个语句</li>
	<li>python3：print是一个函数</li>
</ol><h2>　　input：</h2>

<ol><li>python2：raw_input()接收字符串，input()接收数字</li>
	<li>python3：input()接收的全部是字符串</li>
</ol><h2>　　编码方式：</h2>

<ol><li>python2：默认编码是ASCII码（若想使用中文：#_*_coding:utf-8_*_）</li>
	<li>python3：默认编码是utf-8，支持中文</li>
</ol><h2>　　不等运算符：</h2>

<ol><li>python2：可以使用!=或者&gt;&lt;</li>
	<li>python3：只能使用!=</li>
</ol><h2>　　创建迭代计数器：</h2>

<ol><li>python2：xrange</li>
	<li>python3：range</li>
</ol><h2>　　repr：</h2>

<ol><li>python2：repr可以是语句</li>
	<li>python3：只允许使用repr()函数</li>
</ol><h2>　　文件：</h2>

<ol><li>python2：可以使用!=或者&gt;&lt;</li>
	<li>python3：只能使用!=</li>
</ol><h2>　　整型：</h2>

<ol><li>python2：存在long型</li>
	<li>python3：全部为int型</li>
</ol><h2>　　修改语法：</h2>

<ol><li>python2：字典的keys，values，items以及map，filter，reduce返回的都是一个列表</li>
	<li>python3：字典的keys，values，items以及map，filter，reduce返回一个可迭代对象</li>
</ol><h2>　　新增语法：</h2>

<ol><li>python2：print和exec语句，无nolocal等方法</li>
	<li>python3：print和exec改为函数，新增nolocal等方法</li>
</ol><h2>　　继承：</h2>

<ol><li>python2：默认经典类（新式类需要(object)）</li>
	<li>python3：只有新式类</li>
</ol><h1>三、开发的种类</h1>

<h2>　　编译型</h2>

<p>　　缺点：排错慢，开发效率低，不可移植</p>

<p>　　优点：执行效率高</p>

<p>　　典型：C语言，go语言</p>

<h2>　　解释型</h2>

<p>　　缺点：执行效率低</p>

<p>　　优点：排错快，开发效率高，可移植</p>

<p>　　典型：python，PHP</p>

<h2>　　混合型</h2>

<p>　　典型：java，C#</p>

<h1>四、python的种类</h1>

<p>　　Cpython：基于C语言开发的</p>

<p>　　lpython</p>

<p>　　Jpython</p>

<p>　　PyPy：目前执行最快的</p>

<h1>五、变量与常量</h1>

<p>　　常量：一直不变的量，约定俗称，全部大写为常量</p>

<p>&nbsp;</p>

<p>　　变量：把程序的运行结果存放在内存中，以便后期代码的调用</p>

<p>　　要求：</p>

<ol><li>必须由数字、字母、下划线组成</li>
	<li>不能以数字开头</li>
	<li>不能是关键字</li>
	<li>不能是中文，不能太长，要有可描述性</li>
	<li>官网推荐下划线old_boy和驼峰体OldBoy</li>
</ol>                                    ]]></description></item><item><title>Centos7服务器搭建网络家园和论坛</title><link>http://www.cnblogs.com/heian99/archive/2019/04/29/11972270.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 29 Apr 2019 15:44:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/29/11972270.html</guid><description><![CDATA[
                                            <p><strong>环境：Centos7</strong></p>

<p><strong>工具：mysql，php，httpd</strong></p>

<p><strong>目的：熟练掌握httpd服务器搭建和个服务器之间的配合。</strong></p>

<p><strong>有兴趣的朋友可以来实践一下，我会提供各种源码进行搭建。</strong></p>

<p><strong>网络家园和论坛</strong><strong>源码：</strong><a href="https://www.lanzous.com/i3yqq3c" rel="nofollow">https://www.lanzous.com/i3yqq3c</a></p>

<p><img alt="" class="has" height="634" src="https://img-blog.csdnimg.cn/20190429234212223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="866" src="https://img-blog.csdnimg.cn/20190429233953663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>（1）准备一台centos服务器，我是在虚拟机搭建的centos7.</strong></p>

<p><strong>（2）关闭防火墙和selinux等（<a href="https://blog.csdn.net/heian_99/article/details/85624511" rel="nofollow">centos7关闭防火墙和selinux</a>）</strong></p>

<p><strong>（3）搭建myql数据库（<a href="https://blog.csdn.net/heian_99/article/details/89326404" rel="nofollow">MySQL的rpm安装教程</a>）</strong></p>

<p><strong>（4）搭建httpd服务器（centos7自带httpd，只需要启动即可用）</strong></p>

<p><strong><img alt="" class="has" height="590" src="https://img-blog.csdnimg.cn/20190429225305121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="811"></strong></p>

<p><strong>（5）安装PHP服务器</strong></p>

<ol><li><strong>安装</strong></li>
</ol><pre class="has"><code>[root@wei ~]#  yum install php –y
</code></pre>

<p style="margin-left:0cm;"><strong>安装php-mysql </strong></p>

<pre class="has"><code>[root@wei ~]# yum install php-mysql –y
</code></pre>

<p><strong>2.测试php和apache协同</strong></p>

<p style="margin-left:0cm;"><strong>测试协同</strong></p>

<pre class="has"><code>[root@localhost ~]# cd /var/www/html/</code></pre>

<pre class="has"><code>[root@localhost html]# vim phpinfo.php



&lt;?php

&nbsp; phpinfo();

?&gt;</code></pre>

<p style="margin-left:0cm;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 测试： <a href="http://IP/phpinfo.php" rel="nofollow">http://IP/phpinfo.php</a></strong></p>

<p><strong><img alt="" class="has" height="688" src="https://img-blog.csdnimg.cn/20190429230546718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></strong></p>

<ol><li>测试php和MySQL协同</li>
</ol><pre class="has"><code>[root@localhost html]# vim php_mysql.php

&lt;?php
$servername = "localhost";
$username = "admin";
$password = "123456";

// 创建连接
//$con = mysql_connect($servername,$username,$password);
$conn = new mysqli($servername, $username, $password);

// 检测连接
if ($conn-&gt;connect_error) {
    die("连接失败: " . $conn-&gt;connect_error);
}
echo "连接成功";
?&gt;
</code></pre>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 测试： <a href="http://IP/phpinfo.php" rel="nofollow">http://IP/php_mysql.php</a></strong></p>

<p><img alt="" class="has" height="279" src="https://img-blog.csdnimg.cn/20190429231114300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><strong>（6）部署应用</strong></p>

<p><strong>1.上传代码（代码在上面）（代码上传到/var/www/html/目录）</strong></p>

<p><img alt="" class="has" height="437" src="https://img-blog.csdnimg.cn/20190429231400136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1174"></p>

<p>&nbsp;</p>

<p>2.解压</p>

<p style="margin-left:0cm;">安装解压软件：</p>

<pre class="has"><code>[root@localhost html]# yum install unzip –y</code></pre>

<p>3.配置</p>

<p style="margin-left:0cm;">改名：</p>

<pre class="has"><code>[root@wei html]# mv upload/ farm
</code></pre>

<p><img alt="" class="has" height="145" src="https://img-blog.csdnimg.cn/2019042923185067.png" width="608"></p>

<p>&nbsp;</p>

<h1 style="margin-left:0cm;"><span style="color:#f33b45;">在线安装：</span></h1>

<p style="margin-left:0cm;"><a href="http://192.168.217.131/farm/install/index.php" rel="nofollow">http://192.168.196.131/farm/install/index.php</a></p>

<p>1.问题一</p>

<p><img alt="" class="has" height="581" src="https://img-blog.csdnimg.cn/20190429231932442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p style="margin-left:0cm;">修改/etc/php.ini， 将short_open_tag = On</p>

<pre class="has"><code>vim /etc/php.ini</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="158" src="https://img-blog.csdnimg.cn/20190429232102396.png" width="621"></p>

<p style="margin-left:0cm;">修改完毕，重启httpd服务。</p>

<pre class="has"><code>[root@wei html]# systemctl restart httpd
</code></pre>

<p>2.问题二</p>

<p><img alt="" class="has" height="879" src="https://img-blog.csdnimg.cn/20190429232256597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p style="margin-left:0cm;">修改目录权限：</p>

<pre class="has"><code>[root@localhost html]# chmod -R 777 farm</code></pre>

<p>&nbsp;</p>

<p>让后进项下面步骤，进行在线安装</p>

<p>步骤一：</p>

<p><img alt="" class="has" height="499" src="https://img-blog.csdnimg.cn/20190429232647400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1089"></p>

<p>步骤二：</p>

<p>创建farm数据库和用户</p>

<pre class="has"><code>[root@wei html]# mysql -u root -proot ##登录数据库
Warning: Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 6
Server version: 5.6.44 MySQL Community Server (GPL)

Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; create database farm;   ##创建farm数据库
Query OK, 1 row affected (0.00 sec)

mysql&gt; grant all on farm.* to farm@'localhost' identified by 'farm';  #创建用户，进行授权
Query OK, 0 rows affected (0.00 sec)

mysql&gt; flush privileges;  ##刷新权限表
Query OK, 0 rows affected (0.00 sec)

</code></pre>

<p><img alt="" class="has" height="1026" src="https://img-blog.csdnimg.cn/20190429233500759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>步骤三：</p>

<p>进行安装</p>

<p><img alt="" class="has" height="287" src="https://img-blog.csdnimg.cn/20190429233551411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><img alt="" class="has" height="343" src="https://img-blog.csdnimg.cn/20190429233605856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="912" src="https://img-blog.csdnimg.cn/20190429233635619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>步骤四：</p>

<p>进行测试</p>

<p><a href="http://192.168.196.131/farm/bbs/" rel="nofollow">http://192.168.196.131/farm/bbs/</a></p>

<p><img alt="" class="has" height="910" src="https://img-blog.csdnimg.cn/20190429233730909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<p><a href="http://192.168.196.131/farm/" rel="nofollow">http://192.168.196.131/farm/</a></p>

<p><img alt="" class="has" height="568" src="https://img-blog.csdnimg.cn/20190429233805515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p><a href="http://192.168.196.131/farm/home/space.php?do=home" rel="nofollow">http://192.168.196.131/farm/home/space.php?do=home</a></p>

<p><img alt="" class="has" height="896" src="https://img-blog.csdnimg.cn/20190429234306190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Navicat Premium 详解</title><link>http://www.cnblogs.com/heian99/archive/2019/04/27/11972271.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 27 Apr 2019 13:36:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/27/11972271.html</guid><description><![CDATA[
                                            <p><strong>Navicat是一套数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。</strong></p>

<p><strong>Navicat 是以直觉化的图形用户界面而建的，可以安全和简单地创建、组织、访问并共用信息。&nbsp;<br>
Navicat Premium 是 Navicat 的产品成员之一，能简单并快速地在各种数据库系统间传输数据，或传输一份指定 SQL 格式及编码的纯文本文件。其他功能包括导入向导、导出向导、查询创建工具、报表创建工具、资料同步、备份、工作计划及更多。&nbsp;<br><br>
本文介绍在Navicat Premium中进行简单的数据库管理。&nbsp;<br>
在下载安装完 Navicat Premium 之后，进行以下操作。</strong></p>

<p><strong>Navicat Premium 软件：（提供32位&amp;&amp;64位【破解文件】）</strong></p>

<p><strong><img alt="" class="has" height="124" src="https://img-blog.csdnimg.cn/2019042721283947.png" width="104"></strong></p>

<p><strong>链接：https://pan.baidu.com/s/1bt_W1FuB-uzlmkPaYfj-2g 密码：op4h</strong></p>

<p><strong>如果软件链接失效，可留言提供最新链接</strong></p>

<p><strong>Navicat Premium 安装破解教程</strong></p>

<p><strong><a href="https://blog.csdn.net/loveer0/article/details/82016644" rel="nofollow">https://blog.csdn.net/loveer0/article/details/82016644</a></strong></p>

<p><strong>Navicat Premium 官网详细教程</strong></p>

<p><strong><a href="http://www.formysql.com/premium/" rel="nofollow">http://www.formysql.com/premium/</a>&nbsp;</strong></p>

<p>&nbsp;</p>

<p>在下载安装完 Navicat Premium 之后，进行以下操作。</p>

<blockquote>
<p>连接MySQL数据库&nbsp;</p>
</blockquote>

<p>&nbsp;</p>

<p><img alt="" class="has" height="900" src="https://img-blog.csdnimg.cn/20190427213453205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1200"></p>

<p>&nbsp;</p>

<table><thead><tr><th>快捷键</th>
			<th>功能</th>
		</tr></thead><tbody><tr><td>ctrl+F</td>
			<td>搜索本页数据</td>
		</tr><tr><td>Ctrl+Q</td>
			<td>打开查询窗口</td>
		</tr><tr><td>Ctrl+/</td>
			<td>注释sql语句</td>
		</tr><tr><td>Ctrl+Shift +/</td>
			<td>解除注释</td>
		</tr><tr><td>Ctrl+R</td>
			<td>运行查询窗口的sql语句</td>
		</tr><tr><td>Ctrl+Shift+R</td>
			<td>只运行选中的sql语句</td>
		</tr><tr><td>F6</td>
			<td>打开一个mysql命令行窗口</td>
		</tr><tr><td>Ctrl+L</td>
			<td>删除一行</td>
		</tr><tr><td>Ctrl+N</td>
			<td>打开一个新的查询窗口</td>
		</tr><tr><td>Ctrl+W</td>
			<td>关闭一个查询窗口</td>
		</tr><tr><td>Ctrl+D</td>
			<td>表的数据显示显示页面切换到表的结构设计页面，但是在查询页面写sql时是复制当前行</td>
		</tr></tbody></table><p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL读写分离之MyCAT</title><link>http://www.cnblogs.com/heian99/archive/2019/04/26/11972272.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 26 Apr 2019 13:08:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/26/11972272.html</guid><description><![CDATA[
                                            <p>Mycat实现MySQL主从复制读写分离<br><br><br>
MyCAT的安装及部署<br><br>
1、部署jdk环境<br>
MyCAT用Java开发，需要有JAVA运行环境，mycat依赖jdk1.7的环境<br>
1）上传jdk</p>

<pre class="has"><code>[root@localhost tools]# ll jdk-7u45-linux-x64.tar.gz
-rw-r--r-- 1 root root 138094686 10月 24 2013 jdk-7u45-linux-x64.tar.gz</code></pre>

<p><br><br>
2）安装jdk</p>

<pre class="has"><code>[root@localhost tools]# mkdir /usr/java
[root@localhost tools]# tar xf jdk-7u45-linux-x64.tar.gz -C /usr/java/</code></pre>

<p><br><br>
3）设置环境变量</p>

<pre class="has"><code>[root@localhost tools]# vim /etc/profile.d/java.sh</code></pre>

<p><br>
内容如下：</p>

<pre class="has"><code>export JAVA_HOME=/usr/java/jdk1.7.0_45/
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></pre>

<p><br><br>
使环境变量当前终端生效</p>

<pre class="has"><code>[root@localhost tools]# source /etc/profile.d/java.sh</code></pre>

<p><br><br>
4）测试</p>

<pre class="has"><code>[root@localhost tools]# java -version
java version "1.7.0_45"
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
</code></pre>

<p><br><br>
2、安装Mycat<br>
1）上传mycat包</p>

<pre class="has"><code>[root@localhost tools]# ll Mycat-server-1.5.1-RELEASE-20161130213509-linux.tar.gz
-rw-r--r--. 1 root root 11499865 12月 15 16:33 Mycat-server-1.5.1-RELEASE-20161130213509-linux.tar.gz</code></pre>

<p><br><br><br>
2）解压</p>

<pre class="has"><code>[root@localhost tools]# tar xf Mycat-server-1.5.1-RELEASE-20161130213509-linux.tar.gz -C /usr/local/</code></pre>

<p><br><br>
解压后内容如下：</p>

<pre class="has"><code>[root@localhost tools]# ll /usr/local/mycat</code></pre>

<p><br>
总用量 16</p>

<pre class="has"><code>drwxr-xr-x 2 root root 4096 12月 15 11:36 bin
drwxrwxrwx 2 root root 6 3月 1 2016 catlet
drwxrwxrwx 4 root root 4096 12月 15 11:36 conf
drwxr-xr-x 2 root root 4096 12月 15 11:36 lib
drwxrwxrwx 2 root root 6 10月 28 20:47 logs
-rwxrwxrwx 1 root root 217 10月 28 20:47 version.txt</code></pre>

<p><br><br>
3）添加环境变量</p>

<pre class="has"><code>[root@localhost tools]# vim /etc/profile.d/mycat.sh
export PATH=$PATH:/usr/local/mycat/bin

[root@localhost tools]# source /etc/profile.d/mycat.sh</code></pre>

<p><br><br><br>
3、读写分离配置<br>
1）不使用Mycat托管MySQL主从服务器，简单使用如下配置<br>
#注意：配置前备份下配置文件</p>

<pre class="has"><code>[root@localhost tools]# cd /usr/local/mycat/conf
[root@localhost conf]# cp schema.xml{,.bak}</code></pre>

<blockquote>
<p><br><br>
(1)&lt;schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100" dataNode="dn1"&gt;<br>
这里的TESTDB就是我们所宣称的数据库名称，必须和server.xml中的用户指定的数据库名称一致。添加一个dataNode="dn1"，是指定了我们这个库只有在dn1上，没有分库。<br><br>
(2)&lt;dataNode name="dn1" dataHost="localhost1" database="db1" /&gt;<br>
这里只需要改database的名字，就是你真是的数据库上的数据库名，可根据自己的数据库名称修改。<br><br>
(3) &lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"<br>
writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"&gt;<br><br>
需要配置的位置：<br>
balance="1" writeType="0" switchType="1"<br><br>
balance<br>
1、balance=0 不开启读写分离机制，所有读操作都发送到当前可用的writehostle .<br><br>
2、balance=1 全部的readhost与stand by writeHost 参与select语句的负载均衡。简单的说，双主双从模式(M1-&gt;S1,M2-&gt;S2，并且M1和M2互为主备)，正常情况下，M1，S1，S2都参与select语句的复杂均衡。<br><br>
3、balance=2 所有读操作都随机的在readhost和writehost上分发<br><br>
writeType<br>
负载均衡类型，目前的取值有3种：<br>
1、writeType="0", 所有写操作发送到配置的第一个writeHost。<br>
2、writeType="1"，所有写操作都随机的发送到配置的writeHost。<br>
3、writeType="2"，不执行写操作。<br><br>
switchType<br>
1、switchType=-1 表示不自动切换<br>
2、switchType=1 默认值，自动切换<br>
3、switchType=2 基于MySQL 主从同步的状态决定是否切换</p>
</blockquote>

<blockquote>
<p>(4)&lt;writeHost host="hostM1" url="192.168.95.120:3306" user="mycat" password="123456"&gt;</p>

<p>&lt;!– can have multi read hosts –&gt;</p>

<p>&lt;readHost host="hostS2" url="192.168.95.140:3306" user="mycat_r" password="123456" /&gt;</p>

<p>&lt;readHost host="hostS3" url="192.168.95.140:3307" user="mycat_r" password="123456" /&gt;</p>

<p>&lt;!--&lt;writeHost host="hostS1" url="localhost:3316" user="root"</p>

<p>password="123456" /&gt;--&gt;</p>
</blockquote>

<p><br><br>
配置好文件内容如下:</p>

<pre class="has"><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;
&lt;mycat:schema xmlns:mycat="http://org.opencloudb/" &gt;


&lt;schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100" dataNode="dn1"&gt;
&lt;/schema&gt;
&lt;dataNode name="dn1" dataHost="localhost1" database="db1" /&gt;
&lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"
writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"&gt;
&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;
&lt;writeHost host="hostM1" url="192.168.95.120:3306" user="root"
password="123456"&gt;
&lt;readHost host="hostR1" url="192.168.95.140:3306" user="root" password="123456" /&gt;
&lt;readHost host="hostR2" url="192.168.95.140:3307" user="root" password="123456" /&gt;
&lt;/writeHost&gt;
&lt;/dataHost&gt;
&lt;/mycat:schema&gt;
</code></pre>

<p><br>
4、创建管理用户<br>
主库上对mycat用户授权如下：<br><br>
用户：mycat 密码：123456 端口：3306<br><br>
权限：insert,delete,update,select<br><br>
命令：grant insert,delete,update,select on TD_OA.* to mycat@'192.168.95.%' identified by '123456';<br>
flush privileges;<br><br>
从库上mycat_r用户授权如下：<br>
用户：mycat_r 密码：123456 端口：3306/3307<br>
权限： select<br><br>
grant select on TD_OA.* to mycat@'192.168.95.%' identified by '123456';<br>
flush privileges;<br><br>
测试环境可以直接使用root用户，授予所有权限：</p>

<pre class="has"><code>mysql&gt; grant all on *.* to root@'192.168.95.%' identified by '123456';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; grant all on *.* to root@'localhost' identified by '123456';</code></pre>

<p><br><br><br>
5、修改mycat配置文件<br>
采用默认配置<br><br>
注意：<br><br>
①这里配置的是可以连接主库的两个用户<br><br>
用户：test 密码：test 给予此用户TESTDB数据库增删改查的权限。<br><br>
用户：user 密码：password 给予此用户TESTDB数据库读的权限。<br><br>
②这里的TESTDB，不一定是你数据库上的真实库名，可以任意指定，只要接下来和schema.xml的配置文件的库名统一即可。<br><br>
6、启动Mycat<br>
方法一：# mycat console #&lt;=通过console命令启动mycat，这样方便提取信息<br>
方法二：# mycat start<br>
方法三：# startup_nowrap.sh #服务脚本方式启动<br><br><br>
[root@localhost conf]# netstat -lnupt | egrep "(8|9)066"<br>
tcp6 0 0 :::9066 :::* LISTEN 3342/java<br>
tcp6 0 0 :::8066 :::* LISTEN 3342/java<br><br>
重启：# mycat restart<br><br>
7、在客户端连接mysql主库服务器：<br>
&nbsp;</p>

<pre class="has"><code># mysql -uuser -puser -h192.168.95.130 -P8066 -DTESTDB
Warning: Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.6.29-mycat-1.6-RELEASE-20161028204710 MyCat Server (OpenCloundDB)

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt;
</code></pre>

<p><br>
8、主从同步读写分离测试<br>
管理端创建表:</p>

<pre class="has"><code>[root@localhost ~]# mysql -utest -ptest -h192.168.95.130 -P8066 -DTESTDB
CREATE TABLE test1 (id int(10),name varchar(10),address varchar(20) DEFAULT NULL);</code></pre>

<p><br><br>
手动停止主从同步: stop slave;<br><br>
分别在主从库插入数据:<br><strong>master: insert into test1 values(1,'test1','master');<br><br>
slave1: insert into test1 values(2,'test1','slave1');<br>
slave2: insert into test1 values(3,'test1','slave2');</strong><br><br>
管理端验证<br>
负载均衡:</p>

<pre class="has"><code>mysql&gt; select * from test1;
+------+-------+---------+
| id | name | address |
+------+-------+---------+
| 2 | test1 | slave1 |
+------+-------+---------+
1 row in set (0.00 sec)

mysql&gt; select * from test1;
+------+-------+---------+
| id | name | address |
+------+-------+---------+
| 3 | test1 | slave2 |
+------+-------+---------+
1 row in set (0.00 sec)</code></pre>

<p><br><br>
读写功能:<br>
管理端再次插入数据 insert into test1 values(4,'test1','write');</p>

<pre class="has"><code>mysql&gt; insert into test1 values(4,'test1','write');
Query OK, 1 row affected (0.00 sec)
</code></pre>

<p><br>
#注意：测试完毕启动主从同步功能。<br><br>
9、管理命令与监控<br>
mycat自身有类似其他数据库的管理监控方式，可通过mysql命令行，登陆端口9066执行相应的SQL操作，也可通过jdbc的方式进行远程连接管理。<br><br>
登录：目前mycat有两个端口，8066数据端口，9066管理端口。命令行登录时通过9066管理端口来执行：</p>

<pre class="has"><code># mysql -uuser -puser -h192.168.95.130 -P9066 -DTESTDB
Warning: Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.6.29-mycat-1.6-RELEASE-20161028204710 MyCat Server (monitor)

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt;</code></pre>

<p><br><br>
选项：<br><br>
-h 后面接主机<br><br>
-u mycat server.xml配置的逻辑库用户<br><br>
-p mycat server.xml配置的逻辑库密码<br><br>
-P 后面接的端口9066，注意P大写<br><br><br>
-D Mycat server.xml中配置的逻辑库<br><br>
1）查看所有的命令，如下：</p>

<pre class="has"><code>mysql&gt; show @@help;</code></pre>

<p><br><br>
2）显示mycat数据库的列表，对应的在scehma.xml配置的逻辑库</p>

<pre class="has"><code>mysql&gt; show @@databases;
+----------+
| DATABASE |
+----------+
| TESTDB |
+----------+
1 row in set (0.00 sec)</code></pre>

<p><br><br>
3）显示mycat数据节点的列表，对应的是scehma.xml配置文件的dataNode节点</p>

<pre class="has"><code>mysql&gt; show @@datanode;
+------+----------------+-------+-------+--------+------+------+---------+------------+----------+---------+---------------+
| NAME | DATHOST | INDEX | TYPE | ACTIVE | IDLE | SIZE | EXECUTE | TOTAL_TIME | MAX_TIME | MAX_SQL | RECOVERY_TIME |
+------+----------------+-------+-------+--------+------+------+---------+------------+----------+---------+---------------+
| dn1 | localhost1/db1 | 0 | mysql | 0 | 0 | 1000 | 0 | 0 | 0 | 0 | -1 |
| dn2 | localhost1/db2 | 0 | mysql | 0 | 0 | 1000 | 0 | 0 | 0 | 0 | -1 |
| dn3 | localhost1/db3 | 0 | mysql | 0 | 0 | 1000 | 0 | 0 | 0 | 0 | -1 |
+------+----------------+-------+-------+--------+------+------+---------+------------+----------+---------+---------------+
3 rows in set (0.00 sec)
</code></pre>

<p><br>
其中，NAME表示datanode的名称；dataHost 对应的是dataHost属性的值，数据主机的名称，ACTIVE表示活跃的连接数，IDIE表示闲置的连接数，SIZE对应的是总连接的数量。<br>
&nbsp;</p>

<pre class="has"><code>mysql&gt; show @@heartbeat;
+--------+-------+----------------+------+---------+-------+--------+---------+--------------+---------------------+-------+
| NAME | TYPE | HOST | PORT | RS_CODE | RETRY | STATUS | TIMEOUT | EXECUTE_TIME | LAST_ACTIVE_TIME | STOP |
+--------+-------+----------------+------+---------+-------+--------+---------+--------------+---------------------+-------+
| hostM1 | mysql | 192.168.95.120 | 3306 | 1 | 0 | idle | 0 | 1,0,0 | 2016-12-15 14:25:35 | false |
| hostS2 | mysql | 192.168.95.140 | 3306 | 1 | 0 | idle | 0 | 1,1,1 | 2016-12-15 14:25:35 | false |
| hostS3 | mysql | 192.168.95.140 | 3307 | 1 | 0 | idle | 0 | 1,1,1 | 2016-12-15 14:25:35 | false |
+--------+-------+----------------+------+---------+-------+--------+---------+--------------+---------------------+-------+
3 rows in set (0.01 sec)
</code></pre>

<p><br>
RS_CODE状态为1，正常状态<br><br>
4、获取当前mycat的版本</p>

<pre class="has"><code>mysql&gt; show @@version;</code></pre>

<p><br>
5、显示mycat前端连接状态</p>

<pre class="has"><code>mysql&gt; show @@connection;</code></pre>

<p><br>
6、显示mycat后端连接状态</p>

<pre class="has"><code>mysql&gt; show @@backend;</code></pre>

<p><br>
7、显示数据源<br>
&nbsp;</p>

<pre class="has"><code>mysql&gt; show @@datasource</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL读写分离之Proxy</title><link>http://www.cnblogs.com/heian99/archive/2019/04/24/11972273.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 23 Apr 2019 16:01:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/24/11972273.html</guid><description><![CDATA[
                                            <p><br><strong>MySQL Proxy：</strong><br>
========================================================<br><br><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190423235746381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"><br><br>
MySQL_Proxy Master Slave1 Slave2<br>
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝=<br>
IP 192.168.1.250&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;192.168.1.215&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;192.168.1.66<br>
Server_ID&nbsp; 6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;215&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 66<br><br>
实现步骤：<br>
MySQL主/备复制<br>
安装并配置MySQL Proxy<br>
测试Proxy<br><br><br>
一、MySQL主/备复制（略）<br><br><br>
二、安装并配置MySQL Proxy<br>
1. 安装并配置</p>

<pre class="has"><code>[root@MySQL_Proxy ~]# service mysqld stop
[root@MySQL_Proxy ~]# chkconfig mysqld off
[root@MySQL_Proxy ~]# rpm -qa |grep lua
lua-5.1.4-4.1.el6.x86_64
[root@MySQL_Proxy ~]# tar xf mysql-proxy-0.8.4-linux-el6-x86-64bit.tar.gz -C /usr/local/
[root@MySQL_Proxy ~]# cd /usr/local/
[root@MySQL_Proxy ~]# ln -s mysql-proxy-0.8.4-linux-el6-x86-64bit mysql-proxy
[root@MySQL_Proxy ~]# vim /usr/local/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua
min_idle_connections = 1,
max_idle_connections = 1,</code></pre>

<p><br><br>
2. 启动mysql-proxy</p>

<pre class="has"><code>[root@MySQL_Proxy ~]# lsof -i TCP:3306
[root@MySQL_Proxy ~]# /usr/local/mysql-proxy/bin/mysql-proxy --help-proxy</code></pre>

<p><br>
-P 指定proxy服务器工作的地址和端口<br>
-b 指定写服务器的地址和端口<br>
-r 指定读服务器的地址和端口<br>
-s 指定判断的脚本<br>
--daemon 以后台进程的方式启动<br><br>
调整最大打开的文件数</p>

<pre class="has"><code>[root@MySQL_Proxy ~]# ulimit -a |grep 'open files'
[root@MySQL_Proxy ~]# ulimit -n 10240
[root@MySQL_Proxy ~]# ulimit -a |grep 'open files'
open files (-n) 10240</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>[root@MySQL_Proxy ~]# /usr/local/mysql-proxy/bin/mysql-proxy -P 192.168.1.250:3306 -b 192.168.1.27:3306 -r 192.168.1.215:3306 -r 192.168.1.66:3306 -s /usr/local/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua --daemon
2014-02-13 17:15:54: (critical) plugin proxy 0.8.4 started</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>[root@MySQL_Proxy ~]# netstat -tnlp |grep :3306
tcp 0 0 192.168.10.137:3306 0.0.0.0:* LISTEN 16620/mysql-proxy</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>[root@MySQL_Proxy ~]# vim /etc/rc.local
ulimit -n 10240
/usr/local/mysql-proxy/bin/mysql-proxy -P 192.168.1.250:3306 -b 192.168.1.27:3306 -r 192.168.1.215:3306 -r 192.168.1.66:3306 -s /usr/local/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua --daemon</code></pre>

<p><br><br><br>
三、测试<br>
1. 主库</p>

<pre class="has"><code>mysql&gt; grant ALL on bbs.* to bbs@'192.168.1.%' identified by 'localhost';
mysql&gt; flush privileges;

mysql&gt; create database bbs;
mysql&gt; create table bbs.t1 (name varchar(50));</code></pre>

<p><br><br>
2. 备库<br>
mysql&gt; stop slave; //暂时断掉和主库的连接<br><br>
3. 从客户端测试<br>
a. 读 ====主 or 备<br>
b. 写 ====主<br><br>
4. 备库<br>
mysql&gt; start slave;<br>
=======================================================</p>
                                    ]]></description></item><item><title>MySQL复制技术</title><link>http://www.cnblogs.com/heian99/archive/2019/04/22/11972274.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 22 Apr 2019 14:17:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/22/11972274.html</guid><description><![CDATA[
                                            <p>MySQL高可用方案</p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422213949323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p>投票选举机制，较复杂<br>
MySQL本身没有提供replication failover的解决方案，自动切换需要依赖<a href="http://os.51cto.com/art/201307/401702.htm" rel="nofollow">MHA脚本</a><br>
可以有多台从库，从库可以做报表和备份</p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214023814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214041808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214117224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214128620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/201904222141421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214211319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><strong>MySQL复制技术</strong><br><br><br><br>
===========================================================================<br>
重置数据库：</p>

<pre class="has"><code># service mysqld stop
# rm -rf /usr/local/mysql/data/*
# /usr/local/mysql/scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data</code></pre>

<p><br>
&nbsp;</p>

<h2>复制拓扑：</h2>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214313244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214332500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<h2>复制原理：</h2>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214350321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<h2>1. 在主库上把数据更改记录到二进制日志（Binary Log）中。<br>
2. 备库将主库上的日志复制到自己的中继日志（Relay Log）中。<br>
3. 备库读取中继日志中的事件，将其重放到备库数据库之上。</h2>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190422214418640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p>一、主/备均为刚初始的数据库<br>
单主到多备： Master-MultiSlave<br>
Master&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slave1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Slave2<br>
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br>
IP 192.168.1.27&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 192.168.1.66&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;192.168.1.251<br>
Server_ID&nbsp; 27&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;66&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;251<br><br><br>
如何实现主从复制？<br>
在主服务器（master）上<br>
启用二进制日志<br>
选择一个唯一的server-id<br>
创建具有复制权限的用户<br>
在从服务器（slave）上<br>
启用中继日志（二进制日志可开启，也可不开启）<br>
选择一个唯一的server-id<br>
连接至主服务器，并开始复制<br>
1. 主库</p>

<pre class="has"><code>[root@master ~]# vim /etc/my.cnf
[mysqld]
log-bin=master-bin
binlog_format = row
sync_binlog = 1
skip_name_resolv = 1
log_slave_updates = 1
server_id = 27
[root@master ~]# service mysqld start
[root@master ~]# mysql
mysql&gt; reset master;
mysql&gt; grant replication slave, replication client on *.*
-&gt; to rep@'192.168.1.%' identified by 'localhost';
mysql&gt; flush privileges;
</code></pre>

<p><br>
2. 备库<br>
a. 测试复制账号</p>

<pre class="has"><code>[root@slave1 ~]# mysql -h 192.168.1.27 -urep -plocalhost
</code></pre>

<p><br>
b. 配置复制</p>

<pre class="has"><code>[root@slave1 ~]# vim /etc/my.cnf
log-bin=slave1-bin
binlog_format = row
sync_binlog = 1
skip_name_resolv = 1
log_slave_updates = 1
server_id = 66
[root@slave1 ~]# service mysqld start
[root@slave1 ~]# mysql
mysql&gt; reset master;
mysql&gt; change master to
-&gt; master_host='192.168.1.27',
-&gt; master_user='rep',
-&gt; master_password='localhost',
-&gt; master_log_file='master-bin.000001',
-&gt; master_log_pos=0;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; show slave status\G
*************************** 1. row ***************************
Slave_IO_State:
Master_Host: 192.168.1.27
Master_User: rep
Master_Port: 3306
Connect_Retry: 60
Master_Log_File: mysql-bin.000001
Read_Master_Log_Pos: 4
Relay_Log_File: mysql-relay-bin.000001
Relay_Log_Pos: 4
Relay_Master_Log_File: mysql-bin.000001
Slave_IO_Running: No
Slave_SQL_Running: No

mysql&gt; start slave;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show slave status\G
*************************** 1. row ***************************
Slave_IO_State: Waiting for master to send event
Master_Host: 192.168.1.27
Master_User: rep
Master_Port: 3306
Connect_Retry: 60
Master_Log_File: mysql-bin.000001
Read_Master_Log_Pos: 354
Relay_Log_File: mysql-relay-bin.000002
Relay_Log_Pos: 500
Relay_Master_Log_File: mysql-bin.000001
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
</code></pre>

<p><br>
3. 测试</p>

<pre class="has"><code>Master：
mysql&gt; show processlist\G
*************************** 2. row ***************************
Id: 2
User: rep
Host: 192.168.10.37:50915
db: NULL
Command: Binlog Dump
Time: 324
State: Master has sent all binlog to slave; waiting for binlog to be updated
Info: NULL
2 rows in set (0.00 sec)

mysql&gt; create database bbs;
Query OK, 1 row affected (0.00 sec)

mysql&gt; create table bbs.t1(id int);
Query OK, 0 rows affected (0.03 sec)

mysql&gt; insert into bbs.t1 values(1);
Query OK, 1 row affected (0.02 sec)
mysql&gt; select * from bbs.t1;
+------+
| id |
+------+
| 1 |
+------+
1 row in set (0.00 sec)

Slave：
mysql&gt; show processlist\G
*************************** 2. row ***************************
Id: 2
User: system user
Host:
db: NULL
Command: Connect
Time: 356
State: Waiting for master to send event
Info: NULL
*************************** 3. row ***************************
Id: 3
User: system user
Host:
db: NULL
Command: Connect
Time: -173772
State: Slave has read all relay log; waiting for the slave I/O thread to update it
Info: NULL
3 rows in set (0.00 sec)

mysql&gt; select * from bbs.t1;
+------+
| id |
+------+
| 1 |
+------+
1 row in set (0.03 sec)</code></pre>

<p><br><br><br><br>
二、针对已经运行一段时间的主库实现主/备<br>
单主到多备： Master-MultiSlave<br>
Master&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Slave1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Slave2<br>
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br>
IP 192.168.1.27&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 192.168.1.66&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;192.168.1.251<br>
Server_ID&nbsp; &nbsp;27&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 66&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;251<br><br><br>
1. 主库</p>

<pre class="has"><code>[root@master ~]# vim /etc/my.cnf
log-bin=master-bin
binlog_format = row
sync_binlog = 1
skip_name_resolv = 1
log_slave_updates = 1
server_id = 27
[root@master ~]# service mysqld restart
[root@master ~]# mysql
mysql&gt; grant replication slave, replication client on *.*
-&gt; to rep@'192.168.1.%' identified by 'localhost';
mysql&gt; flush privileges;</code></pre>

<p><br>
========================================================<br>
初始化备库（使其和主库数据一致）： 逻辑备份，物理备份<br>
主库：</p>

<pre class="has"><code>mysql&gt; flush tables with read lock; //主服务器锁定表
[root@master ~]# mysqldump --all-databases &gt; all.sql
[root@master ~]# mysql -e 'show master status'
+------------------+----------+--------------+------------------+
| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| master-bin.000001 | 699 | | |
+------------------+----------+--------------+------------------+
mysql&gt; unlock tables; //解锁表
[root@master ~]# rsync -va all.sql 192.168.1.66:/</code></pre>

<p><br>
========================================================<br><br><br>
2. 备库</p>

<pre class="has"><code>[root@slave1 ~]# vim /etc/my.cnf
server-id = 66
[root@slave1 ~]# service mysqld start
[root@slave1 ~]# mysql
mysql&gt; reset master;
mysql&gt; source /all.sql

mysql&gt; change master to
master_host='192.168.1.27',
master_user='rep',
master_password='localhost',
master_log_file='master-bin.000001',
master_log_pos=699;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; start slave;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show slave status\G
*************************** 1. row ***************************
Slave_IO_State: Waiting for master to send event
Master_Host: 192.168.1.27
Master_User: rep
Master_Port: 3306
Connect_Retry: 60
Master_Log_File: master-bin.000001
Read_Master_Log_Pos: 354
Relay_Log_File: mysql-relay-bin.000002
Relay_Log_Pos: 500
Relay_Master_Log_File: mysql-bin.000001
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
</code></pre>

<p><br>
MySQL主从复制的状况监测<br>
主从状况监测主要参数<br>
Slave_IO_Running: IO线程是否打开 YES/No/NULL<br>
Slave_SQL_Running: SQL线程是否打开 YES/No/NULL<br>
Seconds_Behind_Master: NULL #和主库比同步的延迟的秒数<br><br>
可能导致主从延时的因素<br>
主从时钟是否一致<br>
网络通信是否存在延迟<br>
是否和日志类型，数据过大有关<br>
从库性能，有没开启binlog<br>
从库查询是否优化<br><br>
常见状态错误排除<br>
发现IO进程错误，检查日志，排除故障：<br>
# tail localhost.localdomain.err<br>
...2015-11-18 10:55:50 3566 [ERROR] Slave I/O: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work. Error_code: 1593<br>
找到原因：从5.6开始复制引入了uuid的概念，各个复制结构中的server_uuid得保证不一样<br>
解决方法：(从库是克隆机器)修改从库的uuid<br>
# vim auto.cnf server-uuid=<br><br>
show slave status;报错：Error xxx doesn’t exist<br>
解决方法：<br>
stop slave;<br>
set global sql_slave_skip_counter = 1;<br>
start slave;<br>
三、常见复制拓朴<br>
1. 一主库多备库<br>
2. 主库，分发主库以及备库<br>
3. 主——主复制（双主）<br><br><br><br>
四、MySQL 主主同步<br>
重置数据库：</p>

<pre class="has"><code># service mysqld stop
# rm -rf /usr/local/mysql/data/*
# /usr/local/mysql/scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
</code></pre>

<p><br>
1. mysql1 192.168.1.4:</p>

<pre class="has"><code>[root@mysql1 ~]# vim /etc/my.cnf
log-bin=mysql-bin
server-id = 4
[root@mysql1 ~]# service mysqld start
[root@mysql1 ~]# mysql
mysql&gt; reset master;
mysql&gt; grant replication slave, replication client on *.*
-&gt; to rep@'192.168.1.%' identified by 'localhost';
mysql&gt; flush privileges;
mysql&gt; change master to
-&gt; master_host='192.168.1.251',
-&gt; master_user='rep',
-&gt; master_password='localhost',
-&gt; master_log_file='mysql-bin.000001',
-&gt; master_log_pos=0;
Query OK, 0 rows affected (0.02 sec)
mysql&gt; show slave status\G</code></pre>

<p><br><br>
2. mysql2 192.168.1.251:</p>

<pre class="has"><code>[root@mysql2 ~]# vim /etc/my.cnf
log-bin=mysql-bin
server-id = 251
[root@mysql2 ~]# service mysqld start
[root@mysql2 ~]# mysql
mysql&gt; reset master;
mysql&gt; grant replication slave, replication client on *.*
-&gt; to rep@'192.168.1.%' identified by 'localhost';
mysql&gt; flush privileges;
mysql&gt; change master to
-&gt; master_host='192.168.1.4',
-&gt; master_user='rep',
-&gt; master_password='localhost',
-&gt; master_log_file='mysql-bin.000001',
-&gt; master_log_pos=0;
Query OK, 0 rows affected (0.02 sec)
mysql&gt; show slave status\G
</code></pre>

<p><br>
3. mysql1,mysql2</p>

<pre class="has"><code>mysql&gt; slave start;
mysql&gt; show slave status\G</code></pre>

<p><br><br>
4. 测试<br><br>
5. 建立用于客户连接用户</p>

<pre class="has"><code>mysql&gt; grant ALL on *.* to admin@'192.168.1.%' identified by 'localhost';
mysql&gt; flush privileges;
</code></pre>

<p><br>
===========================================================================<br><br>
生产环境其他常用设置<br>
1、配置忽略权限库同步参数<br>
binlog-ignore-db='information_schema mysql test'<br>
2、从库备份开启binlog<br>
log-slave-updates<br>
log_bin = mysql-bin<br>
expire_logs_days = 7<br>
应用场景：级联复制或从库做数据备份。<br>
3、从库只读read-only来实现<br>
innodb_read_only = ON或1，或者innodb_read_only<br>
结论：当用户权限中没有SUPER权限(ALL权限是包括SUPER的)时，从库的read-only生效！</p>
                                    ]]></description></item><item><title>MySQL数据物理备份之tar打包备份</title><link>http://www.cnblogs.com/heian99/archive/2019/04/21/11972275.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 21 Apr 2019 14:28:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/21/11972275.html</guid><description><![CDATA[
                                            <p>复制数据文件方式，可以使用cp或tar<br><br>
1、停止服务</p>

<pre class="has"><code>[root@localhost mysql]# systemctl stop mysqld
[root@localhost mysql]# netstat -lnupt | grep 3306
</code></pre>

<p><br>
2、备份数据文件</p>

<pre class="has"><code>cd /var/lib/mysql
[root@localhost mysql]# mkdir -p /server/backup
[root@localhost mysql]#tar czf /server/backup/all.`date +%F`.tar.gz *</code></pre>

<p><br><br>
3、将备份文件拷贝到目标服务器</p>

<pre class="has"><code>scp /server/backup/all.`date +%F`.tar.gz 192.168.95.12:/tmp</code></pre>

<p><br><br>
4、目标服务器停止服务</p>

<pre class="has"><code># systemctl stop mysqld</code></pre>

<p><br><br>
5、解压文件至目标服务器数据文件夹</p>

<pre class="has"><code># tar xf /tmp/all.tar.gz -C /usr/local/mysql/data</code></pre>

<p><br>
修改权限</p>

<pre class="has"><code># chown -R mysql.mysql /usr/local/mysql/data
</code></pre>

<p><br>
6、目标服务器启动服务测试</p>

<pre class="has"><code># systemctl start mysqld</code></pre>

<p><br>
&nbsp;</p>
                                    ]]></description></item><item><title>MySQL数据物理备份之lvm快照</title><link>http://www.cnblogs.com/heian99/archive/2019/04/21/11972276.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 21 Apr 2019 14:25:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/21/11972276.html</guid><description><![CDATA[
                                            <h1>使用lvm快照实现物理备份</h1>

<p><br><br>
优点：<br>
几乎是热备(创建快照前把表上锁，创建完后立即释放)<br>
支持所有存储引擎<br>
备份速度快<br>
无需使用昂贵的商业软件(它是操作系统级别的)<br>
缺点：<br>
可能需要跨部门协调(使用操作系统级别的命令，DBA一般没权限)<br>
无法预计服务停止时间<br>
数据如果分布在多个卷上比较麻烦(针对存储级别而言)<br><br><br>
操作流程：<br>
1、flush table with read locak;<br>
2、create snapshot<br>
3、show master status;　show slave status;<br>
4、unlock tables;<br>
5、copy data from cow to backup<br>
6、remove snapshot<br>
&nbsp;</p>

<h1>正常安装MySQL：</h1>

<p><br>
1. 安装系统<br>
2. 准备LVM，例如 /dev/vg_localhost/lv-mysql，mount /usr/local/mysql<br>
3. 源码安装MySQL到 /usr/local/mysql<br><br>
可选操作：　将现在的数据迁移到LVM<br>
1. 准备lvm及文件系统</p>

<pre class="has"><code>[root@localhost ~]# lvcreate -L 2G -n lv-mysql vg_localhost
[root@localhost ~]# mkfs.ext4 /dev/vg_localhost/lv-mysql
</code></pre>

<p><br>
2. 将数据迁移到LVM</p>

<pre class="has"><code>[root@localhost ~]# service mysqld stop
[root@localhost ~]# mount /dev/vg_localhost/lv-mysql /mnt/ //临时挂载点
[root@localhost ~]# rsync -va /usr/local/mysql/ /mnt/ //将MySQL原数据镜像到临时挂载点</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>[root@localhost ~]# umount /mnt/
[root@localhost ~]# mount /dev/vg_localhost/lv-mysql /usr/local/mysql //加入fstab开机挂载
[root@localhost ~]# df -Th
/dev/mapper/vg_localhost-lv--mysql ext4 2.0G 274M 1.7G 15% /usr/local/mysql
[root@localhost ~]# service mysqld start
</code></pre>

<p><br>
&nbsp;</p>

<h1>手动基于LVM快照实现备份：</h1>

<p><br>
1. 加锁</p>

<pre class="has"><code>mysql&gt; flush table with read lock;
</code></pre>

<p><br>
2.创建快照</p>

<pre class="has"><code># lvcreate -L 500M -s -n lv-mysql-snap /dev/vg_localhost/lv-mysql

# mysql -uroot -p123 -e 'show master status' &gt; /backup/`date +%F`_position.txt

mysql&gt; show master status;
+-------------------+----------+--------------+------------------+-------------------+
| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------------+----------+--------------+------------------+-------------------+
| mysqld-bin.000016 | 542 | | | |
+-------------------+----------+--------------+------------------+-------------------+</code></pre>

<p><br><br>
3. 释放锁</p>

<pre class="has"><code>mysql&gt; unlock tables;
</code></pre>

<p><br>
4. 从快照中备份</p>

<pre class="has"><code>[root@localhost ~]# mount -o ro /dev/vg_localhost/lv-mysql-snap /mnt/
[root@localhost ~]# mkdir /backup/`date +%F`
[root@localhost ~]# rsync -a /mnt/ /backup/2014-09-02/</code></pre>

<p><br><br>
5. 移除快照</p>

<pre class="has"><code>[root@localhost ~]# umount /mnt/
[root@localhost ~]# lvremove -f /dev/vg_localhost/lv-mysql-snap
</code></pre>

<p><br>
&nbsp;</p>

<h2>脚本 + Cron</h2>

<p>&nbsp;</p>

<pre class="has"><code>#!/bin/bash
#LVM backmysql...
back_dir=/backup/`date +%F`

[ -d $back_dir ] || mkdir -p $back_dir

mysql -uroot -p678 -e 'flush table with read lock'
lvcreate -L 500M -s -n lv-mysql-snap /dev/vg_localhost/lv-mysql
mysql -uroot -p678 -e 'show master status' |grep mysql &gt; $back_dir/position.txt
mysql -uroot -p678 -e 'flush logs'
mysql -uroot -p678 -e 'unlock tables'

mount -o ro /dev/vg_localhost/lv-mysql-snap /mnt/

rsync -a /mnt/ $back_dir

if [ $? -eq 0 ];then
umount /mnt/
lvremove -f /dev/vg_localhost/lv-mysql-snap
fi
</code></pre>

<p><br><br><br>
&nbsp;</p>

<h1>mylvmbackup</h1>

<p><br>
功能：利用LVM快照实现物理备份，即LVM快照备份的自动版<br><br>
安装perl模块<br>
1. 在线安装</p>

<pre class="has"><code>http://www.lenzg.net/mylvmbackup</code></pre>

<p><br>
它依赖于perl 模块，可用以下命令安装</p>

<pre class="has"><code>perl -MCPAN -e 'install Config::IniFiles'
</code></pre>

<p><br>
2. 离线安装</p>

<pre class="has"><code># yum -y install atrpms-77-1.noarch.rpm perl-Config-IniFiles-2.72-3.em.el6.noarch.rpm perl-File-Copy-Recursive-0.38-1.el6.rfx.noarch.rpm perl-IO-stringy-2.110-8.el6.noarch.rpm
</code></pre>

<p><br>
安装mylvmbackup软件包</p>

<pre class="has"><code># yum -y install mylvmbackup-0.15-0.noarch.rpm</code></pre>

<p><br><br>
备份方法一：</p>

<pre class="has"><code># mylvmbackup --user=root --password=111 --host=localhost --mycnf=/etc/my.cnf --vgname=vg_localhost --lvname=lv-mysql --backuptype=tar --lvsize=100M --backupdir=/
backup</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>[root@localhost backup]# tar xf backup-20140903_000236_mysql.tar.gz
[root@localhost backup]# ls
backup backup-cnf-20140903_000236_mysql
backup-20140903_000236_mysql.tar.gz backup-pos
</code></pre>

<p><br><br>
备份方法二：</p>

<pre class="has"><code>[root@server ~]# vim /etc/mylvmbackup.conf
[mysql] #连接数据库配置
user=root
password=123456
host=localhost
port=3306
socket=/tmp/mysql.sock
mycnf=/etc/my.cnf
[lvm] #LVM逻辑卷的配置
vgname=vg_server #卷组名称
lvname=lv_mysql #逻辑卷名称
backuplv=mysql_snap #快照卷名称
lvsize=500M
[fs] #文件系统配置
xfs=0
mountdir=/var/tmp/mylvmbackup/mnt/ #挂载目录
backupdir=/backup #备份目录，也可以备份到行程主机
[misc] #定义备份选项
backuptype=tar #定义备份的类型
backupretention=0
prefix=backup #定义备份文件名前缀
suffix=_mysql #定义备份文件名后缀
tararg=cvf #定义tar参数，默认为cvf
tarfilesuffix=.tar.gz #定义备份文件后缀名格式
datefmt=%Y%m%d_%H%M%S #定义备份文件名时间戳格式
keep_snapshot=0 #是否保留snaphot
keep_mount=0 #是否卸载snaphot
quiet=0 #定义记录日志类型
注释：其他配置保持输入即可</code></pre>

<p><br><br>
然后直接执行mylvmbackup即可<br><br>
&nbsp;</p>
                                    ]]></description></item><item><title>MySQL数据物理备份之xtrabackup</title><link>http://www.cnblogs.com/heian99/archive/2019/04/21/11972278.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 21 Apr 2019 14:19:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/21/11972278.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<h1><strong>percona-xtrabackup</strong></h1>

<p><br><br>
它是开源免费的支持MySQL 数据库热备份的软件，它能对InnoDB和XtraDB存储引擎的数据库非阻塞地备份。它不暂停服务创建Innodb<strong>热备份</strong>；<br>
为mysql做增量备份；在mysql服务器之间做在线表迁移；使创建replication更加容易；备份mysql而不增加服务器的负载。<br>
percona是一家老牌的mysql技术咨询公司。它不仅提供mysql的技术支持、培训、咨询，还发布了mysql的分支版本--percona Server。并围绕<br>
percona Server还发布了一系统的mysql工具。<br>
=================================================================================<br>
&nbsp;</p>

<h2>完全备份</h2>

<p>&nbsp;</p>

<h2>增量备份</h2>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190421220749983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<h2>差异备份</h2>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190421220813787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p>xtrabackup<br>
Xtrabackup是一个对InnoDB做数据备份的工具，支持在线热备份（备份时不影响数据读写），是商业备份工具InnoDB Hotbackup的一个很好的替代品。<br>
Xtrabackup有两个主要的工具：xtrabackup、innobackupex<br>
xtrabackup 只能备份InnoDB和XtraDB两种数据表，而不能备份MyISAM数据表。 innobackupex 是参考了InnoDB Hotbackup的innoback脚本修改而来的.innobackupex是一个perl脚本封装，封装了xtrabackup。主要是为了方便的同时备份InnoDB和MyISAM引擎的表，但在处理myisam时需要加一个读锁。并且加入了一些使用的选项。如slave-info可以记录备份恢复后作为slave需要的一些信息，根据这些信息，可以很方便的利用备份来重做slave。支持完全备份和增量备份</p>

<ul><li>&nbsp;备份过程快速、可靠；</li>
	<li>备份过程不会打断正在执行的事务；</li>
	<li>&nbsp;能够基于压缩等功能节约磁盘空间和流量；</li>
	<li>自动实现备份检验；</li>
	<li>还原速度快；</li>
</ul><p>使用innobakupex备份时，其会调用xtrabackup备份所有的InnoDB表，复制所有关于表结构定义的相关文件(.frm)、以及MyISAM、MERGE、CSV和ARCHIVE表的相关文件，同时还会备份触发器和数据库配置信息相关的文件。这些文件会被保存至一个以时间命令的目录中。</p>

<p>(1)xtrabackup_checkpoints —— 备份类型（如完全或增量）、备份状态（如是否已经为prepared状态）和LSN(日志序列号)范围信息；每个InnoDB页(通常为16k大小)都会包含一个日志序列号，即LSN。LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明此页面最近是如何发生改变的。</p>

<p>(2)xtrabackup_binlog_info —— mysql服务器当前正在使用的二进制日志文件及至备份这一刻为止二进制日志事件的位置。(3)xtrabackup_binlog_pos_innodb —— 二进制日志文件及用于InnoDB或XtraDB表的二进制日志文件的当前position。</p>

<p>(4)xtrabackup_binary —— 备份中用到的xtrabackup的可执行文件；</p>

<p>(5)backup-my.cnf —— 备份命令用到的配置选项信息；</p>

<h3><br><span style="color:#f33b45;">安装xtrabackup</span><br>
&nbsp;</h3>

<pre class="has"><code>[root@localhost ~]# yum -y install percona-xtrabackup-2.1.9-744.rhel6.x86_64.rpm
[root@localhost ~]# rpm -ql percona-xtrabackup |grep bin
/usr/bin/innobackupex 支持myisam、innodb
/usr/bin/innobackupex-1.5.1
/usr/bin/xbcrypt
/usr/bin/xbstream
/usr/bin/xtrabackup 仅适用于percona Server
/usr/bin/xtrabackup_55 适用mysql 5.5数据库
/usr/bin/xtrabackup_56 适用mysql5.6数据库</code></pre>

<h1>完整备份实例</h1>

<p>：<br>
==备份==</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 /mysqlbackup/full
[root@localhost ~]# ls /mysqlbackup/full/2015-09-15_11-03-03/
backup-my.cnf company mysql school test xtrabackup_binary xtrabackup_checkpoints
bbs 　　ibdata1 performance_schema shop weibo xtrabackup_binlog_info xtrabackup_logfile
[root@localhost 2015-09-15_11-03-03]# cat xtrabackup_binlog_info
localhost-bin.000003 2090096
</code></pre>

<p><br>
==恢复==<br>
a. 准备新环境</p>

<pre class="has"><code>[root@localhost ~]# rm -rf /usr/local/mysql/data
[root@localhost ~]# chown -R mysql.mysql /usr/local/mysql
[root@localhost ~]# /usr/local/mysql/scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data
[root@localhost ~]# killall -9 mysqld
[root@localhost ~]# service mysqld start</code></pre>

<p><br>
b. 恢复</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --apply-log /mysqlbackup/full/2015-09-15_11-03-03/
[root@localhost ~]# rm -rf /usr/local/mysql/data/*
[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --copy-back /mysqlbackup/full/2015-09-15_11-03-03/
[root@localhost ~]# cd /usr/local/mysql
[root@localhost ~]# chown -R mysql.mysql .
[root@localhost ~]# killall -9 mysqld
[root@localhost ~]# service mysqld start</code></pre>

<p><br><br>
&nbsp;</p>

<h1>增量备份实例：</h1>

<p><br>
==备份==<br>
1、完整备份：周一</p>

<pre class="has"><code>create database testdb;
use testdb;
create table test(id int);
insert into test values(1);
select * from test;
</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 /mysqlbackup/full
</code></pre>

<p><br>
2、增量备份：周二　——　周六</p>

<pre class="has"><code>insert into testdb.test values(2);
[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --incremental /mysqlbackup/incremental
--incremental-basedir=完全备份目录</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>insert into testdb.test values(3);
[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --incremental /mysqlbackup/incremental
--incremental-basedir=上次增量目录</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>insert into testdb.test values(4);
[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --incremental /mysqlbackup/incremental
--incremental-basedir=上次增量目录</code></pre>

<p><br>
&nbsp;</p>

<h1>==恢复==</h1>

<p><br>
1.恢复全量的redo log</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --apply-log --redo-only /mysqlbackup/full/...
</code></pre>

<p><br>
2.恢复增量的redo log</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --apply-log --redo-only /mysqlbackup/full/...
--incremental-dir=/mysqlbackup/incremental/第一次增量
</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --apply-log --redo-only /mysqlbackup/full/...
--incremental-dir=/mysqlbackup/incremental/第二次增量
</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --apply-log --redo-only /mysqlbackup/full/...
--incremental-dir=/mysqlbackup/incremental/第Ｎ次增量</code></pre>

<p><br><br>
3.关闭mysqld，替换数据文件(cp,rsyn,innobackupex copy-back)，修改权限<br><br>
4.启动mysqld<br><br>
5.通过binlog增量恢复<br><br>
&nbsp;</p>

<pre class="has"><code>create database testdb;
use testdb;
create table test(id int);
insert into test values(1);
select * from test;

[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 /mysqlbackup/full</code></pre>

<h1>差异备份实例：</h1>

<p><br>
==备份==<br>
1、完整备份：周一<br><br><br>
2、差异备份：周二　——　周六</p>

<pre class="has"><code>insert into testdb.test values(2);
[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --incremental /mysqlbackup/incremental
--incremental-basedir=完全备份目录
</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>insert into testdb.test values(3);
[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --incremental /mysqlbackup/incremental
--incremental-basedir=完全备份目录</code></pre>

<p><br><br>
&nbsp;</p>

<pre class="has"><code>insert into testdb.test values(4);
[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --incremental /mysqlbackup/incremental
--incremental-basedir=完全备份目录
</code></pre>

<h1>==恢复==</h1>

<p><br>
1.恢复全量的redo log</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --apply-log --redo-only /mysqlbackup/full/...
</code></pre>

<p><br>
2.恢复差异的redo log</p>

<pre class="has"><code>[root@localhost ~]# innobackupex --host=localhost --socket=/tmp/mysql.sock --defaults-file=/etc/my.cnf --user=root --password=888 --apply-log --redo-only /mysqlbackup/full/...
--incremental-dir=/mysqlbackup/incremental/某个差异备份
</code></pre>

<p><br>
3.关闭mysqld，替换数据文件(cp,rsyn)，修改权限<br><br>
4.启动mysqld<br><br>
5.通过binlog增量恢复<br><br>
备份单库、多库、多表单数据库备份<br>
innobackupex --defaults-file=/etc/my.cnf --socket=/tmp/mysql.sock --databases=uplook --no-timestamp /server/backup/uplook<br>
多数据库备份innobackupex --user=root --password=123456 --include='dba.*|dbb.*' /server/backup<br>
多表备份方法一：innobackupex --user=root --password=123456 --include='dba.tablea|dbb.tableb' /server/backup<br>
方法二：使用--tables-file参数，这种方式是将所有要备份的完整表名都写在一个文本文件中，每行一个完整表名，然后程序读取这个文本文件进行备份。完整表名即：databasename.tablename<br>
echo "lianxi.Student" &gt;/tmp/table1.txt<br>
innobackupex --defaults-file=/etc/my.cnf --socket=/tmp/mysql.sock --tables-file='/tmp/table1.txt' --no-timestamp /server/backup/table1<br><br>
恢复单库、多库、多表单数据库恢复应用日志：<br>
innobackupex --apply-log /server/backup/uplook<br>
删除数据库数据文件：systemctl stop mysql；rm -rf /usr/local/mysql/data/*<br>
还原数据：innobackupex --copy-back /server/backup/uplook<br>
授权：chown -R mysql.mysql /usr/local/mysql<br>
初始化数据库：/usr/local/mysql/scripts/mysql_install_db --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql --explicit_defaults_for_timestamp<br>
启动数据库：systemctl start mysql<br>
测试：mysql -e "select * from uplook.Student;"<br><br>
多表数据恢复应用日志：<br>
innobackupex --apply-log --export /server/backup/table1/<br>
定义表--删除表空间--拷贝*.ibd/*.cfg文件--导入表空间<br>
定义表：模拟删除表，重新定义表结构，过程略<br>
删除表空间：mysql&gt; ALTER TABLE Student DISCARD TABLESPACE;<br>
拷贝*.ibd/*.cfg文件：[root@localhost ~]# cp /server/backup/table1/lianxi/Student.{cfg,ibd} /usr/local/mysql/data/lianxi/<br>
[root@localhost ~]# chown -R mysql.mysql /usr/local/mysql/data/lianxi/<br>
导入表空间：mysql&gt; ALTER TABLE Student IMPORT TABLESPACE;<br>
测试：mysql&gt; select * from Student;<br>
&nbsp;</p>

<h3>&nbsp;</h3>
                                    ]]></description></item><item><title>MySQL数据逻辑备份</title><link>http://www.cnblogs.com/heian99/archive/2019/04/20/11972279.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 20 Apr 2019 13:21:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/20/11972279.html</guid><description><![CDATA[
                                            <p>逻辑备份： 备份的是建表、建库、插入等操作所执行SQL语句，适用于中小型数据库，效率相对较低。<br>
mysqldump<br>
mydumper<br><br><strong><span style="color:#f33b45;">使用mysqldump实现逻辑备份</span></strong></p>

<p><br>
语法：<br>
# mysqldump -h 服务器 -u用户名 -p密码 数据库名 &gt; 备份文件.sql</p>

<p>关于数据库名：<br>
-A, --all-databases 所有库<br>
school 数据库名<br>
school stu_info t1 school数据库的表stu_info、t1<br>
-B, --databases bbs test mysql 多个数据库<br>
关于其它参数说明：<br>
--single-transaction &nbsp;&nbsp;&nbsp; #基于此项可以实现对InnoDB表做热备份<br>
-x, --lock-all-tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #执行备份时为所有表请求加锁 MyISAM<br>
-l, --lock-tables<br>
-E, --events&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #备份事件调度器代码<br>
--opt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #同时启动各种高级选项<br>
-R, --routines&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #备份存储过程和存储函数<br>
-F, --flush-logs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #备份之前刷新日志<br>
--triggers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #备份触发器<br>
--master-data=2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #备库，该选项将会记录binlog的日志位置与文件名并追加到文件中，如果为1将会输出CHANGE MASTER命令，主从下有用<br>
注意：-B 作用：创建数据库和切换到数据库，恢复时不用创建数据库和删表。备份多个库，-B 数据库1 数据库2 .<br>
-d只备份库结构，不包含数据内容<br>
备份：mysqldump -u 用户名 -p 数据库名 表名 &gt; 备份的文件名<br>
备份多个表：mysqldump -u 用户名 -p 数据库名 表名1 表名2 &gt; 备份的文件名</p>

<p>示例：</p>

<p>备份jiaowu数据库，名字为hei.sql</p>

<p>显示数据库</p>

<pre class="has"><code>[root@wei ~]# mysql -uroot -proot -e 'show databases;'</code></pre>

<p><img alt="" class="has" height="331" src="https://img-blog.csdnimg.cn/20190420202910838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="717"><br>
备份数据库</p>

<pre class="has"><code>[root@wei ~]# mysqldump -uroot -proot jiaowu &gt;hei.sql
</code></pre>

<p><img alt="" class="has" height="472" src="https://img-blog.csdnimg.cn/20190420203308798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="755"></p>

<p><br>
==备份==</p>

<pre class="has"><code>[root@localhost ~]# mysqldump -uroot -proot --single-transaction --master-data=2 company &gt; /tmp/company_`date +%F-%H-%M`.sql
[root@localhost ~]# mysqldump -uroot -proot --single-transaction --master-data=2 school &gt; /tmp/school_`date +%F-%H-%M`.sql
[root@localhost ~]# mysqldump -uroot -proot --single-transaction --master-data=2 school |gzip &gt; /tmp/school_`date +%F-%H-%M`.gz
[root@localhost ~]# mysqldump -uroot -proot --routines --events --triggers --master-data=2 --flush-logs --all-databases &gt; /backup/all_`date +%F`.sql
</code></pre>

<p><img alt="" class="has" height="467" src="https://img-blog.csdnimg.cn/20190420204345705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="815"><br><br><br>
==恢复==</p>

<pre class="has"><code>[root@localhost ~]# mysql -uroot -p888 -e 'create database school'
[root@localhost ~]# mysql -uroot -p888 school &lt; /tmp/school_2015-09-14-15-40.sql
root@(school)&gt; source /tmp/school_2015-09-14-15-40.sql
[root@localhost tmp]# gunzip -fc school_2015-09-14-15-09.gz | mysql -uroot -p888 school</code></pre>

<p><br><br>
==增量备份==<br><img alt="" class="has" src="https://img-blog.csdnimg.cn/2019042020225736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><span style="color:#f33b45;"><strong>增量备份前提：</strong></span></p>

<p>1）my.cnf，是要开启MySQL log-bin日志功能，重启MySQL&nbsp; &nbsp; &nbsp; log_bin = /data/mysql/data/mysql-bin<br>
2）存在一个完全备份，生产环境一般凌晨某个时刻进行全备<br>
示例：</p>

<pre class="has"><code>mysqldump -uroot -p --default-character-set=gbk --single-transaction -F -B school |gzip &gt; /server/backup/school_$(date +%F).sql.gz</code></pre>

<p><br>
InnoDB 表在备份时，通常启用选项 --single-transaction 来保证备份的一致性<br><br>
增量备份--恢复过程<br>
1、检查凌晨备份<br>
2、检查全备后的所有binlog # ls -lrt /usr/local/mysql/data/mysql-bin.*<br>
3、立即刷新并备份出binlog mysqladmin -uroot -p flush-logs<br>
cp /usr/local/mysql/data/mysql-bin.000004 /server/backup/<br>
提示：根据时间点及前一个binlog可以知道发现问题时刻前binlog日志为mysql-bin.000004<br>
4、恢复binlog生成sql语句mysqlbinlog mysql-bin.000004 &gt; bin.log<br>
5、恢复凌晨备份<br>
6、恢复增量备份<br><br>
mysqlbinlog增量恢复方式<br>
基于时间点恢复<br>
1）指定开始时间到结束时间 myslbinlog mysqlbin.000008 --start-datetime=’2014-10-45 01:10:46’ --stop-datetime=’2014-10-45 03:10:46’-r time.sql<br>
2）指定开始时间到文件结束 myslbinlog mysqlbin.000008 --start-datetime=’2014-10-45 01:10:46’ -d esen -r time.sql<br>
3）从文件开头到指定结束时间 myslbinlog mysqlbin.000008 --stop-datetime=’2014-10-45 03:10:46’ -d esen -r time.sql<br>
基于位置点的增量恢复<br>
1）指定开始位置到结束位置 myslbinlog mysqlbin.000008 --start-position=510 --stop-position=1312 -r pos.sql<br>
2）指定开始位置到文件结束 myslbinlog mysqlbin.000008 --start-position=510 -r pos.sql<br>
3）从文件开始位置到指定结束位置 myslbinlog mysqlbin.000008 --stop-position=1312 -r pos.sql<br><br>
==恢复binlog==<br>
单库？全库</p>

<pre class="has"><code>[root@localhost ~]# mysqlbinlog -d school localhost-bin.000002 --start-position=11574908 &gt; school-bin.sql
[root@localhost ~]# mysqlbinlog -d school localhost-bin.000003 &gt;&gt; school-bin.sql
[root@localhost ~]# mysqlbinlog -d school localhost-bin.000004 &gt;&gt; school-bin.sql
[root@localhost ~]# mysql -uroot -p888 school &lt; school-bin.sql
</code></pre>

<p><br><br>
实现自动化备份（数据库小）<br>
备份计划：<br>
1. 什么时间 2:00<br>
2. 对哪些数据库备份<br>
3. 备份文件放的位置<br><br>
备份脚本：</p>

<pre class="has"><code>[root@yang ~]# vim /mysql_back.sql
#!/bin/bash
back_dir=/backup
back_file=`date +%F`_all.sql
user=root
pass=123

if [ ! -d /backup ];then
mkdir -p /backup
fi

# 备份并截断日志
mysqldump -u${user} -p${pass} --lock-all-tables --routines --events --triggers --master-data=2 --flush-logs --all-databases &gt; /$back_dir/$back_file

# 只保留最近一周的备份
cd $back_dir
find . -mtime +7 -exec rm -rf {} \;
</code></pre>

<p><br>
手动测试：</p>

<pre class="has"><code>[root@yang ~]# chmod a+x /mysql_back.sql
[root@yang ~]# chattr +i /mysql_back.sql
[root@yang ~]# /mysql_back.sql
</code></pre>

<p><br>
配置cron：<br>
&nbsp;</p>

<pre class="has"><code>[root@yang ~]# crontab -e
0 2 * * * /mysql_back.sql</code></pre>

<h3><span style="color:#f33b45;">Mydumper介绍</span></h3>

<p><br>
Mydumper是一个针对MySQL和Drizzle的高性能多线程备份和恢复工具。开发人员主要来自MySQL,Facebook,SkySQL公司。目前已经在一些线上使用了Mydumper。<br>
Mydumper主要特性：<br>
• 轻量级C语言写的<br>
• 执行速度比mysqldump快10倍<br>
• 事务性和非事务性表一致的快照(适用于0.2.2以上版本)<br>
• 快速的文件压缩<br>
• 支持导出binlog<br>
• 多线程恢复(适用于0.2.1以上版本)<br>
• 以守护进程的工作方式，定时快照和连续二进制日志(适用于0.5.0以上版本)<br>
• 开源 (GNU GPLv3)<br>
&nbsp;</p>

<pre class="has"><code>#wget https://launchpadlibrarian.net/225370879/mydumper-0.9.1.tar.gz
# yum -y install glib2-devel mysql-devel zlib-devel pcre-devel
[root@localhost ~]# tar xf mydumper-0.9.1.tar.gz -C /usr/local/src/
[root@localhost ~]# cd /usr/local/src/mydumper-0.9.1/
# cmake .
# make
# make install</code></pre>

<p><br><br>
mydumper参数介绍：<br>
-d, --directory 导入备份目录<br>
-q, --queries-per-transaction 每次执行的查询数量, 默认1000<br>
-o, --overwrite-tables 如果表存在删除表<br>
-B, --database 需要备份的库<br>
-T, --tables-list 需要备份的表，用，分隔<br>
-o, --outputdir 输出目录<br>
-s, --statement-size Attempted size of INSERT statement in bytes, default 1000000<br>
-r, --rows 试图分裂成很多行块表<br>
-c, --compress 压缩输出文件<br>
-e, --build-empty-files 即使表没有数据，还是产生一个空文件<br>
-x, --regex 支持正则表达式<br>
-i, --ignore-engines 忽略的存储引擎，用，分隔<br>
-m, --no-schemas 不导出表结构<br>
-k, --no-locks 不执行临时共享读锁 警告：这将导致不一致的备份<br>
-l, --long-query-guard 长查询，默认60s<br>
--kill-long-queries kill掉长时间执行的查询(instead of aborting)<br>
-b, --binlogs 导出binlog<br>
-D, --daemon 启用守护进程模式<br>
-I, --snapshot-interval dump快照间隔时间，默认60s，需要在daemon模式下<br>
-L, --logfile 日志文件<br>
-h, --host<br>
-u, --user<br>
-p, --password<br>
-P, --port<br>
-S, --socket<br>
-t, --threads 使用的线程数，默认4<br>
-C, --compress-protocol 在mysql连接上使用压缩<br>
-V, --version<br>
-v, --verbose 更多输出, 0 = silent, 1 = errors, 2 = warnings, 3 = info, default 2<br><br>
mydumper输出文件：<br>
metadata:元数据 记录备份开始和结束时间，以及binlog日志文件位置。<br>
table data:每个表一个文件<br>
table schemas:表结构文件<br>
binary logs: 启用--binlogs选项后，二进制文件存放在binlog_snapshot目录下<br>
daemon mode:在这个模式下，有五个目录0，1，binlogs，binlog_snapshot，last_dump。<br>
备份目录是0和1，间隔备份，如果mydumper因某种原因失败而仍然有一个好的快照，<br>
当快照完成后，last_dump指向该备份。<br><br>
&nbsp;</p>

<h2>mydumper用例</h2>

<p><br>
==备份==</p>

<pre class="has"><code>#export LD_LIBRARY_PATH="/usr/local/mysql/lib:$LD_LIBRARY_PATH"
[root@localhost ~]# mydumper -h localhost -u root -p 123456 -t 6 -S /tmp/mysql.sock -B uplook -o /mysqlbackup/
[root@localhost ~]# ls /mysqlbackup/
metadata uplooking.Student-schema.sql uplook-schema-create.sql uplook.Student.sql
uplooking-schema-create.sql uplooking.Student.sql uplook.Student-schema.sql

** (mydumper:5247): CRITICAL **: Error connecting to database: Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)</code></pre>

<p><br>
解决方法：建立软连接</p>

<pre class="has"><code>ln -sv /tmp/mysql.sock /var/lib/mysql/mysql.sock

[root@localhost ~]# cat /mysqlbackup/metadata
[root@localhost ~]# cat /mysqlbackup/metadata
Started dump at: 2017-08-05 15:48:09
Finished dump at: 2017-08-05 15:48:09
</code></pre>

<p><br><br>
==恢复==</p>

<pre class="has"><code>[root@localhost ~]# mysql -uroot -p -e 'drop database uplook;'
[root@localhost ~]# myloader -h localhost -u root -p 123456 -S /tmp/mysql.sock -d /mysqlbackup/ -o -B uplook</code></pre>

<p><br>
&nbsp;</p>
                                    ]]></description></item><item><title>MySQL数据备份概述</title><link>http://www.cnblogs.com/heian99/archive/2019/04/20/11972280.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 20 Apr 2019 11:57:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/20/11972280.html</guid><description><![CDATA[
                                            <p><strong>MySQL备份类型</strong><br><br>
热备份、温备份、冷备份 （根据服务器状态）<br>
热备份：读、写不受影响；<br>
温备份：仅可以执行读操作；<br>
冷备份：离线备份；读、写操作均中止；<br><br>
物理备份与逻辑备份 （从对象来分）<br>
物理备份：复制数据文件；<br>
逻辑备份：将数据导出至文本文件中；<br><br>
完全备份、增量备份、差异备份 （从数据收集来分）<br>
完全备份：备份全部数据；<br>
增量备份：仅备份上次完全备份或增量备份以后变化的数据；<br>
差异备份：仅备份上次完全备份以来变化的数据；<br><br><strong>MySQL数据备份</strong><br><br><span style="color:#f33b45;">逻辑备份：</span> 备份的是建表、建库、插入等操作所执行SQL语句，适用于中小型数据库，效率相对较低。<br>
mysqldump<br>
mydumper<br><br><span style="color:#f33b45;">逻辑备份的优点：</span><br>
在备份速度上两种备份要取决于不同的存储引擎<br>
物理备份的还原速度非常快。但是物理备份的最小力度只能做到表<br>
逻辑备份保存的结构通常都是纯ASCII的，所以我们可以使用文本处理工具来处理<br>
逻辑备份有非常强的兼容性，而物理备份则对版本要求非常高<br>
逻辑备份也对保持数据的安全性有保证<br><br><span style="color:#f33b45;">逻辑备份的缺点：</span><br>
逻辑备份要对RDBMS产生额外的压力，而裸备份无压力<br>
逻辑备份的结果可能要比源文件更大。所以很多人都对备份的内容进行压缩<br>
逻辑备份可能会丢失浮点数的精度信息<br><br><span style="color:#f33b45;">物理备份：</span> 直接复制数据库文件，适用于大型数据库环境，不受存储引擎的限制，但不能恢复到异构系统中如Windows。<br>
xtrabackup<br>
inbackup<br>
lvm snapshot<br>
mysqlbackup ORACLE公司也提供了针对企业的备份软件MySQL Enterprise Backup简称<br><br>
MySQL备份内容<br>
数据文件日志文件（比如事务日志，二进制日志）<br>
存储过程，存储函数，触发器<br>
配置文件（十分重要，各个配置文件都要备份）<br>
用于实现数据库备份的脚本，数据库自身清理的crontab等……<br><br><br><span style="color:#f33b45;"><strong>建议：</strong></span></p>

<pre class="has"><code># vim /etc/my.cnf
[mysqld]
log-bin=mysql-bin
server-id=1 #5.7 必须配置server-id 启用binlog功能
binlog_format=statement #5.7 默认binlog只记录create、drop和alter，要记录insert语句必须设置格式

datadir = /usr/local/mysql/data　 #添加此行，数据存放目录
innodb_file_per_table = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #启用InnoDB独立表空间，默认所有数据库使用一个表空间
# service mysqld restart</code></pre>

<p><br>
&nbsp;</p>
                                    ]]></description></item><item><title>MySQL事务优化</title><link>http://www.cnblogs.com/heian99/archive/2019/04/19/11972281.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 19 Apr 2019 15:58:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/19/11972281.html</guid><description><![CDATA[
                                            <h3><span style="color:#f33b45;">====================</span><br><strong>事务特性<br>
事务隔离级别<br>
事务控制语句<br>
MySQL优化</strong><br><span style="color:#f33b45;">====================</span></h3>

<p><br>
事务的概念<br>
事务指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。<br>
例如：A——B转帐，对应于如下两条sql语句<br>
update from account set money=money-100 where name=‘a’;<br>
update from account set money=money+100 where name=‘b’;<br><br>
数据库开启事务命令<br>
start transaction 开启事务<br>
rollback 回滚事务<br>
commit 提交事务<br><br>
事务的特性(ACID)<br>
原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。&nbsp;<br>
一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。<br>
隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。<br>
持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。<br><br>
事务的隔离级别<br>
多个线程开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个线程在获取数据时的准确性。<br>
如果不考虑隔离性，可能会引发如下问题：<br>
脏读：指一个事务读取了另外一个事务未提交的数据。 这是非常危险的，假设Ａ向Ｂ转帐100元，对应sql语句如下所示<br>
1.update account set money=money+100 while name=‘b’;<br>
2.update account set money=money-100 while name=‘a’;<br><br>
不可重复读：在一个事物内读取表中的某一行数据，多次读取结果不同。<br>
例如银行想查询A帐户余额，第一次查询A帐户为200元，此时A向帐户内存了100元并提交了，银行接着又进行了一次查询，此时A帐户为300元了。银行两次查询不一致，可能就会很困惑，不知道哪次查询是准的。<br>
和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。<br>
很多人认为这种情况就对了，无须困惑，当然是后面的为准。我们可以考虑这样一种情况，比如银行程序需要将查询结果分别输出到电脑屏幕和写到文件中，结果在一个事务中针对输出的目的地，进行的两次查询不一致，导致文件和屏幕中的结果不一致，银行工作人员就不知道以哪个为准了。<br><br>
虚读/幻读是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。<br>
如丙存款100元未提交，这时银行做报表统计account表中所有用户的总额为500元，然后丙提交了，这时银行再统计发现帐户为600元了，造成虚读同样会使银行不知所措，到底以哪个为准。<br><br><img alt="" class="has" src="https://img-blog.csdnimg.cn/2019041923563744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70"></p>

<p><br><br>
事务隔离性的设置语句<br>
数据库共定义了四种隔离级别：<br>
Serializable：可避免脏读、不可重复读、虚读情况的发生。（串行化）<br>
Repeatable read：可避免脏读、不可重复读情况的发生。（可重复读）<br>
Read committed：可避免脏读情况发生（读已提交）。<br>
Read uncommitted：最低级别，以上情况均无法保证。(读未提交)<br><br>
set transaction isolation level 设置事务隔离级别<br>
select @@tx_isolation 查询当前事务隔离级别<br><br>
MySQL优化<br>
系统优化：硬件、架构<br>
服务优化<br>
应用优化<br><br>
影响性能的因素：<br>
应用程序、查询、事务管理、数据库设计、数据分布、网络操作系统、硬件<br><br>
系统优化：<br>
1、硬件优化<br>
cpu 64位 一台机器8-16颗CPU 内存 96-128G 3-4个实例<br>
硬盘：数量越多越好<br>
性能：ssd（高并发业务） &gt; sas （普通业务）&gt;sata（线下业务） raid 4块盘，性能 raid0 &gt; raid10 &gt; raid5 &gt; raid1<br>
网卡：多块网卡bond<br><br>
2、软件优化 操作系统：使用64位系统 软件：MySQL 编译优化<br><br>
服务优化：<br>
MySQL配置原则<br>
配置合理的MySQL服务器，尽量在应用本身达到一个MySQL最合理的使用<br>
针对 MyISAM 或 InnoDB 不同引擎进行不同定制性配置<br>
针对不同的应用情况进行合理配置针对 my.cnf 进行配置，后面设置是针对内存为2G的服务器进行的合理设置<br>
公共选项</p>

<table><tbody><tr><td>选项</td>
			<td>缺省值</td>
			<td>推荐值</td>
			<td>说明</td>
		</tr><tr><td>max_connections</td>
			<td>100</td>
			<td>1024</td>
			<td>MySQL服务器同时处理的数据库连接的最大数量</td>
		</tr><tr><td>query_cache_size</td>
			<td>0 (不打开）</td>
			<td>16M</td>
			<td>查询缓存区的最大长度，按照当前需求，一倍一倍增加，本选项比较重要</td>
		</tr><tr><td>sort_buffer_size</td>
			<td>512K</td>
			<td>16M</td>
			<td>每个线程的排序缓存大小，一般按照内存可以设置为2M以上，推荐是16M，该选项对排序order by，group by起作用</td>
		</tr><tr><td>record_buffer</td>
			<td>128K</td>
			<td>16M</td>
			<td>每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区，可以设置为2M以上</td>
		</tr><tr><td>table_cache</td>
			<td>64</td>
			<td>512</td>
			<td>为所有线程打开表的数量。增加该值能增加mysqld要求的文件描述符的数量。MySQL对每个唯一打开的表需要2个文件描述符。</td>
		</tr></tbody></table><p><br><br>
MyISAM 选项</p>

<table><tbody><tr><td>选项</td>
			<td>缺省值</td>
			<td>推荐值</td>
			<td>说明</td>
		</tr><tr><td>key_buffer_size</td>
			<td>8M</td>
			<td>256M</td>
			<td>用来存放索引区块的缓存值, 建议128M以上，不要大于内存的30%</td>
		</tr><tr><td>read_buffer_size</td>
			<td>128K</td>
			<td>16M</td>
			<td>用来做MyISAM表全表扫描的缓冲大小. 为从数据表顺序读取数据的读操作保留的缓存区的长度</td>
		</tr><tr><td>myisam_sort_buffer_size</td>
			<td>16M</td>
			<td>128M</td>
			<td>设置,恢复,修改表的时候使用的缓冲大小，值不要设的太大</td>
		</tr></tbody></table><p><br><br>
InnoDB 选项</p>

<table><tbody><tr><td>选项</td>
			<td>缺省值</td>
			<td>推荐值</td>
			<td>说明</td>
		</tr><tr><td>innodb_buffer_pool_size</td>
			<td>32M</td>
			<td>1G</td>
			<td>InnoDB使用一个缓冲池来保存索引和原始数据, 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少，一般是内存的一半，不超过2G，否则系统会崩溃，这个参数非常重要</td>
		</tr><tr><td>innodb_additional_mem_pool_size</td>
			<td>2M</td>
			<td>128M</td>
			<td>InnoDB用来保存 metadata 信息, 如果内存是4G，最好本值超过200M</td>
		</tr><tr><td>innodb_flush_log_at_trx_commit</td>
			<td>1</td>
			<td>0</td>
			<td>0 代表日志只大约每秒写入日志文件并且日志文件刷新到磁盘; 1 为执行完没执行一条SQL马上commit; 2 代表日志写入日志文件在每次提交后,但是日志文件只有大约每秒才会刷新到磁盘上. 对速度影响比较大，同时也关系数据完整性</td>
		</tr><tr><td>innodb_log_file_size</td>
			<td>8M</td>
			<td>256M</td>
			<td>在日志组中每个日志文件的大小, 一般是innodb_buffer_pool_size的25%，官方推荐是 innodb_buffer_pool_size 的 40-50%, 设置大一点来避免在日志文件覆写上不必要的缓冲池刷新行为</td>
		</tr><tr><td>innodb_log_buffer_size</td>
			<td>128K</td>
			<td>8M</td>
			<td>用来缓冲日志数据的缓冲区的大小. 推荐是8M，官方推荐该值小于16M，最好是 1M-8M 之间</td>
		</tr></tbody></table><p><br>
应用优化：<br>
设计合理的数据表结构：<br>
适当的数据冗余对数据表建立合适有效的数据库索引数据查询：<br>
编写简洁高效的SQL语句<br><br>
表结构设计原则<br>
选择合适的数据类型，如果能够定长尽量定长<br>
使用 ENUM 而不是 VARCHAR,ENUM类型是非常快和紧凑的，在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美 。<br>
不要使用无法加索引的类型作为关键字段，比如 text类型<br>
为了避免联表查询，有时候可以适当的数据冗余，比如邮箱、姓名这些不容易更改的数据<br>
选择合适的表引擎，有时候 MyISAM 适合，有时候InnoDB适合<br>
为保证查询性能，最好每个表都建立有 auto_increment 字段， 建立合适的数据库索引<br>
最好给每个字段都设定 default 值<br><br>
索引建立原则<br>
一般针对数据分散的关键字进行建立索引，比如ID、QQ，像性别、状态值等等建立索引没有意义字段唯一，最少，不可为null<br>
对大数据量表建立聚集索引，避免更新操作带来的碎片。<br>
尽量使用短索引，一般对int、char/varchar、date/time 等类型的字段建立索引<br>
需要的时候建立联合索引，但是要注意查询SQL语句的编写<br>
谨慎建立 unique 类型的索引（唯一索引）<br>
大文本字段不建立为索引，如果要对大文本字段进行检索， 可以考虑全文索引<br>
频繁更新的列不适合建立索引<br>
order by 字句中的字段，where 子句中字段，最常用的sql语句中字段，应建立索引。<br>
唯一性约束，系统将默认为改字段建立索引。<br>
对于只是做查询用的数据库索引越多越好，但对于在线实时系统建议控制在5个以内。<br>
索引不仅能提高查询SQL性能，同时也可以提高带where字句的update，Delete SQL性能。<br>
Decimal 类型字段不要单独建立为索引，但覆盖索引可以包含这些字段。<br>
只有建立索引以后，表内的行才按照特地的顺序存储，按照需要可以是asc或desc方式。<br>
如果索引由多个字段组成将最用来查询过滤的字段放在前面可能会有更好的性能。<br><br>
编写高效的 SQL<br>
能够快速缩小结果集的 WHERE 条件写在前面，如果有恒量条件，也尽量放在前面<br>
尽量避免使用 GROUP BY、DISTINCT 、OR、IN 等语句的使用，避免使用联表查询和子查询，因为将使执行效率大大下降<br>
能够使用索引的字段尽量进行有效的合理排列，如果使用了联合索引，请注意提取字段的前后顺序<br>
针对索引字段使用 &gt;, &gt;=, =, &lt;, &lt;=, IF NULL和BETWEEN 将会使用索引，如果对某个索引字段进行 LIKE 查询，使用 LIKE ‘%abc%’不能使用索引，使用 LIKE ‘abc%’ 将能够使用索引<br>
如果在SQL里使用了MySQL部分自带函数，索引将失效，同时将无法使用 MySQL 的 Query Cache，比如 LEFT(), SUBSTR(), TO_DAYS()，DATE_FORMAT(), 等，如果使用了 OR 或 IN，索引也将失效<br>
使用 Explain 语句来帮助改进我们的SQL语句<br>
不要在where 子句中的“=”左边进行算术或表达式运算，否则系统将可能无法正确使用索引<br>
尽量不要在where条件中使用函数，否则将不能使用索引<br>
避免使用 select *, 只取需要的字段<br>
对于大数据量的查询，尽量避免在SQL语句中使用order by 字句，避免额外的开销，替代为使用ADO.NET 来实现。<br>
如果插入的数据量很大，用select into 替代 insert into 能带来更好的性能<br>
采用连接操作，避免过多的子查询，产生的CPU和IO开销<br>
只关心需要的表和满足条件的数据<br>
适当使用临时表或表变量<br>
对于连续的数值，使用between代替in<br>
where 字句中尽量不要使用CASE条件<br>
尽量不用触发器，特别是在大数据表上<br>
更新触发器如果不是所有情况下都需要触发，应根据业务需要加上必要判断条件<br>
使用union all 操作代替OR操作，注意此时需要注意一点查询条件可以使用聚集索引，如果是非聚集索引将起到相反的结果<br>
当只要一行数据时使用 LIMIT 1<br>
尽可能的使用 NOT NULL填充数据库<br>
拆分大的 DELETE 或 INSERT 语句<br>
批量提交SQL语句<br><br>
架构优化<br>
1）业务拆分：搜索功能，like ，前后都有%，一般不用MySQL数据库<br>
2）业务拆分：某些应用使用nosql持久化存储，例如memcahcedb、redis、ttserver 比如粉丝关注、好友关系等；<br>
3）数据库前端必须要加cache，例如memcached，用户登录，商品查询<br>
4）动态数据静态化。整个文件静态化，页面片段静态化<br>
5）数据库集群与读写分离；<br>
6）单表超过2000万，拆库拆表，人工或自动拆分（登录、商品、订单等）<br><br>
流程、制度、安全优化<br>
任何一次人为数据库记录的更新，都要走一个流程<br>
1）人的流程：开发--&gt;核心开发--&gt;运维或DBA<br>
2）测试流程：内网测试--&gt;IDC测试--&gt;线上执行<br>
3）客户端管理：phpmyadmin等</p>
                                    ]]></description></item><item><title>MySQL日志管理</title><link>http://www.cnblogs.com/heian99/archive/2019/04/19/11972282.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 19 Apr 2019 15:49:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/19/11972282.html</guid><description><![CDATA[
                                            <h3><strong>MySQL日志管理</strong></h3>

<p>&nbsp;</p>

<p><span style="color:#f33b45;">========================================================</span></p>

<ul><li>错误日志: 记录 MySQL 服务器启动、关闭及运行错误等信息</li>
	<li>二进制日志: 又称binlog日志，以二进制文件的方式记录数据库中除 SELECT 以外的操作</li>
	<li>查询日志: 记录查询的信息</li>
	<li>慢查询日志: 记录执行时间超过指定时间的操作</li>
	<li>中继日志： 备库将主库的二进制日志复制到自己的中继日志中，从而在本地进行重放</li>
	<li>通用日志： 审计哪个账号、在哪个时段、做了哪些事件</li>
	<li>事务日志 或称redo日志，记录Innodb事务相关的如事务执行时间、检查点等</li>
</ul><p><span style="color:#f33b45;">========================================================</span></p>

<table><tbody><tr><th>日志类型</th>
			<th>记录信息</th>
		</tr><tr><td>日志文件</td>
			<td>记入文件中的信息类型</td>
		</tr><tr><td>错误日志</td>
			<td>记录启动、运行或停止时出现的问题。</td>
		</tr><tr><td>查询日志</td>
			<td>记录建立的客户端连接和执行的语句。</td>
		</tr><tr><td>二进制日志</td>
			<td>记录所有更改数据的语句。主要用于复制和即时点恢复。</td>
		</tr><tr><td>慢日志</td>
			<td>记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询。</td>
		</tr><tr><td>事务日志</td>
			<td>记录InnoDB等支持事务的存储引擎执行事务时产生的日志。</td>
		</tr></tbody></table><h3><br><br><br>
一、错误日志</h3>

<p><br>
错误日志主要记录如下几种日志：<br>
服务器启动和关闭过程中的信息<br>
服务器运行过程中的错误信息<br>
事件调度器运行一个时间是产生的信息<br>
在从服务器上启动从服务器进程是产生的信息<br><br>
错误日志定义：可以用--log-error[=file_name]选项来指定mysqld保存错误日志文件的位置。<br>
如果没有给定file_name值，mysqld使用错误日志名host_name.err 并在数据目录中写入日志文件。如果你执行FLUSH LOGS，错误日志用-old重新命名后缀并且mysqld创建一个新的空日志文件。(如果未给出--log-error选项，则不会重新命名）。<br>
查看当前错误日志配置 mysql&gt; SHOW GLOBAL VARIABLES LIKE '%log_error%';</p>

<p><img alt="" class="has" height="170" src="https://img-blog.csdnimg.cn/20190419233639750.png" width="483"><br>
是否记录警告日志 mysql&gt; SHOW GLOBAL VARIABLES LIKE '%log_warnings%';<br><img alt="" class="has" height="156" src="https://img-blog.csdnimg.cn/20190419233703307.png" width="604"><br>
二、bin-log<br>
1. 启用<br>
# vim /etc/my.cnf<br>
[mysqld]<br>
log-bin[=dir/[filename]] //目录权限必须mysql用户可写<br>
# service mysqld restart<br><br>
注意：MySQL 5.7.3以后版本，启用bin-log功能，需要设置server-id<br>
2. 暂停<br>
//仅当前会话<br>
SET SQL_LOG_BIN=0;<br>
SET SQL_LOG_BIN=1;<br><br>
3. 查看<br>
查看二进制日志的工具为：mysqlbinlog<br><br>
二进制日志包含了所有更新了数据或者已经潜在更新了数据（例如，没有匹配任何行的一个DELETE）的所有语句语句<br>
以“事件”的形式保存，它描述数据更改。二进制日志还包含关于每个更新数据库的语句的执行时间信息。它不包含没有修改任何数据的语句<br>
二进制日志的主要目的是在数据库存在故障时，恢复时能够最大可能地更新数据库（即时点恢复），因为二进制日志包含备份后进行的所有更新。<br>
二进制日志还用于在主复制服务器上记录所有将发送给从服务器的语句。<br><br>
查看全部：</p>

<pre class="has"><code># mysqlbinlog mysql.000002</code></pre>

<p><img alt="" class="has" height="245" src="https://img-blog.csdnimg.cn/20190419234857667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="764"><br><br>
按时间：</p>

<pre class="has"><code># mysqlbinlog mysql.000002 --start-datetime="2012-12-05 10:02:56"

# mysqlbinlog mysql.000002 --stop-datetime="2012-12-05 11:02:54"

# mysqlbinlog mysql.000002 --start-datetime="2012-12-05 10:02:56" --stop-datetime="2012-12-05 11:02:54"

</code></pre>

<p><br>
按字节数：</p>

<pre class="has"><code># mysqlbinlog mysql.000002 --start-position=260
# mysqlbinlog mysql.000002 --stop-position=260
# mysqlbinlog mysql.000002 --start-position=260 --stop-position=930
</code></pre>

<p><br>
4. 截断bin-log（产生新的bin-log文件）<br>
a. 重启mysql服务器<br>
b. # mysql -uroot -p123 -e 'flush logs'<br><br>
5. 删除bin-log文件<br>
# mysql -uroot -p123 -e 'reset master'<br>
二进制日志文件不能直接删除的，如果使用rm等命令直接删除日志文件，可能导致数据库的崩溃。<br>
必须使用命令PURGE删除日志，语法如下：PURGE { BINARY | MASTER } LOGS { TO 'log_name' | BEFORE datetime_expr }<br><br>
三、查询日志<br>
启用通用查询日志</p>

<pre class="has"><code># vim /etc/my.cnf
[mysqld]
log[=dir\[filename]]
# service mysqld restart</code></pre>

<p><br><br><br>
四、慢查询日志<br>
启用慢查询日志</p>

<pre class="has"><code># vim /etc/my.cnf
[mysqld]
log-slow-queries[=dir\[filename]]
long_query_time=n
# service mysqld restart</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>MySQL 5.6:
slow-query-log=1
slow-query-log-file=slow.log
long_query_time=3</code></pre>

<p><br><br>
查看慢查询日志<br>
测试:BENCHMARK(count,expr)<br>
SELECT BENCHMARK(50000000,2*3);<br><br>
默认与慢查询相关变量：mysql&gt; SHOW GLOBAL VARIABLES LIKE '%slow_query_log%';<br>
默认没有启用慢查询，为了服务器调优，建议开启<br>
开启方法：SET GLOBAL slow_query_log=ON;<br>
当前生效，永久有效配置文件中设置<br>
使用mysqldumpslow命令获得日志中显示的查询摘要来处理慢查询日志<br>
# mysqldumpslow slow.log 那么多久算是慢呢？如果查询时长超过long_query_time的定义值（默认10秒），即为慢查询：<br>
&nbsp;</p>

<pre class="has"><code>mysql&gt; SHOW GLOBAL VARIABLES LIKE 'long_query_time';</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL安全机制</title><link>http://www.cnblogs.com/heian99/archive/2019/04/18/11972283.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 18 Apr 2019 15:56:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/18/11972283.html</guid><description><![CDATA[
                                            <p><strong>MySQL安全机制</strong><br><br>
========================================================<br><span style="color:#f33b45;">MySQL权限表<br>
MySQL用户管理<br>
MySQL权限管理</span><br><br><br>
一、MySQL权限表<br>
mysql.user Global level<br>
用户字段<br>
权限字段<br>
安全字段<br>
资源控制字段<br>
mysql.db、mysql.host Database level<br>
用户字段<br>
权限字段<br>
mysql.tables_priv Table level<br>
mysql.columns_priv Column level<br>
mysql.procs_priv<br><br><br>
二、MySQL用户管理<br>
1. 登录和退出MySQL<br>
示例：<br>
mysql -h192.168.5.240 -P 3306 -u root -p123 mysql -e ‘select user,host from user’<br>
-h 指定主机名<br>
-P MySQL服务器端口<br>
-u 指定用户名<br>
-p 指定登录密码<br>
此处mysql为指定登录的数据库<br>
-e 接SQL语句</p>

<p>查看用户表</p>

<p>用户管理</p>

<pre class="has"><code>mysql&gt;use mysql;</code></pre>

<p>查看</p>

<pre class="has"><code>mysql&gt; select host,user,password from&nbsp;user&nbsp;;</code></pre>

<p><img alt="" class="has" height="381" src="https://img-blog.csdnimg.cn/20190418231408187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="702"><br>
2. 创建用户<br>
方法一：CREATE USER语句创建</p>

<pre class="has"><code>CREATE USER zhang@localhost IDENTIFIED BY "zhang";
</code></pre>

<p>刷新表</p>

<pre class="has"><code> flush privileges;
</code></pre>

<p><img alt="" class="has" height="293" src="https://img-blog.csdnimg.cn/20190418232909974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="681"><br>
方法二： INSERT语句创建</p>

<pre class="has"><code>Imysql&gt; INSERT INTO mysql.user(user,host, password,ssl_cipher,x509_issuer,x509_subject)
    -&gt;  VALUES("user2","localhost",password("123456"),"","","");
Query OK, 1 row affected (0.00 sec)</code></pre>

<pre class="has"><code> flush privileges;</code></pre>

<p><img alt="" class="has" height="343" src="https://img-blog.csdnimg.cn/20190418233619983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="721"></p>

<p>方法三： GRANT语句创建</p>

<pre class="has"><code>mysql&gt; GRANT SELECT ON *.* TO user3@"localhost" IDENTIFIED BY "123456";
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<pre class="has"><code>mysql&gt; FLUSH PRIVILEGES;
</code></pre>

<p><img alt="" class="has" height="323" src="https://img-blog.csdnimg.cn/20190418233745506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="755"><br><br>
3. 删除用户<br>
方法一：DROP USER语句删除</p>

<pre class="has"><code>mysql&gt; DROP USER user1@"localhost";
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p><br><img alt="" class="has" height="395" src="https://img-blog.csdnimg.cn/20190418233935933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="689"><br>
方法二：DELETE语句删除</p>

<pre class="has"><code>mysql&gt; delete from user
    -&gt; where user="user2" and host="localhost";
Query OK, 1 row affected (0.00 sec)</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>mysql&gt; flush privileges;
</code></pre>

<p><img alt="" class="has" height="304" src="https://img-blog.csdnimg.cn/20190418234240966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="649"><br><br><br>
4. 修改用户密码<br>
＝＝＝root修改自己密码<br>
方法一：</p>

<pre class="has"><code># mysqladmin -uroot -p123 password 'new_password' //123为旧密码</code></pre>

<p><br><br>
方法二：</p>

<pre class="has"><code>UPDATE mysql.user SET password=password(‘new_password’)
WHERE user=’root’ AND host=’localhost’;
FLUSH PRIVILEGES;</code></pre>

<p><br><br>
方法三：</p>

<pre class="has"><code>SET PASSWORD=password(‘new_password’);
FLUSH PRIVILEGES;</code></pre>

<p><br><br><br>
==root修改其他用户密码<br>
方法一：</p>

<pre class="has"><code>SET PASSWORD FOR user3@’localhost’=password(‘new_password’);
FLUSH PRIVILEGES;</code></pre>

<p><br><br>
方法二：</p>

<pre class="has"><code>UPDATE mysql.user SET password=password(‘new_password’)
WHERE user=’user3’ AND host=’localhost’;
FLUSH PRIVILEGES;
</code></pre>

<p><br>
方法三：</p>

<pre class="has"><code>GRANT SELECT ON *.* TO user3@’localhost’ IDENTIFIED BY ‘localhost’;
FLUSH PRIVILEGES;
</code></pre>

<p><br><br>
＝＝＝普通用户修改自己密码<br>
方法一：</p>

<pre class="has"><code>SET password=password(‘new_password’);</code></pre>

<p><br><br>
方法二：</p>

<pre class="has"><code># mysqladmin -uzhuzhu -p123 password 'new_password' //123为旧密码
</code></pre>

<p><br>
＝＝＝丢失root用户密码</p>

<pre class="has"><code># vim /etc/my.cnf
[mysqld]
skip-grant-tables
# service mysqld restart
# mysql -uroot
mysql&gt; UPDATE mysql.user SET password=password(‘new_password’)
WHERE user=’root’ AND host=’localhost’;
mysql&gt; FLUSH PRIVILEGES;

</code></pre>

<p><br>
三、MySQL权限管理<br>
权限应用的顺序：<br>
user (Y|N) ==&gt; db ==&gt; tables_priv ==&gt; columns_priv</p>

<p><strong>查看用户权限</strong></p>

<pre class="has"><code>mysql&gt; select Host,User,select_priv,insert_priv,update_priv,delete_priv from user;</code></pre>

<p><img alt="" class="has" height="317" src="https://img-blog.csdnimg.cn/20190418234838303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="758"><br><br>
语法格式：<br>
grant 权限列表 on 库名.表名 to 用户名@'客户端主机' [identified by '密码' with option参数];<br>
==权限列表 all 所有权限（不包括授权权限）<br>
select,update<br><br>
==数据库.表名 *.* 所有库下的所有表 Global level<br>
web.* web库下的所有表 Database level<br>
web.stu_info web库下的stu_info表 Table level<br>
SELECT (col1), INSERT (col1,col2) ON mydb.mytbl Column level<br><br>
==客户端主机 % 所有主机<br>
192.168.2.% 192.168.2.0网段的所有主机<br>
192.168.2.168 指定主机<br>
localhost 指定主机<br><br>
with_option参数<br>
GRANT OPTION： 授权选项<br>
MAX_QUERIES_PER_HOUR： 定义每小时允许执行的查询数<br>
MAX_UPDATES_PER_HOUR： 定义每小时允许执行的更新数<br>
MAX_CONNECTIONS_PER_HOUR： 定义每小时可以建立的连接数<br>
MAX_USER_CONNECTIONS： 定义单个用户同时可以建立的连接数</p>

<p>&nbsp;</p>

<p><strong>grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。</strong></p>

<ul><li>grant select on testdb.* to common_user@’%’</li>
	<li>grant insert on testdb.* to common_user@’%’</li>
	<li>grant update on testdb.* to common_user@’%’</li>
	<li>grant delete on testdb.* to common_user@’%’</li>
</ul><p><strong>&nbsp;MySQL 命令来替代：</strong></p>

<ul><li>grant select, insert, update, delete on testdb.* to common_user@’%’</li>
</ul><p>grant 数据库开发人员，创建表、索引、视图、存储过程、函数。。。等权限。</p>

<p><strong>grant 创建、修改、删除 MySQL 数据表结构权限。</strong></p>

<ul><li>grant create on testdb.* to developer@’192.168.0.%’;</li>
	<li>grant alter on testdb.* to developer@’192.168.0.%’;</li>
	<li>grant drop on testdb.* to developer@’192.168.0.%’;</li>
</ul><p><strong>grant 操作 MySQL 外键权限。</strong></p>

<ul><li>grant references on testdb.* to developer@’192.168.0.%’;</li>
</ul><p><strong>grant 操作 MySQL 临时表权限。</strong></p>

<ul><li>grant create temporary tables on testdb.* to developer@’192.168.0.%’;</li>
</ul><p><strong>grant 操作 MySQL 索引权限。</strong></p>

<ul><li>grant index on testdb.* to developer@’192.168.0.%’;</li>
</ul><p><strong>grant 操作 MySQL 视图、查看视图源代码 权限</strong>。</p>

<ul><li>grant create view on testdb.* to developer@’192.168.0.%’;</li>
	<li>grant show view on testdb.* to developer@’192.168.0.%’;</li>
</ul><p><strong>grant 操作 MySQL 存储过程、函数 权限。</strong></p>

<ul><li>grant create routine on testdb.* to developer@’192.168.0.%’; -- now, can show procedure status</li>
	<li>grant alter routine on testdb.* to developer@’192.168.0.%’; -- now, you can drop a procedure</li>
	<li>grant execute on testdb.* to developer@’192.168.0.%’;</li>
</ul><p><strong>grant 普通 DBA 管理某个 MySQL 数据库的权限</strong>。</p>

<ul><li>grant all privileges on testdb to dba@’localhost’</li>
</ul><p>&nbsp;</p>

<p><strong>grant 高级 DBA 管理 MySQL 中所有数据库的权限。</strong></p>

<ul><li>grant all on *.* to dba@’localhost’</li>
</ul><h3><strong>MySQL grant 权限，分别可以作用在多个层次上。</strong></h3>

<p><strong>1. grant 作用在整个 MySQL 服务器上：</strong></p>

<ul><li>grant select on *.* to dba@localhost; -- dba 可以查询 MySQL 中所有数据库中的表。</li>
	<li>grant all on *.* to dba@localhost; -- dba 可以管理 MySQL 中的所有数据库</li>
</ul><p><strong>2. grant 作用在单个数据库上：</strong></p>

<ul><li>grant select on testdb.* to dba@localhost; -- dba 可以查询 testdb 中的表。</li>
</ul><p><strong>3. grant 作用在单个数据表上：</strong></p>

<ul><li>grant select, insert, update, delete on testdb.orders to dba@localhost;</li>
</ul><p><strong>4. grant 作用在表中的列上：</strong></p>

<ul><li>grant select(id, se, rank) on testdb.apache_log to dba@localhost;</li>
</ul><p><strong>5. grant 作用在存储过程、函数上：</strong></p>

<ul><li>grant execute on procedure testdb.pr_add to ’dba’@’localhost’</li>
	<li>grant execute on function testdb.fn_add to ’dba’@’localhost’</li>
</ul><p><span style="color:#f33b45;"><strong>注意：修改完权限以后 一定要刷新服务，或者重启服务，刷新服务用：FLUSH PRIVILEGES。</strong></span></p>

<p>Grant示例：<br>
GRANT ALL ON *.* TO admin1@'%' IDENTIFIED BY 'localhost';<br><br>
GRANT ALL ON *.* TO admin2@'%' IDENTIFIED BY 'localhost' WITH GRANT OPTION;<br><br>
GRANT ALL ON bbs.* TO admin3@'%' IDENTIFIED BY 'localhost';<br><br>
GRANT ALL ON bbs.user TO admin4@'%' IDENTIFIED BY 'localhost';<br><br>
GRANT SELECT(col1),INSERT(col2,col3) ON bbs.user TO admin5@'%' IDENTIFIED BY 'localhost';<br><br><br>
回收权限REVOKE<br>
查看权限<br>
SHOW GRANTS\G<br>
SHOW GRANTS FOR admin1@'%'\G<br><br>
回收权限REVOKE<br>
语法：<br>
REVOKE 权限列表 ON 数据库名 FROM 用户名@‘客户端主机’<br><br>
示例：<br>
REVOKE DELETE ON *.* FROM admin1@’%’; //回收部分权限<br>
REVOKE ALL PRIVILEGES ON *.* FROM admin2@’%’; //回收所有权限<br>
REVOKE ALL PRIVILEGES,GRANT OPTION ON *.* FROM 'admin2'@'%';<br>
========================================================</p>
                                    ]]></description></item><item><title>MySQL存储过程与函数</title><link>http://www.cnblogs.com/heian99/archive/2019/04/18/11972284.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 18 Apr 2019 14:33:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/18/11972284.html</guid><description><![CDATA[
                                            <p>一、概述：<br>
存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合。<br>
存储过程和函数的区别：<br><span style="color:#f33b45;">• 函数必须有返回值，而存储过程没有。<br>
• 存储过程的参数可以是IN、OUT、INOUT类型，函数的参数只能是IN</span><br><span style="color:#f33b45;"><strong>优点：</strong></span><br>
• 存储过程只在创建时进行编译；而SQL语句每执行一次就编译一次，所以使用存储过程可以提高数据库执行速度。<br>
• 简化复杂操作，结合事务一起封装。<br>
• 复用性好<br>
• 安全性高，可指定存储过程的使用权。<br><span style="color:#f33b45;"><strong>说明：</strong></span><br>
并发量少的情况下，很少使用存储过程。<br>
并发量高的情况下，为了提高效率，用存储过程比较多。<br><br>
二、创建与调用<br>
创建存储过程语法 ：<br>
create procedure sp_name(参数列表)<br>
[特性...]过程体<br><br>
存储过程的参数形式：[IN | OUT | INOUT]参数名 类型<br>
IN 输入参数<br>
OUT 输出参数<br>
INOUT 输入输出参数<br><br>
delimiter $$<br>
create procedure 过程名(参数列表)<br>
begin<br>
SQL语句<br>
end $$<br>
delimiter ;<br><br>
调用：<br>
call 存储过程名(实参列表)<br>
&nbsp;</p>

<h1>存储过程三种参数类型：IN, OUT, INOUT</h1>

<p><br><br>
===================<strong>NONE</strong>========================</p>

<pre class="has"><code>mysql&gt; \d $$
mysql&gt; create procedure p1()
-&gt; begin
-&gt; select count(*) from mysql.user;
-&gt; end$$
Query OK, 0 rows affected (0.51 sec)

mysql&gt; \d ;
mysql&gt; call p1()</code></pre>

<p><img alt="" class="has" height="272" src="https://img-blog.csdnimg.cn/20190418222049281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="707"><br><br>
&nbsp;</p>

<pre class="has"><code>mysql&gt; create school.table t1(
-&gt; id int,
-&gt; name varchar(50)
-&gt; );
Query OK, 0 rows affected (2.81 sec)

mysql&gt; delimiter $$
mysql&gt; create procedure autoinsert1()
-&gt; BEGIN
-&gt; declare i int default 1;
-&gt; while(i&lt;=20000)do
-&gt; insert into school.t1 values(i,md5(i));
-&gt; set i=i+1;
-&gt; end while;
-&gt; END$$
mysql&gt; delimiter ;
</code></pre>

<p><br>
====================<strong>IN</strong>==========================</p>

<pre class="has"><code>mysql&gt; create procedure autoinsert2(IN a int)
-&gt; BEGIN
-&gt; declare i int default 1;
-&gt; while(i&lt;=a)do
-&gt; insert into school.t1 values(i,md5(i));
-&gt; set i=i+1;
-&gt; end while;
-&gt; END$$
Query OK, 0 rows affected (0.00 sec)

mysql&gt; call autoinsert1(10);
Query OK, 1 row affected (1.10 sec)

mysql&gt; set @num=20;
mysql&gt; select @num;
+------+
| @num |
+------+
| 20 |
+------+
1 row in set (0.00 sec)

mysql&gt; call autoinsert1(@num);</code></pre>

<p><br><br><br>
====================<strong>OUT</strong>=======================</p>

<pre class="has"><code>mysql&gt; delimiter $$
mysql&gt; CREATE PROCEDURE p2 (OUT param1 INT)
-&gt; BEGIN
-&gt; SELECT COUNT(*) INTO param1 FROM t1;
-&gt; END$$
Query OK, 0 rows affected (0.00 sec)

mysql&gt; delimiter ;

mysql&gt; select @a;
+------+
| @a |
+------+
| NULL |
+------+
1 row in set (0.00 sec)

mysql&gt; CALL p2(@a);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT @a;
+------+
| @a |
+------+
| 3 |
+------+
</code></pre>

<p><br>
===================<strong>IN 和 OUT</strong>=====================</p>

<h3>作用：统计指定部门的员工数</h3>

<p>&nbsp;</p>

<pre class="has"><code>mysql&gt; create procedure count_num(IN p1 varchar(50), OUT p2 int)
-&gt; BEGIN
-&gt; select count(*) into p2 from employee
-&gt; where post=p1;
-&gt; END$$
Query OK, 0 rows affected (0.00 sec)
mysql&gt; \d ;


mysql&gt; call count_num('hr',@a);

mysql&gt;select @a;</code></pre>

<p><br><br>
&nbsp;</p>

<h3>作用：统计指定部门工资超过例如5000的总人数</h3>

<p>&nbsp;</p>

<pre class="has"><code>mysql&gt; create procedure count_num(IN p1 varchar(50), IN p2 float(10,2), OUT p3 int)
-&gt; BEGIN
-&gt; select count(*) into p3 from employee
-&gt; where post=p1 and salary=&gt;p2;
-&gt; END$$
Query OK, 0 rows affected (0.00 sec)
mysql&gt; \d ;

mysql&gt; call count_num('hr',5000,@a);

</code></pre>

<p><br>
====================<strong>INOUT</strong>======================</p>

<pre class="has"><code>mysql&gt; create procedure proce_param_inout(inout p1 int)
-&gt; begin
-&gt; if (p1 is not null) then
-&gt; set p1=p1+1;
-&gt; else
-&gt; select 100 into p1;
-&gt; end if;
-&gt; end$$
Query OK, 0 rows affected (0.00 sec)


mysql&gt; select @h;
+------+
| @h |
+------+
| NULL |
+------+
1 row in set (0.00 sec)

mysql&gt; call proce_param_inout(@h);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select @h;
+------+
| @h |
+------+
| 100 |
+------+begin
1 row in set (0.00 sec)

mysql&gt; call proce_param_inout(@h);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select @h;
+------+
| @h |
+------+
| 101 |
+------+
1 row in set (0.00 sec)

</code></pre>

<p><br>
&nbsp;</p>

<h1>FUNCTION函数</h1>

<p><br>
=================================================</p>

<pre class="has"><code>mysql&gt; CREATE FUNCTION hello (s CHAR(20))
-&gt; RETURNS CHAR(50) RETURN CONCAT('Hello, ',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select hello('localhost');
+------------------+
| hello('localhost') |
+------------------+
| Hello, localhost! |
+------------------+

root@(company)&gt; select hello('localhost') return1;
+-----------------+
| return1 |
+-----------------+
| Hello, localhost! |
+-----------------+
1 row in set (0.00 sec)


mysql&gt; create function name_from_employee(x int)
-&gt; returns varchar(50)
-&gt; BEGIN
-&gt; return (select emp_name from employee
-&gt; where emp_id=x);
-&gt; END$$
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select name_from_employee(3);

mysql&gt; select * from employee where emp_name=name_from_employee(1);
+--------+----------+------+------------+------------+-----------------+---------+--------+--------+
| emp_id | emp_name | sex | hire_date | post | job_description | salary | office | dep_id |
+--------+----------+------+------------+------------+-----------------+---------+--------+--------+
| 1 | jack | male | 2013-02-02 | instructor | teach | 5000.00 | 501 | 100 |
+--------+----------+------+------------+------------+-----------------+---------+--------+--------+
1 row in set (0.00 sec)

</code></pre>

<p><br><br><br>
==============================================<br>
创建函数的语法：<br>
create function 函数名(参数列表) returns 返回值类型<br>
[特性...] 函数体<br>
函数的参数形式：参数名 类型<br><br>
delimiter $$<br>
create function 函数名(参数列表) returns 返回值类型<br>
begin<br>
有效的SQL语句<br>
end$$<br>
delimiter ;<br>
调用：<br>
select 函数名(实参列表)<br><br>
delimiter $$<br>
create function fun1(str char(20)) returns char(50)<br>
return concat("hello",str,"!");<br>
$$<br>
delimiter ;<br><br>
select fun1(' function');<br><br>
存储过程与函数的维护：<br>
show create procedure pr1 \G;<br>
show create function pr1 \G;<br><br>
show {procedure|function} status {like 'pattern'}<br><br>
drop {procedure|function} {if exists} sp_name<br><br><br>
mysql变量的术语分类：<br>
1.用户变量：以"@"开始，形式为"@变量名"，由客户端定义的变量。<br>
用户变量跟mysql客户端是绑定的，设置的变量只对当前用户使用的客户端生效，当用户断开连接时，所有变量会自动释放。<br>
2.全局变量：定义时如下两种形式，set GLOBAL 变量名&nbsp; 或者&nbsp; set @@global.变量名<br>
对所有客户端生效，但只有具有super权限才可以设置全局变量。<br>
3.会话变量：只对连接的客户端有效。<br>
4.局部变量：设置并作用于begin...end语句块之间的变量。<br>
declare语句专门用于定义局部变量。而set语句是设置不同类型的变量，包括会话变量和全局变量<br>
语法：declare 变量名[...] 变量类型 [default 值]<br>
declare定义的变量必须写在复合语句的开头，并且在任何其它语句的前面。<br><br>
变量的赋值：<br>
直接赋值： set 变量名=表达式值或常量值[...];<br><br>
用户变量的赋值：<br>
1、set 变量名=表达式或常量值;<br>
2、也可以将查询结果赋值给变量(要求查询返回的结果只能有一行)<br>
例：set 列名 into 变量名 from 表名 where 条件;<br>
3、select 值 into @变量名；<br>
客户端变量不能相互共享。<br>
&nbsp;</p>

<pre class="has"><code>delimiter $$
create procedure pr2()
begin
declare xname varchar(50);
declare xdesc varchar(100);
set xname="caiwu";
set xdesc="accouting";
insert into dept(name,desc) values(xname,xdesc);
end$$
delimiter ;
call pr2();</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>delimiter $$
create procedure pr3(in x int,in y int,out sum int)
begin
set sum=x+y;
end$$
delimiter ;
call pr3(3,4,@sum);
select @sum;</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>delimiter //
create function fun6(x int,y int) returns int
begin
declare sum int;
set sum=x+y;
return sum;
end//
delimiter ;
select fun6(4,3);</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>delimiter //
create function fun_add_rand(in_int int )
RETURNS int
BEGIN
declare i_rand int;
declare i_return int;
set i_rand=floor(rand()*100);
set i_return = in_int + i_rand;
return i_return;
END;
//</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL触发器</title><link>http://www.cnblogs.com/heian99/archive/2019/04/18/11972285.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 18 Apr 2019 12:03:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/18/11972285.html</guid><description><![CDATA[
                                            <p><strong>MySQL触发器Triggers</strong><br><br>
========================================================<br>
触发器简介<br>
创建触发器<br>
查看触发器<br>
删除触发器<br>
触发器案例</p>

<h3><br>
一、触发器简介</h3>

<p><br>
触发器（trigger）是一个特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，<br>
比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整<br>
性约束和业务规则等。<br><br>
例如，当学生表中增加了一个学生的信息时，学生的总数就应该同时改变。因此可以针对学生表创建一个触发<br>
器，每次增加一个学生记录时，就执行一次学生总数的计算操作，从而保证学生总数与记录数的一致性。</p>

<h3><br>
二、创建Trigger</h3>

<p><br><span style="color:#f33b45;">语法：<br>
CREATE TRIGGER 触发器名称 BEFORE|AFTER 触发事件<br>
ON 表名 FOR EACH ROW<br>
BEGIN<br>
触发器程序体;<br>
END</span><br><br><strong>&lt;触发器名称&gt;</strong> 最多64个字符，它和MySQL中其他对象的命名方式一样<br><strong>{ BEFORE | AFTER }</strong> 触发器时机<br><strong>{ INSERT | UPDATE | DELETE }</strong>触发的事件<br><strong>ON &lt;表名称&gt;</strong> 标识建立触发器的表名，即在哪张表上建立触发器<br><strong>FOR EACH ROW</strong> 触发器的执行间隔：FOR EACH ROW子句通知触发器 每隔一行<br>
执行一次动作，而不是对整个表执行一次<br><strong>&lt;触发器程序体&gt; </strong> 要触发的SQL语句：可用顺序，判断，循环等语句实现一般程序需要的逻辑功能<br>
&nbsp;</p>

<h2><span style="color:#f33b45;">触发器示例</span><br>
1. 创建表</h2>

<pre class="has"><code>mysql&gt; create table student(
-&gt; id int unsigned auto_increment primary key not null,
-&gt; name varchar(50)
-&gt; );
mysql&gt; insert into student(name) values('wei');

mysql&gt; create table student_total(total int);
mysql&gt; insert into student_total values(1);
</code></pre>

<p><img alt="" class="has" height="154" src="https://img-blog.csdnimg.cn/20190418171344804.png" width="294"></p>

<h3><br>
2. 创建触发器student_insert_trigger</h3>

<h3><span style="color:#f33b45;">创建触发器，实现添加学生信息，数量自动增加</span></h3>

<pre class="has"><code>mysql&gt; \d  $$
mysql&gt; create trigger student_insert_tigger after insert
		on student for each row 
		begin update nummber set count=count+1; 
		end$$
Query OK, 0 rows affected (0.00 sec)

mysql&gt; \d ;</code></pre>

<h3><img alt="" class="has" height="506" src="https://img-blog.csdnimg.cn/20190418195155866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="519"></h3>

<h3><span style="color:#f33b45;">创建触发器，删除学生信息，数量自动减少</span></h3>

<pre class="has"><code>mysql&gt; \d $ &nbsp;# 修改mysql结束符
mysql&gt; create trigger student_delete_trigger after delete
&nbsp; &nbsp; -&gt; on student for each row
&nbsp; &nbsp; -&gt; begin
&nbsp; &nbsp; -&gt; update number set count=count-1;
&nbsp; &nbsp; -&gt; end$
Query OK, 0 rows affected (0.01 sec)

mysql&gt; \d ; &nbsp;

</code></pre>

<h3><span style="color:#f33b45;">删除一个学生信息</span></h3>

<pre class="has"><code>mysql&gt; delete from student wheree id="2";</code></pre>

<p>查看学生信息</p>

<h3><img alt="" class="has" height="216" src="https://img-blog.csdnimg.cn/20190418195455665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="451"><br>
三、查看触发器</h3>

<p><br>
1. 通过SHOW TRIGGERS语句查看</p>

<pre class="has"><code>mysql&gt; show triggers\G;</code></pre>

<p><br><img alt="" class="has" height="613" src="https://img-blog.csdnimg.cn/20190418195633646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="769"></p>

<p>2. 通过系统表triggers查看</p>

<p><br>
USE information_schema<br>
SELECT * FROM triggers\G<br>
SELECT * FROM triggers WHERE TRIGGER_NAME='触发器名称'\G</p>

<h3><img alt="" class="has" height="1049" src="https://img-blog.csdnimg.cn/20190418195914784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1050"><br>
四、删除触发器</h3>

<p><br>
1. 通过DROP TRIGGERS语句删除<br>
DROP TRIGGER 解发器名称</p>

<pre class="has"><code>mysql&gt; drop trigger student_delete_trigger;
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p><img alt="" class="has" height="127" src="https://img-blog.csdnimg.cn/20190418200217998.png" width="565"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL视图及索引</title><link>http://www.cnblogs.com/heian99/archive/2019/04/17/11972286.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 17 Apr 2019 15:46:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/17/11972286.html</guid><description><![CDATA[
                                            <p><strong>视图</strong></p>

<p>视图就是一个表或多个表的查询结果，它是一张虚拟的表，因为它并不能存储数据。</p>

<p>视图的作用、优点：</p>

<p>　　限制对数据的访问</p>

<p>　　让复杂查询变得简单</p>

<p>　　提供数据的独立性</p>

<p>　　可以完成对相同数据的不同显示</p>

<pre class="has"><code>//创建、修改视图
create or replace view view_temp
as
select name, age from temp;

//通常不对视图的数据做修改操作，因为视图是一张虚拟的表，它并不存储实际数据。如果想让视图不被修改，可以用with check option来完成限制。
create or replace view view_temp
as 
select *from temp
with check option;

//删除视图
drop view view_temp;

//显示创建语法
show create view v_temp;</code></pre>

<p>显示学生成绩单的视图</p>

<pre class="has"><code>mysql&gt; create view student_cj as select students.number,students.name,course.math,course.english,course.chinese
    -&gt; from students,course
    -&gt; where students.number=course.number;
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p>使用student_cj个视图，显示结果</p>

<p><img alt="" class="has" height="413" src="https://img-blog.csdnimg.cn/20190417212343364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="747"></p>

<p>删除这个视图</p>

<pre class="has"><code>mysql&gt; drop view student_cj;
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p><img alt="" class="has" height="265" src="https://img-blog.csdnimg.cn/20190417212641238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="507"></p>

<p>查看视图的信息</p>

<pre class="has"><code>mysql&gt; show create view student_cj\G</code></pre>

<p><img alt="" class="has" height="274" src="https://img-blog.csdnimg.cn/20190417212918556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="866"></p>

<p><strong>索引</strong></p>

<p><strong>1.在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。[ 是为了快速查询而针对某些字段建立起来的。]<br>
2.更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。<br>
3.表</strong></p>

<p><strong>01.数据库中的数据都是存储在表中的<br>
02.表是物理存储的，真实存在的</strong></p>

<p>2.案例</p>

<p>创建索引：<code>create index degree_fast on score (degree);</code>&nbsp;<br>
这里的<code>dgeree_fast</code>是索引名，<code>score</code>是表明，<code>degree</code>是表中的一个字段。&nbsp;<br>
创建视图：</p>

<pre class="has"><code>create view [viewName] as 
select [someFields]
from [tableName]</code></pre>

<p>删除索引：&nbsp;<br>
- 01.方式一：<code>drop index degree_fast on score;</code>&nbsp;<br>
- 02.方式二：<code>alter table score drop index degree_fast;</code></p>

<p><code>Mysql cannot drop index needed in a foreign key constraint.</code>Mysql不能在外键约束下删除索引。如果有外键的话，需要先把外键删除，然后再删除索引。</p>
                                    ]]></description></item><item><title>MySQL的select多表查询</title><link>http://www.cnblogs.com/heian99/archive/2019/04/17/11972287.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 17 Apr 2019 08:31:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/17/11972287.html</guid><description><![CDATA[
                                            <h1><strong>select 语句：</strong></h1>

<h3><span style="color:#f33b45;"><strong>select 语句一般用法为: select 字段名 from tb_name where 条件 ;</strong></span></h3>

<h2><span style="color:#ffbb66;"><strong>select 查询语句类型一般分为三种：&nbsp;<br>
单表查询，多表查询，子查询</strong></span></h2>

<p><strong>最简单的单表查询 : select * from tb_name;&nbsp;<br>
*表示，所有字段</strong></p>

<p><strong>查询特定字段(投影)：&nbsp;<br>
select 字段名1，字段名2， from tb_name;</strong></p>

<p><strong>where 语句过滤查询(选择)</strong></p>

<p><strong>select * from tb_name where 条件 ;</strong></p>

<p>&nbsp;</p>

<p><strong>使用SELECT子句进行多表查询</strong></p>

<p>SELECT 字段名 FROM 表1，表2 … WHERE 表1.字段 = 表2.字段 AND 其它查询条件</p>

<p><br>
SELECT a.id,a.name,a.address,a.date,b.math,b.english,b.chinese FROM tb_demo065_tel AS b,tb_demo065 AS a WHERE a.id=b.id<br>
注:在上面的的代码中，以两张表的id字段信息相同作为条件建立两表关联，但在实际开发中不应该这样使用，最好用主外键约束来实现</p>

<h1>首先创建一个数据库</h1>

<p><img alt="" class="has" height="258" src="https://img-blog.csdnimg.cn/20190417163020735.png" width="254"></p>

<h3>学生人数表</h3>

<p><img alt="" class="has" height="214" src="https://img-blog.csdnimg.cn/20190417160835662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="376"></p>

<h2><strong>学生成绩表</strong></h2>

<p><img alt="" class="has" height="224" src="https://img-blog.csdnimg.cn/20190417160900426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="454"></p>

<h2><span style="color:#f33b45;">显示每个学生的对应的成绩</span></h2>

<p><strong>方法一：</strong></p>

<pre class="has"><code>mysql&gt; select students.number,students.name,students.sex,course.math,course.english,course.chinese 
    -&gt; from students inner join course
    -&gt; on students.number=course.number;
</code></pre>

<p><img alt="" class="has" height="252" src="https://img-blog.csdnimg.cn/20190417161313710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="872"></p>

<p><strong>方法二：</strong></p>

<pre class="has"><code>mysql&gt; select students.number,students.name,students.sex,course.math,course.english,course.chinese
    -&gt; from students,course
    -&gt; where students.number=course.number;
</code></pre>

<p><img alt="" class="has" height="257" src="https://img-blog.csdnimg.cn/20190417161639262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="878"></p>

<p>&nbsp;</p>

<h2><span style="color:#f33b45;">根据学号排名升序输出成绩</span></h2>

<pre class="has"><code>mysql&gt; select students.number as 学号,students.name as 姓名,course.math as 数学,course.english as 英语,course.chinese as 语文 from students,course where students.number=course.number  order by students.number;

</code></pre>

<p>&nbsp;</p>

<p><img alt="" class="has" height="249" src="https://img-blog.csdnimg.cn/2019041716215157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="886"></p>

<h2><span style="color:#f33b45;">求学生的总成绩，并显示出来，成绩按降序排列</span></h2>

<pre class="has"><code>mysql&gt; select students.number as 学号,students.name as 姓名,(course.math+course.english +course.chinese) as 总成绩 from students,course where students.number=course.number  order by 总成绩 desc;
</code></pre>

<p><img alt="" class="has" height="248" src="https://img-blog.csdnimg.cn/20190417162912243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="879"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL的select详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2019/04/16/11972288.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 16 Apr 2019 15:50:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/16/11972288.html</guid><description><![CDATA[
                                            <h1>MySQL 查询数据</h1>

<p>MySQL 数据库使用SQL SELECT语句来查询数据。</p>

<p>你可以通过 mysql&gt; 命令提示窗口中在数据库中查询数据</p>

<h3>语法</h3>

<p>以下为在MySQL数据库中查询数据通用的 SELECT 语法：</p>

<pre>SELECT column_name,column_name
FROM table_name
[WHERE Clause]
[LIMIT N][ OFFSET M]</pre>

<ul><li>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li>
	<li>SELECT 命令可以读取一条或者多条记录。</li>
	<li>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li>
	<li>你可以使用 WHERE 语句来包含任何条件。</li>
	<li>你可以使用 LIMIT 属性来设定返回的记录数。</li>
	<li>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li>
</ul><p>建一张表用于我们测试：&nbsp;</p>

<pre class="has"><code>create table student
(
    ids int auto_increment primary key,
    name varchar(20),
    chinese float,
    english float,
    math float 
);</code></pre>

<p><br>
插入如下数据：&nbsp;<br>
&nbsp;</p>

<pre class="has"><code>insert into student values(1,'李明',89,78,90);&nbsp;
insert into student values(2,'乘风',67,89,56);&nbsp;
insert into student values(3,'南宫流云',87,78,77);&nbsp;
insert into student values(4,'南宫皓月',88,98,90);&nbsp;
insert into student values(5,'南宫紫月',82,84,67);&nbsp;
insert into student values(6,'萧炎',55,85,45);&nbsp;
insert into student values(7,'林动',75,65,30);
</code></pre>

<p><img alt="" class="has" height="312" src="https://img-blog.csdnimg.cn/20190416215956815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="519"></p>

<h3 id="1指定查询列">1、指定查询列</h3>

<pre class="has"><code>mysql&gt; select id,name,chinese from student;
</code></pre>

<p><img alt="" class="has" height="270" src="https://img-blog.csdnimg.cn/20190416220159527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="411"></p>

<h3 id="2去重查询">2、去重查询</h3>

<p>用distinct关键字， 如果结果中有完全相同的行，就去除重复行</p>

<pre class="has"><code>mysql&gt; select distinct math from student;
</code></pre>

<p><img alt="" class="has" height="271" src="https://img-blog.csdnimg.cn/20190416220343424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="364"></p>

<h3 id="3select语句中进行运算">3、select语句中进行运算</h3>

<p>查询学生总成绩&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name,(chinese+math+english) as 总成绩 from student;</code></pre>

<p><img alt="" class="has" height="307" src="https://img-blog.csdnimg.cn/20190416220512845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="668"></p>

<h2><strong>查询所有姓南宫人的总成绩。</strong>&nbsp;</h2>

<pre class="has"><code>mysql&gt; select id,name,(chinese+math+english) as 总成绩 from student  
    -&gt; where name like '南宫%';
</code></pre>

<p><img alt="" class="has" height="226" src="https://img-blog.csdnimg.cn/20190416220807102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="670"></p>

<h3 id="5where查询过滤">4、where查询过滤</h3>

<p>在where子句中有很多经常使用的运算符，如下：&nbsp;</p>

<p><img alt="è¿éåå¾çæè¿°" class="has" src="https://img-blog.csdn.net/20180526155434349?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

<p>（1）查询所有英语成绩大于90的同学成绩：&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name,english as 英语 from student
    -&gt; where english &gt; 90;</code></pre>

<p><img alt="" class="has" height="220" src="https://img-blog.csdnimg.cn/20190416221041984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="509"></p>

<p>（2）查询所有总分大于200分的同学&nbsp;</p>

<p><span style="color:#f33b45;">注意：<strong>where子句后不能用别名</strong>&nbsp;<br>
因为数据库中先执行where子句，再执行select子句。</span>&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name,(chinese+math+english) as 总成绩 from student
    -&gt; where (chinese+math+english) &gt; 200;</code></pre>

<p><img alt="" class="has" height="263" src="https://img-blog.csdnimg.cn/20190416231905681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="689"></p>

<p>&nbsp;</p>

<p>（3）查询姓林并且id大于6的学生信息&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name from student
    -&gt; where name like '林%' and id &gt;6;</code></pre>

<p><img alt="" class="has" height="186" src="https://img-blog.csdnimg.cn/20190416232118591.png" width="464"></p>

<p>（4）查询英语成绩大于语文成绩的同学&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name from student
    -&gt; where english &gt; chinese;</code></pre>

<p><img alt="" class="has" height="232" src="https://img-blog.csdnimg.cn/20190416232251100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="410"></p>

<p>（5）查询所有总分大于200并且数学成绩小于语文成绩的学生信息&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name from student
    -&gt; where (chinese+math+english) &gt;200 and math &lt; chinese;</code></pre>

<p><img alt="" class="has" height="208" src="https://img-blog.csdnimg.cn/20190416232442576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="629"></p>

<p>（6）查询所有英语成绩在80到90分的同学&nbsp;<br>
方法一：&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name,english from student
    -&gt; where english &gt;=80 and english &lt;= 90;</code></pre>

<p><img alt="" class="has" height="211" src="https://img-blog.csdnimg.cn/20190416232722872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="481"></p>

<p>方法二：&nbsp;</p>

<p><strong>注意：between是闭区间</strong></p>

<pre class="has"><code>mysql&gt; select id,name,english from student
    -&gt; where english between 80 and 90;</code></pre>

<p><img alt="" class="has" height="217" src="https://img-blog.csdnimg.cn/20190416232943203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="489"></p>

<p>（7）查询数学成绩为89,90,91的同学信息&nbsp;<br>
or:&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name,math from student
    -&gt; where math=89 or math=90 or math=91;</code></pre>

<p><img alt="" class="has" height="190" src="https://img-blog.csdnimg.cn/20190416233143636.png" width="457"></p>

<p>&nbsp;</p>

<p>in:&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name,math from student
    -&gt; where math in(89,90,91);</code></pre>

<p><img alt="" class="has" height="204" src="https://img-blog.csdnimg.cn/20190416233535455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="421"></p>

<h3 id="6order-by排序语句">5、order by排序语句</h3>

<p><strong>asc升序(默认)，desc降序&nbsp;</strong><br>
order by 子句应该位于select语句的结尾&nbsp;<br>
eg：对数学成绩进行排序&nbsp;<br>
默认升序：&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name,math from student
    -&gt; order by math;</code></pre>

<p><img alt="" class="has" height="309" src="https://img-blog.csdnimg.cn/20190416233714121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="469"></p>

<p>降序：&nbsp;</p>

<pre class="has"><code>mysql&gt; select id,name,math from student
    -&gt; order by math desc;</code></pre>

<p><img alt="" class="has" height="312" src="https://img-blog.csdnimg.cn/20190416233809519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="446"></p>

<p>对总分进行从高到低输出&nbsp;<br>
&nbsp;</p>

<pre class="has"><code>mysql&gt; select (chinese+math+english) as 总成绩 from student
    -&gt; order by 总成绩 desc;</code></pre>

<p><img alt="" class="has" height="304" src="https://img-blog.csdnimg.cn/20190416234113731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="660"></p>

<h3 id="7常用函数">6、常用函数</h3>

<p>（1)count(）&nbsp;<br><strong>count(*)统计null值 count(列名)排除null值</strong>&nbsp;<br>
eg :统计当前student表中一共有多少学生&nbsp;</p>

<pre class="has"><code>mysql&gt; select count(*) as 人数 from student;</code></pre>

<p><img alt="" class="has" height="171" src="https://img-blog.csdnimg.cn/20190416234234676.png" width="467"></p>

<p>&nbsp;</p>

<p>(2)sum()&nbsp;<br>
eg：统计一个班数学总成绩&nbsp;</p>

<pre class="has"><code>mysql&gt; select sum(math) as 数学总成绩 from student;</code></pre>

<p><img alt="" class="has" height="160" src="https://img-blog.csdnimg.cn/20190416234431711.png" width="554"></p>

<p>（3）平均值：avg（）&nbsp;</p>

<p>求数学的平均值</p>

<pre class="has"><code>mysql&gt; select sum(math)/count(*) as 数学平均值 from student;</code></pre>

<p><img alt="" class="has" height="156" src="https://img-blog.csdnimg.cn/2019041623475797.png" width="634"></p>

<pre class="has"><code>mysql&gt; select avg(math) as 数学平均值 from student;</code></pre>

<p><img alt="" class="has" height="159" src="https://img-blog.csdnimg.cn/20190416234929331.png" width="566"></p>

<p>7、group by 子句的使用<br>
假设有一个职工信息表，&nbsp;<br>
EMP:表名 ；部门：depton；sal：工资；job：工作&nbsp;<br>
我们设想：&nbsp;<br>
（1）显示每个部门的平均工资和最高工资&nbsp;<br>
select deptno,avg(sal),max(sal) from EMP group by deptno;&nbsp;<br>
（2）显示每个部门的每种岗位的平均工资和最低工资&nbsp;<br>
select avg(sal),min(sal),job, deptno from EMP group by deptno, job;&nbsp;<br>
补充：首先按照deptno分组，然后各组再按照job进行分组。&nbsp;<br>
（3）显示平均工资低于2000的部门和它的平均工资&nbsp;<br>
解题思路：&nbsp;<br>
1. 统计各个部门的平均工资&nbsp;<br>
select avg(sal) from EMP group by deptno&nbsp;<br>
2. having往往和group by配合使用，对group by结果进行过滤&nbsp;<br>
select avg(sal) as myavg from EMP group by deptno having myavg&lt;2000;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL使用alter修改表的结构</title><link>http://www.cnblogs.com/heian99/archive/2019/04/16/11972289.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 16 Apr 2019 10:55:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/16/11972289.html</guid><description><![CDATA[
                                            <blockquote>
<h2><span style="color:#f33b45;"><strong>SQL语句</strong></span></h2>

<h3><strong>&nbsp;&nbsp; &nbsp;DLL&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;数据定义语言</strong></h3>

<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;create，drop</strong></p>

<h3><strong>&nbsp;&nbsp; &nbsp;DML &nbsp; &nbsp; 数据操纵语言</strong></h3>

<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;insert，delete，select，update</strong></p>

<h3><strong>&nbsp;&nbsp; &nbsp;DCL&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;数据控制语言</strong></h3>

<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;grant，revoke</strong></p>
</blockquote>

<h1>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">使用ALTER TABLE修改表结构</span></h1>

<h2><strong>（1）修改表名</strong></h2>

<p>ALTER TABLE &lt;表名&gt; RENAME &lt;新表名&gt;</p>

<pre class="has"><code>mysql&gt; alter table game_account rename account;
Query OK, 0 rows affected (0.05 sec)</code></pre>

<h2><strong>（2）修改表的搜索引擎</strong></h2>

<pre class="has"><code>mysql&gt; alter table account engine=MyISAM;
Query OK, 0 rows affected (0.05 sec)
Records: 0 &nbsp;Duplicates: 0 &nbsp;Warnings: 0</code></pre>

<h3><br><strong>查看表的信息</strong></h3>

<pre class="has"><code>mysql&gt; show create table account\G;
*************************** 1. row ***************************
&nbsp; &nbsp; &nbsp; &nbsp;Table: account
Create Table: CREATE TABLE `account` (
&nbsp; `game_name` char(15) NOT NULL,
&nbsp; `game_password` char(25) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
ERROR:&nbsp;
No query specified</code></pre>

<h2><strong>（3）添加字段</strong></h2>

<p>ALTER TABLE &lt;表名&gt; ADD &lt;字段名称&gt; &lt;字段定义&gt;</p>

<h3><span style="color:#f33b45;">后面添加：</span></h3>

<pre class="has"><code>mysql&gt; alter table account add game_sex enum("M","F") not null;</code></pre>

<h3><br>
&nbsp; &nbsp;&nbsp;<br><span style="color:#f33b45;">前面添加：</span></h3>

<pre class="has"><code>mysql&gt; alter table account add game_address varchar(20) not null default "huabei" first;
Query OK, 0 rows affected (0.00 sec)
Records: 0 &nbsp;Duplicates: 0 &nbsp;Warnings: 0</code></pre>

<h2><span style="color:#f33b45;">中间添加：</span></h2>

<pre class="has"><code>mysql&gt; alter table account add game_money int after game_name;
Query OK, 0 rows affected (0.00 sec)
Records: 0 &nbsp;Duplicates: 0 &nbsp;Warnings: 0</code></pre>

<h2><br><strong><span>（4）删除字段</span></strong></h2>

<p>ALTER TABLE &lt;表名&gt; drop &lt;字段名称&gt;</p>

<pre class="has"><code>mysql&gt; alter table account drop game_wei;
Query OK, 0 rows affected (0.00 sec)
Records: 0 &nbsp;Duplicates: 0 &nbsp;Warnings: 0</code></pre>

<h2><strong>（5）修改字段名称及字段定义</strong></h2>

<p>ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段&gt; &lt;新字段名称&gt; &lt;字段定义&gt;</p>

<pre class="has"><code>mysql&gt; alter table account change game_zhang wei char(25) not null;
Query OK, 0 rows affected (0.01 sec)
Records: 0 &nbsp;Duplicates: 0 &nbsp;Warnings: 0</code></pre>

<pre class="has"><code>mysql&gt; alter table account change wei wei varchar(60) &nbsp;;
Query OK, 0 rows affected (0.00 sec)
Records: 0 &nbsp;Duplicates: 0 &nbsp;Warnings: 0</code></pre>

<h2><br><strong>（6）修改字段定义</strong></h2>

<p>ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名称&gt; &lt;字段定义&gt;</p>

<pre class="has"><code>mysql&gt; alter table account modify wei int ;
Query OK, 0 rows affected (0.01 sec)
Records: 0 &nbsp;Duplicates: 0 &nbsp;Warnings: 0</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>mysql&gt; alter table account modify wei int &nbsp;not null ;
Query OK, 0 rows affected (0.01 sec)
Records: 0 &nbsp;Duplicates: 0 &nbsp;Warnings: 0</code></pre>

<p><br>
&nbsp;</p>
                                    ]]></description></item><item><title>MySQL基本库表管理</title><link>http://www.cnblogs.com/heian99/archive/2019/04/16/11972290.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 16 Apr 2019 04:43:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/16/11972290.html</guid><description><![CDATA[
                                            <h1><strong><span style="color:#f33b45;">基本管理指令</span></strong></h1>

<h3><strong>mysql登陆</strong></h3>

<p><strong>第一种</strong></p>

<pre class="has"><code>[root@wei ~]# mysql -u root -p</code></pre>

<p><strong>第二种（带参输入）</strong></p>

<pre class="has"><code>[root@wei ~]# mysql -uroot -proot</code></pre>

<p><span style="color:#f33b45;"><strong>注意：每个命令后面必须加;</strong></span></p>

<h3><strong>mysql里面清屏</strong></h3>

<h3><span style="color:#f33b45;"><strong>&nbsp;\! clear</strong></span></h3>

<h1><br><strong><span style="color:#f33b45;"><u>数据库基本管理操作</u></span></strong></h1>

<h2><strong>（1）查看数据库</strong></h2>

<p><strong>&nbsp;</strong></p>

<pre class="has"><code>show databases;

mysql&gt; show databases;
+--------------------+
| Database &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |
+--------------------+
| information_schema |
| farm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |
| mysql &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|
| performance_schema |
+--------------------+
4 rows in set (0.00 sec)</code></pre>

<h2><br><strong>（2）创建数据库</strong></h2>

<p><strong>CREATE DATABASE &lt;db_name&gt; [CHARACTER=&lt;字符集&gt; COLLATE=&lt;排序规则&gt;]</strong></p>

<pre class="has"><code>mysql&gt; create database game;
Query OK, 1 row affected (0.01 sec)</code></pre>

<h2><img alt="" class="has" height="331" src="https://img-blog.csdnimg.cn/20190416123455639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="386"><br><strong>(3)查看数据库的创建信息</strong></h2>

<pre class="has"><code>mysql&gt; show create database game;
+----------+-----------------------------------------------------------------+
| Database | Create Database &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |
+----------+-----------------------------------------------------------------+
| game &nbsp; &nbsp; | CREATE DATABASE `game` /*!40100 DEFAULT CHARACTER SET latin1 */ |
+----------+-----------------------------------------------------------------+
1 row in set (0.00 sec)</code></pre>

<h2><img alt="" class="has" height="228" src="https://img-blog.csdnimg.cn/201904161235477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="763"><br><strong>（4）查看mysql数据库支持的字符集</strong></h2>

<p><strong>&nbsp;</strong></p>

<pre class="has"><code>&nbsp; &nbsp;mysql&gt; show character set;</code></pre>

<p><img alt="" class="has" height="551" src="https://img-blog.csdnimg.cn/20190416123631307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="860"></p>

<h2><strong>（5）查看mysql数据库支持字符集的排序规则</strong></h2>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;mysql&gt; show collation;</code></pre>

<h2><img alt="" class="has" height="463" src="https://img-blog.csdnimg.cn/20190416123719340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="903"><br><strong>（6）删除数据库</strong></h2>

<pre class="has"><code>mysql&gt; drop database lol;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show databases;
+--------------------+
| Database &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |
+--------------------+
| information_schema |
| farm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |
| game &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |
| mysql &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|
| performance_schema |
+--------------------+
5 rows in set (0.00 sec)</code></pre>

<h2><strong>（7）切换数据库</strong></h2>

<pre class="has"><code>mysql&gt; use game
Database changed</code></pre>

<h2><span style="color:#f33b45;"><strong>示例：创建一个lol的数据库，字符集为utf8,排序为utf8_general_ci</strong></span></h2>

<pre class="has"><code>mysql&gt; create database lol&nbsp;
&nbsp; &nbsp; -&gt; character set=utf8
&nbsp; &nbsp; -&gt; collate=utf8_general_ci;
Query OK, 1 row affected (0.00 sec)

mysql&gt; show create database lol;
&nbsp; &nbsp;&nbsp;
+----------+--------------------------------------------------------------+
| Database | Create Database &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|
+----------+--------------------------------------------------------------+
| lol &nbsp; &nbsp; &nbsp;| CREATE DATABASE `lol` /*!40100 DEFAULT CHARACTER SET utf8 */ |
+----------+--------------------------------------------------------------+
1 row in set (0.00 sec)</code></pre>

<p>&nbsp;</p>

<h3><span style="color:#f33b45;"><strong>rpm默认数据目录</strong></span></h3>

<p><strong>&nbsp;&nbsp; &nbsp;/var/lib/mysql &nbsp;-----&gt;数据目录：rpm默认数据目录</strong></p>

<p><strong>数据库一般存在数据目录下/var/lib/mysql&nbsp;</strong></p>

<pre class="has"><code>[root@wei ~]# ls /var/lib/mysql
auto.cnf &nbsp;game &nbsp; &nbsp; ib_logfile0 &nbsp;lol &nbsp; &nbsp;mysql.sock
farm &nbsp; &nbsp; &nbsp;ibdata1 &nbsp;ib_logfile1 &nbsp;mysql &nbsp;performance_schema</code></pre>

<p><img alt="" class="has" height="135" src="https://img-blog.csdnimg.cn/20190416123906229.png" width="892"></p>

<h1><span style="color:#f33b45;"><strong>数据表的基本操作管理：</strong></span></h1>

<h2><strong>（1）查看表</strong></h2>

<p>&nbsp;</p>

<pre class="has"><code>mysql&gt; show tables;
+----------------+
| Tables_in_game |
+----------------+
| game_account &nbsp; |
+----------------+
1 row in set (0.00 sec)</code></pre>

<h2><strong>（2）创建表</strong></h2>

<p><strong>CREATE TABLE &lt;表名&gt;(字段名称 数据类型 [属性],字段名称 数据类型 [属性]...)</strong></p>

<p><strong>数据类型：</strong></p>

<p><img alt="" class="has" src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=b3e5187076ec54e741b912188908b768/08f790529822720e9e2977b476cb0a46f31fab9d.jpg"></p>

<p><strong>数值型</strong></p>

<p><img alt="" class="has" src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=72f193848f8ba61edfbbc0297104bb32/ac345982b2b7d0a2cf3091d3c6ef76094a369a87.jpg"><br><strong>字符型</strong></p>

<p><img alt="" class="has" src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=7296315d9adda144da5c64b48287fc9a/10dfa9ec8a1363271c91577d9c8fa0ec08fac704.jpg"><br><strong>日期/时间型</strong></p>

<p><img alt="" class="has" src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=6b7013a09182d158bbd751b7b03a35e0/b3119313b07eca80df41aca99c2397dda144833c.jpg"></p>

<pre class="has"><code>mysql&gt; create table game_account(
&nbsp; &nbsp; -&gt; game_name char(15) not null,
&nbsp; &nbsp; -&gt; game_passwd char(15) not null,
&nbsp; &nbsp; -&gt; );</code></pre>

<h2><strong>&nbsp;&nbsp; &nbsp;<br>
（3）查看创建表的信息</strong></h2>

<pre class="has"><code>mysql&gt; show create table game_account\G;
*************************** 1. row ***************************
&nbsp; &nbsp; &nbsp; &nbsp;Table: game_account
Create Table: CREATE TABLE `game_account` (
&nbsp; `game_name` char(15) NOT NULL,
&nbsp; `game_password` char(25) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
ERROR:&nbsp;
No query specified</code></pre>

<h2><strong>（4）删除表</strong></h2>

<pre class="has"><code>mysql&gt; drop table gam;
Query OK, 0 rows affected (0.01 sec)</code></pre>

<h2><strong>（5）查看表结构</strong></h2>

<pre class="has"><code>mysql&gt; desc game_account;
+---------------+----------+------+-----+---------+-------+
| Field &nbsp; &nbsp; &nbsp; &nbsp; | Type &nbsp; &nbsp; | Null | Key | Default | Extra |
+---------------+----------+------+-----+---------+-------+
| game_name &nbsp; &nbsp; | char(15) | NO &nbsp; | &nbsp; &nbsp; | NULL &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; |
| game_password | char(25) | NO &nbsp; | &nbsp; &nbsp; | NULL &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; |
+---------------+----------+------+-----+---------+-------+
2 rows in set (0.00 sec)</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL的rpm安装教程</title><link>http://www.cnblogs.com/heian99/archive/2019/04/16/11972291.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 16 Apr 2019 01:47:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/16/11972291.html</guid><description><![CDATA[
                                            <h2>Linux 上安装 MySQL</h2>

<p>Linux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址：</p>

<ul><li><strong>MySQL</strong>&nbsp;- MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。</li>
	<li><strong>MySQL-client</strong>&nbsp;- MySQL 客户端程序，用于连接并操作Mysql服务器。</li>
	<li><strong>MySQL-devel</strong>&nbsp;- 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。</li>
	<li><strong>MySQL-shared</strong>&nbsp;- 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。</li>
	<li><strong>MySQL-bench</strong>&nbsp;- MySQL数据库服务器的基准和性能测试工具。</li>
</ul><p>安装前，我们可以检测系统是否自带安装 MySQL:</p>

<pre class="has"><code>rpm -qa | grep mysql</code></pre>

<p>如果你系统有安装，那可以选择进行卸载:</p>

<pre class="has"><code>rpm -e mysql　　// 普通删除模式
rpm -e --nodeps mysql　　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</code></pre>

<p>接下来我们在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：<a href="https://dev.mysql.com/downloads/repo/yum/" rel="nofollow">https://dev.mysql.com/downloads/repo/yum/</a></p>

<p>注意：没安装wget的朋友，需要先安装wget</p>

<pre class="has"><code>[root@wei ~]# yum install wget
</code></pre>

<h3><span style="color:#f33b45;">下载安装包</span></h3>

<pre class="has"><code>wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</code></pre>

<h3><span style="color:#f33b45;">安装rpm包</span></h3>

<pre class="has"><code>rpm -ivh mysql-community-release-el7-5.noarch.rpm</code></pre>

<h3><span style="color:#f33b45;">安装mysql-server服务</span></h3>

<pre class="has"><code>yum install mysql-server</code></pre>

<p>&nbsp;</p>

<h3><span style="color:#f33b45;">权限设置：</span></h3>

<pre class="has"><code>chown mysql:mysql -R /var/lib/mysql</code></pre>

<h3><span style="color:#f33b45;">初始化 MySQL：</span></h3>

<pre class="has"><code>mysqld --initialize</code></pre>

<h3><span style="color:#f33b45;">启动 MySQL：</span></h3>

<pre class="has"><code>systemctl start mysqld</code></pre>

<h3><span style="color:#f33b45;">查看 MySQL 运行状态：</span></h3>

<pre class="has"><code>systemctl status mysqld</code></pre>

<h3><span style="color:#f33b45;">设置为开机自启</span></h3>

<pre class="has"><code>systemctl enable mysqld
</code></pre>

<h2><span style="color:#f33b45;">验证 MySQL 安装</span></h2>

<pre class="has"><code>[root@wei ~]# mysqladmin --version
mysqladmin  Ver 8.42 Distrib 5.6.42, for Linux on x86_64 ##显示这个信息表示成功</code></pre>

<h1><span style="color:#f33b45;">&nbsp;注意：</span></h1>

<p><strong>设置密码&nbsp;<br>
当第一次启动MySQL服务器时，为MySQL根用户生成一个临时密码。 您可以通过运行以下命令找到密码：</strong></p>

<pre class="has"><code>[root@wei ~]# grep  'temporary password' /var/log/mysqld.log
</code></pre>

<p><img alt="" class="has" height="124" src="https://img-blog.csdnimg.cn/20190416092547812.jpg" width="750"></p>

<p><strong>localhost：后边的就是临时密码，先复制下来&nbsp;</strong></p>

<p><span style="color:#f33b45;"><strong>注意：如果没有查到，就是不需要，登陆时，回车即可登陆</strong></span></p>

<p><strong>进入mysql，在Enter password：复制粘贴先前的密码就进去了</strong></p>

<pre class="has"><code>mysql -u root -p
</code></pre>

<p><img alt="" class="has" height="179" src="https://img-blog.csdnimg.cn/20190416092811232.png" width="521"></p>

<h1><strong>修改密码方式</strong></h1>

<pre class="has"><code>[root@wei ~]# mysqladmin -u root -p password
Enter password:        #旧密码
New password:         #新密码
Confirm new password:    #再输入一次
</code></pre>

<h1><span style="color:#f33b45;"><strong>注意：</strong>在输入密码时，密码是不会显示了，你正确输入即可。</span></h1>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>MySQL基础理论</title><link>http://www.cnblogs.com/heian99/archive/2019/04/15/11972292.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 15 Apr 2019 15:28:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/15/11972292.html</guid><description><![CDATA[
                                            <h1><strong><span style="color:#f33b45;">MySQL数据库</span></strong></h1>

<p><strong>以文本的形式存储数据的劣势:</strong></p>

<ul><li><strong>&nbsp; &nbsp; &nbsp; 1、数据冗余(一个文件中出现n次相同的数据)和数据不一致性</strong></li>
	<li><strong>&nbsp;&nbsp; &nbsp; &nbsp;2、数据访问困难</strong></li>
	<li><strong>&nbsp;&nbsp; &nbsp; &nbsp;3、数据孤立</strong></li>
	<li><strong>&nbsp; &nbsp; &nbsp; 4、数据完整性问题</strong></li>
	<li><strong>&nbsp; &nbsp; &nbsp; 5、原子性(多个相关联的操作必须要同时完成</strong></li>
	<li><strong>&nbsp;&nbsp; &nbsp; &nbsp;6、并发访问异常</strong></li>
	<li><strong>&nbsp;&nbsp; &nbsp; &nbsp;7、安全性问题</strong></li>
</ul><p><strong>DBMS----DataBase Management System数据库管理系统</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 以关系(表)的形式存储数据</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 记录Record &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;表中的每一-行数据;<br>
&nbsp;&nbsp; &nbsp; &nbsp;字段(属性) column &nbsp;&nbsp;&nbsp; &nbsp;表中的每一列名字</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 数据库<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;表<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
软件:</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; MySQL, oracle, MariaDB (https:/ /www.percona.com/)，DB2， SQL Server<br>
&nbsp;&nbsp; &nbsp; &nbsp;MongeDB</strong></p>

<p><strong>约束 &nbsp;Constraint</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 域约束:数据类型约束<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;保证某字段的数据类型一致</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 外键约束:引用完整性约束(InnoDB)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;一个表中某字段的数据必须在与之相关的其他表的相关联字段中存在</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 主键约束<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;某字段能惟一标识此字段所属的实体，并且不允许为空，<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;一个表只能有一个主键</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 惟一键约束<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;某字段能惟一标识此字段所属的实体，可以为空&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;一个表可以有多个惟一键</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 检查性约束<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;保证某字段中不能出现违反常理的数据，例如年龄</strong></p>

<h1><strong><span style="color:#f33b45;">MySQL基础应用</span></strong></h1>

<p><strong>一、数据库特点:结构化,无有害,无重复;</strong></p>

<p><strong>二、数据库优点:按一定的数据模型组织,描述和储存;可为各种用户共享,冗余度小,节省储存空间易扩展,编写有关数据应用程序。</strong></p>

<p><strong>三、常用Dos操作指令:</strong></p>

<ol><li><strong>安装数据库:mysqld -install,</strong></li>
	<li><strong>开启/关闭数据库:start mysql/net stop,</strong></li>
	<li><strong>监听端口信息:netstat -a,</strong></li>
	<li><strong>登陆数据库:mysql -uroot -p,</strong></li>
	<li><strong>显示默认数据库:use dbname,</strong></li>
	<li><strong>显示所有数据库:show databases,</strong></li>
	<li><strong>显示默认数据库中的所有表:show tables,</strong></li>
	<li><strong>放弃正在输入的指令:\c,</strong></li>
	<li><strong>显示命令清单:\h,</strong></li>
	<li><strong>退出mysql程序:\q,</strong></li>
	<li><strong>查看mysql服务器状态信息:\s,</strong></li>
	<li><strong>mysql版本信息:SELECT&nbsp;version(),</strong></li>
	<li><strong>打开表结构:desc table。</strong></li>
</ol><p><strong>四、数据库语法组成:</strong></p>

<p><strong>1.DDM(Data Definition Language数据库定义语言):create table,drop table,alter&nbsp;table等</strong></p>

<p><strong>2.DCL(Data Control Language数据控制语言):grant,revoke等;</strong></p>

<p><strong>3.DML(Data Manipulation Language数据操作语言)查询SELECT、插入insert、update修改、删除delete;</strong></p>

<p><strong>五、MYSQL三种常用的数据类型:文本:char,varchar,text;数字,日期和时间类型;</strong></p>

<p><strong><img alt="" class="has" src="https://images2015.cnblogs.com/blog/993601/201607/993601-20160731132726059-281428318.png"></strong></p>

<p><strong>六、常用操作</strong></p>

<ul><li><strong>显示表结构:DESC 表名;</strong></li>
	<li><strong>删除表操作:drop table 表名</strong></li>
	<li><strong>除数据库操作:drop database 数据库名</strong></li>
	<li><strong>更改表结构操作:alter table 表名 action;(action可以是以下操作)</strong></li>
	<li><strong>add 列名 建表语句[first/after]--在表中添加列,制定其位置;</strong></li>
	<li><strong>add primary key (列名)-- 添加一个主键,如果主键已存在,会报错;</strong></li>
	<li><strong>add foreign key (列名) reference 表名 （列名）;-- 为表添加一个外键;</strong></li>
	<li><strong>alter列名 set default 默认值;-- 更改指定列的默认值</strong></li>
	<li><strong>drop 列名 -- 删除一列</strong></li>
	<li><strong>drop primary key -- 删除主键</strong></li>
	<li><strong>engine 类型名 -- 改变表的类型</strong></li>
	<li><strong>rename as 新表名 -- 改变表名</strong></li>
	<li><strong>change 旧列名 新列名 [first /after]-- 更改列的类型和名称</strong></li>
	<li><strong>modify 和change相同;</strong></li>
</ul><p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell awk数组使用</title><link>http://www.cnblogs.com/heian99/archive/2019/04/15/11972293.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 15 Apr 2019 15:18:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/15/11972293.html</guid><description><![CDATA[
                                            <h1><strong><span style="color:#f33b45;">awk中使用数组</span></strong></h1>

<p><strong>一.数组格式</strong></p>

<p><strong>数组是一个包含一系列元素的表.</strong></p>

<p><strong><span style="color:#f33b45;">格式如下：</span></strong></p>

<p><strong>&nbsp;&nbsp;&nbsp; abc[1]=”xiaohong”</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp; abc[2]=”xiaolan”</strong></p>

<p><strong>解释：</strong></p>

<p><strong>abc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：为数组名称</strong></p>

<p><strong>[1]、[2]：为数组元素下标，可以理解为数组的第1个元素、数组的第2个元素</strong></p>

<p><strong>”xiaohong”、”xiaolan”： 元素内容</strong></p>

<p><strong>数组<br>
arrray[index-expression]</strong></p>

<p><span style="color:#7c79e5;"><strong>数组下从1开始，也可以使用字符串作为数组的下标</strong></span></p>

<p><span style="color:#7c79e5;"><strong>index-expression可以使用任意的字符串<br>
需注意的是：如果某数组元素事先不存在，那么引用其时，awk会自动创建次元素并初始化为0，要判断某数组中是否存在某元素，需要<br>
使用index in arrary的方式</strong></span></p>

<h3><span style="color:#f33b45;"><strong>要遍历数组中每一个元素，需要使用 如下的特殊结构：</strong></span></h3>

<p><span style="color:#ffbb66;"><strong>for（变量 in 数组名称）{print 数组名称[小标]}</strong></span></p>

<p><span style="color:#f33b45;"><strong>其中，vae是数组的下标</strong></span></p>

<h3><strong><span style="color:#f33b45;">统计每个shell的使用次数</span></strong><br>
&nbsp;</h3>

<pre class="has"><code>[root@wei awk]# awk -F: '{shell[$7]++}END{for(i in shell){print i,shell[i]}}' /etc/passwd
/bin/sync 1
/bin/bash 17
/sbin/nologin 20
/sbin/halt 1
/sbin/shutdown 1&nbsp;</code></pre>

<h3><br><strong>&nbsp;<br><span style="color:#f33b45;">&nbsp;统计每个状态下的tcp连接个数</span><br>
&nbsp;</strong></h3>

<pre class="has"><code>[root@wei awk]# netstat -antp | awk '/^tcp/{state[$6]++}END{for(i in state){print i,state[i]}}'
LISTEN 9
ESTABLISHED 2</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell awk逻辑控制语句</title><link>http://www.cnblogs.com/heian99/archive/2019/04/15/11972294.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 15 Apr 2019 15:14:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/15/11972294.html</guid><description><![CDATA[
                                            <h1><span style="color:#f33b45;"><strong>awk逻辑控制语句</strong></span></h1>

<h2><strong>1，if...else</strong></h2>

<p><strong>格式：</strong></p>

<p><strong>if（条件）{语句；语句} else {语句1；语句2}</strong></p>

<p><strong>如果statement只有一条语句，{}可以不写</strong></p>

<h3><span style="color:#f33b45;"><strong>以冒号为分隔符，判断第一个字段，如果为root，则显示用户为administrator，否则显示用户问common user</strong></span></h3>

<pre class="has"><code>[root@wei csdn]# awk -F: '{if($3==0){print $1,"is administrator."}else {print $1,"is common user"}}' /etc/passwd
root is administrator.
bin is common user</code></pre>

<h3><span style="color:#f33b45;"><strong>编写uid大于500的用户个数</strong></span></h3>

<pre class="has"><code>[root@wei csdn]# awk -F: -v count=0 '{if($3&gt;500) {count++}}END{print "uid大于500的用户数量：",count}' /etc/passwd
uid大于500的用户数量： 19</code></pre>

<h3><span style="color:#f33b45;"><strong>判断系统的bash用户和nologin用户</strong></span></h3>

<pre class="has"><code>[root@wei csdn]# awk -v num1=0 -v num2=0 -F: '/bash$/ || /nologin$/{if($7=="/bin/bash"){num1++} else {num2++}}END{print "bash用户数量：",num1,"nologin用户数量：",num2}' /etc/passwd
bash用户数量： 17 nologin用户数量： 20</code></pre>

<p>&nbsp;</p>

<h2><br><strong>2，while</strong></h2>

<p><strong>格式：</strong></p>

<p><strong>while(条件) {语句1;语句2;.....}</strong></p>

<h3><strong><span style="color:#f33b45;">passwd前3行进行输出，输出3次</span></strong></h3>

<pre class="has"><code>[root@wei csdn]# head -n 3 /etc/passwd | awk '{i=1;while(i&lt;=3){print $0; i++}}'
root:x:0:0:root:/root:/bin/bash
root:x:0:0:root:/root:/bin/bash
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin</code></pre>

<h3><span style="color:#f33b45;"><strong>以冒号为分割符，判断每一行的每一个字段的长度如果大于4，则显之</strong></span></h3>

<pre class="has"><code>[root@wei awk]# head -n 3 /etc/passwd | awk -F: '{i=1;while(i&lt;=7){if(length($i)&gt;4){print $i};i++}}'
/root
/bin/bash
/sbin/nologin
daemon
daemon
/sbin
/sbin/nologin</code></pre>

<h3><strong><span style="color:#f33b45;">统计test.txt的文件长度大小为5的单词</span></strong></h3>

<pre class="has"><code>[root@wei awk]# awk '{i=1;while(i&lt;NF) {if(length($i)&gt;5){print $i};i++}}' print.txt&nbsp;</code></pre>

<h2><br><strong>3，for &nbsp; 遍历数组</strong></h2>

<p><strong>格式：</strong></p>

<p><strong>for（变量定义；循环终止的条件；改变循环条件的语句） {语句；语句...}</strong></p>

<p><strong>&nbsp;&nbsp; &nbsp;for(i=1;i&lt;=4;i++) {......}</strong></p>

<h3><span style="color:#f33b45;"><strong>以冒号为分隔符，显示/etc/passwd每一行的前3个字段</strong></span></h3>

<pre class="has"><code>[root@wei awk]# awk -F: '{for (i=1;i&lt;=3;i++) { print $i} }' /etc/passwd
root
x
0
bin

</code></pre>

<h2><br><strong>4， break contiune&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;用于中断循环</strong></h2>
                                    ]]></description></item><item><title>Linux shell awk模式使用</title><link>http://www.cnblogs.com/heian99/archive/2019/04/14/11972295.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 14 Apr 2019 14:59:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/14/11972295.html</guid><description><![CDATA[
                                            <h1><strong><span style="color:#ffbb66;">awk的PATTERN表示方法：</span></strong></h1>

<h3><strong><span style="color:#f33b45;">1，正则表达式，格式为/regex/</span></strong></h3>

<p><strong><span style="color:#f33b45;">以冒号为分隔符，显示/etc/passwd以r开头的行的第一段</span></strong></p>

<pre class="has"><code>[root@wei awk]# awk -F: '/^r/{print $1}' /etc/passwd
root</code></pre>

<p><strong><span style="color:#f33b45;">以冒号为分隔符，显示/etc/passwd以nologin结尾的行的第一段</span></strong></p>

<pre class="has"><code>[root@wei awk]# awk -F: '/nologin$/{print $1}' /etc/passwd
bin
daemon
adm
lp
mail</code></pre>

<p><span style="color:#f33b45;"><strong>以冒号为分隔符，显示/etc/passwd以r或者h开头的行的第一段</strong></span></p>

<pre class="has"><code>[root@wei awk]# awk -F: '/^[rh]/{print $1}' /etc/passwd
root
halt
hei</code></pre>

<p><br><strong><span style="color:#f33b45;">写出/etc/的软链接的名字</span></strong></p>

<pre class="has"><code>[root@wei awk]# ls -l /etc/ |awk '/^l/{print $NF}'
/usr/share/icons/hicolor/16x16/apps/fedora-logo-icon.png
../boot/grub2/grub.cfg</code></pre>

<h3><span style="color:#f33b45;"><strong>2，表达式，有下面操作符组成的表达式</strong></span></h3>

<h1><br><strong>awk的操作符</strong></h1>

<h3><span style="color:#7c79e5;"><strong>1 ，算术操作符</strong></span></h3>

<p><strong>-x 负值<br>
+x 转换为数值，正值<br>
x^y x**y &nbsp;次方<br>
x/y<br>
x*y<br>
x-y<br>
x+y<br>
x%y</strong></p>

<h2><span style="color:#7c79e5;"><strong>2 ,字符串操作符</strong></span></h2>

<p><strong>+：实现字符串连接 &nbsp; &nbsp;"ab"+"cd" &nbsp; &nbsp;abcd</strong></p>

<h3><span style="color:#7c79e5;"><strong>3 ,赋值操作符</strong></span></h3>

<p><strong>=<br>
+=<br>
-+<br>
*=<br>
、=<br>
%=<br>
^=<br>
**=</strong></p>

<h3><span style="color:#7c79e5;"><strong>4 ,比较操作符</strong></span></h3>

<p><strong>x&lt;y<br>
x&lt;=y<br>
x&gt;y<br>
x&gt;=y<br>
x==y<br>
x!=y<br>
x~y:x为字符串，y为模式，如果x可以被模式匹配则为真，否则为假<br>
x!~y</strong></p>

<h3><span style="color:#7c79e5;"><strong>5 ,逻辑关系符</strong></span></h3>

<p><strong>&amp;&amp; 与<br>
|| 或者</strong></p>

<p><span style="color:#f33b45;"><strong>显示uid大于等于500的用户的及uid</strong></span></p>

<pre class="has"><code>[root@wei awk]# awk -F: '$3&gt;=500{print $1,$3}' /etc/passwd
polkitd 999
saslauth 998
hei 1200
wei 1001</code></pre>

<h3><br><strong><span style="color:#f33b45;">3 ，指定范围，格式为pattern,pattern2</span></strong></h3>

<p><strong>以冒号为分隔符，显示uid=0到最后一个字段为nologin结尾中间所有的用户名称，uid及shell</strong></p>

<pre class="has"><code>[root@wei awk]# awk -F: '$3==0,$7~"nologin$"{print $1,$3,$7}' /etc/passwd
root 0 /bin/bash
bin 1 /sbin/nologin</code></pre>

<h3><br><strong><span style="color:#f33b45;">4 ，BEGIN/END, 特殊模式</span><br>
&nbsp;&nbsp; &nbsp;BEGIN表示awk进行处理前执行一次操作<br>
&nbsp;&nbsp; &nbsp;END表示awk处理完最后一行结束前执行一次操作<br>
&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">使用BEGIN打印表头</span></strong></h3>

<pre class="has"><code>[root@wei awk]# awk -F: 'BEGIN{printf "%-10s%-10s%-20s\n","username","uid","shell"}$3==0,$7 ~ "nologin$"{printf "%-10s%-10s%-10s\n",$1,$3,$7}' /etc/passwd
username &nbsp;uid &nbsp; &nbsp; &nbsp; shell &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
root &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; /bin/bash&nbsp;
bin &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; /sbin/nologin</code></pre>

<h3><br><strong><span style="color:#f33b45;">使用END打印表尾</span></strong></h3>

<pre class="has"><code>[root@wei awk]# awk -F: 'BEGIN{printf "%-10s%-10s%-20s\n","username","uid","shell"}$3==0,$7 ~ "nologin$"{printf "%-10s%-10s%-10s\n",$1,$3,$7}END{print "END OFFILE..."}' /etc/passwd
username &nbsp;uid &nbsp; &nbsp; &nbsp; shell &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
root &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; /bin/bash&nbsp;
bin &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; /sbin/nologin
END OFFILE...</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell awk中printf使用</title><link>http://www.cnblogs.com/heian99/archive/2019/04/14/11972297.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 14 Apr 2019 13:29:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/14/11972297.html</guid><description><![CDATA[
                                            <h1><strong><span style="color:#f33b45;">printf 是 awk 的重要格式化输出命令</span></strong></h1>

<h3><strong>printf格式化输出内容</strong></h3>

<h3><strong>格式：<br>
&nbsp;&nbsp; &nbsp;printf format，item1，item2...<br>
&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">要点：</span></strong></h3>

<p><span style="color:#f33b45;"><strong>1，printf输出时要指定格式format<br>
2，formay用于指定后面的每个item输出的格式<br>
3，printf语句不会自动打印换行符\n</strong></span></p>

<h2><span style="color:#e579b6;"><strong>format格式：</strong></span></h2>

<p><strong>%c:显示单个字符<br>
%d,%i:十进制整数<br>
%e,%E:科学计数法显示数值<br>
%f:显示浮点数<br>
%g,%G:以科学计数法的格式或浮点数的格式显示数值<br>
%s:显示字符串<br>
%u:无符号整数<br>
%%:显示%自身</strong></p>

<h2><strong><span style="color:#e579b6;">修饰符:</span><br>
N:显示宽度，N为数字<br>
-:左对齐，默认为右对齐<br>
+:显示数值符号</strong></h2>

<pre class="has"><code>weizhang[root@wei awk]# awk '{printf "%s\n", $3}' print.txt&nbsp;
wei
zhang</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei awk]# awk '{printf "%6s\n", $3}' print.txt&nbsp;
&nbsp; &nbsp;wei
&nbsp;zhang</code></pre>

<h2><span style="color:#f33b45;"><strong>显示前三个用户的用户名，uid，家目录</strong></span></h2>

<pre class="has"><code>[root@wei awk]# head -n 3 /etc/passwd | awk -F: '{printf "%-8s%-3d%-6s\n",$1,$3,$6}'
root &nbsp; &nbsp;0 &nbsp;/root&nbsp;
bin &nbsp; &nbsp; 1 &nbsp;/bin &nbsp;
daemon &nbsp;2 &nbsp;/sbin&nbsp;</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell awk中print及变量使用</title><link>http://www.cnblogs.com/heian99/archive/2019/04/14/11972298.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 14 Apr 2019 13:00:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/14/11972298.html</guid><description><![CDATA[
                                            <h2><strong>Linux处理文本工具<br>
&nbsp;&nbsp; &nbsp;<span style="color:#f33b45;">grep： 过滤文本内容<br>
&nbsp;&nbsp; &nbsp;sed： &nbsp;编辑文本内容<br>
&nbsp;&nbsp; &nbsp;awk: &nbsp; 显示文本</span><br>
&nbsp;&nbsp; &nbsp;<br>
awk： &nbsp;Aho Peter Weinberger &nbsp;Kernighan<br>
报告生成器，以特定的条件查找文本内容，在以特定的格式显示</strong></h2>

<h3><strong><span style="color:#f33b45;">awk命令的格式：</span></strong></h3>

<p><strong># awk [option] 'script' file1 file2...</strong></p>

<p><strong># awk [option] 'PATTERM{action}' file1 file2...</strong></p>

<p><strong><span style="color:#f33b45;">PATTERN：</span><br>
&nbsp;&nbsp; &nbsp;用文本字符与正则表达式元字符描述的条件，可以省略不写</strong></p>

<p><strong><span style="color:#f33b45;">action:</span><br>
&nbsp;&nbsp; &nbsp;print<br>
&nbsp;&nbsp; &nbsp;printf &nbsp;指定输出项的格式：格式必须写</strong></p>

<h3><strong><span style="color:#f33b45;">option选项</span>：<br>
&nbsp;&nbsp; &nbsp;-F &nbsp;指定文本分割符<br>
&nbsp;&nbsp; &nbsp;<br><span style="color:#ffbb66;">awk处理文本机制：<br>
awk将符合PATTERN的文本逐渐取出，并按照指定的分割符（默认为空白，通过—F选项可以指定分割符）进行分割，然后将分割后的每段按照特定的格式输出</span></strong></h3>

<h2><br><strong><span style="color:#f33b45;">awk的输出：</span></strong></h2>

<p><strong>一 print</strong></p>

<p><strong>print的使用格式：<br>
&nbsp;&nbsp; &nbsp;print item1，item,...</strong></p>

<h3><strong><span style="color:#f33b45;">注意：</span></strong></h3>

<p><br><strong>1，各项目间使用逗号分隔开，而输出时以空白字符串为分隔<br>
2，输出的item可以为字符串，数值，当前的记录的字段（$1）,变量或者awk的表达式，数值会先转换字符串，然后输出<br>
3，print命令后面的item可以省略，此时其功能相当于print（$0代表未分割的整行文本内容），因此，如果想输出空行，则需要使用print "";</strong></p>

<h3><br><strong><span style="color:#f33b45;">以空白分割，显示文本的第一段及第二段内容</span></strong></h3>

<pre class="has"><code>[root@wei awk]# awk '{print $1,$3}' print.txt&nbsp;
i wei
i zhang</code></pre>

<pre class="has"><code>[root@wei awk]# awk '{print "hello",$3}' print.txt&nbsp;
hello wei
hello zhang</code></pre>

<h3><br><strong><span style="color:#f33b45;">显示passwd的用户名称</span></strong></h3>

<pre class="has"><code>[root@wei awk]# awk -F: '{print $1}' /etc/passwd
root
bin
daemon
adm
lp</code></pre>

<h3><br><strong><span style="color:#f33b45;">显示设备的挂载情况</span></strong></h3>

<pre class="has"><code>[root@wei awk]# df -hT | sed '1d' | awk '{print "设备名称：",$1,"挂载点：",$7,"总容量：",$3}'
设备名称： /dev/mapper/centos-root 挂载点： / 总容量： 17G
设备名称： devtmpfs 挂载点： /dev 总容量： 476M
设备名称： tmpfs 挂载点： /dev/shm 总容量： 488M</code></pre>

<h1><br><strong><span style="color:#7c79e5;"><u>awk变量</u></span></strong></h1>

<h3><strong><span style="color:#f33b45;">1 awk内置变量之记录变量</span></strong></h3>

<p><strong>FS：指定读取文本时，所使用的行分隔符，默认为空白字符，相当于awk的—F选项<br>
OFS：指定输出的分隔符，默认为空白字符；</strong></p>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei awk]# head -n 1 /etc/passwd | awk -F: '{print $1,$7}'
root /bin/bash</code></pre>

<p><strong>FS模式</strong></p>

<pre class="has"><code>[root@wei awk]# head -n 1 /etc/passwd | awk 'BEGIN{FS=":"}{print $1,$7}'
root /bin/bash</code></pre>

<p><strong>OFS模式</strong></p>

<pre class="has"><code>[root@wei awk]# head -n 1 /etc/passwd | awk -F: 'BEGIN{OFS="---"}{print $1,$7}'
root---/bin/bash</code></pre>

<p><br><strong>模式混合</strong></p>

<pre class="has"><code>[root@wei awk]# head -n 1 /etc/passwd | awk 'BEGIN{FS=":";OFS="---"}{print $1,$7}'
root---/bin/bash</code></pre>

<h3><br><strong><span style="color:#f33b45;">2 &nbsp;awk内置变量之数据变量</span></strong></h3>

<p><strong>NR：记录awk所处理的文本行数，如果有多个文件，所有的文件统一进行计数</strong></p>

<pre class="has"><code>第 1 行内容： 127.0.0.1 &nbsp; localhost localhost.localdomain localhost4 localhost4.localdomain4
第 2 行内容： ::1 &nbsp; &nbsp; &nbsp; &nbsp; localhost localhost.localdomain localhost6 localhost6.localdomain6
第 3 行内容： \S
第 4 行内容： Kernel \r on an \m
第 5 行内容：&nbsp;</code></pre>

<p><strong>注意：<br>
print在显示变量值时，不要使用$</strong></p>

<p><strong>FNR：记录awk所处理的文本行数，如果有多个文件，所有的文件分别进行计数</strong></p>

<pre class="has"><code>[root@wei awk]# awk '{print "第",FNR,"行内容：",$0}' /etc/hosts /etc/issue
第 1 行内容： 127.0.0.1 &nbsp; localhost localhost.localdomain localhost4 localhost4.localdomain4
第 2 行内容： ::1 &nbsp; &nbsp; &nbsp; &nbsp; localhost localhost.localdomain localhost6 localhost6.localdomain6
第 1 行内容： \S
第 2 行内容： Kernel \r on an \m
第 3 行内容：</code></pre>

<p><br><strong>NF：记录awk正在处理的当前行被分隔成几个字段</strong></p>

<pre class="has"><code>[root@wei awk]# cat print.txt&nbsp;
i am wei
i am zhang
[root@wei awk]# awk '{print NF}' print.txt&nbsp;
3
3
[root@wei awk]# awk '{print $NF}' print.txt&nbsp;
wei
zhang</code></pre>

<h3><strong><span style="color:#f33b45;">3 用户自定义的变量</span></strong></h3>

<p><strong><span style="color:#f33b45;">awk允许用户自定义变量，变量名称不能以数字开头，且区分大小写</span></strong></p>

<p><strong>示例：&nbsp;</strong></p>

<p><strong>方法一：使用-v选项</strong></p>

<pre class="has"><code>[root@wei awk]# head -n 3 /etc/passwd | awk -v test="hello" -F: '{print test,$1}'
hello root
hello bin
hello daemon</code></pre>

<p><strong>方法二：在BEGIN{}模式自定义变量</strong></p>

<pre class="has"><code>[root@wei awk]# head -n 3 /etc/passwd | awk -F: 'BEGIN{test="hello"}{print test,$1}'
hello root
hello bin
hello daemon</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell 数组</title><link>http://www.cnblogs.com/heian99/archive/2019/04/11/11972299.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 11 Apr 2019 15:05:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/11/11972299.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<h1><strong>Shell 数组</strong></h1>

<p><strong>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。</strong></p>

<p><strong>与大部分编程语言类似，数组元素的下标由0开始。</strong></p>

<p><strong>Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：</strong></p>

<pre class="has"><code>array_name=(value1 ... valuen)</code></pre>

<p><strong>我们也可以使用下标来定义数组:</strong></p>

<pre class="has"><code>array_name[0]=value0
array_name[1]=value1
array_name[2]=value2</code></pre>

<p><strong>读取数组</strong></p>

<p><strong>读取数组元素值的一般格式是：</strong></p>

<pre class="has"><code>${array_name[index]}</code></pre>

<p><strong>数组 Array<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;一段连续的内存空间</strong></p>

<h3><br><strong>&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">(1)定义数组</span></strong></h3>

<pre class="has"><code>[root@wei ~]# aa[0]=hei
[root@wei ~]# aa[1]=wei
[root@wei ~]# aa[2]=zhang
[root@wei ~]# hei=(192.168.196.1 192.168.196.2 192.168.196.3)
[root@wei ~]# echo ${hei[1]}
192.168.196.2
[root@wei ~]# echo ${hei[*]}
192.168.196.1 192.168.196.2 192.168.196.3</code></pre>

<h2><strong><span style="color:#f33b45;">(2)删除数组</span></strong></h2>

<pre class="has"><code>[root@wei ~]# unset hei
[root@wei ~]# echo ${hei[*]}</code></pre>

<h3><br><strong><span style="color:#f33b45;">(3)获取数组的长度</span></strong></h3>

<pre class="has"><code>[root@wei ~]# aa=(tom hei zhang wei)
[root@wei ~]# echo ${aa[*]}
tom hei zhang wei
[root@wei ~]# echo ${#aa[*]}
4
[root@wei ~]# echo ${#aa[@]}
4</code></pre>

<h3><strong><span style="color:#f33b45;">编写脚本，找出数组中最大数</span></strong></h3>

<p>&nbsp;</p>

<pre class="has"><code>#!/bin/bash
#

number=(53 54 654 45 677 46 999)
max=${number[0]}
for i in `seq 7`;do
&nbsp; &nbsp; &nbsp; &nbsp; if [ ${number[$i]} -gt $max ];then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max=${number[$i]}
&nbsp; &nbsp; &nbsp; &nbsp; fi
done
echo $max</code></pre>

<h1><strong><span style="color:#f33b45;">随机数</span></strong></h1>

<pre class="has"><code>[root@wei ~]# echo $RANDOM
10803
[root@wei ~]# echo $RANDOM
5555</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell 字符串操作</title><link>http://www.cnblogs.com/heian99/archive/2019/04/10/11972300.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 10 Apr 2019 13:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/10/11972300.html</guid><description><![CDATA[
                                            <h1><span style="color:#f33b45;">shell脚本中对字符串的处理</span></h1>

<h3><span style="color:#3399ea;">1 ${#变量名}</span></h3>

<p>作用：返回字符串的长度</p>

<pre class="has"><code># foo="this is a test"
# echo ${#foo} &nbsp; &nbsp;//返回字符串的长度
14</code></pre>

<h3><span style="color:#7c79e5;">2 &nbsp;${变量名：offset：length}</span></h3>

<p>作用：截取字符串，length指定截取的长度，也可以不写，字符串的第一个字符的索引值为0</p>

<pre class="has"><code># foo=“abcdefg”
# echo ${foo:3:2} &nbsp; &nbsp;//从下标为3的字符开始截取，共截取2个
de
# echo &nbsp;${foo:3} &nbsp; &nbsp;//从下标为3的字符开始截取到最后的字符
defg</code></pre>

<h3><br><span style="color:#3399ea;">3 &nbsp;${变量名#pattern} &nbsp; ${变量名##pattern}</span></h3>

<p>pattern：模式，通配符表达式<br>
作用：清除字符串中符合pattern的字符，从字符串最前匹配</p>

<pre class="has"><code># foo=“file.txt.zip”
# echo ${foo#*.} &nbsp; &nbsp;//一个#号代表按照最短匹配清除
txt.zip
# echo ${foo##*.} &nbsp; //2个#号代表按照最长匹配清除
zip</code></pre>

<h3><span style="color:#3399ea;">4 ${变量名%pattern} &nbsp; ${变量名%%pattern}</span></h3>

<p>pattern：模式，通配符表达式<br>
作用：清除字符串中符合pattern的字符，从字符串最后匹配</p>

<pre class="has"><code># foo=“file.txt.zip”
# echo ${foo%.*} &nbsp; &nbsp;//一个%号代表按照最短匹配清除
file.txt
# echo ${foo%%.*} &nbsp; //2个%号代表按照最长匹配清除
file</code></pre>

<h3><br><span style="color:#3399ea;">5 字符串替换操作</span></h3>

<p>${变量名/old/new}</p>

<pre class="has"><code>[root@wei ~]# foo="mp3.txt.txt.mp3.avi"
[root@wei ~]# echo ${foo/txt/TXT}
mp3.TXT.txt.mp3.avi
[root@wei ~]# echo ${foo//txt/TXT}
mp3.TXT.TXT.mp3.avi</code></pre>

<pre class="has"><code>[root@wei ~]# foo="txt.txt.txt"
[root@wei ~]# echo ${foo/#txt/TXT}
TXT.txt.txt
[root@wei ~]# echo ${foo/%txt/TXT}
txt.txt.TXT</code></pre>

<h3><br><span style="color:#3399ea;">6 实现大小写字母的转换</span></h3>

<p><span style="color:#f33b45;">大写转换小写</span></p>

<pre class="has"><code>[root@wei ~]# foo="ABcd"
[root@wei ~]# echo ${foo,}
aBcd
[root@wei ~]# echo ${foo,,}
abcd</code></pre>

<p><br><span style="color:#f33b45;">小写转换大写</span><br>
&nbsp;</p>

<pre class="has"><code>[root@wei ~]# echo ${foo^}
AbCD
[root@wei ~]# echo ${foo^^}
ABCD</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell sed命令使用</title><link>http://www.cnblogs.com/heian99/archive/2019/04/09/11972301.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 09 Apr 2019 14:22:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/09/11972301.html</guid><description><![CDATA[
                                            <p><strong>Linux处理文本文件的工具:</strong></p>

<p><strong>&nbsp;&nbsp; &nbsp;grep&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;过滤文件内容<br>
&nbsp;&nbsp; &nbsp;sed&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;编辑文件内容<br>
&nbsp;&nbsp; &nbsp;awk<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;正则表达式Regex<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
正则表达式Regex</strong></p>

<p>&nbsp;</p>

<p><strong>sed在处理文本时是逐行读取文件内容，读到匹配的行就根据指令做操作，不匹配就跳过。</strong></p>

<p><strong>sed是Linux下一款功能强大的非交互流式文本编辑器，可以对文本文件进行增、删、改、查等操作，支持按行、按字段、按正则匹配文本内容，灵活方便，特别适合于大文件的编辑。本文主要介绍sed的一些基本用法，并通过shell脚本演示sed的使用实例。</strong></p>

<p>&nbsp;</p>

<h3><span style="color:#f33b45;"><strong>(1)匹配单个字符的元字符</strong></span></h3>

<p><strong>&nbsp;&nbsp; &nbsp;.<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;[abc]&nbsp;&nbsp; &nbsp;[a-z]&nbsp;&nbsp; &nbsp;[A-Z]&nbsp;&nbsp; &nbsp;[0-9]&nbsp;&nbsp; &nbsp;[a-zA-Z0-9]&nbsp;&nbsp; &nbsp;[^a-z]<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;[[:alpha:]]&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[[:upper:]]&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[[:lower:]] &nbsp;&nbsp; &nbsp;[[:digit:]]</strong></p>

<h3><br><strong>&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">(2)匹配字符出现位置</span></strong></h3>

<p><strong>&nbsp;&nbsp; &nbsp;^str &nbsp; 以...开头<br>
&nbsp;&nbsp; &nbsp;str$ &nbsp; 以...结尾<br>
&nbsp;&nbsp; &nbsp;^$&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;空行</strong></p>

<h3><span style="color:#f33b45;"><strong>(3)匹配字符出现的次数</strong></span></h3>

<p><strong>&nbsp;&nbsp; &nbsp;*&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;\?<br>
&nbsp;&nbsp; &nbsp;\+<br>
&nbsp;&nbsp; &nbsp;\{3\}<br>
&nbsp;&nbsp; &nbsp;\{2,5\}<br>
&nbsp;&nbsp; &nbsp;\{2,\}</strong></p>

<h1><br><strong>&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">sed: Stream Editor 流编辑器</span></strong></h1>

<p><strong>&nbsp;&nbsp; &nbsp;行编辑器 &nbsp;逐行编辑<br>
&nbsp;&nbsp; &nbsp;<br><span style="color:#7c79e5;">将每行内容读入到内存中，在内存中进行处理，将结果返回给屏幕，此段内存空间称为摸索空间</span></strong></p>

<p><span style="color:#7c79e5;"><strong>默认不编写原文件，仅对模式空间的数据进行处理，处理结束后，将模式空间的内容显示到屏幕</strong></span></p>

<h3><span style="color:#f33b45;"><strong>sed命令的使用格式</strong></span></h3>

<p><strong># sed [option] scripts file1 file2...</strong></p>

<p><strong># sed [option] 'AddressCommand' file1 file ...</strong></p>

<p><strong>&nbsp;&nbsp; &nbsp;Address:表示对那些进行处理<br>
&nbsp;&nbsp; &nbsp;Command：操作命令<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;option选项：<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:#f33b45;">&nbsp;-n:不在显示模式空间的内容（默认显示）<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-i：直接修改原文件<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-e：‘AddressCommand’ -e ‘AddressCommand’：同时执行多个匹配操作<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; [root0shell ~]+ sed -e ‘/^#/d’ -e '/^5/d' /etc/fstab<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-f：FILE将多个AddressCommand保存至文件中，每行一个AddressCommand;读取该文件中的操作同时执行多个操作</span></strong></p>

<p><br><span style="color:#f33b45;"><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; -r:表示使用扩展正则表达式</strong></span></p>

<p><br><strong>Address表示方法:<br><span style="color:#ffbb66;">(1)StartLine, EndLine</span><br>
&nbsp;&nbsp; &nbsp;1, 100<br>
&nbsp;&nbsp; &nbsp;1,$</strong></p>

<p><strong><span style="color:#ffbb66;">(2)lineNumber</span><br>
&nbsp;&nbsp; &nbsp;3</strong></p>

<p><span style="color:#ffbb66;"><strong>(3)Startline, tn</strong></span></p>

<p><strong>&nbsp;&nbsp; &nbsp;5,+2 &nbsp; &nbsp; /root/,+2</strong></p>

<p><span style="color:#ffbb66;"><strong>(4)/正则表达式/</strong></span></p>

<p><strong>&nbsp;&nbsp; &nbsp;/root/<br>
&nbsp;&nbsp; &nbsp;/bash$/</strong></p>

<p><strong><span style="color:#ffbb66;">(5)/正则表达式1/, /正则表达式2/</span><br>
&nbsp;&nbsp; &nbsp;第1次被Regex1匹配的行升始，到第1次被Regex2匹配的行中同的所有行</strong></p>

<h1><span style="color:#f33b45;"><strong>d删除</strong></span></h1>

<p><strong>删除前4行</strong></p>

<pre class="has"><code>[root@wei init.d]# sed '1,4d' nginx.sh&nbsp;</code></pre>

<p><strong>删除最后一行</strong></p>

<pre class="has"><code>[root@wei init.d]# sed '$d' nginx.sh&nbsp;</code></pre>

<p><strong>删除#开头的行</strong></p>

<pre class="has"><code>[root@wei ~]# sed '/^#/d' /etc/fstab</code></pre>

<p><strong>删除/开头的行</strong></p>

<pre class="has"><code>[root@wei ~]# sed '/^\//d' /etc/fstab&nbsp;</code></pre>

<p><strong>删除带数字的行</strong></p>

<pre class="has"><code>[root@wei ~]# sed '/[0-9]/d' /etc/fstab&nbsp;</code></pre>

<h3><strong><span style="color:#f33b45;">p 显示符合条件的行</span></strong></h3>

<p><br><strong>&nbsp;<br>
&nbsp;显示以/开头的行</strong></p>

<pre class="has"><code>[root@wei ~]# sed -n '/^\//p' /etc/fstab&nbsp;</code></pre>

<h3><span style="color:#f33b45;"><strong>a &nbsp;\string &nbsp;在符合条件的行后追加新行，string为追加的内容</strong></span></h3>

<p><strong>&nbsp; &nbsp; 在以/开头的行后面追加# hello word<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;[root@wei ~]# sed '/^\//a\# hello word' /etc/fstab&nbsp;</code></pre>

<p><strong>&nbsp; &nbsp; 在以/开头的行后面分别追加# hello word &nbsp;# hello linux</strong></p>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;[root@wei ~]# sed '/^\//a\# hello word' /etc/fstab&nbsp;</code></pre>

<h3><strong><span style="color:#f33b45;">i &nbsp;&nbsp; &nbsp;\string &nbsp;在符合条件的行前追加新行，string为追加的内容</span></strong></h3>

<p><br><strong>&nbsp;&nbsp; &nbsp;在文件的第一行追加 # hello linux<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>&nbsp; &nbsp; [root@wei ~]# sed '1i \# hello linux' /etc/fstab&nbsp;</code></pre>

<h3><span style="color:#f33b45;"><strong>c &nbsp; \string 替换指定的内容</strong></span></h3>

<p><strong>&nbsp;&nbsp; &nbsp;将文件中最后一行的内容替换为 end of file<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;[root@wei ~]# sed '$c\end of file' /etc/fstab&nbsp;</code></pre>

<h3><strong>&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">= &nbsp; 用于显示每一行的行号</span></strong></h3>

<p><br><strong>&nbsp;&nbsp; &nbsp;显示/etc/passwd文件最后一行的行号</strong></p>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;[root@wei ~]# sed -n '$=' /etc/passwd

</code></pre>

<h3><br><strong><span style="color:#f33b45;">r &nbsp;file_name &nbsp; 将指定的文件的内容添加到符合条件的后面</span></strong></h3>

<p><strong>&nbsp;&nbsp; &nbsp;将文件的第二行后面追加/etc/fstab<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;[root@wei ~]# sed '2r /etc/issue' /etc/fstab&nbsp;</code></pre>

<h3><br><strong><span style="color:#f33b45;">w &nbsp;file_name &nbsp; 将符合条件的内容另存到指定的文件中</span></strong></h3>

<p><br><strong>&nbsp;&nbsp; &nbsp;将以#开头的行另存到/1.txt中<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;[root@wei ~]# sed '/^#/w /root/1.txt' /etc/fstab&nbsp;</code></pre>

<h1><br><strong><span style="color:#f33b45;">查找并替换</span></strong></h1>

<p><strong>默认情况下，只替换每一行第一次出现的字符</strong></p>

<p><strong>s &nbsp;/old/new/[修饰符]<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;old:正则表达式/<br>
&nbsp;&nbsp; &nbsp;new：替换的内容<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;修饰符<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;g：替换第一行所有的字符<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;i：忽略大小写</strong></p>

<h3><strong><span style="color:#f33b45;">查找文件的UUID，并替换成uuid</span></strong></h3>

<pre class="has"><code>[root@wei ~]# sed 's/UUID/uuid/' /etc/fstab&nbsp;</code></pre>

<h3><strong><span style="color:#f33b45;">将行首的/替换成#</span></strong></h3>

<pre class="has"><code>[root@wei ~]# sed 's/^\//#/' /etc/fstab&nbsp;</code></pre>

<pre class="has"><code>[root@wei ~]# sed 's|/|#|g' /etc/fstab&nbsp;</code></pre>

<h3><span style="color:#f33b45;"><strong>将每一行出现的所有/替换成@</strong></span></h3>

<pre class="has"><code>[root@wei ~]# sed 's/\//@/g' /etc/fstab</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell 函数应用示例02</title><link>http://www.cnblogs.com/heian99/archive/2019/04/02/11972302.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 02 Apr 2019 11:39:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/02/11972302.html</guid><description><![CDATA[
                                            <h1><span style="color:#f33b45;">nginx服务控制脚本：</span></h1>

<h2><span style="color:#f33b45;">安装ngix</span></h2>

<pre class="has"><code>[root@wei function]# yum install gcc pcre-devel openssl-devel

[root@wei function]# tar xf nginx-1.14.2.tar.gz&nbsp;
[root@wei function]# cd nginx-1.14.2
[root@wei nginx-1.14.2]# ./configure --prefix=/usr/local/nginx
[root@wei nginx-1.14.2]# make &amp;&amp; make instal

</code></pre>

<h1><br><span style="color:#f33b45;">编写控制nginx的脚本</span></h1>

<pre class="has"><code>#!/bin/bash
#

nginx_cmd=/usr/local/nginx/sbin/nginx
nginx_conf=/usr/local/nginx/conf/nginx.conf
nginx_pid_file=/usr/local/nginx/logs/nginx.pid
start(){
&nbsp;&nbsp; &nbsp;$nginx_cmd
&nbsp;&nbsp; &nbsp;if [ $? -eq 0 ];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "服务nginx启动.....[ok]"
&nbsp;&nbsp; &nbsp;fi
}

stop(){
&nbsp;&nbsp; &nbsp;$nginx_cmd -s stop
&nbsp;&nbsp; &nbsp;

}

reload(){
&nbsp;&nbsp; &nbsp;if $nginx_cmd -t &amp;&gt; /dev/null;then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$nginx_cmd -s reload
&nbsp;&nbsp; &nbsp;else
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$nginx_cmd -t
&nbsp;&nbsp; &nbsp;fi

}

status(){
&nbsp;&nbsp; &nbsp;if [ -e $nginx_pid_file &nbsp;];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "服务nginx(`cat $nginx_pid_file`) is running"
&nbsp;&nbsp; &nbsp;else
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "服务nginx is stopped"
&nbsp;&nbsp; &nbsp;fi
}


if [ -z $1 ];then
&nbsp;&nbsp; &nbsp;echo "使用：$0{start|stop|restart|reload|status}"
&nbsp;&nbsp; &nbsp;exit 9
fi

case $1 in
&nbsp;&nbsp; &nbsp;start)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;start
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;stop)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;stop
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;restart)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;stop
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sleep 2
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;start
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;reload)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;reload
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;*)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "使用：$0{start|stop|restart|reload|status}"
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;exit 9
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
esac</code></pre>

<h2><span style="color:#f33b45;">演示：</span></h2>

<pre class="has"><code>[root@wei init.d]# /etc/init.d/nginx status
服务nginx(4974) is running
[root@wei init.d]# /etc/init.d/nginx statscdsdc
使用：/etc/init.d/nginx{start|stop|restart|reload|status}
[root@wei init.d]# /etc/init.d/nginx stop
[root@wei init.d]# /etc/init.d/nginx status
服务nginx is stopped
[root@wei init.d]# /etc/init.d/nginx start
服务nginx启动.....[ok]
</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell 函数应用示例01</title><link>http://www.cnblogs.com/heian99/archive/2019/04/01/11972303.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 01 Apr 2019 15:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/01/11972303.html</guid><description><![CDATA[
                                            <p><strong>函数Function的使用</strong></p>

<p><strong>定义函数</strong></p>

<h3><strong>（1）</strong></h3>

<p><span style="color:#f33b45;"><strong>函数名称() {<br>
&nbsp;&nbsp; &nbsp;...<br>
&nbsp;&nbsp; &nbsp;...</strong></span></p>

<p><span style="color:#f33b45;"><strong>}</strong></span></p>

<h3><strong>(2)</strong></h3>

<p><span style="color:#f33b45;"><strong>function 函数名称{<br>
&nbsp;&nbsp; &nbsp;...<br>
&nbsp;&nbsp; &nbsp;...<br>
}</strong></span></p>

<h3><strong>调用函数<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; <span style="color:#f33b45;">&nbsp;函数名称</span></strong></h3>

<p><strong>也可以通过位置变量的方式给函数传递参数</strong></p>

<ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
	<li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）</li>
</ul><h3><span style="color:#f33b45;">编写脚本，编写函数，并调用</span></h3>

<pre class="has"><code>#!/bin/bash
#

sayhei() {
&nbsp;echo "$1"
}

sayhei wei
sayhei linux
sayhei windows</code></pre>

<h3><strong><span style="color:#f33b45;">执行效果</span></strong></h3>

<p><img alt="" class="has" height="148" src="https://img-blog.csdnimg.cn/20190401230150113.png" width="399"></p>

<h2><span style="color:#f33b45;">编写脚本，实现下面的功能</span><br><span style="color:#3399ea;">==============<br>
&nbsp; &nbsp;目录管理<br>
1：创建目录<br>
2：删除目录<br>
3：退出脚本<br>
==============</span></h2>

<pre class="has"><code>#!/bin/bash
#
create_dir(){
&nbsp;&nbsp; &nbsp;read -p "输入目录名称：" dir
&nbsp;&nbsp; &nbsp;if [ ! -e $dir ];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;mkdir -p $dir
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo “目录$dir创建完成”
&nbsp;&nbsp; &nbsp;else
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "目录$dir存在"
&nbsp;&nbsp; &nbsp;fi

}

remove_dir(){
&nbsp;&nbsp; &nbsp;read -p "输入目录名称" dir
&nbsp;&nbsp; &nbsp;if [ -e $dir &nbsp;];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;rm -r $dir
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "目录$dir删除成功"
&nbsp;&nbsp; &nbsp;fi

}
showmenu(){
cat &lt;&lt; eof
==============
&nbsp; &nbsp;目录管理
1.创建目录
2.删除目录
3.退出脚本
==============
eof
}
while true;do
read -p "请输入你的选择:显示菜单[m] " choice
&nbsp;&nbsp; &nbsp;case $choice in
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;create_dir
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;remove_dir
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;3)&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;exit 0
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;m)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;showmenu
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "输入错误,请重新选择"
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;esac

done</code></pre>

<h2><span style="color:#f33b45;">执行效果</span></h2>

<p><img alt="" class="has" height="350" src="https://img-blog.csdnimg.cn/20190401230323209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="333"></p>
                                    ]]></description></item><item><title>Linux shell while循环语句</title><link>http://www.cnblogs.com/heian99/archive/2019/04/01/11972304.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 01 Apr 2019 11:33:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/04/01/11972304.html</guid><description><![CDATA[
                                            <h3><strong>for ：明确循环次数<br>
while ：不确定循环换次数</strong></h3>

<h3><strong>while循环</strong></h3>

<h3>（1）</h3>

<p><span style="color:#f33b45;"><strong>while CONDITION；do<br>
&nbsp; &nbsp; &nbsp; statement<br>
&nbsp;&nbsp; &nbsp; &nbsp;statement<br>
&nbsp;&nbsp; &nbsp; &nbsp;&lt;改变循环条件真假的语句&gt;<br>
done</strong></span></p>

<h3><span style="color:#f33b45;">编写脚本，计算1--100的和</span></h3>

<pre class="has"><code>#!/bin/bash
#
sum=0
i=1

while [ $i -le 100 &nbsp;];do
&nbsp;&nbsp; &nbsp;let sum=$sum+$i
&nbsp;&nbsp; &nbsp;let i=$i+1
done

echo $sum</code></pre>

<h3><br><span style="color:#f33b45;">编写while循环，输入q退出（不输入q，不退出）</span></h3>

<pre class="has"><code>#!/bin/bash
#
read -p "请输入你的选择：" choice

while [ $choice != q &nbsp;];do
&nbsp;&nbsp; &nbsp;echo -e "\033[31m输入错误\033[0m" #加的颜色代码
&nbsp;&nbsp; &nbsp;read -p "请输入你的选择：" choice
done</code></pre>

<h3><img alt="" class="has" height="337" src="https://img-blog.csdnimg.cn/20190401192859102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="535"><br><strong>（2）</strong></h3>

<p><span style="color:#f33b45;">while true；do<br>
&nbsp; &nbsp; &nbsp; statement<br>
&nbsp;&nbsp; &nbsp; &nbsp;statement<br>
&nbsp;&nbsp; &nbsp; &nbsp;&lt;break退出&gt;<br>
done</span></p>

<h3>&nbsp;</h3>

<h3><span style="color:#f33b45;">编写while循环，输入q退出（不输入q，不退出）</span></h3>

<pre class="has"><code>#/bin/bash
#
while true;do
&nbsp;&nbsp; &nbsp;read -p "请输入你的选择" str
&nbsp;&nbsp; &nbsp;echo "输入错误"
&nbsp;&nbsp; &nbsp;if [ $str == q ];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break
&nbsp;&nbsp; &nbsp;fi
done</code></pre>

<h3><span style="color:#f33b45;">编写脚本，每4秒查看系统的内存</span></h3>

<pre class="has"><code>#!/bin/bash
#
while true;do
&nbsp;&nbsp; &nbsp;uptime
&nbsp;&nbsp; &nbsp;sleep 3
done</code></pre>

<p><img alt="" class="has" height="225" src="https://img-blog.csdnimg.cn/20190401193025486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="664"><br><strong><span style="color:#f33b45;">（3）</span></strong></p>

<p><span style="color:#f33b45;">while read line;do<br>
&nbsp;&nbsp; &nbsp;statement<br>
&nbsp;&nbsp; &nbsp;statement<br>
done &lt; file</span></p>

<h3><br><span style="color:#f33b45;">编写脚本，向系统每个用户打招呼</span></h3>

<pre class="has"><code>v#!/bin/bash
#
while read line;do
&nbsp;&nbsp; &nbsp;sh_name=$(echo $line | awk -F: '{print $1}')
&nbsp;&nbsp; &nbsp;echo "Hello $sh_name"

done &lt; /etc/passwd</code></pre>

<h3><img alt="" class="has" height="508" src="https://img-blog.csdnimg.cn/20190401193117987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="889"><br><span style="color:#f33b45;">编写脚本，统计/bin/bash /sbin/nologin的个数</span></h3>

<pre class="has"><code>[root@wei while]# cat 6.sh&nbsp;
#!/bin/bash
#
bash_number=0
nologin_number=0

while read line;do
&nbsp;&nbsp; &nbsp;sh_name=$(echo $line | awk -F: '{print $7}')
&nbsp;&nbsp; &nbsp;case $sh_name in
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/bin/bash)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;let bash_number=$bash_number+1
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/sbin/nologin)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;let nologin_number=$nologin_number+1
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;esac

done &lt; /etc/passwd

echo "bash用户数量：$bash_number"
echo "nologin_number用户数量：$nologin_number"</code></pre>

<h3><span style="color:#f33b45;">执行效果</span></h3>

<pre class="has"><code>[root@wei while]# ./6.sh&nbsp;
bash用户数量：17
nologin_number用户数量：17</code></pre>

<p><img alt="" class="has" height="183" src="https://img-blog.csdnimg.cn/20190401193158805.png" width="461"></p>

<h3><br><span style="color:#f33b45;">util循环：</span></h3>

<h3><span style="color:#f33b45;">util CONDITION；do<br>
&nbsp;&nbsp; &nbsp;statement<br>
&nbsp;&nbsp; &nbsp;statement<br>
done</span></h3>

<h3><strong>条件为假时，执行循环，条件为真时，结束循环</strong></h3>

<h1><br><span style="color:#3399ea;">重点掌握</span></h1>

<h1><span style="color:#3399ea;">if，case</span></h1>

<h1><span style="color:#3399ea;">for，while</span></h1>
                                    ]]></description></item><item><title>Linux shell 中断循环语句</title><link>http://www.cnblogs.com/heian99/archive/2019/03/23/11972305.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 23 Mar 2019 14:26:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/23/11972305.html</guid><description><![CDATA[
                                            <h2>无限循环：</h2>

<p>循环有限的生命，他们跳出来，一旦条件是 false 还是 false 取决于循环。</p>

<p>由于所需的条件是不符合一个循环可能永远持续下去。永远不会终止执行一个循环执行无限次数。出于这个原因，这样的循环被称为无限循环。</p>

<h2>break语句：</h2>

<p>break语句用于终止整个循环的执行，完成后所有行代码break语句的执行。然后，它逐级的代码跟在循环结束。</p>

<h2>continue 语句:</h2>

<p>continue语句break命令类似，但它会导致当前迭代的循环退出，而不是整个循环。</p>

<p>这种参数是有用的，当一个错误已经发生，但你想尝试执行下一个循环迭代。</p>

<h3><span style="color:#f33b45;">中断循环的语句<br>
&nbsp; &nbsp; &nbsp;break &nbsp; &nbsp; 中断整体循环<br>
&nbsp;&nbsp; &nbsp; contiune &nbsp;中断本次循环</span><br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
break用法：</h3>

<h3><span style="color:#f33b45;">编写脚本，判断大于3000的累加和的数</span></h3>

<pre class="has"><code>#!/bin/bash
#

sum=0
for i in `seq 100`;do
&nbsp;&nbsp; &nbsp;let sum=$sum+$i
&nbsp;&nbsp; &nbsp;if [ $sum -ge 3000 ];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo $i
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break
&nbsp;&nbsp; &nbsp;fi
done</code></pre>

<h2><span style="color:#f33b45;">contiune用法：</span></h2>

<h3><br><span style="color:#f33b45;">编写脚本，求100的奇数的累加和</span></h3>

<pre class="has"><code>#!/bin/bash&nbsp;
#

sum=0
for i in `seq 100`;do
&nbsp;&nbsp; &nbsp;let ys=$i%2
&nbsp;&nbsp; &nbsp;if [ $ys -eq 0 ];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue
&nbsp;&nbsp; &nbsp;fi
&nbsp;&nbsp; &nbsp;let sum=$sum+$i
done
echo $sum</code></pre>

<h2><br><span style="color:#f33b45;">编写脚本，输出在/bin/bash的前5个用户</span></h2>

<pre class="has"><code>#!/bin/bash
#
number=0
line=$(wc -l /etc/passwd |awk '{print $1}')
for i in `seq $line`;do
&nbsp;&nbsp; &nbsp;sh_name=$(head -n $i /etc/passwd | tail -n 1 | awk -F: '{print $7}')
&nbsp;&nbsp; &nbsp;if [ $sh_name = "/bin/bash" ]; then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;user_name=$(head -n $i /etc/passwd | tail -n 1 | awk -F: '{print $1}' )
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo $user_name
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;let number=$number+1
&nbsp;&nbsp; &nbsp;fi

&nbsp;&nbsp; &nbsp;if [ $number -ge 5 ];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break
&nbsp;&nbsp; &nbsp;fi

done</code></pre>

<h3><span style="color:#f33b45;">执行效果</span></h3>

<pre class="has"><code>[root@wei break]# bash 2.sh 
root
mysql
hei
wei
a
[root@wei break]# ls /home/
a  c  d  hei  user1  user10  user2  user3  user4  user5  user6  user7  user8  user9  wei
</code></pre>

<p></p>
                                    ]]></description></item><item><title>Linux shell for循环结构</title><link>http://www.cnblogs.com/heian99/archive/2019/03/21/11972306.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 21 Mar 2019 14:34:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/21/11972306.html</guid><description><![CDATA[
                                            <h1><strong><span style="color:#f33b45;">Linux Shell&nbsp; &nbsp;for循环结构</span></strong></h1>

<h2><strong><span style="color:#ffbb66;">循环结构</span><br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; 1：循环开始条件<br>
&nbsp;&nbsp; &nbsp; 2：循环操作<br>
&nbsp;&nbsp; &nbsp; 3：循环终止的条件</strong></h2>

<p>&nbsp;</p>

<h3><strong><span style="color:#f33b45;">shell语言<br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp;</span><span style="color:#ffbb66;"> &nbsp;for，while，util</span></strong></h3>

<h3><strong><span style="color:#f33b45;">&nbsp;&nbsp;<br>
for循环</span></strong></h3>

<h3><strong>语法：</strong></h3>

<p><strong>（1）</strong></p>

<p><strong>for 变量 in 取值列表；do<br>
&nbsp;&nbsp; &nbsp;statement<br>
&nbsp;&nbsp; &nbsp;statement<br>
done</strong></p>

<p><strong>（2）</strong></p>

<p><strong>for 变量 in 取值列表<br>
do<br>
&nbsp;&nbsp; &nbsp;statement<br>
&nbsp;&nbsp; &nbsp;statement<br>
done</strong></p>

<p><span style="color:#ffbb66;"><strong>上面两个用法的效果是一样的。</strong></span></p>

<p>&nbsp;</p>

<h2>&nbsp;</h2>

<p><br><strong>取值列表：<br>
&nbsp;&nbsp; &nbsp;数字<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 20 30<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;使用seq命令生成数字的序列<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;seq 10<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;seq 3 10<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;seq 1 2 10<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;字符<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;aa bb &nbsp;cc<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;文件<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</strong></p>

<p><span style="color:#f33b45;"><strong>示例</strong></span></p>

<p><span style="color:#ffbb66;">seq可以快速去值，奇数等</span></p>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei for]# seq 5
1
2
3
4
5
[root@wei for]# seq 2 6
2
3
4
5
6</code></pre>

<h3><br><span style="color:#f33b45;"><strong>示例：1--100的累加和</strong></span></h3>

<p>&nbsp;</p>

<pre class="has"><code>#!/bin/bash
#
sum=0
for i in `seq 1 100`
do
&nbsp;&nbsp; &nbsp;let sum=$sum+$i
done
echo $sum&nbsp;

[root@wei for]# bash 1.sh&nbsp;
5050</code></pre>

<h3><br><strong><span style="color:#f33b45;">示例：1--100的奇数累加和</span></strong></h3>

<pre class="has"><code>#!/bin/bash

sum=0

for i in `seq 100`
do
&nbsp;&nbsp; &nbsp;let ys=$i%2
&nbsp;&nbsp; &nbsp;if [ $ys -ne 0 ];then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;let sum=$sum+$i
&nbsp;&nbsp; &nbsp;fi

done

echo $sum

[root@wei for]# bash 2.sh&nbsp;
2500</code></pre>

<h3><br><strong><span style="color:#f33b45;">创建10个用户，初始密码为：root，登陆重新修改密码</span></strong></h3>

<pre class="has"><code>#!/bin/bash
#

for i in `seq 10`
do
&nbsp;&nbsp; &nbsp;if ! id user$i &amp;&gt; /dev/null ; then
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;useradd user$i
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "root" | passwd --stdin user$i &amp;&gt; /dev/null
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;passwd -e user$i &amp;&gt; /dev/null
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "用户user$i创建完成，初始密码为：root"
&nbsp;&nbsp; &nbsp;else
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "用户user$i已经存在"
&nbsp;&nbsp; &nbsp;fi
done</code></pre>

<h3><span style="color:#f33b45;"><strong>以字符作为取值类表</strong></span></h3>

<pre class="has"><code>#!/bin/bash
#

for name in a d c d ;do
&nbsp;&nbsp; &nbsp;useradd $name
&nbsp;&nbsp; &nbsp;echo "$name create finishe"
done</code></pre>

<p><br><strong><span style="color:#f33b45;">以文件作为取值列表</span></strong></p>

<h3><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;`<span style="color:#ffbb66;">cat file`</span><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">编写脚本，读取文本</span></strong></h3>

<pre class="has"><code>#!/bin/bash&nbsp;
#
for i in `cat /shell/for/1.txt`;do
&nbsp;&nbsp; &nbsp;echo "line:$i"
done
[root@wei for]# ./wen.sh&nbsp;
line:nangong
line:chengfneg</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell case条件判断及位置变量</title><link>http://www.cnblogs.com/heian99/archive/2019/03/20/11972307.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 20 Mar 2019 13:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/20/11972307.html</guid><description><![CDATA[
                                            <h3><span style="color:#f33b45;">case语句使用于需要进行多重分支的应用情况</span></h3>

<h3><br>
case分支判断结构</h3>

<p><strong>语法：</strong></p>

<p><strong>case 变量名称 in<br>
&nbsp; &nbsp; &nbsp;value1)<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; statement<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; statement<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; ;;<br>
&nbsp;&nbsp; &nbsp; value2)<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; statement<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; statement<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; ;;<br>
&nbsp;&nbsp; &nbsp; *)<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; statement<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; statement<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; ;;&nbsp;&nbsp; &nbsp;&nbsp;<br>
esac</strong><br>
&nbsp;&nbsp; &nbsp;&nbsp;</p>

<p><span style="color:#f33b45;"><strong>case语句结构特点如下：<br>
case行尾必须为单词 in 每个模式必须以右括号 ） 结束<br>
双分号 ;; 表示命令序列结束<br>
case语句结构特点如下：<br>
匹配模式中可是使用方括号表示一个连续的范围，如[0-9]；使用竖杠符号“|”表示或。<br>
最后的“*）”表示默认模式，当使用前面的各种模式均无法匹配该变量时，将执行“*）”后的命令序列。</strong></span></p>

<p>&nbsp;</p>

<h2><span style="color:#f33b45;">编写脚本，判断用户输入的字符串</span></h2>

<pre class="has"><code>#!/bin/bash
#

read -p "输入字符串：" str

case $str in
&nbsp; &nbsp; &nbsp;linux|Linux)
&nbsp; &nbsp; &nbsp; &nbsp; echo "windows"
&nbsp; &nbsp; &nbsp; &nbsp; ;;
&nbsp; &nbsp; &nbsp;windows|Windows)
&nbsp; &nbsp; &nbsp; &nbsp; echo "linux"
&nbsp; &nbsp; &nbsp; &nbsp; ;;
&nbsp; &nbsp; &nbsp;*)
&nbsp; &nbsp; &nbsp; &nbsp; echo "other"
&nbsp; &nbsp; &nbsp; &nbsp; ;;
esac</code></pre>

<h3><span style="color:#f33b45;">运行效果：</span></h3>

<pre class="has"><code>[root@wei case]# bash 1.sh&nbsp;
输入字符串：linux
windows</code></pre>

<h2><br><span style="color:#f33b45;">特殊变量：</span><br>
&nbsp; &nbsp;<br><span style="color:#ffbb66;">&nbsp; &nbsp;位置变量</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;$1,$2,$3...........$9,$1{10}<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;$1:命令的第1个参数<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$0 &nbsp;命令本身<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$# &nbsp;命令参数的个数<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">使用位置变量</span></h2>

<pre class="has"><code>#!/bin/bash
#


case $1 in
&nbsp; &nbsp; &nbsp; &nbsp; linux|Linux)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo "windows"
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;
&nbsp; &nbsp; &nbsp; &nbsp; windows|Windows)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo "linux"
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;
&nbsp; &nbsp; &nbsp; &nbsp; *)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo "other"
esac</code></pre>

<h3><br><span style="color:#f33b45;">执行效果</span></h3>

<pre class="has"><code>[root@wei case]# ./2.sh linux
windows</code></pre>

<h2><span style="color:#f33b45;">判断字符是为空</span></h2>

<pre class="has"><code>#!/bin/bash
#

if [ -z $1 ];then #判断字符串是否为空
&nbsp;&nbsp; &nbsp;echo "使用：./2.sh{linux/windows}"
&nbsp;&nbsp; &nbsp;exit 9
fi

case $1 in
&nbsp;&nbsp; &nbsp;linux|Linux)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "windows"
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;windows|Windows)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "linux"
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;*)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "other"
esac</code></pre>

<h3><span style="color:#f33b45;">执行效果</span></h3>

<pre class="has"><code>[root@wei case]# ./2.sh&nbsp;
使用：./2.sh{linux/windows}</code></pre>

<h3><strong><span style="color:#f33b45;">$0 &nbsp;命令本身&nbsp;&nbsp; &nbsp;<br>
$# &nbsp;命令参数的个数</span></strong></h3>

<h3><strong><span style="color:#f33b45;">示例：</span></strong></h3>

<pre class="has"><code>#!/bin/bash
#

if [ $# -ne 1 ];then
&nbsp;&nbsp; &nbsp;echo "使用：$0{linux/windows}"
&nbsp;&nbsp; &nbsp;exit 9
fi

case $1 in
&nbsp;&nbsp; &nbsp;linux|Linux)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "windows"
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;windows|Windows)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "linux"
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;*)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "other"
esac

</code></pre>

<h3><br><span style="color:#f33b45;">执行效果：</span></h3>

<pre class="has"><code>[root@wei case]# /shell/case/2.sh&nbsp;
使用：/shell/case/2.sh{linux/windows}
[root@wei case]# ./2.sh&nbsp;
使用：./2.sh{linux/windows}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code></pre>

<h3><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">去除文件所在的路径名：</span></h3>

<p><strong><span style="color:#7c79e5;">basename [路径文件]</span></strong></p>

<pre class="has"><code>[root@wei case]# basename /etc/fstab&nbsp;
fstab</code></pre>

<p>获取文件所在的路径名：</p>

<p><span style="color:#7c79e5;"><strong>dirname [路径文件]</strong></span><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>

<pre class="has"><code>[root@wei case]# dirname /etc/fstab&nbsp;
/etc</code></pre>

<h3><span style="color:#f33b45;">脚本</span></h3>

<pre class="has"><code>#!/bin/bash
#

if [ $# -ne 1 ];then
&nbsp;&nbsp; &nbsp;echo "使用：$(basename $0){linux/windows}"
&nbsp;&nbsp; &nbsp;exit 9
fi

case $1 in
&nbsp;&nbsp; &nbsp;linux|Linux)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "windows"
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;windows|Windows)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "linux"
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;;;
&nbsp;&nbsp; &nbsp;*)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo "other"
esac
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code></pre>

<h3><br><span style="color:#f33b45;">&nbsp; 执行效果&nbsp; &nbsp; </span>&nbsp;&nbsp;</h3>

<pre class="has"><code>
[root@wei case]# /shell/case/2.sh&nbsp;
使用：2.sh{linux/windows}</code></pre>

<p><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>
                                    ]]></description></item><item><title>Linux shell if条件判断2</title><link>http://www.cnblogs.com/heian99/archive/2019/03/19/11972308.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 19 Mar 2019 14:12:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/19/11972308.html</guid><description><![CDATA[
                                            <p><strong>前面介绍linux shell的if判断的语法，现在再补充一点。</strong></p>

<p><strong><a href="https://blog.csdn.net/heian_99/article/details/88625227" rel="nofollow">Linux shell if条件判断1</a></strong></p>

<p><strong>分支判断结构<br>
&nbsp; &nbsp; if , case<br>
&nbsp;</strong></p>

<p><strong>下面两个结构语法，已经在前面有过示例。</strong></p>

<p><br><strong>结构1：<br>
if CONDITON； then<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;<br>
fi</strong></p>

<p><strong>结构2：</strong></p>

<p><strong>if CONDITON； then<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement</strong></p>

<p><strong>else<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement<br>
fi</strong></p>

<p>&nbsp;</p>

<p><strong>下面会分享几个我编写的示例，希望对大家有所帮助。</strong></p>

<h3><br><span style="color:#f33b45;"><strong>编写脚本，有用户输入用户名，判断用户是否存在，如果不存在，就显示用户不存在，如果存在，以下面格式输出用户相关信息：</strong></span></h3>

<p><strong>用户名：<br>
宿主目录：<br>
shell程序：</strong></p>

<pre class="has"><code>[root@wei shell]# cat if2.sh&nbsp;
#!/bin/bash
#
read -p "请输入用户名：" name

if id $name &amp;&gt; /dev/null; then
&nbsp; &nbsp;echo "用户名：" $name
&nbsp; &nbsp;homedir=`grep "^$name:" /etc/passwd | awk -F: '{print $6}' `
&nbsp; &nbsp;shname=`grep "^$name:" /etc/passwd | awk -F: '{print $7}' `
&nbsp; &nbsp;echo "宿主目录：$homedir"
&nbsp; &nbsp;echo "SHELL名称：$shname "
else
&nbsp; &nbsp;echo "用户$name不存在"
fi</code></pre>

<h3><br><span style="color:#f33b45;"><strong>编写脚本，判断文件是否存在空行，有则显示空行个数，没有则显示文件类容，并在每一行显示行号</strong></span></h3>

<pre class="has"><code>#!/bin/bash
#
read -p "请输入文件的名称：" file

if grep "^$" $file &amp;&gt; /dev/null; then
&nbsp; &nbsp;number=`grep "^$" $file | wc -l`
&nbsp; &nbsp;echo "文件$file中的空行的数量：$number"
else
&nbsp; &nbsp;echo "文件$file内容如下："
&nbsp; &nbsp;cat -n $file
fi</code></pre>

<h2><br><span style="color:#3399ea;"><strong>用法3 ：多分支if结构</strong></span></h2>

<p><br><strong>if CONDITON； then<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement</strong></p>

<p><strong>elif CONDITON； then<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement<br>
elif CONDITON； then<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement<br>
else<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement</strong></p>

<p><strong>fi</strong></p>

<p><br><strong>多个条件的写法：<br>
&nbsp; &nbsp;AND &nbsp; &nbsp; &nbsp; &nbsp;[conditionl -a condition2] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[conditionl ] &amp;&amp; [ condition2]<br>
&nbsp; &nbsp;OR &nbsp; &nbsp; &nbsp; &nbsp; [conditionl -o condition2] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[conditionl ] || [ condition2]</strong></p>

<h3><span style="color:#f33b45;"><strong>编写脚本，判断当前系统时间的小时数字</strong></span></h3>

<p><strong>&nbsp; &nbsp;9--11 &nbsp; &nbsp; &nbsp; morning<br>
&nbsp; &nbsp;12--14 &nbsp; &nbsp; &nbsp;noon<br>
&nbsp; &nbsp;15--18 &nbsp; &nbsp; &nbsp;afternoon<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;night<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>#!/bin/bash
#
hour=`date +%H`
if [ $hour -ge 9 -a $hour -le 11 ]; then
&nbsp; &nbsp;echo "Morning"&nbsp;
elif [ $hour -ge 12 -a $hour -le 14 ]; then
&nbsp; &nbsp;echo " Noon"
elif [ $hour -ge 15 -a $hour -le 18 ]; then
&nbsp; &nbsp;echo " Afternoon"
else
&nbsp; &nbsp;echo "Night"
fi</code></pre>

<p><strong>执行效果：</strong></p>

<pre class="has"><code>[root@wei shell]# date
2019年 03月 19日 星期二 18:44:50 CST
[root@wei shell]# bash shi.sh&nbsp;
&nbsp;Afternoon</code></pre>

<p><strong>数学表达式</strong></p>

<p><strong>字符表达式<br>
&nbsp;[ str1 == str2 ]<br>
&nbsp;[ str1 != str2 ]<br>
&nbsp;[ -z &nbsp;str1 &nbsp;] &nbsp; 判断字符串是否为空</strong></p>

<h3><span style="color:#f33b45;"><strong>判断两次密码是否相同&nbsp;</strong></span></h3>

<pre class="has"><code>#!/bin/bash
#
read -p "请输入密码：" pwd1
read -p "请在一次输入密码：" pwd2
if [ "$pwd1" == "$pwd2" ];then
&nbsp; &nbsp;echo "密码输入正确"
else
&nbsp; &nbsp;echo "密码两次输入不一致"
fi</code></pre>

<p><strong>文件目录表达式：<br>
&nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp;[ -e file ] &nbsp;判断文件目录是否存在<br>
&nbsp;&nbsp; &nbsp; [ -f file ] &nbsp;判断是否为文件<br>
&nbsp;&nbsp; &nbsp; [ -e file ] &nbsp;判断是否为目录<br>
&nbsp;&nbsp; &nbsp; [ -r file ] &nbsp;判断文件是否有r权限<br>
&nbsp;&nbsp; &nbsp; [ -w file ] &nbsp;判断文件是否有w权限<br>
&nbsp;&nbsp; &nbsp; [ -x file ] &nbsp;判断文件是否有x权限<br>
&nbsp;&nbsp; &nbsp;&nbsp;</strong></p>

<p><strong>双目表达式<br>
单目表达式 &nbsp;[ -e file ] &nbsp;[ ! -e file ]</strong></p>

<h2><span style="color:#f33b45;"><strong>用法4： if的内嵌语法</strong></span></h2>

<p><br><strong>if CONDITON； then<br>
&nbsp; &nbsp;if CONDITON； then<br>
&nbsp; &nbsp; &nbsp; statement<br>
&nbsp; &nbsp; &nbsp; statement<br>
&nbsp; &nbsp; fi<br>
else<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement<br>
fi</strong></p>

<h3><span style="color:#f33b45;"><strong>判断用户是否存在，如果用户存在，判断他的root的id和group的id是否相同</strong></span></h3>

<pre class="has"><code>#!/bin/bsah
#
read -p "输入用户名： " name

if id $name &amp;&gt; /dev/null; then
&nbsp; &nbsp;#获取uid，gid进行判断
&nbsp; &nbsp;user_id=$(id -u $name)
&nbsp; &nbsp;group_id=$(id -g $name)
&nbsp; &nbsp;if [ $user_id -eq $group_id ];then
&nbsp; &nbsp; &nbsp; echo " Good user"
&nbsp; &nbsp;else
&nbsp; &nbsp; &nbsp; echo "Bad user"
&nbsp; &nbsp;fi
else
&nbsp; &nbsp;echo "用户不存在"
fi</code></pre>

<h3><span style="color:#f33b45;"><strong>判断文件是否存在，如果存在输入到备份的文件去</strong></span></h3>

<pre class="has"><code>#!/bin/bash
#
read -p "输入文件的路径：" file
if [ -e $file ]; then
&nbsp; &nbsp;read -p "输入备份的路径：" dir
&nbsp; &nbsp;if [ -e $dir ]; then
&nbsp; &nbsp; &nbsp; cp $file $dir
&nbsp; &nbsp; &nbsp; echo "文件$file备份到$dir目录"
&nbsp; &nbsp;else
&nbsp; &nbsp; &nbsp; &nbsp;mkdir -p $dir
&nbsp; &nbsp; &nbsp; &nbsp;cp $file $dir
&nbsp; &nbsp; &nbsp; &nbsp;echo "文件$file备份到$dir目录"
&nbsp; &nbsp;fi
else
&nbsp; &nbsp;echo “文件$file不存在”
fi</code></pre>
                                    ]]></description></item><item><title>Linux shell if条件判断1</title><link>http://www.cnblogs.com/heian99/archive/2019/03/17/11972309.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 17 Mar 2019 12:00:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/17/11972309.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<h3><strong><span style="color:#f33b45;">shell 逻辑控制语句：</span><br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; <span style="color:#ffbb66;">分支判断结构</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; if<br>
&nbsp;&nbsp; &nbsp; &nbsp; case<br><span style="color:#f33b45;">&nbsp;&nbsp; &nbsp; 循环结构</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;for<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;until<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</strong></h3>

<h1><br><strong><span style="color:#f33b45;">if语句结构</span></strong></h1>

<h3><strong><span style="color:#3399ea;">用法1</span></strong></h3>

<p><strong>if CONDITON； then<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;<br>
fi</strong></p>

<p><br><strong>CONDITION条件的写法：</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;COMMAND<br>
&nbsp;&nbsp; &nbsp; &nbsp;[ expression ]<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
expression表达式：<br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; 数学表达式<br>
&nbsp;&nbsp; &nbsp; 字符表达式<br>
&nbsp;&nbsp; &nbsp; 文件目录表达式<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
数学表达式：<br>
&nbsp; &nbsp; [ number1 -eq number2 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 等于<br>
&nbsp;&nbsp; &nbsp;[ number1 -ne number2 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不等于<br>
&nbsp;&nbsp; &nbsp;[ number1 -gt number2 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 大于<br>
&nbsp;&nbsp; &nbsp;[ number1 -ge number2 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 大于等于<br>
&nbsp;&nbsp; &nbsp;[ number1 -lt number2 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 小于<br>
&nbsp;&nbsp; &nbsp;[ number1 -le number2 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 小于等于<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<h3><span style="color:#f33b45;"><strong>编写脚本，有用户输入用户名，判断用户不存在则创建</strong></span></h3>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei shell]# vim if.sh</code></pre>

<pre class="has"><code>#!/bin/bash
#
read -p "请输入用户名： " name

id $name &amp;&gt; /dev/null
if [ $? -ne 0 ];then
read -p "输入密码：" passwd
useradd $name
echo "$passwd" | passwd --stdin $name &amp;&gt; /dev/null
echo "用户$name创建完成，初始密码为：$passwd"
fi</code></pre>

<h3><br><strong><span style="color:#f33b45;">检测语法执行状况</span></strong></h3>

<pre class="has"><code>[root@wei shell]# bash -x if.sh&nbsp;
+ read -p '请输入用户名： ' name
请输入用户名： wei
+ id wei
+ '[' 1 -ne 0 ']'
+ read -p 输入密码： passwd
输入密码：123456
+ useradd wei
+ echo 123456
+ passwd --stdin wei
+ echo 用户wei创建完成，初始密码为：123456
用户wei创建完成，初始密码为：123456</code></pre>

<h2><span style="color:#f33b45;"><strong>检测语法错误</strong></span></h2>

<pre class="has"><code>[root@wei shell]# bash -n if.sh&nbsp;</code></pre>

<h2><span style="color:#f33b45;"><strong>条件语言脚本</strong></span></h2>

<h1><span style="color:#f33b45;"><strong>用法2： 单分支if</strong></span></h1>

<p><strong>if CONDITON； then<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement</strong></p>

<p><strong>else<br>
&nbsp; &nbsp;statement<br>
&nbsp; &nbsp;statement<br>
fi</strong></p>

<p><br><strong><span style="color:#f33b45;">编写脚本，由用户输入用户名，判断用户不存在则创建，并设置用户第一次登陆系统时需要修改密码。否则提示用户已存在</span></strong></p>

<pre class="has"><code>#!/bin/bash
#
read -p "请输入用户名： " name

if id $name &amp;&gt; /dev/null ;then
&nbsp; &nbsp;echo " 用户$name已经存在"
else
&nbsp; &nbsp;useradd $name
&nbsp; &nbsp;read -p "输入密码：" passwd
&nbsp; &nbsp;echo "$passwd" | passwd --stdin $name &amp;&gt; /dev/null
&nbsp; &nbsp;passwd -e $name &amp;&gt; /dev/null &nbsp;&nbsp;
&nbsp; &nbsp;echo "用户$name创建完成，初始密码为：$passwd"
fi</code></pre>

<h2><span style="color:#f33b45;"><strong>由用户输入一个用户名，判断用户的UID和GID</strong></span></h2>

<h3><strong><span style="color:#3399ea;">判断的方式</span></strong></h3>

<p><strong>[root@wei shell]# grep "hei" /etc/passwd<br>
hei:x:1000:1000::/home/hei:/bin/bash<br>
[root@wei shell]# grep "hei" /etc/passwd | awk -F: '{print $3,$4}'<br>
1000 1000<br>
[root@wei shell]# id -u hei<br>
1000<br>
[root@wei shell]# id -g hei<br>
1000</strong></p>

<h3><span style="color:#f33b45;"><strong>脚本语法</strong></span></h3>

<pre class="has"><code>#!/bin/bash
#
read -p "输入用户名：" name
user_id=$(id -u $name)
group_id=$(id -g $name)

if [ $user_id -eq $group_id &nbsp;];then
&nbsp; &nbsp;echo "Good"
else
&nbsp; &nbsp;echo "Bad"
fi</code></pre>

<h3><br><strong><span style="color:#f33b45;">执行结果</span></strong></h3>

<pre class="has"><code>[root@wei shell]# bash id.sh&nbsp;
输入用户名：hei
Good
[root@wei shell]# id hei
uid=1000(hei) gid=1000(hei) 组=1000(hei)
[root@wei shell]# usermod -u 1200 hei
[root@wei shell]# id hei
uid=1200(hei) gid=1000(hei) 组=1000(hei)
[root@wei shell]# bash id.sh&nbsp;
输入用户名：hei
Bad
</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell简单创建用户脚本</title><link>http://www.cnblogs.com/heian99/archive/2019/03/14/11972310.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 14 Mar 2019 14:07:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/14/11972310.html</guid><description><![CDATA[
                                            <h3>前面介绍简单的shell编写规则。</h3>

<h3>现在开始编写一个简单的shell脚本。</h3>

<h3><a href="https://blog.csdn.net/heian_99/article/details/88560250" rel="nofollow"><strong>Linux shell介绍</strong></a></h3>

<p>&nbsp;</p>

<h2>编写shell脚本<br>
&nbsp; &nbsp;<span style="color:#3399ea;">1.创建脚本文件<br>
&nbsp; &nbsp;2.根据需求，编写脚本<br>
&nbsp; &nbsp;3.测试执行脚本</span><br>
&nbsp; &nbsp;<br><span style="color:#f33b45;">编写脚本，实现创建用户hei，病设置用户密码为root</span></h2>

<pre class="has"><code>[root@wei shell]# vim user.sh</code></pre>

<pre class="has"><code>#!/bin/bash
# 注释
useradd hei
echo "root" | passwd --stdin hei &amp;&gt; /dev/null
echo "hei用户创建完成，默认密码是：root"</code></pre>

<h3><br><span style="color:#f33b45;">执行方法：</span></h3>

<p>（1）利用bash执行</p>

<pre class="has"><code>[root@wei shell]# bash user.sh&nbsp;</code></pre>

<p>（2）加权限，在执行</p>

<pre class="has"><code>[root@wei shell]# chmod a+x user.sh
[root@wei shell]# ./user.sh&nbsp;</code></pre>

<h2><span style="color:#f33b45;">变量名编写</span></h2>

<pre class="has"><code>[root@wei shell]# vim users.sh&nbsp;</code></pre>

<pre class="has"><code>#!/bin/bash

name=wei
passwd=root

useradd $name
echo "$passwd" | passwd --stdin $name &amp;&gt; /dev/null
echo "用户$name创建完成，默认密码是：$passwd"</code></pre>

<h3><span style="color:#f33b45;">输入字符</span></h3>

<pre class="has"><code>[root@wei shell]# read -p "输入数字：" number
输入数字：99</code></pre>

<pre class="has"><code>#!/bin/bash
#
read -p "输入用户名：" name
read -p "输入密码：" passwd

useradd $name
echo "$name" | passwd --stdin $name &amp;&gt; /dev/null
echo "用户$name创建完成，密码是：$passwd"</code></pre>

<h1>以上三种方法都可以。</h1>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell变量详解</title><link>http://www.cnblogs.com/heian99/archive/2019/03/14/11972311.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 14 Mar 2019 12:17:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/14/11972311.html</guid><description><![CDATA[
                                            <p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>

<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>

<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>

<h2>Shell 脚本</h2>

<p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。</p>

<p>业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。</p>

<p>&nbsp;</p>

<p><span style="color:#f33b45;"><strong>SHELL 变量</strong></span><br>
&nbsp; &nbsp;<br>
&nbsp; &nbsp;<span style="color:#3399ea;">变量（内存空间）<br>
&nbsp; &nbsp;增加脚本的灵活性，适用性<br>
&nbsp; &nbsp;</span><br><strong><span style="color:#f33b45;">类型：</span></strong><br>
&nbsp; &nbsp; &nbsp;自定义变量<br>
&nbsp;&nbsp; &nbsp; 环境变量（Path）<br>
&nbsp;&nbsp; &nbsp; 特殊变量<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br><span style="color:#f33b45;">自定义变量</span></p>

<p><span style="color:#e579b6;"><u><strong>变量名称规范：</strong></u></span></p>

<ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
	<li>中间不能有空格，可以使用下划线（_）。</li>
	<li>不能使用标点符号。</li>
	<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul><h3>1 &nbsp;声明变量</h3>

<p># 变量名称=变量值</p>

<pre class="has"><code>[root@wei csdn]# name=wei</code></pre>

<h3><br>
2 &nbsp;调用变量的值</h3>

<p>&nbsp; &nbsp;$变量名称<br>
&nbsp; &nbsp;${变量名称} &nbsp; &nbsp;变量名称或紧跟数字，字符的时候</p>

<p>输出时，由变量名，必须用双引号</p>

<pre class="has"><code>[root@wei csdn]# name=cat
[root@wei csdn]# echo "this is $name"
this is cat
&nbsp; &nbsp;
[root@wei csdn]# echo "this is ${name}"
this is cat
&nbsp; &nbsp;
[root@wei csdn]# echo "this is ${name}s"
this is cats</code></pre>

<h3>3 &nbsp;SHELL变量的值默认全做为字符处理</h3>

<pre class="has"><code>[root@wei csdn]# a=10
[root@wei csdn]# b=20
[root@wei csdn]# c=a+b
[root@wei csdn]# echo $c
a+b

[root@wei csdn]# a=10
[root@wei csdn]# b=20
[root@wei csdn]# c=$a+$b
[root@wei csdn]# echo $c
10+20</code></pre>

<h3><span style="color:#f33b45;">数学运算：</span></h3>

<p><span style="color:#f33b45;">方法1：$(())</span></p>

<pre class="has"><code>[root@wei csdn]# a=10
[root@wei csdn]# b=20
[root@wei csdn]# c=$((a+b))
[root@wei csdn]# echo $c
30</code></pre>

<p><span style="color:#f33b45;">方法2：关键字：let</span></p>

<pre class="has"><code>[root@wei csdn]# a=10
[root@wei csdn]# b=20
[root@wei csdn]# let c=a+b
[root@wei csdn]# echo $c
30</code></pre>

<p><span style="color:#f33b45;">方法3：关键字：declare</span></p>

<pre class="has"><code>[root@wei csdn]# a=10
[root@wei csdn]# b=20
[root@wei csdn]# declare -i c=a+b
[root@wei csdn]# echo $c
30</code></pre>

<p>数学运算符：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; -<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; *<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; / &nbsp; &nbsp; 整除<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; % &nbsp; &nbsp; 取余</p>

<h2><span style="color:#f33b45;">生成随机数</span></h2>

<pre class="has"><code>[root@wei csdn]# echo $RANDOM&nbsp;
11400
[root@wei csdn]# echo $RANDOM&nbsp;
9702
[root@wei csdn]# echo $RANDOM&nbsp;
21328</code></pre>

<p>生成10以内的随机数：</p>

<pre class="has"><code>[root@wei csdn]# echo $((RANDOM%10))
4
[root@wei csdn]# echo $((RANDOM%10))
2</code></pre>

<h3><br>
4 命令引用</h3>

<p><br>
&nbsp; &nbsp;反引号 `COMMAND`<br>
&nbsp; &nbsp;$(COMMAND)</p>

<pre class="has"><code>[root@wei csdn]# a=`ls -ldh /etc/`
[root@wei csdn]# echo $a
drwxr-xr-x. 77 root root 8.0K 3月 14 16:23 /etc/

[root@wei csdn]# b=$(ls -ldh /etc/)
[root@wei csdn]# echo $b
drwxr-xr-x. 77 root root 8.0K 3月 14 16:23 /etc/</code></pre>

<h2><span style="color:#f33b45;">提取ip</span></h2>

<pre class="has"><code>[root@wei csdn]# ifconfig ens33 |grep "netmask" | awk '{print $2}'
192.168.196.131</code></pre>

<pre class="has"><code>[root@wei csdn]# head -n 3 /etc/passwd |awk -F: '{print $1,$6,$7}'
root /root /bin/bash
bin /bin /sbin/nologin
daemon /sbin /sbin/nologin</code></pre>

<h3><br>
5 &nbsp;删除变量</h3>

<p># unset 变量名称</p>

<h3><span style="color:#f33b45;">环境变量</span></h3>

<p><strong>（1）查看环境变量</strong></p>

<pre class="has"><code>[root@wei csdn]# env | less</code></pre>

<p><strong>（2）定义环境变量：修改环境变量的值</strong></p>

<p>#export 变量名称=变量值</p>

<pre class="has"><code>[root@wei csdn]# vim /etc/profile
[root@wei csdn]# source /etc/profile

</code></pre>

<p><br>
$?判断上个命令的执行状态（0--255）</p>

<p>0：代表成功<br>
其余:代表失败</p>

<p><img alt="" class="has" height="260" src="https://img-blog.csdnimg.cn/20190314201632223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="643"></p>

<p><br>
&nbsp;</p>
                                    ]]></description></item><item><title>Linux shell之重定向输入，输出</title><link>http://www.cnblogs.com/heian99/archive/2019/03/12/11972312.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 12 Mar 2019 14:28:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/12/11972312.html</guid><description><![CDATA[
                                            <p>shell是一个命令解释器，它在操作系统的最外层，负责直接与用户对话，把用户的输入解释给操作系统，并处理各种各样的操作系统的输出结果，输出到屏幕返回给用户。这种对话方式可以是交互的方式（从键盘输入命令，可以立即得到shell的回应），或非交互（执行脚本程序）的方式。<br>
下图的黄色部分就是命令解释器shell处于的操作系统中位置形象图解。</p>

<p><img alt="" class="has" src="https://images2018.cnblogs.com/blog/1066162/201807/1066162-20180726074043035-450540228.png"></p>

<h1><strong><span style="color:#f33b45;">Linux SHELL 脚本</span></strong></h1>

<p>&nbsp; &nbsp; &nbsp;大量重复执行的工作<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; shell（Linux壳）， 一类程序的名称<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; 文本文件-----&gt;shell命令，/bin/bash提供逻辑控制语句</p>

<h3><br><span style="color:#f33b45;">重定向向符号的使用</span><br>
&nbsp;&nbsp; &nbsp;/dev/stdin &nbsp; &nbsp; 标准输入设备（键盘） &nbsp; &nbsp; &nbsp; &nbsp;0<br>
&nbsp;&nbsp; &nbsp;/dev/stdout &nbsp; &nbsp;标准输出设备（显示器） &nbsp; &nbsp; &nbsp;1<br>
&nbsp;&nbsp; &nbsp;/dev/stderr &nbsp; &nbsp;标准错误输出设备（显示器） &nbsp;2</h3>

<p><img alt="" class="has" height="171" src="https://img-blog.csdnimg.cn/20190312222311388.png" width="712"></p>

<p>&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">输出重定向符号</span><br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&gt; &nbsp;覆盖原文件信息<br>
&nbsp;&nbsp; &nbsp;&gt;&gt; &nbsp;往原文件后面追加类容<br>
&nbsp; &nbsp;&nbsp;</p>

<p>&nbsp; &nbsp; &gt; &nbsp;&gt;&gt; &nbsp; 用于重定向标准输出<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;</p>

<pre class="has"><code>[root@wei ~]# ls -ldh /etc/ /tmp/1.txt
[root@wei ~]# ls -ldh /tmp/ &gt;&gt;/tmp/1.txt&nbsp;</code></pre>

<p>&nbsp;&nbsp; &nbsp;2&gt; &nbsp;2&gt;&gt; &nbsp; &nbsp; 用于重定向标准错误输出<br>
&nbsp; &nbsp; &nbsp; &nbsp;</p>

<pre class="has"><code> [root@wei ~]# ls -ldh /qwertyuasdfgh 2&gt; /tmp/1.txt &nbsp;&nbsp;</code></pre>

<p>&nbsp; &nbsp;</p>

<p>&nbsp; &nbsp; &amp;&gt; &nbsp;同时重定向标准输出及标准错误输出<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;特殊设备文件：/dev/null （垃圾站）<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp;</p>

<pre class="has"><code> &nbsp;&nbsp;&nbsp; &nbsp;[root@wei ~]# ls -ldh /etc/ &amp;&gt;/dev/null&nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;[root@wei ~]# grep "root" /etc/passwd &amp;&gt; /dev/null&nbsp;</code></pre>

<p><br><span style="color:#f33b45;">输入重定向符号</span><br>
&nbsp;</p>

<pre class="has"><code>[root@wei ~]# cat /tmp/1.txt&nbsp;
chengfeng
[root@wei ~]# tr 'a-z' 'A-Z' &lt; /tmp/1.txt&nbsp;
CHENGFENG</code></pre>

<h2>&nbsp;<br><span style="color:#f33b45;">输出信息：</span></h2>

<h3><span style="color:#7c79e5;">1 &nbsp;echo</span></h3>

<pre class="has"><code>[root@wei ~]# echo "请输出你的选择" &nbsp; &nbsp;#默认会打印换行符
请输出你的选择

[root@wei ~]# echo -n "请输出你的选择"
请输出你的选择[root@wei ~]#&nbsp;

[root@wei ~]# echo -e "a\nbb\nccc" &nbsp; &nbsp; # \n 回车
a
bb
ccc

[root@wei ~]# echo -e "a\tbb\tccc" &nbsp; &nbsp; # \t tab键
a&nbsp;&nbsp; &nbsp;bb&nbsp;&nbsp; &nbsp;ccc</code></pre>

<h3><br><span style="color:#7c79e5;">2 &nbsp;printf</span></h3>

<pre class="has"><code>[root@wei ~]# printf "hello wowrd"
hello wowrd[root@wei ~]#&nbsp;</code></pre>

<p><span style="color:#7c79e5;">3 HERE DOCUMENT &nbsp; -----&gt;输出多行信息</span></p>

<pre class="has"><code>[root@wei ~]# cat &lt;&lt; eof &nbsp;（eof为提示符，可以任意定义）
&gt; 选择
&gt; 安装
&gt; 重启
&gt; 关机
&gt; eof
选择
安装
重启
关机</code></pre>

<h2><span style="color:#f33b45;">双引号和单引号的区别：</span></h2>

<p><span style="color:#7c79e5;">单引号：所有字符会失去原有的含义<br>
双引号：特殊的字符会转义</span></p>

<h3><span style="color:#f33b45;">如何交互命令:</span></h3>

<pre class="has"><code>[root@wei ~]# echo "root" | passwd --stdin hei &amp;&gt; /dev/null

[root@wei ~]# echo -e "n\rp\r1\r+100M\rw\r" | fdisk /dev/vdb &amp;&gt; /dev/null&nbsp;</code></pre>

<p><span style="color:#ffbb66;">显示历史命令</span></p>

<pre class="has"><code>[root@wei ~]# history</code></pre>

<p><span style="color:#ffbb66;">执行历史命令的某一条</span></p>

<pre class="has"><code>[root@wei ~]# !254</code></pre>

<p><span style="color:#ffbb66;">清空历史命令</span></p>

<pre class="has"><code>[root@wei ~]# history -c</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux的httpd服务搭建</title><link>http://www.cnblogs.com/heian99/archive/2019/03/12/11972313.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 12 Mar 2019 11:30:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/12/11972313.html</guid><description><![CDATA[
                                            <p>在服务搭建前，还要了解一下httpd的日志。</p>

<p>日志有助有工作人员，查看服务器出错状况，更能统计数据分析网页运行情况。</p>

<h1><span style="color:#f33b45;"><strong>PV和UV两大分析</strong></span></h1>

<h3><span style="color:#7c79e5;">PV &nbsp;Page View 页面访问量<br>
UV &nbsp;User View 用户访问量</span></h3>

<p><span style="color:#f33b45;">1)指定错误日志的名称及级别</span></p>

<p><strong><span style="color:#7c79e5;">错误日志的路径：</span></strong>/var/log/httpd/error_log</p>

<p><span style="color:#7c79e5;"><strong>错误级别：</strong></span> debug, info, notice, warn, error, crit</p>

<p><span style="color:#7c79e5;"><strong>访问日志：</strong></span> /var/log/httpd/access_log</p>

<pre class="has"><code>[root@wei httpd]# head -n 1 /var/log/httpd/access_log</code></pre>

<p><img alt="" class="has" height="203" src="https://img-blog.csdnimg.cn/2019031219235115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="808"><br><span style="color:#f33b45;">（2）定义访问日志的格式</span></p>

<p><span style="color:#f33b45;">LogFormat "%h %l %u %t \"%r\" %&gt;s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined</span></p>

<pre class="has"><code>192.168.196.1 - - [07/Mar/2019:05:33:39 +0800] "GET / HTTP/1.1" 200 1766 "-" "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36"</code></pre>

<p>&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;<span style="color:#3399ea;"><strong> %h 远端主机<br>
&nbsp; &nbsp; &nbsp; &nbsp;%l 远端登录名(由identd而来，如果支持的话)，除非IdentityCheck设为"On"，否则将得到一个"-"。<br>
&nbsp;&nbsp; &nbsp; &nbsp; %u 远程用户名(根据验证信息而来；如果返回status(%s)为401，可能是假的)<br>
&nbsp;&nbsp; &nbsp; &nbsp; %t 时间，用普通日志时间格式(标准英语格式)<br>
&nbsp;&nbsp; &nbsp; &nbsp; %r 请求的第一行<br>
&nbsp;&nbsp; &nbsp; &nbsp; %&gt;s:HTTP状态码<br>
&nbsp;&nbsp; &nbsp; &nbsp; %b 以CLF格式显示的除HTTP头以外传送的字节数，也就是当没有字节传送时显示’-'而不是0。<br>
&nbsp;&nbsp; &nbsp; &nbsp; %{Referer}i：记录超链接地址<br>
&nbsp;&nbsp; &nbsp; &nbsp; %{User-Agent}i：记录客户端的浏览器类型</strong></span></p>

<p><br><span style="color:#f33b45;">（3）指定访问日志的名称及格式</span></p>

<p>&nbsp;CustomLog "logs/access_log" combined</p>

<p>&nbsp;</p>

<h1><strong><span style="color:#f33b45;">虚拟主机 VirtualHost</span></strong></h1>

<p>&nbsp; &nbsp; 作用：在一台物理服务器上运行多个网站<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;类型：<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 基于域名的虚拟主机（常用）<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 基于IP地址的虚拟主机<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 基于端口的虚拟主机<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
配置虚拟主机</p>

<pre class="has"><code>&lt;VirtualHost 10.1.2.3:80&gt;
&nbsp; ServerAdmin webmaster@host.example.com
&nbsp; DocumentRoot /www/docs/host.example.com
&nbsp; ServerName host.example.com
&nbsp; ErrorLog logs/host.example.com-error_log
&nbsp; TransferLog logs/host.example.com-access_log
&lt;/VirtualHost&gt;</code></pre>

<h3><br><span style="color:#f33b45;">示例：基于主机名的虚拟主机</span></h3>

<p>&nbsp; www.a.org &nbsp; &nbsp;网页目录：/var/www/html/a.org &nbsp; 日志：/var/log/httpd/a.org<br>
&nbsp;</p>

<p>&nbsp;www.a.org &nbsp;</p>

<p>(1)准备目录</p>

<pre class="has"><code>[root@wei ~]# mkdir /var/www/html/a.org
[root@wei ~]# vim /var/www/html/a.org/index.html
[root@wei ~]# mkdir /var/log/httpd/a.org</code></pre>

<p>（2）编写配置文件</p>

<pre class="has"><code>[root@wei ~]# vim /etc/httpd/conf.d/a.org.conf</code></pre>

<pre class="has"><code>&lt;VirtualHost 192.168.196.132:80&gt;
&nbsp; DocumentRoot /var/www/html/a.org
&nbsp; ServerName www.a.org
&nbsp; ErrorLog /var/log/httpd/a.org/error_log
&nbsp; CustomLog /var/log/httpd/a.org/access_log combined

&lt;/VirtualHost&gt;</code></pre>

<p><br>
（3）检测配置文件语法</p>

<pre class="has"><code>[root@wei ~]# httpd -t</code></pre>

<p>（4）重启服务</p>

<pre class="has"><code>[root@wei ~]# systemctl restart httpd</code></pre>

<p><br>
&nbsp;</p>

<p><br>
&nbsp;</p>
                                    ]]></description></item><item><title>Linux的httpd服务介绍和部署</title><link>http://www.cnblogs.com/heian99/archive/2019/03/08/11972314.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 08 Mar 2019 13:48:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/08/11972314.html</guid><description><![CDATA[
                                            <p><strong>软件介绍</strong></p>

<p><strong>客户端代理软件<br>
&nbsp; &nbsp; IE，firefox，chroome，opera<br>
&nbsp;&nbsp; &nbsp;<br>
服务器端软件<br>
&nbsp; &nbsp; &nbsp;httpd，Nginx，Tengine，ISS，Lighthttp<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
应用程序服务器<br>
&nbsp; &nbsp; &nbsp; ISS，Tomcat（JSP，open sourec），Websphere（IBM，JSP，commodity）Weblogic(oracle,JSP,commodity)<br>
&nbsp;&nbsp; &nbsp; &nbsp;JBoss(redhat,JSP),Resin,php</strong></p>

<p><br><strong>httpd安装及配置</strong></p>

<p><strong>ASF：Apache Software Foundation &nbsp; http://www.apache.org/<br>
&nbsp; &nbsp; &nbsp;web:httpd<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Tomcat<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; Hadoop<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
httpd: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://httpd.apache.org/<br>
&nbsp; &nbsp; &nbsp; Web Server,Open Sourec<br>
&nbsp;&nbsp; &nbsp; &nbsp;2.4,2.2,2.0<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
httpd软件安装:<br>
&nbsp; &nbsp; &nbsp;rpm<br>
&nbsp; &nbsp; &nbsp;源码软件</strong></p>

<p><strong>httpd特性:<br>
&nbsp; &nbsp; 事先创建进程<br>
&nbsp; &nbsp; 按需维持适当的进程<br>
&nbsp; &nbsp; 模块化设计，核心较小，各种功能都能通过模块添加:模块可以在运行时启用<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 支持运行配置，支持单独编译模块<br>
&nbsp; &nbsp; 支持多种虚拟主机的配置<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 基于IP的虚拟主机<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;基于端口的虚拟主机<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;基于域名的虚拟主机<br>
&nbsp;&nbsp; &nbsp;支持https协议(mod_ ss1)<br>
&nbsp;&nbsp; &nbsp;支持用户认证<br>
&nbsp; &nbsp; 支持基于IP或主机名的访问控制机制<br>
&nbsp;&nbsp; &nbsp;支持每目录的访问控制<br>
&nbsp;&nbsp; &nbsp;支持URL重写</strong></p>

<p><strong>安装httpd软件</strong></p>

<pre class="has"><code>[root@wei ~]# yum install -y httpd</code></pre>

<p><strong>开启服务</strong></p>

<pre class="has"><code>[root@wei ~]# systemctl start httpd</code></pre>

<p><strong>开机自启</strong></p>

<pre class="has"><code>[root@wei ~]# systemctl enable httpd</code></pre>

<p><strong>查看端口号</strong></p>

<pre class="has"><code>[root@wei ~]# ss -antp |grep httpd</code></pre>

<p><strong><img alt="" class="has" height="255" src="https://img-blog.csdnimg.cn/20190308213345807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="793"></strong></p>

<p><strong>查看它启动的进程</strong></p>

<pre class="has"><code>[root@wei ~]# ps aux|grep httpd</code></pre>

<p><strong><img alt="" class="has" height="459" src="https://img-blog.csdnimg.cn/20190308213451440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="801"></strong></p>

<p><strong>httpd目录:</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; /etc/httpd/ conf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 主配置文件 &nbsp;httpd. conf<br>
&nbsp;&nbsp; &nbsp; &nbsp;/etc/httpd/conf.d/* . conf &nbsp; &nbsp; &nbsp; 子配置文件<br>
&nbsp;&nbsp; &nbsp; &nbsp;/var/log/httpd &nbsp;日志<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; access_ .log &nbsp;访问日志<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;error_ log &nbsp;错误日志</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; /var/www/html &nbsp;默认静态页面的目录<br>
&nbsp;&nbsp; &nbsp; &nbsp;/var/www/cgi-bin &nbsp;默认动态页面的目录</strong></p>

<p><strong><img alt="" class="has" height="512" src="https://img-blog.csdnimg.cn/20190308213717876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="732">CGI: Comnon Gateway Interface通用网关接口<br>
&nbsp; &nbsp; 让web服务器启动某应用程序解析动态页面的机制开发动态网页的语言:<br>
&nbsp; &nbsp; &nbsp; perl, python, java (Servlet JSP), php</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; PHP &nbsp; &nbsp;LAMP , LNMP<br>
&nbsp; &nbsp; &nbsp; JSP &nbsp; &nbsp;Tomcat, Weblogical<br>
&nbsp;&nbsp; &nbsp; &nbsp;Python &nbsp;mod_ wsgi模块</strong></p>

<h2><br><span style="color:#f33b45;"><strong>&nbsp;httpd配置文件&nbsp;---- &nbsp;/etc/httpd/conf/httpd.conf ;</strong></span></h2>

<p><strong>diretive value<br>
&nbsp; &nbsp; 指令不区分大小写<br>
&nbsp; &nbsp; value区分大小写</strong></p>

<p><span style="color:#ffbb66;"><strong>1）设置httpd的主目录</strong></span></p>

<p><strong>ServerRoot "/etc/httpd"&nbsp;&nbsp; &nbsp;</strong></p>

<p><span style="color:#ffbb66;"><strong>2）监听ip的地址和端口</strong></span></p>

<p><strong>&nbsp; &nbsp; #Listen 12.34.56.78:80<br>
&nbsp; &nbsp; &nbsp;Listen 80<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br><span style="color:#ffbb66;">3）指定子配置文件的路径及名称</span></strong></p>

<p><strong>&nbsp;Include conf.modules.d/*.conf</strong></p>

<p><span style="color:#ffbb66;"><strong>4)设置运行httpd进程的用户及用户组名称</strong></span></p>

<p><strong>User apache<br>
Group apache</strong></p>

<p><span style="color:#ffbb66;"><strong>5)长连接相关的配置</strong></span></p>

<p><strong>KeepAlive on<br>
MaxKeepAliveRequests 100<br>
KeepAliveTimeout 15</strong></p>

<p><span style="color:#ffbb66;"><strong>6)设置管理员的邮箱</strong></span></p>

<p><strong>ServerAdmin root@localhost</strong></p>

<p><span style="color:#ffbb66;"><strong>7)设置网站的主机名</strong></span></p>

<p><strong>ServerName www.a. org</strong></p>

<p><span style="color:#ffbb66;"><strong>8)设置网页目录</strong></span></p>

<p><strong>DocumentRoot "/var/www/html"&nbsp;</strong></p>

<p><span style="color:#ffbb66;"><strong>9)设置网页的首页名称</strong></span></p>

<p><strong>DirectoryIndex index. html</strong></p>

<p><span style="color:#ffbb66;"><strong>10）针对目录权限</strong></span></p>

<p><strong>&lt;Directory "/var/www/html"&gt;<br>
&nbsp; Options Indexes FollowSymLinks<br>
&nbsp; &nbsp; AllowOverride None<br>
&nbsp; &nbsp; Require all granted<br>
&lt;/Directory&gt;</strong></p>

<p><br><strong><span style="color:#f33b45;">A） Require all granted</span><br>
&nbsp; &nbsp; 允许所有的客户端访问该目录的页面文件<br>
&nbsp;&nbsp; &nbsp;<br><span style="color:#f33b45;">B）Options Indexes FollowSymLinks</span><br>
&nbsp; &nbsp;定义目录下的网页文件被访问时的访问属性<br>
&nbsp; &nbsp; &nbsp; &nbsp;None：不支持任何选项<br>
&nbsp;&nbsp; &nbsp; &nbsp; Indexes：无index.html 时，列出所有的文件，禁用<br>
&nbsp;&nbsp; &nbsp; &nbsp; FollowSymLinks：存在软链接网页文件时，是否只可以访问对应原网页文件的内容，禁用<br>
&nbsp; &nbsp; &nbsp; &nbsp;SymLinksifOwnerMatch:允许访问软链接，但所属必须和运行httpd进程的所属一致<br>
&nbsp;&nbsp; &nbsp; &nbsp; Includes:允许执行服务器端包含(SSI格式的网页文件)，禁用<br>
&nbsp;&nbsp; &nbsp; &nbsp; ExeCGI:允许运行CGI脚本<br>
&nbsp; &nbsp; &nbsp; &nbsp;Multiviews:内容协商机制(根据客户端的语言不同显示不同的网页)，多视图:禁用<br>
&nbsp;&nbsp; &nbsp; &nbsp; A11:启用所有选项</strong></p>

<p><span style="color:#f33b45;"><strong>C）Allowoverride None</strong></span></p>

<p><strong>&nbsp; &nbsp; &nbsp; 是否允许建立.htaccess文件覆盖提权配置</strong></p>

<p><br><strong><span style="color:#7c79e5;">查看帮助手册</span></strong></p>

<p><strong>[root@wei csdn]# yum -y install httpd-manual</strong></p>

<p><br><strong>http://192.168.196.131/manual/</strong></p>

<h1><br><strong><span style="color:#f33b45;">支持用户认证</span></strong></h1>

<h3><span style="color:#ffbb66;"><strong>示例：客户端通过用户hei访问首页（/var/www/html）</strong></span></h3>

<p><strong>(1)创建用户名称和密码</strong></p>

<pre class="has"><code>[root@wei ~]# htpasswd -c /etc/httpd/.webuser hei
New password:&nbsp;
Re-type new password:&nbsp;
Adding password for user hei</code></pre>

<p><strong>（2）编辑配置文件</strong></p>

<pre class="has"><code>[root@wei ~]# vim /etc/httpd/conf/httpd.conf</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>&lt;Directory "/var/www/html"&gt;
&nbsp; &nbsp;
&nbsp; &nbsp; Options Indexes FollowSymLinks
&nbsp; &nbsp; AllowOverride AuthConfig
&nbsp; &nbsp; AuthType Basic
&nbsp; &nbsp; AuthName "Resttrict test"
&nbsp; &nbsp; AuthUserFile /etc/httpd/.webuser
&nbsp; &nbsp; Require valid-user
&nbsp; &nbsp;#Require user 用户名称 &nbsp; 只允许指定用户访问

&lt;/Directory&gt;</code></pre>

<p><strong>检测配置文件语法</strong></p>

<pre class="has"><code>
[root@wei ~]# httpd -t

Syntax OK</code></pre>

<p><strong>(3)重启服务</strong></p>

<pre class="has"><code>[root@wei ~]# systemctl restart httpd</code></pre>

<p><img alt="" class="has" height="504" src="https://img-blog.csdnimg.cn/20190308214756306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="749"></p>

<p>&nbsp;</p>

<p><strong>（4）再次创建一个用户wei<br>
创建用户名称和密码</strong></p>

<pre class="has"><code>[root@wei ~]# htpasswd &nbsp;/etc/httpd/.webuser wei

[root@wei ~]# cat /etc/httpd/.webuser&nbsp;
hei:$apr1$nBaKumC0$lsSLO6LqDQ58CWLjXIfJT0
wei:$apr1$ovl.gsGg$SHvY5Aksj9MdZv9u8E5XF1</code></pre>

<h3><br><strong><span style="color:#ffbb66;">基于客户端ip地址的认证</span></strong></h3>

<p><strong>1) 允许所有喜户端访问</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; Require all granted</strong></p>

<p><strong>2)拒绝所有端访问</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; Require al1 denied3)仅允许某主机访问</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; Require ip 192.168.1.14) 明确拒绝某主机访问</strong></p>

<h2><strong>&nbsp;&lt;RequireAll&gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp;Require all granted<br>
&nbsp; &nbsp; &nbsp; &nbsp;Require not ip 192.168.96.1<br>
&nbsp; &nbsp; &nbsp;&lt;/RequireAll&gt;<br><span style="color:#f33b45;">&nbsp;windos访问效果图</span></strong></h2>

<p><img alt="" class="has" height="305" src="https://img-blog.csdnimg.cn/20190308214144293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="565"><br><strong>&nbsp;&nbsp; &nbsp;&nbsp;<br>
检测配置文件语法<br>
[root@wei ~]# httpd -t</strong></p>

<p><strong>Syntax OK</strong></p>

<p><strong>重启服务</strong></p>

<p><strong>[root@wei ~]# systemctl restart httpd<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;</strong></p>

<p><br>
&nbsp;</p>
                                    ]]></description></item><item><title>Linux的web服务的介绍</title><link>http://www.cnblogs.com/heian99/archive/2019/03/06/11972315.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 06 Mar 2019 12:27:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/06/11972315.html</guid><description><![CDATA[
                                            <p><strong>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构<br>
&nbsp; &nbsp; &nbsp;<br><span style="color:#f33b45;">&nbsp;&nbsp; &nbsp; 网页类型：</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; <span style="color:#ffbb66;">&nbsp;静态网页 </span>&nbsp; HTML超文本标记语言 &nbsp; *.html<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <span style="color:#ffbb66;">&nbsp;动态网站</span><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 类似于脚本文件，根据传递的参数不同，返回的页面结果不同的<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; PHP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *.php<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Java(JSP) &nbsp; &nbsp; &nbsp; &nbsp; *.jsp<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Python(Django模块)*.wsgi<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
HTTP-------------HyperText Transfer Protocol &nbsp; 超文本传输协议</strong></p>

<p><strong><span style="color:#7c79e5;">HTTP/0.9</span>：仅纯文本（超链接），ASCLL<br>
&nbsp; &nbsp; HTTP ：HyperText Mark Language 超文本标记语言<br>
&nbsp;&nbsp; &nbsp;&lt;h1&gt;I am cehngfneg.&lt;/h1&gt;<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;<br><span style="color:#7c79e5;">HTTP/1.0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MIME机制：Multipurpose Internet Mail Extensions，多用途互联网邮件扩展<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 将非文本数据在传输前重新编码为文本格式再传输，接收方能够用相反的方式将其还原成以前的格式，还能够调用相应的程序打开此文件<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 缓存机制<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><span style="color:#7c79e5;">HTTP/1.1（无状态连接）</span><br>
&nbsp; &nbsp; &nbsp; 增强了缓存机制的管理<br>
&nbsp;&nbsp; &nbsp; &nbsp;长连接keepalive机制<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 超时时间<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 每个长连接请求文件个数的限制<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br><span style="color:#f33b45;">HTTP报文：请求报文，响应报文</span><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br><span style="color:#86ca5e;">HTTP请求报文语法：</span></strong></p>

<p><strong>&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;<br>
&lt;headers&gt;</strong></p>

<p><strong>&lt;entity-body&gt;</strong></p>

<p><span style="color:#ffbb66;"><strong>请求报文：</strong></span></p>

<p><strong>GET /1.gif HTTP/1.1<br>
Host:www.bj.com<br>
Connection:keep-alive</strong></p>

<p><strong>HTTP方法：<br>
&nbsp; &nbsp; &nbsp; GET，PUT，POST，DELETE，HEAD<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
URI：Uniform Resource Identifier，统一资源标识符 &nbsp; &nbsp; &nbsp; &nbsp;/.jpg<br>
&nbsp; &nbsp; &nbsp;全局范围内，唯一标识某个资源的名称<br>
&nbsp;&nbsp; &nbsp; 统一：路径格式上的统一<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
URL：Uniform Resource Locator &nbsp;统一资源定位符<br>
&nbsp; &nbsp; &nbsp;protocal://Host:Port/path/to/file<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; http://192.168.1.1/1.jpg<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; http://192.168.1.1:8000/1.jpg</strong></p>

<p><span style="color:#86ca5e;"><strong>HTTP响应报文语法：</strong></span></p>

<p><strong>&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;<br>
&lt;headers&gt;</strong></p>

<p><strong>&lt;entity-body&gt;</strong></p>

<p><br><strong><span style="color:#ffbb66;">&nbsp;状态代码:</span><br>
&nbsp;<br>
1xx:纯信息<br>
2xx:成功类信息<br>
3xX:重定向类信息I<br>
&nbsp; &nbsp; &nbsp;301:永久重定向<br>
&nbsp;&nbsp; &nbsp; 302:临时重定向<br>
&nbsp; &nbsp; &nbsp;304: not-modified, 使用缓存的内容响应客户端<br>
4xx:客户端错误类信息<br>
5xx:服务器端错误类信息</strong></p>

<p><br><strong><span style="color:#ffbb66;">响应报文:</span><br>
HTTP/1.1 200 OK<br>
X-Powerd=By: PHP/5.2.17<br>
vary: Accept-Encoding, Cookie, User-Agent<br>
Cache-Control: max-age=3, must-revalidate<br>
Content-Encoding: gzip<br>
Content -Length: 6931</strong></p>

<p><strong>上面两个报文的第一 行通常称为报文的“起始行(start line)"; 后面的标签格式称为报文首部域(Header<br>
field)，每个首部域都由名称(name)和值(value)组成，中间用逗号分隔。另外，响应报文通常还有- - 个称作Body的信息主体，即响应给客户端的内容</strong></p>

<p><br><span style="color:#f33b45;"><strong>web服务器的主要操作:</strong></span></p>

<p><strong>1、建立连接----接受或拒绝客户端连接请求<br>
2、接收请求----通过网络读取HTTP请求报文<br>
3、处理请求----解析请求报文并做出相应的动作<br>
4、访问资源----访问请求报文中所请求的资源<br>
5、构建响应----使用正确的首部生成HTTP响应报文<br>
6、发送响应----向客户端发送生成的响应报文<br>
7、记录日志----当已经完成的HTTP事务记录进日志文件</strong></p>

<p><br><span style="color:#7c79e5;"><strong>web服务器响应并发连接(qps--&gt; query per second) 的方式:</strong></span></p>

<p><strong>1、单进程/单线程机制<br>
&nbsp; &nbsp; 依次处理每个请求<br>
2、多进程/多线程机制(稳定)<br>
&nbsp; &nbsp; 每个请求生成子进程响应<br>
3、一一个进程响应多个请求(单进程多线程)<br>
&nbsp; &nbsp; &nbsp; 事件驱动机制<br>
&nbsp;&nbsp; &nbsp; &nbsp;通知机制<br>
4、多进程响应多个请求</strong></p>
                                    ]]></description></item><item><title>Linux的DNS主从服务器部署</title><link>http://www.cnblogs.com/heian99/archive/2019/03/05/11972316.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 05 Mar 2019 13:35:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/05/11972316.html</guid><description><![CDATA[
                                            <p>下面的部署是在<a href="https://blog.csdn.net/heian_99/article/details/88196569" rel="nofollow">Linux的DNS正向解析部署</a>上进行修改的。</p>

<p>如果有什么问题或者错误，可以访问上篇帖子</p>

<p>下面开始有关DNS的服务部署。&lt;DNS主从服务器&gt;</p>

<p>环境描述：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 192.168.196.132 &nbsp; &nbsp; DNS主服务器<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;192.168.196.131 &nbsp; &nbsp; DNS从服务器<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;<br>
将主服务器的上的wei.com区域的记录与从服务器同步</p>

<h1><strong><span style="color:#f33b45;">主服务器：</span></strong></h1>

<p>（1）编辑主配置文件named.conf</p>

<pre class="has"><code>[root@wei named]# vim /var/named/chroot/etc/named.conf&nbsp;</code></pre>

<pre class="has"><code>options {
&nbsp; &nbsp; &nbsp; directory "/var/named";
};


zone "wei.com" {
&nbsp; &nbsp; &nbsp;type master;
&nbsp; &nbsp; &nbsp;allow-transfer { 192.168.196.131;}; &nbsp;&gt;&gt;&gt;指定从服务器的IP
&nbsp; &nbsp; &nbsp;file "wei.com.zone";
};
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
zone "1.168.192.in-addr.arpa" {
&nbsp; &nbsp; &nbsp; type master;
&nbsp; &nbsp; &nbsp; file "192.168.1.zone"; &nbsp;
}; &nbsp; &nbsp; &nbsp; </code></pre>

<p>&nbsp;&nbsp;</p>

<p>（2）编辑wei.com的区域的记录文件，添加从服务器的NS记录</p>

<pre class="has"><code>[root@wei named]# vim /var/named/chroot/var/named/wei.com.zone&nbsp;</code></pre>

<pre class="has"><code>$TTL 1D
@ &nbsp; &nbsp; &nbsp; IN SOA &nbsp;wei.com. 123456.qq.com. (
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; ; serial
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1D &nbsp; &nbsp; &nbsp;; refresh
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1H &nbsp; &nbsp; &nbsp;; retry
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1W &nbsp; &nbsp; &nbsp;; expire
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3H ) &nbsp; &nbsp;; minimum
&nbsp; &nbsp; &nbsp; &nbsp; NS &nbsp; &nbsp; &nbsp;dns01.wei.com.
&nbsp; &nbsp; &nbsp; &nbsp; NS &nbsp; &nbsp; &nbsp;dns02.wei.com.
dns01 &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.196.132
dns02 &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.196.131
web &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.1
web &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.11
wei.com. &nbsp; A &nbsp;192.168.1.1
*.wei.com. &nbsp; A &nbsp;192.168.1.1
ftp &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.2
&nbsp; &nbsp; &nbsp; &nbsp; MX &nbsp;10 &nbsp;mail.wei.com.
mail &nbsp; &nbsp;A &nbsp; &nbsp; &nbsp; 192.168.1.3</code></pre>

<p><br>
&nbsp; &nbsp;&nbsp;<br>
（3）重启服务</p>

<pre class="has"><code>[root@wei named]# systemctl restart named-chroot

[root@wei named]# systemctl restart named</code></pre>

<h1><br><span style="color:#f33b45;">从服务器：</span></h1>

<p>（1）安装软件</p>

<pre class="has"><code>[root@wei named]# yum install -y bind bind-chroot</code></pre>

<p>（2）编辑主配置文件</p>

<pre class="has"><code>[root@wei csdn]# vim /var/named/chroot/etc/named.conf</code></pre>

<pre class="has"><code>options {
&nbsp; &nbsp; &nbsp; directory "/var/named";
};


zone "wei.com" {
&nbsp; &nbsp; &nbsp;type slave;
&nbsp; &nbsp; &nbsp;masters { 192.168.196.132;}; &gt;&gt;&gt;&gt;指向主服务器
&nbsp; &nbsp; &nbsp;file "slaves/wei.com.zone";
};</code></pre>

<p>（3）重启服务</p>

<pre class="has"><code>[root@wei named]# systemctl restart named-chroot

[root@wei named]# systemctl restart named</code></pre>

<p>（4）测试</p>

<pre class="has"><code>[root@wei slaves]# cd /var/named/chroot/var/named/slaves

[root@wei slaves]# ls
wei.com.zone</code></pre>

<p>已经成功加载</p>

<p><img alt="" class="has" height="254" src="https://img-blog.csdnimg.cn/20190305212740195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="566"><br>
（5）nslookup检查</p>

<p><img alt="" class="has" height="623" src="https://img-blog.csdnimg.cn/20190305213010130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="608"></p>

<p>&nbsp;</p>

<p>好的，这就已经完成主从服务器的搭建了。</p>

<p>我们去主服务器新加区域，看能否同步解析</p>

<p><img alt="" class="has" height="491" src="https://img-blog.csdnimg.cn/2019030521333539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="655"></p>

<p>重启主服务器。</p>

<p>现在去测试从服务器的同步情况，已经成功了，ok。</p>

<p><img alt="" class="has" height="402" src="https://img-blog.csdnimg.cn/20190305213438942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="516"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux的DNS反向解析部署</title><link>http://www.cnblogs.com/heian99/archive/2019/03/05/11972317.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 05 Mar 2019 13:19:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/05/11972317.html</guid><description><![CDATA[
                                            <p>下面的部署是在<a href="https://blog.csdn.net/heian_99/article/details/88196569" rel="nofollow">Linux的DNS正向解析示例</a>上进行修改的。</p>

<p>如果有什么问题或者错误，可以访问上篇帖子</p>

<p>下面开始有关DNS的服务部署。&lt;DNS反向解析&gt;</p>

<p>工具：虚拟机</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;centos7&nbsp;</p>

<p>配置：Linux&nbsp;&nbsp;&nbsp;IP 192.168.196.132</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSN&nbsp;&nbsp;&nbsp;192.168.196.132</p>

<p>&nbsp;</p>

<p>建立DAS反向区域，实现反向解析</p>

<p>（1）编辑主配置文件named.conf</p>

<pre class="has"><code>[root@wei named]# vim /var/named/chroot/etc/named.conf&nbsp;</code></pre>

<p><br>
添加下面的代码</p>

<pre class="has"><code>zone "1.168.192.in-addr.arpa" {
&nbsp; &nbsp; &nbsp; type master;
&nbsp; &nbsp; &nbsp; file "192.168.1.zone"; &nbsp;
}; &nbsp;</code></pre>

<p><img alt="" class="has" height="405" src="https://img-blog.csdnimg.cn/20190305211607230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="615"></p>

<p>（2）建立反向区域</p>

<p>可以复制正向解析的文件作为模板</p>

<pre class="has"><code>[root@wei named]# cp /var/named/chroot/var/named/wei.com.zone /var/named/chroot/var/named/192.168.1.zone</code></pre>

<p>修改192.168.1.zone脚本</p>

<pre class="has"><code>[root@wei named]# vim /var/named/chroot/var/named/192.168.1.zone</code></pre>

<pre class="has"><code>$TTL 1D
@ &nbsp; &nbsp; &nbsp; IN SOA &nbsp;wei.com. 123456.qq.com. (
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; ; serial
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1D &nbsp; &nbsp; &nbsp;; refresh
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1H &nbsp; &nbsp; &nbsp;; retry
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1W &nbsp; &nbsp; &nbsp;; expire
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3H ) &nbsp; &nbsp;; minimum
&nbsp; &nbsp; &nbsp; &nbsp; NS &nbsp; &nbsp; &nbsp;dns01.wei.com.
dns01 &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.196.132
1 &nbsp; &nbsp; &nbsp; PTR &nbsp; &nbsp; web.wei.com.
11 &nbsp; &nbsp; &nbsp;PTR &nbsp; &nbsp; web.wei.com.
2 &nbsp; &nbsp; &nbsp; PTR &nbsp; &nbsp; ftp.wei.com.
3 &nbsp; &nbsp; &nbsp; PTR &nbsp; &nbsp; mail.wei.com.</code></pre>

<p>（3）重启服务<br>
&nbsp;</p>

<pre class="has"><code>[root@wei named]# systemctl restart named-chroot

[root@wei named]# systemctl restart named</code></pre>

<p>（4）使用nslookup测试查看</p>

<p><img alt="" class="has" height="481" src="https://img-blog.csdnimg.cn/20190305211902801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="684"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux的DNS实现负载均衡及泛域名部署</title><link>http://www.cnblogs.com/heian99/archive/2019/03/05/11972318.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 05 Mar 2019 12:03:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/05/11972318.html</guid><description><![CDATA[
                                            <p>DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的</p>

<p><img alt="" class="has" src="http://segmentfault.com/img/bVkYML"><img alt="" class="has" src="http://segmentfault.com/img/bVkYML"></p>

<p><img alt="" class="has" src="%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8Bhttps%3A//image-static.segmentfault.com/365/448/3654482496-54f6c9fe72e0d_articlex"><img alt="" class="has" height="380" src="https://image-static.segmentfault.com/365/448/3654482496-54f6c9fe72e0d_articlex" width="497"></p>

<p>&nbsp;</p>

<p>下面的部署是在<a href="https://blog.csdn.net/heian_99/article/details/88196569" rel="nofollow">Linux的DNS正向解析部署</a>上进行修改的。</p>

<p>如果有什么问题或者错误，可以访问上篇帖子</p>

<p>下面开始有关DNS的服务部署。&lt;<span style="color:#f33b45;">DNS实现负载均衡及泛域名</span>&gt;</p>

<p>工具：虚拟机</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; centos7&nbsp;</p>

<p>配置：Linux&nbsp; &nbsp;IP 192.168.196.132</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DSN&nbsp; &nbsp;192.168.196.132</p>

<h2><span style="color:#f33b45;">负载平衡</span></h2>

<p>利用DNS记录实现负载均衡效果</p>

<p>web &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.1<br>
web &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.11</p>

<p>同一主机名解析到不同的ip上</p>

<pre class="has"><code>[root@wei named]# vim /var/named/chroot/var/named/wei.com.zone&nbsp;</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>$TTL 1D
@ &nbsp; &nbsp; &nbsp; IN SOA &nbsp;wei.com. 123456.qq.com. (
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; ; serial
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1D &nbsp; &nbsp; &nbsp;; refresh
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1H &nbsp; &nbsp; &nbsp;; retry
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1W &nbsp; &nbsp; &nbsp;; expire
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3H ) &nbsp; &nbsp;; minimum
&nbsp; &nbsp; &nbsp; &nbsp; NS &nbsp; &nbsp; &nbsp;dns01.wei.com.
dns01 &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.196.132
web &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.1
web &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.11
ftp &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.2
&nbsp; &nbsp; &nbsp; &nbsp; MX &nbsp;10 &nbsp;mail.wei.com.
mail &nbsp; &nbsp;A &nbsp; &nbsp; &nbsp; 192.168.1.3</code></pre>

<h2>重启服务</h2>

<pre class="has"><code>[root@wei named]# systemctl restart named-chroot

[root@wei named]# systemctl restart named</code></pre>

<h2><span style="color:#ffbb66;">效果图</span></h2>

<p><img alt="" class="has" height="401" src="https://img-blog.csdnimg.cn/20190305195654675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="478"></p>

<h2><span style="color:#f33b45;">泛域名记录</span></h2>

<p>wei.com. &nbsp; A &nbsp; &nbsp; 192.168.1.1<br>
*.wei.com &nbsp;A &nbsp; &nbsp; 192.168.1.1</p>

<pre class="has"><code>[root@wei named]# vim /var/named/chroot/var/named/wei.com.zone&nbsp;</code></pre>

<p><br>
&nbsp;</p>

<pre class="has"><code>$TTL 1D
@ &nbsp; &nbsp; &nbsp; IN SOA &nbsp;wei.com. 123456.qq.com. (
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; ; serial
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1D &nbsp; &nbsp; &nbsp;; refresh
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1H &nbsp; &nbsp; &nbsp;; retry
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1W &nbsp; &nbsp; &nbsp;; expire
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3H ) &nbsp; &nbsp;; minimum
&nbsp; &nbsp; &nbsp; &nbsp; NS &nbsp; &nbsp; &nbsp;dns01.wei.com.
dns01 &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.196.132
web &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.1
web &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.11
wei.com. &nbsp; A &nbsp;192.168.1.1 &nbsp; &nbsp;# 使用wei.com就可以访问域名
*.wei.com. &nbsp; A &nbsp;192.168.1.1 &nbsp;# 无论前面加什么，都会解析到192.168.1.1上
ftp &nbsp; &nbsp; A &nbsp; &nbsp; &nbsp; 192.168.1.2
&nbsp; &nbsp; &nbsp; &nbsp; MX &nbsp;10 &nbsp;mail.wei.com.
mail &nbsp; &nbsp;A &nbsp; &nbsp; &nbsp; 192.168.1.3

</code></pre>

<h2>重启服务</h2>

<pre class="has"><code>[root@wei named]# systemctl restart named-chroot

[root@wei named]# systemctl restart named</code></pre>

<h2><span style="color:#ffbb66;">效果图</span></h2>

<p><img alt="" class="has" height="580" src="https://img-blog.csdnimg.cn/20190305200202194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="822"></p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux的DNS正向解析部署</title><link>http://www.cnblogs.com/heian99/archive/2019/03/05/11972319.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 05 Mar 2019 11:21:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/05/11972319.html</guid><description><![CDATA[
                                            <p>前面介绍了DNS的作用及其相关的结果。<a href="https://blog.csdn.net/heian_99/article/details/88195866" rel="nofollow">Linux服务之DNS介绍</a></p>

<p>下面开始有关DNS的服务部署。<span style="color:#f33b45;">&lt;DNS正向解析示例&gt;</span></p>

<p>工具：虚拟机</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; centos7&nbsp;</p>

<p>配置：Linux&nbsp; &nbsp;IP 192.168.196.132</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DSN&nbsp; &nbsp;192.168.196.132</p>

<p>要求：</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;web.wei.com &nbsp; &nbsp; &nbsp;192.168.1.1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftp.wei.com &nbsp; &nbsp; &nbsp;192.168.1.2 &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mail.wei.com &nbsp; &nbsp; 192.168.1.3<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</p>

<p>准备工作：（可以看前期教程）<br>
&nbsp; &nbsp; &nbsp;关闭SElinux，防火墙<br>
&nbsp;&nbsp; &nbsp; 配置yum源</p>

<h1><span style="color:#f33b45;">容易犯错的地方：查看/etc/resolv.conf 确保你的DNS是否正确</span></h1>

<h1><img alt="" class="has" height="152" src="https://img-blog.csdnimg.cn/20190305192006505.png" width="443"></h1>

<p>&nbsp;</p>

<h1>DNS正向解析</h1>

<p>（1）安装软件 bind&nbsp; bind-chroot</p>

<pre class="has"><code>[root@wei csdn]# yum install -y bind bind-chroot
</code></pre>

<p>2.编辑DNS的主配置文件，创建区域wei.com</p>

<p>新建named.conf</p>

<pre class="has"><code>[root@wei named]# vim /var/named/chroot/etc/named.conf&nbsp;</code></pre>

<p>&nbsp;填写内容</p>

<pre class="has"><code>options{
   directory “/var/named";
};
zone "wei.com"{
  type master;
  file "wei.com.zone"
}:</code></pre>

<p>&nbsp;<img alt="" class="has" height="259" src="https://img-blog.csdnimg.cn/20190305190515255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="665"></p>

<p>&nbsp;3.复制记录文件的模板，并编辑</p>

<p><span style="color:#f33b45;">模板：/usr/share/doc/bind-9.9.4/sample/var/named/named.localhost</span></p>

<pre class="has"><code>[root@wei named]# cd /usr/share/doc/bind-9.9.4/sample/var/named/

[root@wei named]# cp named.localhost /var/named/chroot/var/named/wei.com.zone 	</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>$TTL 1D
@       IN SOA  wei.com. 123456.qq.com. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      dns01.wei.com.
dns01   A       192.168.196.132
web     A       192.168.1.1
ftp     A       192.168.1.2
        MX  10  mail.wei.com.
mail    A       192.168.1.3
</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="397" src="https://img-blog.csdnimg.cn/20190305190809177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="698"></p>

<p>&nbsp;</p>

<p>4.启动named服务</p>

<pre class="has"><code>[root@wei named]# systemctl start named-chroot

[root@wei named]# systemctl start named</code></pre>

<p>开机自启</p>

<pre class="has"><code>[root@wei named]# systemctl enable named-chroot

[root@wei named]# systemctl enable named</code></pre>

<p>查看端口53</p>

<p><img alt="" class="has" height="449" src="https://img-blog.csdnimg.cn/20190305191001671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="784"></p>

<p>&nbsp;</p>

<p>5.测试</p>

<p>（1）nslookup</p>

<p><img alt="" class="has" height="605" src="https://img-blog.csdnimg.cn/20190305191444361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="670"></p>

<p><br>
（2）dig</p>

<p>[root@wei named]# dig -t A web.wei.com</p>

<p><img alt="" class="has" height="569" src="https://img-blog.csdnimg.cn/20190305191749596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="794"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Linux服务之DNS介绍</title><link>http://www.cnblogs.com/heian99/archive/2019/03/05/11972320.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 05 Mar 2019 10:46:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/03/05/11972320.html</guid><description><![CDATA[
                                            <p><strong>DNS-------Domain Name System域名系统</strong></p>

<p><strong><span style="color:#f33b45;">介绍：</span>DNS就是把域名和IP地址联系在一起的服务，有了DNS服务器，你就不用输入IP地址来访问一个网站，可以通过输入网址访问。</strong></p>

<p>&nbsp;</p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" class="has" src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=0e7681ce9d8fa0ec7f926c0b16a775d6/d043ad4bd11373f0eea42c62a80f4bfbfaed04b7.jpg"></strong></p>

<p>&nbsp;</p>

<p><strong><span style="color:#f33b45;">作用：</span>（1）将域名，主机名解析对应的ip地址 &nbsp; &nbsp; &nbsp; 正向解析<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（2）将IP地址解析成对应的主机名，域名 &nbsp; &nbsp; 反向解析 &nbsp; &nbsp;</strong></p>

<p><br><strong><span style="color:#f33b45;">区域zone：</span><br>
&nbsp;&nbsp; &nbsp;正向区域 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nangong.com<br>
&nbsp;&nbsp; &nbsp;反向区域 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;X.X.X.in-addr.arpa &nbsp; 192.168.196.0/24 &nbsp; &nbsp;196.168.1962.in-addr.arpa</strong></p>

<p>&nbsp;</p>

<p><strong><span style="color:#f33b45;">记录Record</span><br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;A记录 &nbsp; &nbsp; &nbsp;主机记录 &nbsp; &nbsp; &nbsp; &nbsp;www.nangong.com &nbsp; A &nbsp; 192.168.1.1<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;NS记录 &nbsp; &nbsp; 标识DNS服务器自身的名称<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NS &nbsp; &nbsp; dns1.nangong.com.<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;dns1.nangong.com &nbsp; &nbsp; &nbsp; &nbsp; A &nbsp; &nbsp;192.168.1.2<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;MX记录 &nbsp; &nbsp; 标识邮件服务器的名称<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; MX &nbsp; &nbsp; &nbsp;10 &nbsp; &nbsp;mail.nangong.com.<br>
&nbsp;&nbsp; &nbsp; &nbsp; mail.nangong.com &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A &nbsp; &nbsp;192.168.196.3<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;CNAME记录 &nbsp;别名记录 &nbsp; &nbsp;<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; m.mail.com &nbsp; CNAME &nbsp; mail.nangong.com.<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;PTR记录 &nbsp; &nbsp; 反向指针记录<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;192.168.1.1 &nbsp; &nbsp;PTR &nbsp; &nbsp; www.nangong.com.<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</strong></p>

<p><strong>DNS域名结构：</strong></p>

<p><strong>&nbsp; &nbsp; . &nbsp;根域<br>
&nbsp; &nbsp; &nbsp; &nbsp;com<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jd &nbsp; &nbsp; &nbsp;www.jd.com----------&gt;www.jd.com.<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; baidu<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; taobao<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;cn&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;edu<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;org<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
DNS解析方式：<br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; 递归<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 客户端只需要向DNS服务器发送一次请求<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;迭代<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 客户端需要发送多次DNS请求</strong></p>
                                    ]]></description></item><item><title>Linux文件服务管理之nfs</title><link>http://www.cnblogs.com/heian99/archive/2019/02/04/11972321.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 04 Feb 2019 11:57:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/02/04/11972321.html</guid><description><![CDATA[
                                            <p><strong>NFS（Network File System）即网络文件系统，<br>
是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。<br>
在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</strong></p>

<p><strong>NFS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-----------Network File Syste &nbsp; &nbsp;网络文件系统</strong></p>

<p><br><strong>作用：在Linux服务器间实现数据共享</strong></p>

<p><strong>软件：nfs-utils<br>
&nbsp; &nbsp; &nbsp; rpcbind<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
目录导出文件----/etc/exports</strong></p>

<p><strong>文件格式：</strong></p>

<p><br><strong>&nbsp; &nbsp; &nbsp; &nbsp;目录名称 &nbsp; &nbsp;客户端地址（权限）<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;客户端地址：<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; IP地址：192.168.196.131<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 网关：192.168.196.0/24<br>
&nbsp; &nbsp; &nbsp; &nbsp; 权限：<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ro &nbsp; &nbsp; &nbsp; &nbsp; 只读<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; rw &nbsp; &nbsp; &nbsp; &nbsp; 读写<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; sync &nbsp; &nbsp; &nbsp; 同步<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; async &nbsp; &nbsp; &nbsp;异步<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;all_squash &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 客户端所有用户上传的文件的所属均为nfsnobody<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; root_squash &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端root用户上传的文件的所属会被映射为nfsnobody<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; no_root_squash &nbsp; &nbsp; &nbsp; &nbsp; 客户端root用户上传的文件所属仍为root<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; anonuid=&lt;number&gt;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; anongid=&lt;number&gt;<br>
&nbsp;&nbsp;</strong></p>

<h2><strong>Linux服务器：192.168.196.131</strong></h2>

<h2><strong>Linux客户端：192.168.196.131</strong></h2>

<p><strong>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
示例：<br>
&nbsp; &nbsp; 通过nfs共享本地目录/wedata 允许192.168.196.132以只读方式挂载</strong></p>

<p><br><strong>（1）安装软件</strong></p>

<pre class="has"><code>[root@wei ~]# yum -y install rpcbind nfs-utils</code></pre>

<p><strong>（2）创建文件</strong></p>

<pre class="has"><code>[root@wei ~]# mkdir /wedata
[root@wei ~]# touch /wedata/{1..10}.html</code></pre>

<p><strong>（3）修改配置文件/etc/exports</strong></p>

<pre class="has"><code>[root@wei ~]# vim /etc/exports
</code></pre>

<pre class="has"><code>/wedata &nbsp; &nbsp;192.168.196.132(ro)

</code></pre>

<p><br><strong>（4）重启服务</strong></p>

<pre class="has"><code>[root@wei ~]# systemctl restart rpcbind
[root@wei ~]# systemctl restart nfs-server</code></pre>

<p>或者下面的命令</p>

<p><img alt="" class="has" height="406" src="https://img-blog.csdnimg.cn/20190204195131540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="985"></p>

<p>&nbsp;</p>

<p><strong>（5）查看本地共享目录</strong></p>

<pre class="has"><code>[root@wei ~]# showmount -e localhost
Export list for localhost:
/wedata 192.168.196.132</code></pre>

<p><strong>（6）客户端访问（软件也需要安装）</strong></p>

<pre class="has"><code>[root@zhang ~]# mount 192.168.196.131:/wedata /web/
[root@zhang ~]# ls /web/
10.html &nbsp;1.html &nbsp;2.html &nbsp;3.html &nbsp;4.html &nbsp;5.html &nbsp;6.html &nbsp;7.html &nbsp;8.html &nbsp;9.html</code></pre>

<p><br><strong>设置为开机挂载 &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 修改配置文件/etc/fstab&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>[root@zhang ~]# vim /etc/fstab&nbsp;</code></pre>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;192.168.196.131:/wedata &nbsp; /web &nbsp;nfs defaults 0 0</code></pre>

<p><img alt="" class="has" height="692" src="https://img-blog.csdnimg.cn/20190204195305806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="986"></p>

<p><img alt="" class="has" height="692" src="https://img-blog.csdnimg.cn/20190204195424733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="986"></p>

<p>至于权限修改，根据情况可以来修改</p>

<p><img alt="" class="has" height="692" src="https://img-blog.csdnimg.cn/20190204195620309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="986"></p>

<p><br><strong>&nbsp;&nbsp; &nbsp;</strong><br>
&nbsp;</p>                                    ]]></description></item><item><title>Linux文件服务管理之vsftpd</title><link>http://www.cnblogs.com/heian99/archive/2019/02/03/11972322.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 03 Feb 2019 13:08:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/02/03/11972322.html</guid><description><![CDATA[
                                            <p>简介</p>

<p>vsftpd是 “very secure FTP deamon”的缩写，是一个完全免费，开源的<a href="https://www.baidu.com/s?wd=ftp%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" rel="nofollow">ftp服务器</a>软件。</p>

<p>&nbsp;</p>

<p>特点</p>

<p>小巧轻快，安全易用，支持虚拟用户、支持带宽限制等功能。</p>

<p>FTP &nbsp; &nbsp;------------File Transfer Protocol &nbsp;文件传输协议</p>

<p>FTP协议的连接模式：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主动连接<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 被动连接<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
软件：vsftpd<br>
配置文件：/etc/vsftpd/vsftpd.conf<br>
服务：vsftpd<br>
端口：21/tcp &nbsp;命令连接端口<br>
&nbsp; &nbsp; &nbsp; 20/tcp &nbsp;数据连接端口（主动）<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
FTP根目录：<br>
&nbsp; &nbsp; &nbsp; 用户宿主目录<br>
&nbsp;&nbsp; &nbsp;<br>
访问方式：<br>
&nbsp; &nbsp; &nbsp;匿名用户访问（ftp）<br>
&nbsp;&nbsp; &nbsp; 用户认证的访问<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
示例：搭建匿名访问的FTP服务器</p>

<p>（1）安装vsftpd软件</p>

<pre class="has"><code>[root@wei csdn]# yum install -y vsftpd</code></pre>

<p><br>
（2）开启服务，开机自启</p>

<pre class="has"><code>[root@wei ftp]# systemctl start vsftpd
[root@wei ftp]# systemctl enable vsftpd</code></pre>

<p>已经成功，默认的共享目录是/var/ftp/pub路径</p>

<p><img alt="" class="has" height="201" src="https://img-blog.csdnimg.cn/20190203205019511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="529"><br>
示例：允许匿名用户上传文件</p>

<pre class="has"><code>[root@wei ~]# chmod o+w /var/ftp/pub/

[root@wei ~]# vim /etc/vsftpd/vsftpd.conf&nbsp;</code></pre>

<p><br>
anon_upload_enable=YES &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt;&gt;&gt;允许上传文件<br>
anon_mkdir_write_enable=YES &nbsp; &nbsp; &nbsp; &nbsp;&gt;&gt;&gt;&gt;允许上传目录</p>

<p><br>
anon_umask=022 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt;&gt;&gt;&gt;允许其他用户能下载匿名用户文件</p>

<p>anon_other_write_enable=YES &nbsp; &nbsp; &nbsp; &nbsp;&gt;&gt;&gt;&gt;允许修改文件名称，删除文件</p>

<p>anon_root=/comapng&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt;&gt;&gt;共享目录修改</p>

<p><img alt="" class="has" height="751" src="https://img-blog.csdnimg.cn/20190203205353620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="900"></p>

<h2><span style="color:#f33b45;"><strong>注意：圈住的是匿名用户访问时的权限，可根据上面代码修改权限</strong></span></h2>

<p>重启vsftpd软件</p>

<pre class="has"><code>[root@wei ~]# systemctl restart vsftpd</code></pre>

<p>&nbsp;</p>

<p><br>
访问方式：</p>

<p>linux客户端：</p>

<pre class="has"><code>[root@zhang hei]# lftp 192.168.196.131
lftp 192.168.196.131:~&gt; ls
drwxr-xr-x    5 0        0             111 Oct 30 19:45 pub
</code></pre>

<p>&nbsp;</p>

<p>windows客户端：</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="ftp://192.168.196.131/" rel="nofollow">ftp://192.168.196.131</a></p>

<p><img alt="" class="has" height="611" src="https://img-blog.csdnimg.cn/20190203205631866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="741"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h1><strong>本地用户认证的FTP服务</strong></h1>

<p>在普通用户家目录创建文件，可以访问这些文件</p>

<p>示例：</p>

<p>创建文件</p>

<pre class="has"><code>[root@wei ~]# ls /home/hei/
[root@wei ~]# touch /home/hei/{1..4}.txt</code></pre>

<p><br>
访问方式：</p>

<p>linux客户端：</p>

<pre class="has"><code>[root@zhang hei]# lftp 192.168.196.131 -u hei

</code></pre>

<p><img alt="" class="has" height="336" src="https://img-blog.csdnimg.cn/20190203210354197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="655"></p>

<p>windows客户端：</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="ftp://192.168.196.131/" rel="nofollow">ftp://192.168.196.131</a></p>

<p><img alt="" class="has" height="642" src="https://img-blog.csdnimg.cn/20190203210540434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="799"></p>

<p><img alt="" class="has" height="609" src="https://img-blog.csdnimg.cn/20190203210637446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="753"></p>

<p><img alt="" class="has" height="602" src="https://img-blog.csdnimg.cn/20190203210652617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="745"></p>

<p>&nbsp;</p>

<p>由此可见，可以访问用户家目录下的文件。</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux文件服务管理之Samba</title><link>http://www.cnblogs.com/heian99/archive/2019/02/03/11972323.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 03 Feb 2019 12:39:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/02/03/11972323.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<p>Linux文件服务器的搭建<br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; Samba<br>
&nbsp;&nbsp; &nbsp; vsftpd<br>
&nbsp;&nbsp; &nbsp; nfs<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
Samba服务<br>
&nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" height="481" src="https://img-blog.csdnimg.cn/2019020319415694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1023"><br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;作用：共享目录<br>
&nbsp;&nbsp; &nbsp; &nbsp;软件：Samba 服务器 ，Samba-client 客户端<br>
&nbsp;&nbsp; &nbsp; &nbsp;配置文件：/etc/smaba/smb.conf<br>
&nbsp;&nbsp; &nbsp; &nbsp;服务：smb,nmb<br>
&nbsp;&nbsp; &nbsp; &nbsp;端口：smb ---&gt;139/tcp , 445/tcp &nbsp;提供文件共享功能<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nmb ---&gt;137/udp , 138/udp &nbsp;提供解析计算机名称<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
配置文件：/etc/smaba/smb.conf</p>

<p>全局配置<br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;workgroup = SAMBA &nbsp; &nbsp; &nbsp;---设置工作组名称<br>
&nbsp;&nbsp; &nbsp; &nbsp;server string =Samba Server Version %v &nbsp; ----显示samba软件版本信息<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;interface = lo eth0 192.168.196.131？24 &nbsp; ---samba服务监听的ip地址<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;hosts allow=127.192.168.12 192.168.196.0 &nbsp;-----设置仅允许那些主机访问<br>
&nbsp;&nbsp; &nbsp; &nbsp;hosts deny=192.168.12. &nbsp;192.168.1.1/24 &nbsp; &nbsp; -----拒绝那些主机访问<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;security =user &nbsp; &nbsp; -------基于用户认证访问<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;share &nbsp; &nbsp;-------匿名访问<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
共享目录配置<br>
&nbsp; &nbsp; &nbsp; &nbsp;[共享名称]<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comment= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;====描述信息<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; path = /bj &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;====指定目录名称<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; browseable = yes &nbsp; &nbsp; &nbsp; &nbsp;====可下载文件<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; writable = yes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;====可上传文件<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; public = yes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;====运行所有用户访问<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; write list =user1 &nbsp; &nbsp; &nbsp; ====仅允许user1可上传文件</p>

<h1><br>
&nbsp;&nbsp; &nbsp; &nbsp;<br><span style="color:#f33b45;">示例：</span></h1>

<p><br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;环境描述：<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Linux &nbsp; 192.168.196.131 &nbsp; &nbsp; &nbsp; Centos7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;文件共享服务器<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
windows/Linux客户端<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp; &nbsp; 需求：通过samba软件将本地的/caiwu 目录共享，客户端可以通过hei用户访问，仅允许下载文件&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
前提：selinux和防火墙全部关闭<br>
（1）安装软件<br>
&nbsp;</p>

<pre class="has"><code>[root@wei ~]# &nbsp;yum -y install samba samba-client</code></pre>

<p><br>
&nbsp;<br>
创建共享用户</p>

<pre class="has"><code>[root@wei ~]# useradd hei
[root@wei ~]# smbpasswd -a hei</code></pre>

<p><img alt="" class="has" height="192" src="https://img-blog.csdnimg.cn/20190203194601751.png" width="986"><br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</p>

<p>查看共享用户</p>

<pre class="has"><code>[root@wei ~]# pdbedit -L</code></pre>

<p><img alt="" class="has" height="73" src="https://img-blog.csdnimg.cn/20190203194857739.png" width="455"></p>

<p>配置文件/etc/smaba/smb.conf</p>

<pre class="has"><code>[root@wei ~]# vim /etc/samba/smb.conf
</code></pre>

<pre class="has"><code>[caiwu]
        comment = caiwu
        path = /caiwu
        browseable = yes
</code></pre>

<p><img alt="" class="has" height="753" src="https://img-blog.csdnimg.cn/20190203195401688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1100"></p>

<p>重启samba服务</p>

<p>[root@wei ~]# systemctl start smb<br>
&nbsp;</p>

<pre class="has"><code>[root@wei ~]# systemctl start smb
</code></pre>

<p>&nbsp;</p>

<h1>测试访问：&nbsp;<br>
&nbsp;<br>
&nbsp;windows访问：\\192.168.196.131</h1>

<p><img alt="" class="has" height="649" src="https://img-blog.csdnimg.cn/20190203195738821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="796"></p>

<p>已经共享成功</p>

<p><img alt="" class="has" height="638" src="https://img-blog.csdnimg.cn/20190203195820428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="795"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2>&nbsp;Linux客户端：<br>
&nbsp;</h2>

<pre class="has"><code>[root@wei ~]# &nbsp;yum -y install samba-client
[root@zhang ~]# smbclient //192.168.196.131/caiwu-U hei</code></pre>

<p><img alt="" class="has" height="411" src="https://img-blog.csdnimg.cn/20190203200158864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="869"></p>

<p>&nbsp;</p>

<h1><span style="color:#f33b45;">文件的上传</span></h1>

<p>如果想要上传文件，这需要修改文件权限w为其他共享用户</p>

<p>如果不给权限会出现下面的情况</p>

<p><strong>windows客户端</strong></p>

<p><img alt="" class="has" height="648" src="https://img-blog.csdnimg.cn/20190203200624830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="797"></p>

<p>&nbsp;</p>

<p><strong>Linux客户端</strong></p>

<p><img alt="" class="has" height="146" src="https://img-blog.csdnimg.cn/20190203200719482.png" width="661"></p>

<p>重点修改文件权限w为其他共享用户</p>

<p><span style="color:#f33b45;">修改单个用户权限则可以使用下面这段命令</span></p>

<pre class="has"><code>[root@wei ~]# setfacl -m u:hei:rwx /caiwu/</code></pre>

<p><img alt="" class="has" height="196" src="https://img-blog.csdnimg.cn/20190203201501406.png" width="674"></p>

<p>修改配置文件</p>

<p><img alt="" class="has" height="311" src="https://img-blog.csdnimg.cn/20190203203249583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="658"></p>

<h2>重启就可以上传文件了</h2>

<p><img alt="" class="has" height="569" src="https://img-blog.csdnimg.cn/20190203203518173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="735"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h1><span style="color:#f33b45;">多用户示例：</span></h1>

<p>&nbsp;</p>

<p>&nbsp; <strong>&nbsp; &nbsp; &nbsp; &nbsp; 通过samba软件将本地的/shanghai目录共享，允许hei用户下载文件，允许admin用户上传文件</strong><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;<br>
（1）创建目录，创建共享用户</p>

<pre class="has"><code>[root@zhang ~]# mkdir /shichang
[root@zhang ~]# touch /shichang/{1..5}.jpg
[root@zhang ~]# useradd admin
[root@zhang ~]# useradd zhang
[root@zhang ~]# smbpasswd -a zhang
[root@zhang ~]# smbpasswd -a admin</code></pre>

<p>配置文件修改下面这样</p>

<pre class="has"><code>[shichang]
path = /shichang
browseable = yes
write list = admin</code></pre>

<p>（2）重启服务访问</p>

<p>&nbsp;</p>

<p>（3）测试访问：</p>

<p>&nbsp; &nbsp; 清除windows的共享缓存<br>
&nbsp;&nbsp; &nbsp; &nbsp;net use * /del</p>

<p><img alt="" class="has" height="339" src="https://img-blog.csdnimg.cn/20190203203814524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="647"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux服务管理之DHCP</title><link>http://www.cnblogs.com/heian99/archive/2019/02/02/11972324.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 02 Feb 2019 12:00:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/02/02/11972324.html</guid><description><![CDATA[
                                            <h2>1、DHCP服务简介</h2>

<p><strong>DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)是一个</strong><a href="https://baike.so.com/doc/3165868-3336420.html" rel="nofollow"><strong>局域网</strong></a><strong>的</strong><a href="https://baike.so.com/doc/5403497-5641193.html" rel="nofollow"><strong>网络协议</strong></a><strong>，使用</strong><a href="https://baike.so.com/doc/5418284-5656447.html" rel="nofollow"><strong>UDP</strong></a><strong>协议工作，&nbsp;主要有两个用途:给内部网络或</strong><a href="https://baike.so.com/doc/520018-550563.html" rel="nofollow"><strong>网络服务</strong></a><strong>供应商自动分配IP地址，给用户或者内部网络管理员作为对所有</strong><a href="https://baike.so.com/doc/3435270-3615253.html" rel="nofollow"><strong>计算机</strong></a><strong>作中央管理的手段，在RFC 2131中有详细的描述。DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口;546号端口用于DHCPv6 Client，而不用于DHCPv4，是为DHCP failover服务，这是需要特别开启的服务，DHCP failover是用来做"双机热备"的。</strong></p>

<h2>2、DHCP服务作用</h2>

<p><strong>为大量客户机自动分配地址，提供集中管理</strong></p>

<p><strong>减轻管理和维护成本、提高网络配置效率<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; 原理：<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.客户端发送DHCP Discovery探索DHCP服务器&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2.DHCP服务器发送DHCP Offer (IP/NETMASK/GATEWAY/DNS)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;3.客户端发送DHCP Request<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;4.DHCP服务器发送DHCP ACK<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;5.客户端发送Gratuation ARP用于检测IP地址是否冲突<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</strong><img alt="" class="has" height="450" src="https://img-blog.csdnimg.cn/20190202195928715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="932"><br><strong>软件：dhcp<br>
配置文件：/etc/dhcp/dhcpd.conf<br>
服务：dhcpd<br>
端口：67/udp（DHCP服务端口） ,68/udp（DHCP客户端端口）</strong></p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux服务管理之ntp</title><link>http://www.cnblogs.com/heian99/archive/2019/02/02/11972325.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 02 Feb 2019 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/02/02/11972325.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<p>NTP是网络时间协议(Network Time Protocol)，它是用来同步网络中各个计算机的时间的协议。</p>

<p>在计算机的世界里，时间非常地重要，例如对于火箭发射这种科研活动，对时间的统一性和准确性要求就非常地高，是按照A这台计算机的时间，还是按照B这台计算机的时间？NTP就是用来解决这个问题的，NTP（Network Time Protocol，网络时间协议）是用来使网络中的各个计算机时间同步的一种协议。它的用途是把计算机的时钟同步到<a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E5%8D%8F%E8%B0%83%E6%97%B6" rel="nofollow">世界协调时</a>UTC，其精度在局域网内可达0.1ms，在互联网上绝大多数的地方其精度可以达到1-50ms。</p>

<p>它可以使计算机对其服务器或时钟源（如石英钟，GPS等等）进行时间同步，它可以提供高精准度的时间校正，而且可以使用加密确认的方式来防止病毒的协议攻击。</p>

<p>NTP服务器</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp;NTP ----------- Network Time Protocol 网络时间协议<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; 软件：ntp<br>
&nbsp;&nbsp; &nbsp; &nbsp; 配置文件： /etc/ntp.conf<br>
&nbsp;&nbsp; &nbsp; &nbsp; 服务：ntp<br>
&nbsp;&nbsp; &nbsp; &nbsp; 端口：123/udp<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
示例：配置ntp时间服务器</p>

<p>1.安装ntp软件</p>

<pre class="has"><code>[root@wei ~]# yum install ntp -y
</code></pre>

<p><br>
2.编辑ntp配置文件</p>

<pre class="has"><code>[root@wei ~]# vim /etc/ntp.conf
</code></pre>

<p>添加下面的代码</p>

<p>restrict 192.168.196.0 mask 255.255.255.0 nomodify notrap</p>

<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;server 127.127.1.0 iburst<br>
&nbsp;27 fudge 127.127.1.0 stratum 10&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</p>

<p><br>
&nbsp;&nbsp; <img alt="" class="has" height="705" src="https://img-blog.csdnimg.cn/20190202194217860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="731">&nbsp; &nbsp;&nbsp;<br>
3.重启ntpd服务</p>

<pre class="has"><code>[root@wei ~]# systemctl start ntpd     #启动服务
[root@wei ~]# systemctl enable ntpd    #设置为开机启动
Created symlink from /etc/systemd/system/multi-user.target.wants/ntpd.service to /usr/lib/systemd/system/ntpd.service.&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;
</code></pre>

<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
在客户端输入：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>

<pre class="has"><code>&nbsp;&nbsp;&nbsp; &nbsp;[root@zhang csdn]# ntpdate 192.168.196.131</code></pre>

<p><img alt="" class="has" height="179" src="https://img-blog.csdnimg.cn/20190202194615451.png" width="922"></p>

<p>&nbsp;</p>

<p>即可同步时间</p>

<p><br>
同步网络时间：&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</p>

<pre class="has"><code> &nbsp;&nbsp;&nbsp; &nbsp;[root@wei ~]# /usr/sbin/ntpdate time.windows.com</code></pre>

<p><img alt="" class="has" height="155" src="https://img-blog.csdnimg.cn/20190202194954821.png" width="915"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux服务管理之SSH</title><link>http://www.cnblogs.com/heian99/archive/2019/02/01/11972326.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 01 Feb 2019 13:34:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/02/01/11972326.html</guid><description><![CDATA[
                                            <p><strong>Linux服务SSH</strong></p>

<p><strong>ssh服务：<br>
管理服务器的方式：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;本地管理类 &nbsp; （安装系统，故障修复）<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;SHH远程连接方式<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Linux：ssh命令<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; windows:Xshell , SecureCRT , Putty<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
提供ssh服务/ssh客户端工具的软件：<br>
openssh-clients-7.4p1-16.el7.x86_64<br>
openssh-server-7.4p1-16.el7.x86_64</strong></p>

<p><strong>查看ssh状态</strong></p>

<pre class="has"><code>[hei@wei ~]$ systemctl status sshd</code></pre>

<p><strong><img alt="" class="has" height="460" src="https://img-blog.csdnimg.cn/20190201185013920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="940"></strong></p>

<p><strong>查看ssh的端口：</strong></p>

<pre class="has"><code>[root@wei ~]# ss -antp | grep sshd</code></pre>

<p><strong><img alt="" class="has" height="365" src="https://img-blog.csdnimg.cn/20190201185103754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1175"><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
1.远程连接主机</strong></p>

<p><strong># shh [user@]host</strong></p>

<p><strong>&nbsp; &nbsp; # ssh 192.168.196.132<br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;# ssh marin@192.168.196.132<br>
&nbsp;&nbsp; &nbsp;<br>
2.远程连接主机执行命令</strong></p>

<p><strong># ssh 192.168.196.132 ‘hostname’ &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong></p>

<pre class="has"><code>[root@wei ~]# ssh hei@192.168.196.132 'hostname'
hei@192.168.196.132's password:&nbsp;
wei</code></pre>

<p><strong>3.远程复制文件工具</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp;scp &nbsp; &nbsp; &nbsp; rsync<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
# scp /etc/fstab 192.168.196.132:/tmp# scp 192.168.196.132:/etc/passwd /tmp<br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp;-r: 复制目录<br>
&nbsp;&nbsp; &nbsp;&nbsp;</strong></p>

<pre class="has"><code>[root@wei ~]# scp /etc/fstab 192.168.196.132:/tmp
root@192.168.196.132's password:&nbsp;
fstab &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;100% &nbsp;465 &nbsp; &nbsp;17.4KB/s &nbsp; 00:00 &nbsp; &nbsp;
[root@wei ~]# scp 192.168.196.132:/etc/passwd /tmp
root@192.168.196.132's password:&nbsp;
passwd&nbsp;

</code></pre>

<p><br><strong>rsync</strong></p>

<p><strong># rsync -av /bj/ 192.168.196.132:/bj &nbsp;#拷贝文件</strong></p>

<p><strong># rsync -av /bj 192.168.196.132:/bj &nbsp; #拷贝目录</strong></p>

<p><strong>配置文件：/etc/ssh/sshd_config、</strong></p>

<p><strong><span style="color:#f33b45;">注意：下面几项操作在配置文件中进行</span></strong></p>

<p><strong>(1)关闭SSH的主机名解析<br>
&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; GSSAPIAuthentication no<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" height="518" src="https://img-blog.csdnimg.cn/20190201211704865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="867"><br>
&nbsp;&nbsp; &nbsp; &nbsp; UseDNS no<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<img alt="" class="has" height="687" src="https://img-blog.csdnimg.cn/20190201211635121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="851"></strong></p>

<pre class="has"><code>&nbsp;&nbsp; &nbsp;[root@zhang ~]# systemctl restart sshd</code></pre>

<p><br><strong>（2）禁用root用户远程连接</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; PermitRootLogin no</strong></p>

<p><strong><img alt="" class="has" height="354" src="https://img-blog.csdnimg.cn/20190201211849837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="995"></strong></p>

<p><strong>（3）修改默认端口<br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;Port 1999</strong></p>

<p><strong><img alt="" class="has" height="217" src="https://img-blog.csdnimg.cn/20190201211914429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="390"></strong></p>

<p><strong><span style="color:#f33b45;">注意：此时连接需要加端口（-p） root用户已经登录不上</span></strong></p>

<pre class="has"><code>[root@wei ~]# ssh hei@192.168.196.132 -p 1999</code></pre>

<p><strong>（4）监听ip</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListenAddress 192.168.196.131</strong></p>

<p><strong><img alt="" class="has" height="217" src="https://img-blog.csdnimg.cn/20190201211914529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="390"></strong></p>

<h1>&nbsp;</h1>

<h1><strong>SSH认证方式：</strong></h1>

<h3><br><strong>&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;基于用户名，密码：默认<br>
&nbsp;&nbsp; &nbsp; &nbsp;基于密钥<br>
&nbsp;&nbsp; &nbsp; &nbsp;</strong></h3>

<p><strong>基于密钥的配置方法：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.在客户端生成密钥对<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 2.把公钥传给服务器<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
（1）在客户端生成密钥对</strong></p>

<p><span style="color:#f33b45;"><strong>注意：默认生成的密钥会存储在/root/.ssh/目录下</strong></span></p>

<pre class="has"><code>[root@wei ~]# ssh-keygen -t rsa

</code></pre>

<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</strong><img alt="" class="has" height="484" src="https://img-blog.csdnimg.cn/20190201213031258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="854"><strong>&nbsp;</strong></p>

<p><br><strong>（2）把公钥传送给服务器</strong></p>

<p><span style="color:#f33b45;"><strong>注意：传递的公钥会存储在/root/.ssh/目录下</strong></span></p>

<pre class="has"><code>[root@wei .ssh]# ssh-copy-id -i -p 1999 192.168.196.132</code></pre>

<p><img alt="" class="has" height="273" src="https://img-blog.csdnimg.cn/20190201213339720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="876"></p>

<p>&nbsp;</p>

<p><br><strong>注意：可以给普通用户复制公钥，但是要修改目录和公钥的权限为普通用户的</strong></p>

<p><img alt="" class="has" height="353" src="https://img-blog.csdnimg.cn/20190201212614669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="656"></p>                                    ]]></description></item><item><title>Linux计划任务管理</title><link>http://www.cnblogs.com/heian99/archive/2019/01/31/11972327.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 31 Jan 2019 13:08:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/31/11972327.html</guid><description><![CDATA[
                                            <h1><br><strong>计划任务</strong></h1>

<h3><strong>类型：<br>
&nbsp; &nbsp; 一次性计划任务<br>
&nbsp;&nbsp; &nbsp;周期性计划任务</strong></h3>

<h1><br><strong>&nbsp;&nbsp; &nbsp;<br>
一次性计划任务</strong></h1>

<p><strong>前提： &nbsp;atd服务必须运行</strong></p>

<pre class="has"><code>[root@wei init.d]# yum -y install at &nbsp; &nbsp; &nbsp; &nbsp;#安装atd服务

[root@wei init.d]# systemctl start atd &nbsp; &nbsp; &nbsp;#开启atd服务

[root@wei init.d]# systemctl status atd &nbsp; &nbsp; #查看atd开启状态</code></pre>

<p><br><strong><img alt="" class="has" height="335" src="https://img-blog.csdnimg.cn/20190131205405517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1008"></strong></p>

<p><strong>18:00关机（以系统时间为准）：</strong></p>

<pre class="has"><code>[root@wei init.d]# at 18:00
at&gt; poweroff
at&gt; &lt;EOT&gt; &nbsp;# Ctrl+d 提交任务
job 1 at Fri Feb &nbsp;1 18:00:00 2019</code></pre>

<p><br><strong>1分钟后执行的任务：<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>[root@wei init.d]# at now + 1 minute
at&gt; mkdir /root/nangong
at&gt; &lt;EOT&gt;
job 4 at Thu Jan 31 18:49:00 2019</code></pre>

<h1><strong>周期性计划任务</strong></h1>

<p><strong>前提：crond服务必须运行</strong></p>

<pre class="has"><code>[root@wei ~]# yum install crontabs &nbsp; &nbsp; &nbsp;#安装crond服务

[root@wei init.d]# systemctl start crond &nbsp; &nbsp; &nbsp;#开启crond服务

[root@wei ~]# systemctl status crond &nbsp; &nbsp; &nbsp; #查看crond开启状态</code></pre>

<p><strong><img alt="" class="has" height="420" src="https://img-blog.csdnimg.cn/20190131205612649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="862"><br><br>
制作周期性计划任务</strong></p>

<p><strong># crontab -e&nbsp;</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; 时间 &nbsp; &nbsp; &nbsp; &nbsp;COMMAND</strong></p>

<p><strong>时间：<br>
&nbsp; &nbsp; 分 &nbsp;时 &nbsp;日 &nbsp; 月 &nbsp; 周<br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; 分钟： 0----59<br>
&nbsp; &nbsp; 时： &nbsp; 0----23<br>
&nbsp; &nbsp; 日期： 1----31<br>
&nbsp; &nbsp; 月： &nbsp; 1---12<br>
&nbsp; &nbsp; 周： &nbsp; 0----6<br>
&nbsp; &nbsp; &nbsp;* &nbsp;表示每周（日 &nbsp; 月 &nbsp; 周）<br>
&nbsp;&nbsp; &nbsp; - &nbsp;连续的时间<br>
&nbsp;&nbsp; &nbsp; ， 不连续的时间<br>
示例：</strong></p>

<p><strong>每天晚上11:30 &nbsp; &nbsp; 30 23 * * *<br>
每天零点 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 0 * * *&nbsp;&nbsp; &nbsp;<br>
每天早上8:10 9:10 10:10 &nbsp; 10 8-10 * * * &nbsp;<br>
每隔5分钟 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/5 * * * *<br>
每隔3小时 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* */3 * * *&nbsp;&nbsp; &nbsp; &nbsp;</strong></p>

<p><strong>COMMAND命令：&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.建议写命令的完整路径 /bin/mkdir/abc<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 2.只能写一条命令（shell）<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</strong><br>
&nbsp;</p>

<h3><strong><span style="color:#f33b45;">注意：<br>
&nbsp; &nbsp; &nbsp; &nbsp;在写命令时%在周期性计划任务中是结束的意思，因此在使用%时，需要加\右斜杠转义<br>
&nbsp;&nbsp; &nbsp; &nbsp; &amp;&gt; /dev/null &nbsp;不给用户发邮件</span><br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</strong></h3>

<p><strong>创建计划任务</strong></p>

<p><strong>示例：<br>
（1）每分钟在tmp目录下创建文件</strong></p>

<p><strong>[root@wei ~]# crontab -e&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</strong></p>

<p><strong>*/1 * * * * &nbsp; /usr/bin/touch /tmp/wei/$(date +\%F-\%T).txt</strong></p>

<p><strong><img alt="" class="has" height="453" src="https://img-blog.csdnimg.cn/20190131205939941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1050"></strong></p>

<p><strong>（2）每分钟分别显示磁盘使用，cpu状态，内存状态的信息</strong></p>

<p><strong><span style="color:#f33b45;">分析：一行只能写一条命令，但要显示三个命令，则需要借助shell脚本。然后在周期性任务中调用shell脚本。</span></strong></p>

<p><strong><span style="color:#7c79e5;">（1）创建shell脚本</span></strong></p>

<pre class="has"><code>[root@wei ~]# vim hei.sh
#!/bin/bash
echo
echo "CPU负载"
uptime
echo
echo "磁盘容量："
df -hT
echo
echo "内存容量"
free -h</code></pre>

<p><strong><span style="color:#7c79e5;">我在次调用演示。</span></strong></p>

<p><strong><img alt="" class="has" height="560" src="https://img-blog.csdnimg.cn/20190131210452568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="973"></strong></p>

<p><strong><span style="color:#7c79e5;">（2）创建周期性任务</span></strong><br>
&nbsp;</p>

<pre class="has"><code>[root@wei ~]# crontab -e&nbsp;&nbsp; &nbsp;&nbsp;

*/1 * * * * &nbsp;/usr/bin/bash /root/hei.sh </code></pre>

<p><strong><span style="color:#f33b45;">注意：这个会给root用户发邮件显示shell脚本运行的信息</span></strong></p>

<p>&nbsp;</p>

<pre class="has"><code>*/1 * * * *  /usr/bin/bash /root/hei.sh &amp;&gt; /dev/null</code></pre>

<p><strong><span style="color:#f33b45;">&nbsp; &amp;&gt; /dev/null &nbsp;不给用户发邮件</span></strong></p>

<p><br><strong>查看计划任务</strong></p>

<pre class="has"><code>[root@wei ~]# crontab -l
*/1 * * * * &nbsp; /usr/bin/touch /tmp/wei/$(date +\%F-\%T).txt
*/1 * * * * &nbsp;/usr/bin/bash /root/hei.sh &amp;&gt; /dev/null</code></pre>

<p><strong>删除计划任务（全部删除）</strong></p>

<pre class="has"><code>[root@wei ~]# crontab -r</code></pre>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux系统运行模式介绍</title><link>http://www.cnblogs.com/heian99/archive/2019/01/31/11972328.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 31 Jan 2019 12:51:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/31/11972328.html</guid><description><![CDATA[
                                            <p>Linux运行模式</p>

<ul><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自由服务，即不需要用户独立去安装的软件服务，而是在系统安装好之后就可以直接使用的服务（内置服务）。</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行模式也称为运行级别，属于linux的自有服务。</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行模式可以理解为一旦你开机了，计算机就以你设置的运行模式给你展示。</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;控制运行模式的进程是：init&nbsp;&nbsp;&nbsp;，初始化进程，进程id是1。</li>
</ul><p>Centos 7系统运行方式（target）：</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; multi—user.target &nbsp;字符模式（多用户模式）<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graphical.target &nbsp; &nbsp;图像模式<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
（1）查看当前的默认级别：</p>

<pre class="has"><code>[root@wei ~]# systemctl get-default
multi-user.target</code></pre>

<p>（2）修改默认级别</p>

<pre class="has"><code>[root@wei ~]# systemctl get-default graphical.target</code></pre>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>

<p>Centos 6系统运行方式：<br>
&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp;关机模式<br>
&nbsp;&nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp;单用户模式（修复）<br>
&nbsp;&nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp;字符模式（无网络）<br>
&nbsp;&nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp;完全字符模式（黑底白字）<br>
&nbsp;&nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp;预留<br>
&nbsp;&nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp;图形模式<br>
&nbsp;&nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp;重启模式&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
查看当前的默认级别</p>

<pre class="has"><code>[root@wei ~]# runlevel&nbsp;
N 3
&nbsp;&nbsp; &nbsp; &nbsp;</code></pre>

<p><br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
init id 可以来回切换模式<br>
编辑文件/etc/inittab修改默认的启动模式</p>

<p><br>
&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;</p>

<p><br>
&nbsp;</p>                                    ]]></description></item><item><title>Linux进程控制</title><link>http://www.cnblogs.com/heian99/archive/2019/01/30/11972329.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 30 Jan 2019 12:52:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/30/11972329.html</guid><description><![CDATA[
                                            <p><strong>Linux上进程有5种状态，这5中状态可以与一般操作系统的状态对应起来：</strong></p>

<ul><li><strong>运行：正在运行或在运行队列中等待。</strong></li>
	<li><strong>中断：休眠中， 受阻， 在等待某个条件的形成或接受到信号。</strong></li>
	<li><strong>不可中断：收到信号不唤醒和不可运行， 进程必须等待直到有中断发生。</strong></li>
	<li><strong>僵死：进程已终止， 但进程描述符存在， 直到父进程调用wait4()系统调用后释放。</strong></li>
	<li><strong>停止：进程收到SIGSTOP， SIGSTP， SIGTIN， SIGTOU信号后停止运行运行。</strong></li>
</ul><p><br><strong>进程控制</strong></p>

<p><strong>&nbsp; &nbsp; 信号：Signal<br>
&nbsp;&nbsp; &nbsp;<br>
查看所有的信号</strong></p>

<pre class="has"><code>[root@wei csdn]# kill -l
&nbsp;1) SIGHUP&nbsp;&nbsp; &nbsp; 2) SIGINT&nbsp;&nbsp; &nbsp; 3) SIGQUIT&nbsp;&nbsp; &nbsp; 4) SIGILL&nbsp;&nbsp; &nbsp; 5) SIGTRAP
&nbsp;6) SIGABRT&nbsp;&nbsp; &nbsp; 7) SIGBUS&nbsp;&nbsp; &nbsp; 8) SIGFPE&nbsp;&nbsp; &nbsp; 9) SIGKILL&nbsp;&nbsp; &nbsp;10) SIGUSR1
11) SIGSEGV&nbsp;&nbsp; &nbsp;12) SIGUSR2&nbsp;&nbsp; &nbsp;13) SIGPIPE&nbsp;&nbsp; &nbsp;14) SIGALRM&nbsp;&nbsp; &nbsp;15) SIGTERM
16) SIGSTKFLT&nbsp;&nbsp; &nbsp;17) SIGCHLD&nbsp;&nbsp; &nbsp;18) SIGCONT&nbsp;&nbsp; &nbsp;19) SIGSTOP&nbsp;&nbsp; &nbsp;20) SIGTSTP
21) SIGTTIN&nbsp;&nbsp; &nbsp;22) SIGTTOU&nbsp;&nbsp; &nbsp;23) SIGURG&nbsp;&nbsp; &nbsp;24) SIGXCPU&nbsp;&nbsp; &nbsp;25) SIGXFSZ
26) SIGVTALRM&nbsp;&nbsp; &nbsp;27) SIGPROF&nbsp;&nbsp; &nbsp;28) SIGWINCH&nbsp;&nbsp; &nbsp;29) SIGIO&nbsp;&nbsp; &nbsp;30) SIGPWR
31) SIGSYS&nbsp;&nbsp; &nbsp;34) SIGRTMIN&nbsp;&nbsp; &nbsp;35) SIGRTMIN+1&nbsp;&nbsp; &nbsp;36) SIGRTMIN+2&nbsp;&nbsp; &nbsp;37) SIGRTMIN+3
38) SIGRTMIN+4&nbsp;&nbsp; &nbsp;39) SIGRTMIN+5&nbsp;&nbsp; &nbsp;40) SIGRTMIN+6&nbsp;&nbsp; &nbsp;41) SIGRTMIN+7&nbsp;&nbsp; &nbsp;42) SIGRTMIN+8
43) SIGRTMIN+9&nbsp;&nbsp; &nbsp;44) SIGRTMIN+10&nbsp;&nbsp; &nbsp;45) SIGRTMIN+11&nbsp;&nbsp; &nbsp;46) SIGRTMIN+12&nbsp;&nbsp; &nbsp;47) SIGRTMIN+13
48) SIGRTMIN+14&nbsp;&nbsp; &nbsp;49) SIGRTMIN+15&nbsp;&nbsp; &nbsp;50) SIGRTMAX-14&nbsp;&nbsp; &nbsp;51) SIGRTMAX-13&nbsp;&nbsp; &nbsp;52) SIGRTMAX-12
53) SIGRTMAX-11&nbsp;&nbsp; &nbsp;54) SIGRTMAX-10&nbsp;&nbsp; &nbsp;55) SIGRTMAX-9&nbsp;&nbsp; &nbsp;56) SIGRTMAX-8&nbsp;&nbsp; &nbsp;57) SIGRTMAX-7
58) SIGRTMAX-6&nbsp;&nbsp; &nbsp;59) SIGRTMAX-5&nbsp;&nbsp; &nbsp;60) SIGRTMAX-4&nbsp;&nbsp; &nbsp;61) SIGRTMAX-3&nbsp;&nbsp; &nbsp;62) SIGRTMAX-2
63) SIGRTMAX-1&nbsp;&nbsp; &nbsp;64) SIGRTMAX&nbsp;&nbsp; &nbsp;</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><strong>常用的信号：</strong></p>

<p><strong>&nbsp; &nbsp; 1) SIGHUP &nbsp; &nbsp; 让一个进程不用重启，就可以重读其配置文件，并让新配置生效<br>
&nbsp;&nbsp; &nbsp;2) SIGINT &nbsp; &nbsp; 硬件中断信号。 Ctrl+c<br>
&nbsp;&nbsp; &nbsp;9) SIGKILL &nbsp; &nbsp;杀死一个进程<br>
&nbsp;&nbsp; &nbsp;15) SIGTERM &nbsp; 终止一个进程<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
如何调用一个信号：<br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; 信号号码： kill -9 &lt;PID&gt; （杀死程序后，要删除交互文件，才能正常恢复）<br>
&nbsp;&nbsp; &nbsp; 信号名称： kil -SIGKILL &lt;PID&gt;<br>
&nbsp;&nbsp; &nbsp; 信号名称简写：kill -KILL &lt;PID&gt;</strong></p>

<p><strong># kill &lt;PID&gt;</strong></p>

<p><strong># killall &lt;PROCESS_NAME&gt;&nbsp;&nbsp; &nbsp;</strong></p>

<pre class="has"><code>[root@wei csdn]# killall httpd</code></pre>

<p><br><strong>控制进程的运行方式（前台/后台）<br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp;前台：占用命令提示符</strong></p>

<p><strong>（1）控制命令在后台运行</strong></p>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei csdn]# firefox &amp;</code></pre>

<p><br><strong>（2）查看后台的应用程序</strong></p>

<pre class="has"><code>[root@wei csdn]# jobs -l

</code></pre>

<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;<br>
（3）将正在运行的指令放入后台，并暂停运行</strong></p>

<p><br><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Ctrl+z</strong></p>

<p><br><strong>（4）将后台的程序调回前台继续运行</strong></p>

<p><strong># fg &lt;后台任务编号&gt;</strong><br>
&nbsp;</p>                                    ]]></description></item><item><title>Linux进程管理之top</title><link>http://www.cnblogs.com/heian99/archive/2019/01/29/11972330.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 29 Jan 2019 09:11:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/29/11972330.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<p>关于Linux进程查看，前面讲解了ps命令，下面拉介绍另一个命令top</p>

<p>&nbsp;</p>

<p>ps：静态查看</p>

<p>top：动态查看</p>

<p><br>
动态查看进程的状态&nbsp;</p>

<p># top</p>

<p><br><img alt="" class="has" height="809" src="https://img-blog.csdnimg.cn/2019012917095356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1119"></p>

<pre class="has"><code>[root@wei ~]# top
top - 18:38:46 up 15 min,  2 users,  load average: 0.09, 0.07, 0.06
Tasks:  98 total,   1 running,  97 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.0 us,  1.3 sy,  0.0 ni, 97.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :   997956 total,   613748 free,   215484 used,   168724 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.   605556 avail Mem 
 </code></pre>

<p><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7.6%us &nbsp;用户进程占用的CPU<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 1.6%sy &nbsp;系统进程占用的CPU<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 0.0%ni &nbsp;调整过优先级的进程占用的CPU<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 90.6%id &nbsp;CPU空闲<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 0.0%wa &nbsp; 等待磁盘IO的进程所占用的CPU<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
Cpu(s) :显示所有的CPU平均比，按1可现实每个CPU的使用情况</p>

<p>top交互式指令：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; M：按内存使用排序<br>
&nbsp; &nbsp; &nbsp; &nbsp; P：按CPU使用排序&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;T：按运行时间排序<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;l: 是否显示TOP第1行信息<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;m: 是否显示内存使用信息<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;t: 是否显示CPU及任务信息<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;c：是否显示完整的命令行<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;q：退出TOP<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>

<p><br>
显示当前时刻CPU的使用情况</p>

<pre class="has"><code>[root@wei ~]# uptime
&nbsp;19:03:27 up 39 min, &nbsp;2 users, &nbsp;load average: 0.00, 0.01, 0.05</code></pre>

<p>top选项：<br>
&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;-d 1 ：指定top信息刷新的频率<br>
&nbsp;&nbsp; &nbsp; &nbsp;-b &nbsp;：以批模式显示进程信息<br>
&nbsp;&nbsp; &nbsp; &nbsp;-n 2：共显示两批信息<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
# top -d 1 -b -n 2</p>

<p><br>
查看服务器性能 ：<br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1.ps ，top<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2.df &nbsp;-hT<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;3.free -m &nbsp;查看磁盘<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
使用这三个命令需要安装sysstat</p>

<pre class="has"><code>[root@wei csdn]# yum install sysstat</code></pre>

<p>&nbsp;&nbsp; &nbsp;# mpstat &nbsp; 查看CPU</p>

<p>&nbsp; &nbsp; # vmstat &nbsp; 查看内存<br>
&nbsp;&nbsp; &nbsp;# iostat &nbsp; 查看磁盘<br>
&nbsp; &nbsp; # sar &nbsp; &nbsp; &nbsp;查看网卡<br>
&nbsp;</p>

<p>四个基本用法一样，参数设置一样。</p>

<pre class="has"><code>[root@wei csdn]# mpstat 1 &nbsp; &nbsp; 一秒显示一次
[root@wei csdn]# mpstat 1 5 &nbsp; &nbsp; 一秒显示一次，显示5次</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux进程管理之ps</title><link>http://www.cnblogs.com/heian99/archive/2019/01/29/11972331.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Tue, 29 Jan 2019 08:45:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/29/11972331.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<p><strong><a href="http://lib.csdn.net/base/linux" rel="nofollow">Linux</a>&nbsp;是一种动态系统，能够适应不断变化的计算需求。</strong><strong>下面介绍一些 Linux 所提供的工具来进行进程的查看与控制，掌握这些让我们能在某些进程出现异常的时候及时查看相关的指标，从而解决问题。</strong></p>

<p>&nbsp;</p>

<p><br><strong>进程管理</strong></p>

<p><strong>进程 &nbsp; process<br>
&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; 某应用程序打开的进程<br>
&nbsp;&nbsp; &nbsp; &nbsp; PID &nbsp; &nbsp; &nbsp; &nbsp; Process ID<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; 类型：<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;用户空间进程<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;内核空间进程</strong></p>

<p><br><strong>用户空间进程：通过执行用户程序、应用程序或内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</strong></p>

<p><strong>内核空间进程：可以执行内存资源分配和进程切换等管理工作；而且，该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行</strong>。</p>

<p>&nbsp;</p>

<p>静态查看进程状态</p>

<pre class="has"><code># ps
 
[root@wei csdn]# ps                &gt;&gt;&gt;&gt;查看本终端的进程
   PID TTY          TIME CMD
  1806 pts/1    00:00:00 bash
  2805 pts/1    00:00:00 ps
</code></pre>

<p>选项的使用方式：</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; BSD风格：选项没有横线- &nbsp; &nbsp; &nbsp; &nbsp;ps aux<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SysV风格：选项需要带有横线- &nbsp; ps -elf<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
BSD风格：<br>
&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; a ：显示与终端相关的进程<br>
&nbsp;&nbsp; &nbsp; &nbsp; u : 显示启动进程的用户<br>
&nbsp;&nbsp; &nbsp; &nbsp; x ：显示与终端无关的程序<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</p>

<pre class="has"><code># ps a

# ps u

# ps x</code></pre>

<pre class="has"><code>
[root@wei csdn]# ps u
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       1343  0.0  0.2 115436  2032 pts/0    Ss+  19:59   0:00 -bash
root       1674  0.0  0.2 115432  2032 tty1     Ss+  20:01   0:00 -bash</code></pre>

<p>&nbsp;</p>

<table border="1" cellpadding="2" cellspacing="1"><tbody><tr><td>USER</td>
			<td>运行进程的用户</td>
		</tr><tr><td>%CPU</td>
			<td>进程所占欧诺个的CPU百分比</td>
		</tr><tr><td>&nbsp;%MEM&nbsp;</td>
			<td>进程所占用的MEM百分比</td>
		</tr><tr><td>VSZ&nbsp;</td>
			<td>虚拟内存集，进程独有的内存+共享存在</td>
		</tr><tr><td>PSS</td>
			<td>进程独有的内存</td>
		</tr></tbody></table><p>&nbsp;</p>

<p>STAT &nbsp; &nbsp;进程的状态</p>

<p>&nbsp; &nbsp; &nbsp; D: 不可中断的睡眠（等待磁盘IO完成）<br>
&nbsp; &nbsp; &nbsp; S：可中断的睡眠（不需要等待磁盘IO完成）<br>
&nbsp; &nbsp; &nbsp; R：运行或就绪<br>
&nbsp; &nbsp; &nbsp; T: 停止<br>
&nbsp; &nbsp; &nbsp; Z：僵死 &nbsp;Zombie</p>

<p>&nbsp; &nbsp; &nbsp; &lt; :高优先级进程<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 会被CPU优先执行<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 会获取更多的CPU执行时间&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;N:低优先级进程<br>
&nbsp;&nbsp; &nbsp; &nbsp;+：前台进程组中的进程<br>
&nbsp;&nbsp; &nbsp; &nbsp;l:多线程进程（Thread）<br>
&nbsp;&nbsp; &nbsp; &nbsp;s：会话进程首进程，某一个连接的父进程</p>

<pre class="has"><code>[root@wei csdn]# ps aux |less
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.1  0.6 127940  6580 ?        Ss   19:58   0:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root          2  0.0  0.0      0     0 ?        S    19:58   0:00 [kthreadd]
root          3  0.0  0.0      0     0 ?        S    19:58   0:00 [ksoftirqd/0]
root          5  0.0  0.0      0     0 ?        S&lt;   19:58   0:00 [kworker/0:0H]</code></pre>

<p><strong><span style="color:#f33b45;">&nbsp;带有方括号为系统进程（Linux内核启动）<br>
&nbsp; &nbsp;无方括号的（用户进程）</span></strong></p>

<p><br>
SysV风格选项：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;-e &nbsp;显示所有进程<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;-l &nbsp;详细信息<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;-f &nbsp;以长格式显示（更多字段类容）</p>

<pre class="has"><code>[root@wei csdn]# ps -elf | less
F S UID         PID   PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root          1      0  0  80   0 - 31985 ep_pol 19:58 ?        00:00:04 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
1 S root          2      0  0  80   0 -     0 kthrea 19:58 ?        00:00:00 [kthreadd]
1 S root          3      2  0  80   0 -     0 smpboo 19:58 ?        00:00:01 [ksoftirqd/0]
	</code></pre>

<p>进程优先级：<br>
&nbsp; &nbsp; &nbsp; 0---139<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;数据越小，越先级越高<br>
&nbsp;&nbsp; &nbsp; &nbsp;<br>
高优先级进程：<br>
&nbsp; &nbsp; 会获取CPU更多的执行时间<br>
&nbsp;&nbsp; &nbsp;会被CPU优先执行<br>
&nbsp;&nbsp; &nbsp;<br>
nice值：<br>
&nbsp; &nbsp; 新优先级=旧优先级——nice值<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;-20----19<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;普通用户仅能够调大nice值，既降低进程优先级<br>
&nbsp;&nbsp; &nbsp;root用户可以随意调整nice值<br>
&nbsp;&nbsp; &nbsp;<br>
显示进程树</p>

<pre class="has"><code>[root@wei csdn]# yum install psmisc  #  安装显示pstree的命令包

[root@wei csdn]# pstree
systemd─┬─NetworkManager───2*[{NetworkManager}]
        ├─VGAuthService
        ├─auditd───{auditd}
        ├─crond
        ├─dbus-daemon───{dbus-daemon}
        ├─login───bash
        ├─lvmetad
        ├─master─┬─pickup
        │        └─qmgr
        ├─mysqld_safe───mysqld───21*[{mysqld}]
        ├─polkitd───5*[{polkitd}]
        ├─rsyslogd───2*[{rsyslogd}]
        ├─sshd─┬─2*[sshd───bash]
        │      └─sshd───bash───pstree
        ├─systemd-journal
        ├─systemd-logind
        ├─systemd-udevd
        ├─tuned───4*[{tuned}]
        └─vmtoolsd───{vmtoolsd}
</code></pre>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei csdn]# ps aux | grep vim
root       2917  0.2  0.5 151600  5136 pts/2    S+   21:39   0:00 vim list
root       2925  0.0  0.0 112720   984 pts/1    R+   21:43   0:00 grep --color=auto vim
[root@wei csdn]# pidof vim
2917
[root@wei csdn]# pidof bash
1828 1806 1674 1343</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux的网络参数设置</title><link>http://www.cnblogs.com/heian99/archive/2019/01/28/11972332.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 28 Jan 2019 08:09:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/28/11972332.html</guid><description><![CDATA[
                                            <p><br><strong>前面讲解了lLinux 的IP组成，下面就讲一下Linux的网络设置和数据传递。</strong></p>

<p><strong>其实这地方对运维的人员来说，不会要精通，但还是要了解。必要时刻还会用到的</strong></p>

<p>&nbsp;</p>

<p><strong>电脑之间数据的传递：</strong></p>

<p><strong>数据的传递要分为下面几层。</strong></p>

<p><strong>OSI七层模型<br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;应用层 &nbsp;表示层 &nbsp;会话层 &nbsp;传输层 &nbsp;网络层 &nbsp;数据链路层 &nbsp;物理层<br>
&nbsp;&nbsp; &nbsp;<br>
数据封装过程：<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;MAC帧头+IP报头+TCP/UDP报头+数据<br>
&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TCP/UDP报头:<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;端口号 &nbsp;Port &nbsp;区分不同的应用程序<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;取值范围：1---65535 &nbsp;基于ip地址</strong><br>
&nbsp;</p>

<p><strong>数据解包，则反之。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong></p>

<p>&nbsp;</p>

<p><br><strong>centos 7 提供network ，NetworkManager服务实现网络参数</strong></p>

<p><strong>基于network服务</strong></p>

<p><strong>1.查看操作</strong></p>

<p><strong>（1）查看网卡IP地址</strong></p>

<p><strong># ifconfig</strong></p>

<p><strong># ip addr show</strong></p>

<p><img alt="" class="has" height="804" src="https://img-blog.csdnimg.cn/20190128160215859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="922"></p>

<p><strong>（2）查看网关</strong></p>

<p><strong># &nbsp;route -n&nbsp;</strong></p>

<p><strong># ip route</strong></p>

<p><img alt="" class="has" height="357" src="https://img-blog.csdnimg.cn/20190128160308293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="885"></p>

<p><strong>（3）查看DNS服务地址</strong></p>

<p><strong># cat /etc/resolv.conf</strong></p>

<pre class="has"><code>[root@wei ~]# cat /etc/resolv.conf</code></pre>

<p><img alt="" class="has" height="271" src="https://img-blog.csdnimg.cn/20190128160340332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="571"></p>

<p>&nbsp;</p>

<p><strong>修改网卡TCP/IP参数</strong></p>

<p><strong>配置文件地方 /etc/sysconfig/network-scripts/ifcfg-ens33&nbsp;</strong></p>

<p><br><strong>内容:<br>
DEVICE=网卡名称<br>
NANE=网卡配置文件名称<br>
ONBOOT=yes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//设置开机自动启动网卡<br>
BOOTPROTO=none &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //手动指定IP<br>
IPADDR=192.168.196.131 &nbsp; //IP地址&nbsp;<br>
NETMASK=255.255.255.0 &nbsp; &nbsp;//子网掩码 &nbsp;或者PREFIX=24<br>
GATEWAY=192.168.196.2 &nbsp; &nbsp;//网关<br>
DNS1=8.8.8.8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //dns服务地址<br>
DNS2=8.8.4.4</strong></p>

<p><strong>示例：</strong></p>

<p><strong>&nbsp; &nbsp;为eth0网卡配置多个IP地址 &nbsp; 10.1.1.1/24<br>
&nbsp; &nbsp;<br>
临时生效：</strong></p>

<p><strong>[root@wei ~]# ifconfig ens33:0 10.1.1.1/24</strong></p>

<p><strong>[root@wei ~]# ip addr dev ens33 10.1.1.1/24</strong></p>

<p><strong>永久生效：</strong></p>

<p><strong>[root@wei ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33:0</strong></p>

<p><br><strong>DEVICE=en33s:0<br>
NANE=ens33:0<br>
ONBOOT=yes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
BOOTPROTO=none &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
IPADDR=192.168.196.131 &nbsp;&nbsp;<br>
NETMASK=255.255.255.0 &nbsp;&nbsp;</strong></p>

<p><br><strong>[root@wei ~]# systemctl restart NetworkManager<br>
[root@wei ~]# systemctl restart network</strong></p>

<p><strong>临时禁用网卡</strong></p>

<p><strong># ifdown 网卡名称</strong></p>

<p><strong>启用网卡</strong></p>

<p><strong># if 网卡名称</strong></p>

<p><br><strong>端口号（port）：</strong></p>

<p><strong>（1）查看TCP端口</strong></p>

<p><strong>[root@wei csdn]# ss -antp</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; a: all &nbsp;全部<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;n：number &nbsp;数据<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;p：port &nbsp; 端口号：<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;t：tcp &nbsp; &nbsp;协议<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
[root@wei csdn]# netstat -antp</strong></p>

<p><img alt="" class="has" height="795" src="https://img-blog.csdnimg.cn/20190128160543333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="945"><br><strong>（2）查看UDP端口</strong></p>

<p><strong>[root@wei csdn]# ss -anup</strong></p>

<p><strong>[root@wei csdn]# netstat -anup</strong></p>

<p><img alt="" class="has" height="248" src="https://img-blog.csdnimg.cn/20190128160640176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="944"></p>

<p><br><strong>（3）查看所有的UDP和TCP的端口</strong></p>

<p><br><strong>[root@wei csdn]# netstat -anutp<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
[root@wei csdn]# ss -anutp</strong></p>

<p><img alt="" class="has" height="761" src="https://img-blog.csdnimg.cn/2019012816075689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="915"></p>

<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</strong></p>                                    ]]></description></item><item><title>Linux的IP详解</title><link>http://www.cnblogs.com/heian99/archive/2019/01/27/11972333.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 27 Jan 2019 14:23:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/27/11972333.html</guid><description><![CDATA[
                                            <h1><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;俗话说：黑发不知勤学早，白首方悔读书迟。</strong></h1>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ————正是年轻的我们，更应该吃苦学习，工作。加油吧，</strong></p>

<p>&nbsp;</p>

<p><strong>前面介绍了linux的软件管理。下面就介绍关于linux的ip详解。</strong></p>

<p><strong>Linux系统网络参数分别为：</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; 计算机名称<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;IP地址<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;子网掩码<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;默认网关<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;DNS服务<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
1.计算机名称</strong></p>

<p><strong>Centos 7：</strong></p>

<p><strong>（注意：centos6不是这样修改，需要修改配置文件）</strong></p>

<pre class="has"><code>#hostnamectl set-hostname node01.linux.com &nbsp; 【FQDN 完全合格域名】</code></pre>

<p><br><strong>查看Linux主机名的配置文件</strong></p>

<p><strong># cat /etc/hostname&nbsp;</strong></p>

<h2><img alt="" class="has" height="217" src="https://img-blog.csdnimg.cn/20190127222105278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="462"><br><br><span style="color:#f33b45;"><strong>重点</strong></span></h2>

<p><strong>IP地址 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 192.168.196.131 &nbsp; &nbsp;点分十进制表示法</strong></p>

<p><strong>组成：32位二进制数字</strong></p>

<p><strong>xxxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</strong></p>

<p><strong>0--255 &nbsp; 0--255 &nbsp; &nbsp;0--255 &nbsp;0--255</strong></p>

<p><strong>大致范围：0.0.0.0--255.255.255.255</strong></p>

<p><br><strong>类型：</strong></p>

<p><strong>1.根据第一个字节的取值范围分类</strong></p>

<p><strong>A类：0--127<br>
B类：128--191<br>
C类：192--223 &nbsp; &nbsp; 单播地址 Unicast（前三个）同一个网络内，一个IP地址只能标识一个网络节点<br>
D类：224--239 &nbsp; &nbsp; 组播地址 Multicast<br>
E类：240--255 &nbsp; &nbsp; 科学研究</strong></p>

<p><strong>2.根据IP地址的使用范围</strong></p>

<p><strong>私网地址（不能直接访问互联网，可重复使用）<br>
&nbsp; &nbsp;10.0.0.0-----------10.255.255.255<br>
&nbsp; &nbsp;172.16.0.0---------172.31.255.255<br>
&nbsp; &nbsp;192.168.0.0---------192.168.255.255<br>
公网地址</strong></p>

<p><br><strong>特殊地址：<br>
&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;127.x.x.x &nbsp; &nbsp; &nbsp; 127.0.0.0<br>
&nbsp;&nbsp; &nbsp; &nbsp;168.254.x.x</strong></p>

<p><br><strong>子网掩码 netmask</strong></p>

<p><strong>作用： 判断多个地址是否属于同一网络<br>
原理：分别将IP地址与子网掩码转换为二进制数字，依次进行逻辑与运算（网段）</strong></p>

<p><br><strong>默认子网掩码（只是默认，不是固定）</strong></p>

<p><strong>A类：255.0.0.0 &nbsp; &nbsp; &nbsp; &nbsp; /8<br>
B类：255.255.0.0 &nbsp; &nbsp; &nbsp; /16<br>
C类：255.255.255.0 &nbsp; &nbsp; /24</strong></p>

<p><strong>192.168.1.1 &nbsp;255.255.255.0 --------&gt;192.168.1.1/24</strong></p>

<p><strong>&nbsp;&nbsp; &nbsp;</strong></p>

<p><br>
&nbsp;</p>                                    ]]></description></item><item><title>Linux的yum管理</title><link>http://www.cnblogs.com/heian99/archive/2019/01/26/11972334.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 26 Jan 2019 09:04:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/26/11972334.html</guid><description><![CDATA[
                                            <p>&nbsp;</p>

<p><strong>前面介绍了软件的管理的方式rpm。但有个缺点，rpm不能解决依赖。</strong></p>

<p><strong>下面介绍的yum软件管理。可以完美的解决这个问题。</strong></p>

<p><br><strong>使用yum的方式管理rpm软件<br>
&nbsp; &nbsp;<br>
&nbsp; &nbsp; 优势：自动解决软件的依赖关系<br>
&nbsp;&nbsp; &nbsp;<br>
前提条件：配置yum仓库/yum源</strong></p>

<h1><strong>yum源类型：</strong></h1>

<h2><strong>&nbsp; &nbsp; &nbsp;1.本地yum源<br>
&nbsp; &nbsp; &nbsp;2.ftp源<br>
&nbsp;&nbsp; &nbsp; 3.http源<br>
&nbsp;&nbsp; &nbsp;&nbsp;</strong></h2>

<h3><br><strong>&nbsp; &nbsp; 配置yum的地方：</strong></h3>

<p><br><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;阿里云镜像：&nbsp;&nbsp; &nbsp; https://mirrors.aliyun.com<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 网易云镜像： &nbsp; &nbsp; http://mirrors.163.com/<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;epel源 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Centos官网 ：http://vault.centos.org&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# yum install epel-release &nbsp; 安装epel源<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</strong></p>

<p><strong>yum源/yum仓库的配置文件<br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp;/etc/yum.repos.d/*.repo<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
示例：配置本地yum源</strong></p>

<pre class="has"><code>[root@wei yum.repos.d]# mount /dev/sr0 /mnt/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@wei yum.repos.d]# ls /mnt/
CentOS_BuildTag &nbsp;EULA &nbsp;images &nbsp; &nbsp;LiveOS &nbsp; &nbsp;repodata &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RPM-GPG-KEY-CentOS-Testing-7
EFI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GPL &nbsp; isolinux &nbsp;Packages &nbsp;RPM-GPG-KEY-CentOS-7 &nbsp;TRANS.TBL
[root@wei yum.repos.d]# mkdir /etc/yum.repos.d/beifeng
[root@wei yum.repos.d]# mv /etc/yum.repos.d/CentOS-* /etc/yum.repos.d/beifeng/
[root@wei yum.repos.d]# ls
beifeng &nbsp;mysql-community.repo &nbsp;mysql-community-source.repo
[root@wei yum.repos.d]# vim centos.repo
[root@wei yum.repos.d]# ls
beifeng &nbsp;centos.repo &nbsp;mysql-community.repo &nbsp;mysql-community-source.repo

配置内容：
[centos7.2]
name=centos7.2
baseurl=file:///mnt
enable=1
gpgcheck=0</code></pre>

<p><br><strong>清除yum缓存：</strong></p>

<pre class="has"><code>[root@wei yum.repos.d]# yum clean all</code></pre>

<p><br><strong>生成yum缓存：</strong></p>

<pre class="has"><code>[root@wei yum.repos.d]# yum makecache</code></pre>

<p><strong>查看yum的列表</strong></p>

<pre class="has"><code>[root@wei yum.repos.d]# yum repolist</code></pre>

<h1><br><strong>yum常规操作</strong></h1>

<h2><strong>（1）yum安装软件</strong></h2>

<p>&nbsp;</p>

<p><strong># yum install 软件名</strong></p>

<p>&nbsp;</p>

<p><strong># yum install -y 软件名</strong></p>

<p>&nbsp;</p>

<p><strong>（2）显示yum中所有软件</strong></p>

<pre class="has"><code>[root@wei ~]# yum list all</code></pre>

<p>&nbsp;</p>

<p><strong>（3）显示所有的软件组</strong></p>

<pre class="has"><code>[root@wei ~]# yum grouplist</code></pre>

<p><strong>（4）安装软件组</strong></p>

<p><strong># yum groupinstall -y 软件组的名称</strong></p>

<p><strong>(英文组，要用“”括起来)</strong></p>

<p><strong>（5）查询文件所属的软件名称</strong></p>

<p><strong># yum provides “*bin/passwd”</strong></p>

<p>&nbsp;</p>

<h1><strong>源码软件管理安装</strong></h1>

<h2><strong>&nbsp; &nbsp; 1.配置安装参数<br>
&nbsp;&nbsp; &nbsp;2.编译<br>
&nbsp;&nbsp; &nbsp;3.安装</strong></h2>

<p>&nbsp;</p>

<p><strong>前提：gcc编译环境（自己安装yum install gcc）</strong></p>

<p><strong>示例：编译安装htop软件</strong></p>

<p><strong>htop软件源码：</strong><a href="https://www.lanzous.com/i2zs97g" rel="nofollow">https://www.lanzous.com/i2zs97g</a></p>

<p><br><strong><span style="color:#f33b45;">解压</span><br>
[root@wei ~]# tar zxf htop-1.0.2.tar.gz&nbsp;</strong></p>

<p><span style="color:#f33b45;"><strong>切入htop-1.0.2目录</strong></span></p>

<p><strong>[root@wei ~]#cd htop-1.0.2</strong></p>

<p><span style="color:#f33b45;"><strong>查看配置</strong></span></p>

<p><strong>[root@wei htop-1.0.2]# ./configure --help |less</strong></p>

<p><span style="color:#f33b45;"><strong>配置参数</strong></span></p>

<p><strong>[root@wei htop-1.0.2]# ./configure --prefix=/usr/local/htop</strong></p>

<p><span style="color:#f33b45;"><strong>编译</strong></span></p>

<p><strong>[root@wei htop-1.0.2]# make</strong></p>

<p><span style="color:#f33b45;"><strong>安装</strong></span></p>

<p><strong>[root@wei htop-1.0.2]# make install</strong></p>

<p><span style="color:#f33b45;"><strong>启动（已经安装成功接界面）</strong></span></p>

<p><strong>[root@wei share]# /usr/local/htop/bin/htop&nbsp;</strong></p>

<p><img alt="" class="has" height="854" src="https://img-blog.csdnimg.cn/20190126170137238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1121"></p>

<p><br><strong>出现错误：</strong></p>

<p><strong>configure: error: You may want to use --disable-unicode or install libncursesw.</strong></p>

<p><strong>解决办法：<br>
[root@wei htop-1.0.2]# yum install -y ncurses-devel&nbsp;</strong></p>                                    ]]></description></item><item><title>Linux的rpm管理</title><link>http://www.cnblogs.com/heian99/archive/2019/01/26/11972335.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 26 Jan 2019 07:18:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/26/11972335.html</guid><description><![CDATA[
                                            <h1><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<u>&nbsp;书山有路勤为径，学海无涯苦作舟</u></strong></h1>

<p>&nbsp;</p>

<p><strong>自学linux已经有几天了，感觉还可以。坚持下去，就会有收获。</strong></p>

<p><strong>每个系统都用相应的软件的管理，Linux也不例外。下面讲解Linux 的rpm管理软件。</strong></p>

<p>&nbsp;</p>

<p><strong>Linux软件管理</strong></p>

<p><strong>&nbsp; &nbsp; windows：.exe &nbsp;.mai<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;centos/RHEL/Fedoea&nbsp; ：二进制格式软件(*.rpm) &nbsp; &nbsp; &nbsp;redhat package management<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;源码软件(*.tar.gz , *.tar.bz2)&nbsp;<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<p><strong>rpm软件管理</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp;光盘iso镜像文件<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br>
rpm软件名称的组成<br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; zlib-devel-1.2.7-17.el7.x86_64.rpm<br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp;zlib-devel：软件名称<br>
&nbsp;&nbsp; &nbsp; 1.2.7：版本<br>
&nbsp;&nbsp; &nbsp; el7.x86_64 ： 软件运行平台<br>
&nbsp;&nbsp; &nbsp; el7.noarch ： 无系统架构，可以安装任何版本</strong></p>

<p><strong>下面的两个网站可以下载rpm包（网站是国外的，可能比较慢）</strong></p>

<p><strong>rpm下载：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color:#f33b45;">https://pkgs.org/</span><br>
&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;rpm下载：&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color:#f33b45;">&nbsp;http://rpmfind.net/</span></strong></p>

<p>&nbsp;</p>

<p><strong>注意：你下载的rpm包要对应你服务器的版本号和运行平台</strong></p>

<p>&nbsp;</p>

<h2><strong>查看系统平台信息</strong></h2>

<pre class="has"><code>[root@wei ~]# uname -r</code></pre>

<p><strong><img alt="" class="has" height="484" src="https://img-blog.csdnimg.cn/20190126145759719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="846"></strong></p>

<p>&nbsp;</p>

<h1><strong><span style="color:#f33b45;">注意：本地系统没有rpm软件包，那么只能挂载iso镜像文件</span></strong></h1>

<p><strong>（1）有和运行平台相对应的iso镜像文件（我的centos7的）</strong></p>

<p><strong><img alt="" class="has" height="39" src="https://img-blog.csdnimg.cn/20190126150352248.png" width="795"></strong></p>

<p><strong>（2）设置虚拟机，加载镜像文件</strong></p>

<p><strong><img alt="" class="has" height="902" src="https://img-blog.csdnimg.cn/20190126150546255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="863"></strong></p>

<p>&nbsp;</p>

<p><strong>（3）光盘挂载</strong></p>

<pre class="has"><code>[root@wei dev]# mount /dev/sr0 /mnt/</code></pre>

<p><br><strong><img alt="" class="has" height="286" src="https://img-blog.csdnimg.cn/201901261510333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="726"></strong></p>

<p><br><strong>光盘卸载</strong></p>

<pre class="has"><code>[root@wei dev]# umount /dev/sr0&nbsp;</code></pre>

<p><br><strong><img alt="" class="has" height="134" src="https://img-blog.csdnimg.cn/20190126151142850.png" width="512"></strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><strong>管理rpm软件</strong></p>

<p><strong>1.查询软件是否安装</strong></p>

<p><strong># rpm -q 软件名称</strong></p>

<p><img alt="" class="has" height="174" src="https://img-blog.csdnimg.cn/20190126151323714.png" width="405"></p>

<p><strong># rpm -qa | grep 软件名称</strong></p>

<p><img alt="" class="has" height="215" src="https://img-blog.csdnimg.cn/20190126151403364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="466"></p>

<p><strong>2.查询软件的说明信息</strong></p>

<p><strong>#rpm -qi 软件名称</strong></p>

<p><img alt="" class="has" height="659" src="https://img-blog.csdnimg.cn/2019012615144295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="732"></p>

<p><strong>3.查看软件生成的文件</strong></p>

<p><strong># rpm -ql 软件名称</strong></p>

<p><img alt="" class="has" height="395" src="https://img-blog.csdnimg.cn/20190126151533822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="726"></p>

<p><br><strong>[root@wei ~]# rpm -ql bash | less</strong></p>

<p><br><strong>4.查看文件由那个软件生成</strong></p>

<p><strong># rpm -qf 文件名称</strong></p>

<pre class="has"><code>[root@wei ~]# which chmod
/usr/bin/chmod
[root@wei ~]# rpm -qf /usr/bin/chmod&nbsp;
coreutils-8.22-21.el7.x86_64</code></pre>

<p><img alt="" class="has" height="222" src="https://img-blog.csdnimg.cn/20190126151637953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="584"></p>

<p><br><strong>5.查看软件的配置文件</strong></p>

<p><strong># rpm -qc 软件名称</strong></p>

<pre class="has"><code>[root@wei ~]# rpm -qc vim-enhanced
/etc/profile.d/vim.csh
/etc/profile.d/vim.sh</code></pre>

<p><br><strong>管理操作：</strong></p>

<p><strong>（1）安装软件</strong></p>

<p><strong># rpm -ivh 软件安装包名称<br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; i: 安装 install<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; v：显示详细信息 verbose<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; h：显示软件安装进度<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
安装vsftpd软件</strong></p>

<pre class="has"><code>[root@wei ~]# mount /dev/sr0 /mnt/

[root@wei ~]# rpm -ivh /mnt/Packages/vsftpd-3.0.2-22.el7.x86_64.rpm&nbsp;
准备中... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;################################# [100%]
正在升级/安装...
&nbsp; &nbsp;1:vsftpd-3.0.2-22.el7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;################################# [100%]</code></pre>

<p><br><strong>安装dhcp软件</strong></p>

<pre class="has"><code>[root@wei ~]# rpm -ivh /mnt/Packages/dhcp-4.2.5-68.el7.centos.x86_64.rpm&nbsp;
准备中... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;################################# [100%]
正在升级/安装...
&nbsp; &nbsp;1:dhcp-12:4.2.5-68.el7.centos &nbsp; &nbsp; &nbsp;################################# [100%]</code></pre>

<p><strong>安装软件出现依赖问题</strong></p>

<p><strong>&nbsp; &nbsp; 选项--nodeps 忽略依赖关系安装<br>
&nbsp;&nbsp; &nbsp;</strong></p>

<p><strong>（2）卸载软件</strong></p>

<p><strong># rpm -e 软件名称</strong></p>

<p>&nbsp;</p>

<pre class="has"><code>[root@wei ~]# rpm -q dhcp
dhcp-4.2.5-68.el7.centos.x86_64
[root@wei ~]# rpm -e dhcp
[root@wei ~]# rpm -q dhcp
未安装软件包 dhcp&nbsp;</code></pre>

<p><strong>选项--nodeps 忽略依赖关系卸载</strong></p>

<p><strong>（3）升级软件</strong></p>

<p><strong># rpm -Uvh 软件安装包名称</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;注意：自动卸载就版本软件</strong></p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux用户环境配置文件</title><link>http://www.cnblogs.com/heian99/archive/2019/01/25/11972336.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 25 Jan 2019 13:37:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/25/11972336.html</guid><description><![CDATA[
                                            <p><br><strong>用户操作环境配置文件：</strong></p>

<p><strong>从/etc/skel目录复制过来</strong></p>

<p><strong><img alt="" class="has" height="286" src="https://img-blog.csdnimg.cn/20190125210956175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="675"></strong></p>

<p><strong>.bashrc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 打开新终端 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /etc/bashrc<br>
.bash_profile &nbsp; &nbsp; &nbsp; 用户登录系统 &nbsp; &nbsp; &nbsp; &nbsp; /ect/profile<br>
.bash_logout &nbsp; &nbsp; &nbsp; &nbsp;注销系统 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong></p>

<p><br><strong>示例：设置命令别名</strong></p>

<h2><strong>临时命令别名（关机重启，就没有了）</strong></h2>

<p><strong># alias 命令别名=‘命令’</strong></p>

<pre class="has"><code>alias ipshow='cat /etc/sysconfig/network-scripts/ifcfg-ens33'</code></pre>

<p><img alt="" class="has" height="548" src="https://img-blog.csdnimg.cn/20190125211616558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="883"></p>

<h2><br><strong>永久别名（可以一直存在）</strong></h2>

<p><strong>针对单个用户设置别名</strong></p>

<p>（1）创建hei用户，修改vim /home/hei/.bashrc&nbsp;</p>

<p><img alt="" class="has" height="193" src="https://img-blog.csdnimg.cn/20190125212504317.png" width="567"></p>

<p>（2）进入&nbsp; /home/hei/.bashrc ，在最后一行添加&nbsp;&nbsp;<strong>&nbsp;alias ipshow=' cat /etc/sysconfig/network-scripts/ifcfg-ens33' 保存退出</strong></p>

<p><img alt="" class="has" height="349" src="https://img-blog.csdnimg.cn/20190125212435357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="771"></p>

<p>（3）切换到hei用户下查看</p>

<p><img alt="" class="has" height="623" src="https://img-blog.csdnimg.cn/2019012521312935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="748"></p>

<p><br><strong>针对所有用户设置别名</strong></p>

<p><strong>这个方法和上面的一样，只需要修改的文件不一样。下面已经列出</strong></p>

<p><strong>（1）修改/etc/bashrcde文件</strong></p>

<p><strong>（2）添加命令别名代码</strong></p>

<p><strong>（3）刷新文件即可</strong><br>
&nbsp;</p>

<pre class="has"><code>root@wei ~]# vim /etc/bashrc
&nbsp;
&nbsp; &nbsp;alias ipshow=' cat /etc/sysconfig/network-scripts/ifcfg-ens33'
[root@wei ~]# source /etc/bashrc</code></pre>

<p><br>
&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux文件权限管理</title><link>http://www.cnblogs.com/heian99/archive/2019/01/25/11972337.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 25 Jan 2019 12:59:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/25/11972337.html</guid><description><![CDATA[
                                            <h1><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 路漫漫其修远兮，吾将上下而求索</strong></h1>

<p><strong>inux文件目录权限管理</strong></p>

<p><strong>常规权限：<br>
&nbsp; &nbsp; &nbsp;r &nbsp; &nbsp;read &nbsp; &nbsp;读取 &nbsp; &nbsp;4<br>
&nbsp; &nbsp; &nbsp;w &nbsp; &nbsp;write &nbsp; 写入&nbsp;&nbsp; &nbsp; &nbsp;2<br>
&nbsp;&nbsp; &nbsp; x &nbsp; &nbsp;execute 执行 &nbsp; &nbsp;1<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
文件：<br>
&nbsp; &nbsp; r &nbsp;查看文件内容（cat/more/less/head/tail/grep）<br>
&nbsp;&nbsp; &nbsp;w &nbsp;编辑文件内容（vim）<br>
&nbsp;&nbsp; &nbsp;x &nbsp;shell/python脚本</strong></p>

<p><strong>目录：<br>
&nbsp; &nbsp; r &nbsp;查看目录的文件（ls/tmp）<br>
&nbsp;&nbsp; &nbsp;w &nbsp;修改目录的文件（新建,删除,mv）<br>
&nbsp;&nbsp; &nbsp;x &nbsp;切换目录（cd）<br>
&nbsp;&nbsp; &nbsp;<br>
除去第一个，三个为一组&nbsp;&nbsp; &nbsp;<br>
查看文件权限</strong></p>

<p><img alt="" class="has" height="146" src="https://img-blog.csdnimg.cn/20190125204200725.png" width="582"></p>

<p><strong>查看目录权限</strong></p>

<p><img alt="" class="has" height="200" src="https://img-blog.csdnimg.cn/20190125204234344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="575"></p>

<p><strong>设置文件目录权限</strong></p>

<p><strong>（1）chmod &nbsp; &nbsp;修改权限</strong></p>

<p><strong># chmod {augo}{+-=}{rwx} 文件名称</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;a &nbsp; all &nbsp; &nbsp;所有<br>
&nbsp;&nbsp; &nbsp; &nbsp; u &nbsp; user &nbsp; 属主用户<br>
&nbsp;&nbsp; &nbsp; &nbsp; g &nbsp; group &nbsp;属组<br>
&nbsp;&nbsp; &nbsp; &nbsp; o &nbsp; other &nbsp;其他<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<br>
# chmod a+x /tmp/1.txt<br>
# chmod u-x,o+r /tmp/2.txt<br>
# chmod nnn 文件名称</strong></p>

<p><strong>权限设置例子：</strong></p>

<pre class="has"><code>[root@wei ~]# ls -l /test/
总用量 0
-rw-r--r--. 1 root root 0 1月 &nbsp;25 10:42 1.txt
-rw-r--r--. 1 root root 0 1月 &nbsp;25 10:42 2.txt
-rw-r--r--. 1 root root 0 1月 &nbsp;25 10:42 3.txt
-rw-r--r--. 1 root root 0 1月 &nbsp;25 10:42 4.txt
-rw-r--r--. 1 root root 0 1月 &nbsp;25 10:42 5.txt
[root@wei ~]# chmod a+x /test/1.txt&nbsp; #设置文件1.txt为所有用户可执行（x）
[root@wei ~]# ls -l /test/1.txt&nbsp;
-rwxr-xr-x. 1 root root 0 1月 &nbsp;25 10:42 /test/1.txt  #查看文件1.txt的权限
[root@wei ~]# chmod g-r,o-r /test/2.txt&nbsp; #设置文件2.txt用户属组权限不可读，其他用户权限不可读
[root@wei ~]# ls -l /test/2.txt&nbsp; #查看文件2.txt的权限
-rw-------. 1 root root 0 1月 &nbsp;25 10:42 /test/2.txt
[root@wei ~]# chmod g=rw /test/3.txt&nbsp;#覆盖文件3.txt用户属组的权限为可读可写
[root@wei ~]# ls -l /test/3.txt&nbsp;#查看文件3.txt的权限
-rw-rw-r--. 1 root root 0 1月 &nbsp;25 10:42 /test/3.txt
[root@wei ~]# chmod 600 /test/4.txt&nbsp;#设置文件4.txt的权限为主用户可读可写
[root@wei ~]# ls -l /test/4.txt&nbsp;
-rw-------. 1 root root 0 1月 &nbsp;25 10:42 /test/4.txt
[root@wei ~]# chmod 000 /test/5.txt       #设置5.txt的文件权限为所有不可读不可写不可执行&nbsp;
[root@wei ~]# ls -l /test/5.txt&nbsp;
----------. 1 root root 0 1月 &nbsp;25 10:42 /test/5.txt</code></pre>

<p><strong>（2）修改文件的属主,属组</strong></p>

<p><strong># chown 用户名称.用户组名称 &nbsp;文件名称</strong></p>

<pre class="has"><code>[root@wei ~]# chown user1.caiwu /test/1.txt

[root@wei ~]# chown user1 /test/2.txt&nbsp;

[root@wei ~]# chown root.caiwu /test/4.txt&nbsp;</code></pre>

<p><br><strong>仅修改属组：<br>
&nbsp;<br>
# chgrp 用户组名称 文件名称</strong></p>

<pre class="has"><code>[root@wei ~]# ls -l /test/3.txt&nbsp;</code></pre>

<p><br><strong>属组权限设置例子：</strong></p>

<pre class="has"><code>[root@wei ~]# ls -l /test/
总用量 0
-rwxr-xr-x. 1 root root 0 1月 &nbsp;25 10:42 1.txt
-rw-------. 1 root root 0 1月 &nbsp;25 10:42 2.txt
-rw-rw-r--. 1 root root 0 1月 &nbsp;25 10:42 3.txt
-rw-------. 1 root root 0 1月 &nbsp;25 10:42 4.txt
----------. 1 root root 0 1月 &nbsp;25 10:42 5.txt
[root@wei ~]# groupadd caiwu # 添加用户属组caiwu
[root@wei ~]# chown user1.caiwu /test/1.txt&nbsp; #把1.txt的主用户改为user，属组改为caiwu
[root@wei ~]# ls -l /test/1.txt&nbsp;
-rwxr-xr-x. 1 user1 caiwu 0 1月 &nbsp;25 10:42 /test/1.txt
[root@wei ~]# chown user1 /test/2.txt&nbsp; #把2.txt的主用户改为user1，属组不变
[root@wei ~]# ls -l /test/2.txt&nbsp;
-rw-------. 1 user1 root 0 1月 &nbsp;25 10:42 /test/2.txt
[root@wei ~]# chgrp caiwu /test/3.txt&nbsp; 把3.txt的属组改为caiwu
[root@wei ~]# ls -l /test/3.txt&nbsp;
-rw-rw-r--. 1 root caiwu 0 1月 &nbsp;25 10:42 /test/3.txt
[root@wei ~]# chown root.caiwu /test/4.txt&nbsp; #把#4.txt的主用户为root，属组为caiwu
[root@wei ~]# ls -l /test/4.txt&nbsp;
-rw-------. 1 root caiwu 0 1月 &nbsp;25 10:42 /test/4.txt</code></pre>

<p><strong>方法2<br>
&nbsp; &nbsp; &nbsp; &nbsp;facl-----------文件访问控制列表</strong></p>

<p><strong>设置权限：</strong></p>

<p><strong>针对单个用户设置权限</strong></p>

<p><strong># setfacl -m u：用户名：权限 文件名称</strong></p>

<pre class="has"><code>[root@wei test]# setfacl -m u:user4:r /test/3.txt&nbsp;</code></pre>

<p><br><strong>针对单个用户组设置权限</strong></p>

<p><strong># setfacl -m g：用户组名称 ：权限 文件名称</strong></p>

<pre class="has"><code>[root@wei test]# setfacl -m g:caiwu:rwx /test/3.txt&nbsp;</code></pre>

<p><strong>查看权限</strong></p>

<p><strong># getfacl 文件名称</strong></p>

<pre class="has"><code>[root@wei test]# getfacl /test/3.txt&nbsp;
getfacl: Removing leading '/' from absolute path names
# file: test/3.txt
# owner: user1
# group: user3
user::rw-
user:user4:r--
group::rwx
group:caiwu:rwx
mask::rwx</code></pre>

<p><br><strong>删除权限</strong></p>

<p><br><strong>针对单个用户设置权限删除</strong></p>

<p><strong># setfacl -x u：用户名：文件名称</strong></p>

<pre class="has"><code>[root@wei test]# setfacl -x u:user4 /test/3.txt &nbsp;</code></pre>

<p><br><strong>针对单个用户组设置权限删除</strong></p>

<p><strong># setfacl -x g：用户组名称 &nbsp;文件名称</strong></p>

<pre class="has"><code>[root@wei test]# setfacl -x g:caiwu /test/3.txt&nbsp;

</code></pre>

<p><br><strong>简单例子：</strong></p>

<pre class="has"><code>[root@wei test]# setfacl -x u:user4 /test/3.txt&nbsp;
[root@wei test]# getfacl /test/3.txt&nbsp;
getfacl: Removing leading '/' from absolute path names
# file: test/3.txt
# owner: user1
# group: user3
user::rw-
group::rwx
group:caiwu:rwx
mask::rwx
other::r-x

[root@wei test]# setfacl -x g:caiwu /test/3.txt&nbsp;
[root@wei test]# getfacl /test/3.txt&nbsp;
getfacl: Removing leading '/' from absolute path names
# file: test/3.txt
# owner: user1
# group: user3
user::rw-
group::rwx
mask::rwx
other::r-x</code></pre>

<p><br><strong>特殊权限<br>
&nbsp; &nbsp; &nbsp;suid &nbsp; &nbsp; &nbsp; &nbsp; 4<br>
&nbsp;&nbsp; &nbsp; sgid &nbsp; &nbsp; &nbsp; &nbsp; 2<br>
&nbsp;&nbsp; &nbsp; sticky bit &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
1,suid<br>
&nbsp; &nbsp; &nbsp;<br>
&nbsp;&nbsp; &nbsp;作用：普通用户在执行命令期间，会临时获取到命令属主用户对操作系统的权限<br>
&nbsp;&nbsp; &nbsp;<br>
设置suid权限</strong></p>

<p><strong># chmod u+s 文件名称</strong></p>

<p><strong>2，sgid<br>
&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; 针对目录设置<br>
&nbsp;&nbsp; &nbsp; 作用：目录拥有sgid权限后，在目录下创建的文件会继承目录的属组信息<br>
&nbsp;&nbsp; &nbsp;&nbsp;<br>
设置sgid权限</strong></p>

<p><strong># chmod g+s 目录名称&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;</strong></p>

<pre class="has"><code>[root@wei ~]# mkdir /linux
[root@wei ~]# ls -dhl /linux&nbsp;
drwxr-xr-x. 2 root root 6 1月 &nbsp;25 11:55 /linux
[root@wei ~]# chgrp caiwu /linux
[root@wei ~]# ls -dhl /linux&nbsp;
drwxr-xr-x. 2 root caiwu 6 1月 &nbsp;25 11:55 /linux
[root@wei ~]# touch /linux/1.txt
[root@wei ~]# ls -l /linux/1.txt&nbsp;
-rw-r--r--. 1 root root 0 1月 &nbsp;25 11:56 /linux/1.txt
[root@wei ~]# chmod g+s /linux/
[root@wei ~]# ls -dhl /linux&nbsp;
drwxr-sr-x. 2 root caiwu 19 1月 &nbsp;25 11:56 /linux
[root@wei ~]# touch /linux/2.txt
[root@wei ~]# ls -l /linux/2.txt&nbsp;
-rw-r--r--. 1 root caiwu 0 1月 &nbsp;25 11:58 /linux/2.txt</code></pre>

<p><br><strong>3,sticky bit</strong></p>

<p><strong>针对目录设置<br>
作用：只用目录下文件的属主用户,目录属主用户及root可删除的文件</strong></p>

<p><strong>设置sticky bit权限</strong></p>

<p><strong># chmod o+t 目录名称</strong></p>

<pre class="has"><code>公司部门 开发部（经理，员工1，员工2）
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/project
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; (1)经理可以查看写
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; (2)员工可以相互看，修改，但不能删除
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;
[root@wei ~]# useradd jl
[root@wei ~]# useradd yg1
[root@wei ~]# useradd yg2
[root@wei ~]# mkdir /project
[root@wei ~]# chown jl /project/
[root@wei ~]# ls -dhl /project/
drwxr-xr-x. 2 jl root 6 1月 &nbsp;25 12:11 /project/
[root@wei ~]# usermod -G jl yg1
[root@wei ~]# usermod -G jl yg2
[root@wei ~]# chgrp jl /project/
[root@wei ~]# chmod g+w /project/
[root@wei ~]# chmod g+s /project/
[root@wei ~]# chmod o+t /project/
[root@wei ~]# ls -hdl /project/
drwxrwsr-t. 2 jl jl 6 1月 &nbsp;25 12:11 /project/</code></pre>

<p><strong>chmod chown chgrp setfacl<br>
共同选项： -R 递归修改</strong><br>
&nbsp;</p>                                    ]]></description></item><item><title>Linux用户权限管理</title><link>http://www.cnblogs.com/heian99/archive/2019/01/24/11972338.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 24 Jan 2019 14:28:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/24/11972338.html</guid><description><![CDATA[
                                            <h1>&nbsp;</h1>

<h1>Linux操作系统：&nbsp;多用户多任务的操作系统</h1>

<p>&nbsp;</p>

<h2>用户类型分为：<br>
&nbsp; &nbsp; 管理员用户 ： root<br>
&nbsp; &nbsp; 普通用户分为：系统用户/程序用户</h2>

<p><strong>用户相关的文件：</strong></p>

<p><strong>&nbsp; &nbsp; /etc/passwd &nbsp; &nbsp; &nbsp;用户信息<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 格式：x:UID:GID:说明信息:SHELL<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; UID:<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1000----60000 &nbsp; &nbsp;创建用户<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0-----999 &nbsp; &nbsp; &nbsp; &nbsp;系统用户<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; SHELL：<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /bin/bash &nbsp; &nbsp; &nbsp; &nbsp;默认<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; /sbin/nologin &nbsp; &nbsp;系统用户<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp;/etc/shadow &nbsp; &nbsp; &nbsp;用户密码信息</strong></p>

<p>&nbsp;</p>

<h3>用户：<br>
&nbsp; &nbsp; &nbsp;基本组<br>
&nbsp;&nbsp; &nbsp; 附加组 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userA----&gt; 用户组userA：</h3>

<p>1.创建用户</p>

<p># useradd [option] 用户名称</p>

<p>option选项：</p>

<p><br>
(1) -u &nbsp;UID 指定用户的uid</p>

<pre class="has"><code>[root@wei ~]# useradd -u 1200 wei2
[root@wei ~]# id wei2
uid=1200(wei2) gid=1200(wei2) 组=1200(wei2)</code></pre>

<p>(2)指定用户的基本组,附加组<br>
&nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; -g gid/组名称<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-G gid/组名称,,,<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</p>

<pre class="has"><code>[root@wei ~]# groupadd nan
[root@wei ~]# useradd -g wei2 -G nan wei3
[root@wei ~]# id wei3
uid=1201(wei3) gid=1200(wei2) 组=1200(wei2),1201(nan)</code></pre>

<p>(3)指定用户shell名称<br>
&nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; -s shell名称<br>
&nbsp;&nbsp; &nbsp; &nbsp;-M &nbsp;不创建宿主目录<br>
&nbsp;&nbsp; &nbsp; &nbsp;</p>

<pre class="has"><code>[root@wei ~]# useradd -s /sbin/nologin -M zhangmiao</code></pre>

<p><br>
(4)创建系统用户<br>
&nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp; -r&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</p>

<pre class="has"><code>[root@wei ~]# useradd -r nangong&nbsp;</code></pre>

<p><br>
(5)指定用户的宿主目录</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp;-d&nbsp;<br>
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;</p>

<pre class="has"><code>[root@wei ~]# useradd -d /tmp/hei hei
[root@wei ~]# ls /tmp/
hei &nbsp;vmware-root
[root@wei ~]# grep "hei" /etc/passwd
hei:x:1203:1203::/tmp/hei:/bin/bash</code></pre>

<p>2，切换用户</p>

<p># su - 用户名称</p>

<p>3，查看用户id</p>

<p># id 用户名称</p>

<pre class="has"><code>[root@wei ~]# id wei
uid=1000(wei) gid=1000(wei) 组=1000(wei)</code></pre>

<p>id的选项：</p>

<pre class="has"><code>[root@wei ~]# id wei3
uid=1201(wei3) gid=1200(wei2) 组=1200(wei2),1201(nan)
[root@wei ~]# id -u wei3
1201
[root@wei ~]# id -g wei3
1200
[root@wei ~]# id -G wei3
1200 1201
[root@wei ~]# id -u -n wei3
wei3
[root@wei ~]# id -g -n wei3
wei2
[root@wei ~]# id -G -n wei3
wei2 nan</code></pre>

<p>3,设置用户密码</p>

<p># passwd 用户名</p>

<pre class="has"><code>[root@wei ~]# passwd wei</code></pre>

<p>(1)查看用户密码状态</p>

<pre class="has"><code>[root@wei ~]# passwd -S wei
wei PS 2019-01-24 0 99999 7 -1 (密码已设置，使用 SHA512 算法。)</code></pre>

<p>(2)锁定用户密码</p>

<pre class="has"><code>[root@wei ~]# passwd -l wei
锁定用户 wei 的密码 。
passwd: 操作成功

</code></pre>

<p>(3)解锁用户密码</p>

<pre class="has"><code>[root@wei ~]# passwd -u wei
解锁用户 wei 的密码。
passwd: 操作成功

</code></pre>

<p>(4)强制用户密码过期</p>

<pre class="has"><code>[root@wei ~]# passwd -e wei
正在终止用户 wei 的密码。
passwd: 操作成功
</code></pre>

<p><br>
4,修改用户信息</p>

<p># usermod &nbsp;[option] 用户名称&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; -u UID<br>
&nbsp;&nbsp; &nbsp; &nbsp;-g 组名称<br>
&nbsp;&nbsp; &nbsp; &nbsp;-G 组名称<br>
&nbsp;&nbsp; &nbsp; &nbsp;-s shell名称<br>
替换原有附加组</p>

<pre class="has"><code>[root@wei ~]# id wei3
uid=1201(wei3) gid=1200(wei2) 组=1200(wei2),1201(nan)
[root@wei ~]# groupadd shicahng
[root@wei ~]# usermod -G shicahng wei3
[root@wei ~]# id wei3
uid=1201(wei3) gid=1200(wei2) 组=1200(wei2),1204(shicahng)</code></pre>

<p>添加多个附加组</p>

<pre class="has"><code>[root@wei ~]# usermod -aG nan wei3
[root@wei ~]# id wei3
uid=1201(wei3) gid=1200(wei2) 组=1200(wei2),1201(nan),1204(shicahng)</code></pre>

<p><br>
6,删除用户</p>

<p># userdel [option] 用户名称</p>

<pre class="has"><code>[root@wei ~]# userdel wei

[root@wei ~]# userdel -r wei2 &nbsp;&gt;&gt;同时删除用户的宿主文件</code></pre>

<p><br>
用户组管理</p>

<p>1,创建用户组</p>

<p># groupadd 用户组名称</p>

<p>2,删除用户组</p>

<p># groupdel 用户组名称</p>

<pre class="has"><code>[root@wei ~]# groupadd jishu
[root@wei ~]# useradd tom
[root@wei ~]# useradd tom1
[root@wei ~]# usermod -G jishu tom
[root@wei ~]# usermod -G jishu tom1
[root@wei ~]# grep "jishu" /etc/group
jishu:x:1205:tom,tom1
[root@wei ~]# gpasswd -d tom jishu
正在将用户“tom”从“jishu”组中删除
[root@wei ~]# grep "jishu" /etc/group
jishu:x:1205:tom1</code></pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>压缩，解压缩 和tar详细介绍</title><link>http://www.cnblogs.com/heian99/archive/2019/01/23/11972339.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 23 Jan 2019 15:19:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/23/11972339.html</guid><description><![CDATA[
                                            <hr><h1 style="margin-left:0cm;"><strong>文件压缩/解压缩 &nbsp;gzip&nbsp;&nbsp; bzip2&nbsp; xz</strong></h1>

<h2 style="margin-left:0cm;"><strong>只能压缩文件，不能压缩文件夹（压缩完后，文件会消失）</strong></h2>

<p><strong>先建三个文件来进行演示</strong></p>

<pre class="has"><code>touch ./{1..3}.txt
</code></pre>

<p><img alt="" class="has" height="242" src="https://img-blog.csdnimg.cn/20190123225310151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="669"></p>

<h3><strong>&nbsp;文件已经创建好，下面就开始介绍文件的压缩和解压（ gzip&nbsp; &nbsp;bzip2&nbsp; &nbsp; xz ）</strong></h3>

<p>&nbsp;</p>

<h1><span style="color:#f33b45;"><u><strong>gzip介绍：</strong></u></span></h1>

<p><strong>压缩： gzip&nbsp; 源文件</strong></p>

<pre class="has"><code>gzip 1.txt</code></pre>

<p><img alt="" class="has" height="213" src="https://img-blog.csdnimg.cn/20190123225534394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="594"></p>

<p><strong>解压缩 ： gzip -d 源文件</strong></p>

<pre class="has"><code>gzip -d  1.txt.gz </code></pre>

<p><img alt="" class="has" height="215" src="https://img-blog.csdnimg.cn/20190123225717616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="569"></p>

<h1><span style="color:#f33b45;"><u>bzip2介绍</u></span></h1>

<p><strong>压缩：bzip2&nbsp; 源文件</strong></p>

<pre class="has"><code>bzip2 2.txt</code></pre>

<p><img alt="" class="has" height="179" src="https://img-blog.csdnimg.cn/20190123225948102.png" width="633"></p>

<p><strong>解压缩 : bizp2&nbsp; -d&nbsp; 源文件</strong></p>

<pre class="has"><code>bzip2 -d 2.txt.bz2</code></pre>

<p><img alt="" class="has" height="263" src="https://img-blog.csdnimg.cn/2019012323044277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="703"></p>

<h1><strong>&nbsp;<span style="color:#f33b45;"><u>xz介绍</u></span></strong></h1>

<p><strong>压缩：xz 源文件</strong></p>

<pre class="has"><code>xz 3.txt</code></pre>

<p><img alt="" class="has" height="264" src="https://img-blog.csdnimg.cn/20190123230639519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="722"></p>

<p><strong>解压缩：xz -d 源文件</strong></p>

<pre class="has"><code>xz -d 3.txt.xz 
</code></pre>

<p><img alt="" class="has" height="203" src="https://img-blog.csdnimg.cn/20190123231253353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="540"></p>

<p>&nbsp;</p>

<h1 style="margin-left:0cm;"><strong>创建打包文件 ------tar</strong></h1>

<h2 style="margin-left:0cm;"><strong>1）创建打包文件 &nbsp;&nbsp;*.tar</strong></h2>

<h3 style="margin-left:0cm;"><strong># tar cf 打包文件名称 &nbsp;源文件</strong></h3>

<h3 style="margin-left:0cm;"><strong>e：creat创建</strong></h3>

<h3 style="margin-left:0cm;"><strong>f :&nbsp; file文件</strong></h3>

<p><img alt="" class="has" height="214" src="https://img-blog.csdnimg.cn/20190123231536899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="719"></p>

<h2 style="margin-left:0cm;"><strong>2)解包</strong></h2>

<h3 style="margin-left:0cm;"><strong>&nbsp;# tar xf 打包文件名称 【-c解压到的目录】</strong></h3>

<p><img alt="" class="has" height="212" src="https://img-blog.csdnimg.cn/20190123231729588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="738"></p>

<h2 style="margin-left:0cm;"><strong>3）查看包</strong></h2>

<h3 style="margin-left:0cm;"><strong>#tar tvf 打包的文件名称 </strong></h3>

<p><img alt="" class="has" height="448" src="https://img-blog.csdnimg.cn/20190123231619516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="731"></p>

<h1 style="margin-left:0cm;"><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 调用gzip使用压缩 &nbsp;解压缩</strong></h1>

<p style="margin-left:0cm;"><strong>压缩</strong></p>

<p style="margin-left:0cm;"><strong>#tar czf 打包文件名称 &nbsp;源文件</strong></p>

<p style="margin-left:0cm;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z：调用gzip</strong></p>

<p style="margin-left:0cm;"><strong>解压缩：</strong></p>

<p style="margin-left:0cm;"><strong># tar xzf 打包文件的名称 【-c 目录名称】</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<h1 style="margin-left:0cm;"><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;调用bzip2使用压缩 &nbsp;解压缩</strong></h1>

<p style="margin-left:0cm;"><strong>压缩</strong></p>

<p style="margin-left:0cm;"><strong>#tar cjf 打包文件名称 目录名称</strong></p>

<p style="margin-left:0cm;"><strong>j：调用bzip2</strong></p>

<p style="margin-left:0cm;"><strong>解压缩</strong></p>

<p style="margin-left:0cm;"><strong>#tar xjf 打包文件名称 【-c 目录名称】</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<h1 style="margin-left:0cm;"><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 调用xz使用压缩 &nbsp;解压缩</strong></h1>

<p style="margin-left:0cm;"><strong>压缩</strong></p>

<p style="margin-left:0cm;"><strong>#tar cJf 打包文件名称 目录名称</strong></p>

<p style="margin-left:0cm;"><strong>J：调用zx</strong></p>

<p style="margin-left:0cm;"><strong>解压缩</strong></p>

<p style="margin-left:0cm;"><strong>#tar xJf 打包文件名称 【-c 目录名称】</strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>grep基本详细使用</title><link>http://www.cnblogs.com/heian99/archive/2019/01/23/11972340.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 23 Jan 2019 13:30:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/23/11972340.html</guid><description><![CDATA[
                                            <h1 style="margin-left:0cm;">&nbsp;</h1>

<h1 style="margin-left:0cm;"><strong>过滤文件类容---grep</strong></h1>

<h2 style="margin-left:0cm;">grep正则表达式应用：</h2>

<h3 style="margin-left:0cm;"><strong>#grep 【option】”pattern” 文件名称</strong></h3>

<h3 style="margin-left:0cm;">pattern模式</h3>

<h3 style="margin-left:0cm;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由普通字符和正则表达式的元字符组构成的条件</h3>

<p>&nbsp;</p>

<p><strong>简单例子</strong></p>

<pre class="has"><code>grep "root" /etc/passwd
</code></pre>

<p><img alt="" class="has" height="240" src="https://img-blog.csdnimg.cn/20190123204009457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="619"></p>

<h2 style="margin-left:0cm;">正则表达式的元字符</h2>

<h3 style="margin-left:0cm;">（1）匹配单个字符的元字符</h3>

<p style="margin-left:0cm;"><strong>. 任意单个字符（前面是一个小点）</strong></p>

<pre class="has"><code>grep "r..t" /etc/passwd
</code></pre>

<p><strong>&nbsp;注意：.&nbsp; &nbsp;代表任意字符，此处有两个&nbsp; .&nbsp; ，代表两个任意字符，看下面的例子</strong></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="293" src="https://img-blog.csdnimg.cn/20190123204437689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="789"></p>

<p style="margin-left:0cm;"><strong>&nbsp; [ ]&nbsp; &nbsp;代表或者的关系</strong></p>

<p><strong>&nbsp;连续的字符范围</strong></p>

<p style="margin-left:0cm;"><strong>[a-z]&nbsp; : a到z的所有小写字母</strong></p>

<p style="margin-left:0cm;"><strong>[A-Z]&nbsp; &nbsp;： A到Z所有的大写字母</strong></p>

<p style="margin-left:0cm;"><strong>[a-zA-Z] ：包含所有的大小写字母&nbsp;</strong></p>

<p style="margin-left:0cm;"><strong>[0-9]&nbsp; ：0到9的所有数字</strong></p>

<p style="margin-left:0cm;"><strong>[a-zA-Z0-9 ]&nbsp; ：包含所有大小字母和数字</strong></p>

<h2 style="margin-left:0cm;"><span style="color:#f33b45;">为了方便后面的练习，在此建立个临时文件，写入字符，当做练习的文件</span>&nbsp;</h2>

<pre class="has"><code>vim 1.txt
rot
rAt
rBt
r1t
root
rVCt
r4t
</code></pre>

<pre class="has"><code>grep "r[a-z]t" 1.txt

grep "r[A-Z]t" 1.txt
</code></pre>

<p><img alt="" class="has" height="342" src="https://img-blog.csdnimg.cn/20190123210234548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="664"></p>

<p style="margin-left:0cm;"><strong>^ 取反</strong></p>

<p style="margin-left:0cm;"><strong>[^a-z]</strong></p>

<pre class="has"><code>grep "r[^0-9]t" 1.txt 
</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="341" src="https://img-blog.csdnimg.cn/20190123210505532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="812"></p>

<h3 style="margin-left:0cm;">(2)匹配字符出现的位置</h3>

<p style="margin-left:0cm;"><strong>^string&nbsp; 以string开头</strong></p>

<pre class="has"><code> grep "^root" /etc/passwd</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="189" src="https://img-blog.csdnimg.cn/2019012321070646.png" width="555"></p>

<p style="margin-left:0cm;"><strong>对首行[rbh]开头</strong></p>

<pre class="has"><code>grep "^[rbh]" /etc/passwd</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="197" src="https://img-blog.csdnimg.cn/20190123210831400.png" width="575"></p>

<p style="margin-left:0cm;"><strong>不是【rbh】开头</strong></p>

<pre class="has"><code>grep "^[^rbh]" /etc/passwd</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="278" src="https://img-blog.csdnimg.cn/20190123210928496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="670"></p>

<p style="margin-left:0cm;"><strong>string$&nbsp; 以string$结尾</strong></p>

<p style="margin-left:0cm;"><strong>以bash结尾的</strong></p>

<pre class="has"><code> grep "bash$" /etc/passwd</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="145" src="https://img-blog.csdnimg.cn/20190123211047362.png" width="548"></p>

<p style="margin-left:0cm;"><strong>查看nologin的行数</strong></p>

<pre class="has"><code>grep "nologin$" /etc/passwd | wc -l</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="111" src="https://img-blog.csdnimg.cn/20190123211230787.png" width="623"></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><strong>^$ ： 代表 空行</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><strong>查看目录名称（此处是指目录文件）</strong></p>

<pre class="has"><code>ls -l /etc/ | grep "^d"</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="357" src="https://img-blog.csdnimg.cn/20190123211622848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="691"></p>

<h2 style="margin-left:0cm;"><span style="color:#f33b45;">为了方便后面的练习，在此建立个临时文件，写入字符，当做练习的文件</span>&nbsp;</h2>

<pre class="has"><code>vim 2.txt
a
ab
abb
abbbb
abbbbb
abbbbbbb
</code></pre>

<h2 style="margin-left:0cm;"><strong>*&nbsp; 匹配其前一个字符出现任意次</strong></h2>

<h2 style="margin-left:0cm;"><strong>&nbsp;&nbsp;.*任意字符</strong></h2>

<pre class="has"><code> grep "ab*" 3.txt</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="185" src="https://img-blog.csdnimg.cn/20190123211950512.png" width="452"></p>

<h3 style="margin-left:0cm;">\?&nbsp;&nbsp; 0次或者1次 &nbsp;&nbsp;可有可无</h3>

<pre class="has"><code>grep "ab\?" 2.txt</code></pre>

<p style="margin-left:0cm;"><img alt="" class="has" height="183" src="https://img-blog.csdnimg.cn/20190123212046669.png" width="452"></p>

<h3 style="margin-left:0cm;">\+&nbsp; 1次或者多次 &nbsp;&nbsp;最少1次</h3>

<pre class="has"><code>grep "ab\+" 2.txt</code></pre>

<h3 style="margin-left:0cm;"><img alt="" class="has" height="209" src="https://img-blog.csdnimg.cn/20190123212225265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="452"></h3>

<h3 style="margin-left:0cm;">\{2\}&nbsp;&nbsp;&nbsp; 出现两次</h3>

<pre class="has"><code>grep "ab\{2\}" 2.txt</code></pre>

<h3 style="margin-left:0cm;"><img alt="" class="has" height="174" src="https://img-blog.csdnimg.cn/20190123212324847.png" width="482"></h3>

<h3 style="margin-left:0cm;">\{2，5\}&nbsp;&nbsp;&nbsp; 最少2次，最多5次</h3>

<pre class="has"><code>grep "ab\{2,5\}" 2.txt</code></pre>

<p><img alt="" class="has" height="160" src="https://img-blog.csdnimg.cn/20190123212425325.png" width="450"></p>

<h1 style="margin-left:0cm;">option选项</h1>

<h2 style="margin-left:0cm;">1）-i 忽略大小写</h2>

<p style="margin-left:0cm;">&nbsp;</p>

<pre class="has"><code>[root@zhang ~]# grep -i "^r" 1.txt</code></pre>

<p style="margin-left:0cm;">&nbsp;</p>

<h2 style="margin-left:0cm;">2）-o 仅显示符合正则表达式的内容，不显示整行</h2>

<pre class="has"><code>[root@zhang ~]# grep -o&nbsp; "r..t" /etc/passwd

root</code></pre>

<h2 style="margin-left:0cm;">3）-v 反向过滤</h2>

<pre class="has"><code>[root@zhang ~]# grep -v "^#" /etc/fstab



/dev/mapper/centos-root /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xfs&nbsp;&nbsp;&nbsp;&nbsp; defaults&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0

UUID=20b4a09c-ba00-41d4-a6d5-7dc24bc0a057 /boot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xfs&nbsp;&nbsp;&nbsp;&nbsp; defaults&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0

/dev/mapper/centos-swap swap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swap&nbsp;&nbsp;&nbsp; defaults&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0</code></pre>

<p style="margin-left:0cm;">&nbsp;</p>

<h2 style="margin-left:0cm;">4）-e 根据多条件过滤文件</h2>

<pre class="has"><code>[root@zhang ~]# grep -e "^$" -e "^#" /etc/fstab



#

# /etc/fstab

# Created by anaconda on Mon Jan&nbsp; 7 01:19:06 2019</code></pre>

<h2 style="margin-left:0cm;">4）-E 支持扩展正则表达式</h2>

<pre class="has"><code>grep -E "vmx|svm" /proc/cpuinfo

</code></pre>

<h2 style="margin-left:0cm;">5）-A n 显示符合条件的后2行</h2>

<pre class="has"><code>[root@zhang ~]# ifconfig |grep -A 2 "netmask"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 192.168.196.131&nbsp; netmask 255.255.255.0&nbsp; broadcast 192.168.196.255

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet6 fe80::20c:29ff:fe8e:e21b&nbsp; prefixlen 64&nbsp; scopeid 0x20&lt;link&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether 00:0c:29:8e:e2:1b&nbsp; txqueuelen 1000&nbsp; (Ethernet)

--

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 127.0.0.1&nbsp; netmask 255.0.0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet6 ::1&nbsp; prefixlen 128&nbsp; scopeid 0x10&lt;host&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop&nbsp; txqueuelen 1000&nbsp; (Local Loopback)</code></pre>

<p style="margin-left:0cm;">&nbsp;</p>

<h2 style="margin-left:0cm;">6）-B n 显示符合条件的前2行</h2>

<pre class="has"><code>[root@zhang ~]# ifconfig |grep -B 2 "netmask"

ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;&nbsp; mtu 1500

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 192.168.196.131&nbsp; netmask 255.255.255.0&nbsp; broadcast 192.168.196.255

--



lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;&nbsp; mtu 65536

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 127.0.0.1&nbsp; netmask 255.0.0.0</code></pre>

<h2><span style="color:#3399ea;"><u><strong>博主正在自学Linux云计算，有学习的的小伙伴可以相互交流，增强技术。</strong></u></span></h2>

<hr>                                    ]]></description></item><item><title>Vim文本编辑器详细用法</title><link>http://www.cnblogs.com/heian99/archive/2019/01/19/11972341.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 19 Jan 2019 11:03:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/19/11972341.html</guid><description><![CDATA[
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h2><a id="1_ViVim_0"></a>1 Vi、Vim文本编辑器</h2>
<p>1．Vi、Vim<br>
Vi是Visual interface的简称。<br>
Vim是Vi的增强版，即Vi Improved。在后面的实例中将介绍Vim的使用。</p>
<h2><a id="vi_8"></a>为什么学vi？</h2>
<p>1）所有的Unix Like 系统都会内建 vi 文本编辑器，其他的文本编辑器则不一定会存在；<br>
2）很多个别软件的编辑接口都会主动呼叫 vi (例如未来会谈到的 crontab, visudo, edquota 等指令)；<br>
3）vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法癿正确性，方便程序设计；<br>
4）因为程序简单，编辑速度相当快速。</p>
<p><strong>系统自带教程：vimtutor<br>
vim [options] [filelist]<br>
常用选项：<br>
+[num]<br>
+/{pat}</strong></p>
<h2><a id="1_21"></a>1、工作模式、命令模式、输入模式和末行模式</h2>
<p><img src="https://img-blog.csdnimg.cn/20190119184917217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
Vim拥有5种编辑模式：命令模式、输入模式、末行模式、可视化模式、查询模式。<br>
1）．命令模式（其它模式→ESC）<br>
2）．输入模式（命令模式→a、i、o、A、I、O）<br>
3）．末行模式（命令模式→:）<br>
4）．可视化模式（命令模式→v）<br>
5）．查询模式（命令模式→?、/）</p>
<h2><a id="2_31"></a>2、模式之间切换</h2>
<p><img src="https://img-blog.csdnimg.cn/20190119185126706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<strong>命令模式：</strong><br>
<img src="https://img-blog.csdnimg.cn/2019011918522467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20190119185236884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20190119185247593.png" alt="在这里插入图片描述"><br>
<strong>输入模式：</strong></p>
<p>新增 (append)</p>
<p>a ：从光标所在位置後面开始新增资料，光标後的资料随新增资料向後移动。<br>
A： 从光标所在列最後面的地方开始新增资料。</p>
<p>插入 (insert)</p>
<p>i： 从光标所在位置前面开始插入资料，光标後的资料随新增资料向後移动。<br>
I ：从光标所在列的第一个非空白字元前面开始插入资料。</p>
<p>开始 (open)</p>
<p>o ：在光标所在列下新增一列并进入输入模式。<br>
O: 在光标所在列上方新增一列并进入输入模式</p>
<p><strong>末行模式：</strong><br>
<img src="https://img-blog.csdnimg.cn/20190119185605373.png" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20190119185619908.png" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20190119185636316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><a id="3_59"></a>3、打开文件</h2>
<p>vim /path/to/somefile<br>
vim +# :打开文件，并定位于第#行<br>
vim +：打开文件，定位至最后一行<br>
vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首<br>
默认处于编辑模式</p>
<h2><a id="4_66"></a>4、关闭文件</h2>
<p>1、末行模式关闭文件<br>
:q  退出<br>
:wq 保存并退出<br>
:q! 不保存并退出<br>
:w 保存<br>
:w! 强行保存<br>
:wq --&gt; :x<br>
2、编辑模式下退出<br>
ZZ: 保存并退出</p>
<h2><a id="4_77"></a>4、移动光标(编辑模式)</h2>
<p>1、逐字符移动：<br>
h: 左<br>
l: 右<br>
j: 下<br>
k: 上<br>
#h: 移动#个字符；</p>
<p>2、以单词为单位移动<br>
w: 移至下一个单词的词首<br>
e: 跳至当前或下一个单词的词尾<br>
b: 跳至当前或前一个单词的词首</p>
<p>#w:</p>
<p>3、行内跳转：<br>
0: 绝对行首<br>
^: 行首的第一个非空白字符<br>
$: 绝对行尾<br>
home<br>
end</p>
<p>4、行间跳转<br>
#G：跳转至第#行；<br>
G：最后一行<br>
1G：跳转到第1行首===gg</p>
<p>末行模式下，直接给出行号即可<br>
:5 直接定位到第5行首</p>
<h2><a id="5_107"></a>5、翻屏</h2>
<p>Ctrl+f: 向下翻一屏<br>
Ctrl+b: 向上翻一屏</p>
<p>Ctrl+d: 向下翻半屏<br>
Ctrl+u: 向上翻半屏</p>
<h2><a id="6_115"></a>6、删除单个字符</h2>
<p>x: 删除光标所在处的单个字符<br>
#x: 删除光标所在处及向后的共#个字符</p>
<h2><a id="7_d_120"></a>7、删除命令: d</h2>
<p>d命令跟跳转命令组合使用；<br>
#dw, #de, #db</p>
<p>dd: 删除当前光标所在行<br>
#dd: 删除包括当前光标所在行在内的#行；</p>
<p>末行模式下：<br>
StartADD,EndADDd<br>
.: 表示当前行<br>
$: 最后一行<br>
+#: 向下的#行</p>
<h2><a id="8_p_134"></a>8、粘贴命令 p</h2>
<p>p: 如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面；<br>
P: 如果删除或复制为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面；</p>
<h2><a id="9_y_139"></a>9、复制命令 y</h2>
<p>用法同d命令<br>
yy 复制1行<br>
5yy 复制5行</p>
<h2><a id="10_146"></a>10、修改：先删除内容，再转换为输入模式</h2>
<p>c: 用法同d命令</p>
<h2><a id="11r_150"></a>11、替换：r</h2>
<p>R: 替换模式</p>
<h2><a id="12_u_154"></a>12、撤消编辑操作 u</h2>
<p>u：撤消前一次的编辑操作<br>
连续u命令可撤消此前的n次编辑操作<br>
#u: 直接撤消最近#次编辑操作</p>
<p>撤消最近一次撤消操作：Ctrl+r</p>
<h2><a id="13_163"></a>13、可视化模式</h2>
<p>v: 按字符选取<br>
该模式下通过光标移动选择文本，选取后按 y 可以把文本提取到缓冲区（即复制），c 可以剪切。之后可以使用p在光标后粘贴，P粘贴在光标前<br>
V：按矩形选取<br>
V是行选取模式，以行为单位进行选取。Ctrl+v是块选取模式，可以选取一块矩形区域中的文本。</p>
<h2><a id="14_170"></a>14、查找</h2>
<p>/PATTERN<br>
?PATTERN<br>
n<br>
N</p>
<h2><a id="15_177"></a>15、查找并替换</h2>
<pre><code>	在末行模式下使用s命令
	ADDR1,ADDR2s@PATTERN@string@gi
	1,$
	%：表示全文	
	:s/root/admin/  替换光标所在行第一个root为admin
	:s/root/admin/g 替换光标所在行所有root为admin
	:1,5 s/root/admin/g 替换第1-5行所有root为admin
	:1,$ s/admin/root/g 替换所有行的admin为root ==== 1,$ 等价于%
</code></pre>
<h2><a id="16vim_190"></a>16、使用vim编辑多个文件</h2>
<p>vim FILE1 FILE2 FILE3<br>
:next 切换至下一个文件<br>
:prev 切换至前一个文件<br>
:last 切换至最后一个文件<br>
:first 切换至第一个文件</p>
<p>退出<br>
:qa 全部退出</p>
<h2><a id="17_201"></a>17、分屏显示一个文件</h2>
<p>Ctrl+w, s: 水平拆分窗口<br>
Ctrl+w, v: 垂直拆分窗口</p>
<p>在窗口间切换光标：<br>
Ctrl+w, ARROW(表示上下左右箭头)</p>
<pre><code>:qa 关闭所有窗口
</code></pre>
<h2><a id="18_211"></a>18、分窗口编辑多个文件</h2>
<p>vim -o : 水平分割显示<br>
vim -O : 垂直分割显示</p>
<h2><a id="19_216"></a>19、将当前文件中部分内容另存为另外一个文件</h2>
<p>末行模式下使用w命令	<br>
:w	<br>
:ADDR1,ADDR2w /path/to/somewhere</p>
<h2><a id="20_222"></a>20、将另外一个文件的内容填充在当前文件中</h2>
<p>:r /path/to/somefile</p>
<h2><a id="21shell_226"></a>21、跟shell交互</h2>
<p>:! COMMAND</p>
<h2><a id="22_231"></a>22、高级话题</h2>
<p>1、显示或取消显示行号<br>
:set number<br>
:set nu</p>
<p>:set nonu</p>
<p>2、显示忽略或区分字符大小写<br>
:set ignorecase<br>
:set ic</p>
<p>:set noic</p>
<p>3、设定自动缩进<br>
:set autoindent<br>
:set ai<br>
:set noai</p>
<p>4、查找到的文本高亮显示或取消<br>
:set hlsearch<br>
:set nohlsearch</p>
<p>5、语法高亮<br>
:syntax on<br>
:syntax off</p>
<h2><a id="23_258"></a>23、配置文件</h2>
<pre><code>/etc/vimrc
~/.vimrc
set hlsearch            "高亮度反白
set backspace=2     "可随时用退格键删除
set autoindent        "自动缩排
set tabstop=4			"缩进
set softtabstop=4   softtabstop是“逢4空格进1制表符”,前提是你tabstop=4
set shiftwidth=4      自动缩进空格长度
set mouse=a				"使用鼠标
set selection=exclusive
set selectmode=mouse,key
set ruler               "可显示最后一行的状态
set showmode            "左下角那一行的状态
set nu                  "可以在每一行的最前面显示行号啦！
set bg=dark             "显示不同的底色色调
syntax on               "进行语法检验，颜色显示	
</code></pre>

                                    ]]></description></item><item><title>Linux命令查找文件目录</title><link>http://www.cnblogs.com/heian99/archive/2019/01/07/11972342.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Mon, 07 Jan 2019 15:55:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/07/11972342.html</guid><description><![CDATA[
                                            <p><strong>座右铭：长风破浪会有时，直挂云帆济沧海。</strong></p>

<p><strong>linux一般查看文件或者目录有几种方法。</strong></p>

<p style="margin-left:0cm;"><strong>/查看文件类容--------cat/more/less/head/tail&nbsp;&nbsp; 只能查看文本型（txt）</strong></p>

<p style="margin-left:0cm;"><strong>（1）查看文件较少的类容</strong></p>

<p style="margin-left:0cm;"><strong>cat /etc/fstab</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="388" src="https://img-blog.csdnimg.cn/20190107233111669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1011"></strong></p>

<p style="margin-left:0cm;"><strong>cat -n /etc/fstab</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="618" src="https://img-blog.csdnimg.cn/2019010723333718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="959"></strong></p>

<p style="margin-left:0cm;"><strong>（2）查看未知类容</strong></p>

<p style="margin-left:0cm;"><strong>看未知的类容文件，我们不知道有多大，就用more和less查看比较方便使用</strong></p>

<h3 style="margin-left:0cm;"><strong>两者相同点：可以 翻页 或者 一行一行查看</strong></h3>

<h2 style="margin-left:0cm;"><strong>&nbsp; &nbsp; &nbsp; &nbsp;不同点：more只能往下翻页，有的翻过了，就不能翻回去了</strong></h2>

<h2 style="margin-left:0cm;"><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;less可以往上往下随意查看翻动</strong></h2>

<p style="margin-left:0cm;">&nbsp;</p>

<h3 style="margin-left:0cm;"><strong>more/less&nbsp; 分页显示类容</strong></h3>

<h3 style="margin-left:0cm;"><strong>more 只能往下翻（空格：翻页 &nbsp;&nbsp;回车：一行一行 &nbsp;&nbsp;q：退出）</strong></h3>

<h3 style="margin-left:0cm;"><strong>less&nbsp;&nbsp; 可以上下翻</strong></h3>

<p style="margin-left:0cm;"><strong>less /usr/share/dict/words</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="693" src="https://img-blog.csdnimg.cn/2019010723400934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="927"></strong></p>

<p style="margin-left:0cm;"><strong>（3）head/tail（头部/尾巴）</strong></p>

<p style="margin-left:0cm;"><strong>head</strong></p>

<p style="margin-left:0cm;"><strong>不写-n显示前10行类容</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="513" src="https://img-blog.csdnimg.cn/2019010723430748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="726"></strong></p>

<p style="margin-left:0cm;"><strong>[root@chengfeng ~]# head -n 3 /etc/passwd(显示前三行)</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="279" src="https://img-blog.csdnimg.cn/20190107234153885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="806"></strong></p>

<p style="margin-left:0cm;"><strong>Tail</strong></p>

<p style="margin-left:0cm;"><strong>不写-n显示后10行类容</strong></p>

<p style="margin-left:0cm;"><strong>[root@chengfeng ~]# tail-n 3 /etc/passwd(显示前三行)</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="566" src="https://img-blog.csdnimg.cn/20190107234448629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="818"></strong></p>

<p><strong>（4）查看文件类型</strong></p>

<p>&nbsp;</p>

<p><strong>&nbsp;</strong></p>

<pre class="has"><code>[root@chengfeng ~]# file /etc/passwd  （查看文件类型）</code></pre>

<p><strong><img alt="" class="has" height="257" src="https://img-blog.csdnimg.cn/20190107234655848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="857"></strong></p>

<p><strong>&nbsp;（5）查看命令所在的路径</strong></p>

<pre class="has"><code>[root@chengfeng ~]# which ls
alias ls='ls --color=auto'
	/usr/bin/ls
[root@chengfeng ~]# which cd
/usr/bin/cd
</code></pre>

<p><strong>（6）|&nbsp; :管道符 &nbsp;连接命令 &nbsp;前面的命令给后面命令当参数</strong></p>

<pre class="has"><code>[root@chengfeng ~]# head -n 5 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
[root@chengfeng ~]# head -n 5 /etc/passwd | tail -n 1（显示passwd第5行的类容）
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
</code></pre>

<p><strong>&nbsp;显示前4个最大文件</strong></p>

<pre class="has"><code>root@chengfeng ~]# ls -lhS /etc/ | head -n 5
总用量 1.4M
-rw-r--r--.  1 root root   655K 6月   7 2013 services
-rw-r--r--   1 root root    92K 1月   7 14:35 ld.so.cache
-rw-r--r--   1 root root    51K 5月  15 2013 mime.types
-rw-r--r--   1 root root    15K 10月 31 08:17 autofs.conf
</code></pre>

<p><strong>&nbsp;显示最近修改的文件</strong></p>

<pre class="has"><code>[root@chengfeng ~]# ls -lt /etc/ |head -n 11
总用量 1396
drwxr-xr-x   5 root lp        304 1月   7 19:01 cups
-rw-r--r--   1 root root       57 1月   7 19:01 resolv.conf
-rw-r--r--   1 root root     1992 1月   7 14:51 passwd
----------   1 root root     1138 1月   7 14:50 shadow
----------   1 root root      690 1月   7 14:50 gshadow
-rw-r--r--   1 root root      862 1月   7 14:50 group
-rw-r--r--.  1 root root      850 1月   7 14:49 group-
----------.  1 root root      682 1月   7 14:49 gshadow-
</code></pre>

<p><strong>（7）查找文件或目录</strong></p>

<p style="margin-left:0cm;"><strong># find 路径 查找方式</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p><strong>按文件名称查找</strong></p>

<pre class="has"><code>[root@chengfeng ~]# find /etc/ -name "*.conf"
/etc/resolv.conf
/etc/pki/ca-trust/ca-legacy.conf
/etc/yum/pluginconf.d/fastestmirror.conf

</code></pre>

<p style="margin-left:0cm;"><strong>统计查找的文件个数</strong></p>

<pre class="has"><code>[root@chengfeng ~]# find /etc/ -name "*.conf" |wc -l
352
</code></pre>

<p><strong>&nbsp;</strong></p>

<p style="margin-left:0cm;"><strong>按文件大小查找</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><strong>查找大于1M的文件</strong></p>

<pre class="has"><code>[root@chengfeng ~]# find /etc/ -size +1M
/etc/udev/hwdb.bin
/etc/selinux/targeted/contexts/files/file_contexts.bin
/etc/selinux/targeted/policy/policy.31
/etc/selinux/targeted/active/policy.kern
/etc/selinux/targeted/active/policy.linked
</code></pre>

<p><strong>&nbsp;按文件的修改时间查找</strong></p>

<p>&nbsp;</p>

<p style="margin-left:0cm;"><strong>查找7前修改的文件</strong></p>

<pre class="has"><code>[root@chengfeng ~]# find / -mtime +7</code></pre>

<p style="margin-left:0cm;"><strong>查找7内修改的文件</strong></p>

<pre class="has"><code>[root@chengfeng ~]# find / -mtime -7</code></pre>

<p><strong>&nbsp;按文件的类型查找</strong></p>

<pre class="has"><code>[root@chengfeng ~]# find /dev/ -type b
/dev/dm-1
/dev/dm-0
/dev/sda2
/dev/sda1
/dev/sda
/dev/sr0
[root@chengfeng ~]# find /dev/ -type l
</code></pre>

<p style="margin-left:0cm;"><strong>复合条件查文件</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><strong>[root@chengfeng ~]# find / -mtime +7 -a -size +100k（a：and并列）</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><strong>Find /bj/ -name “*.txt” &nbsp;-exec rm -rf {}\;&nbsp; 删除</strong></p>

<p style="margin-left:0cm;"><strong># Find /bj/ -name “*.txt” &nbsp;-exec cp {} /root \;复制</strong></p>                                    ]]></description></item><item><title>Linux文件增删改</title><link>http://www.cnblogs.com/heian99/archive/2019/01/06/11972344.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sun, 06 Jan 2019 05:58:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/06/11972344.html</guid><description><![CDATA[
                                            <p><strong>Linux目录/文件增删改</strong></p>

<p style="margin-left:0cm;"><strong>创建文件</strong></p>

<p style="margin-left:0cm;"><strong>(1)</strong></p>

<p style="margin-left:0cm;"><strong># touch&nbsp; &lt;文件名称&gt;</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="358" src="https://img-blog.csdnimg.cn/2019010613380274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="997"></strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><strong>(2)</strong></p>

<p style="margin-left:0cm;"><strong>花括号展开</strong></p>

<p style="margin-left:0cm;"><strong>touch /root/{1,3,9}.txt</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="262" src="https://img-blog.csdnimg.cn/20190106134002790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="963"></strong></p>

<p style="margin-left:0cm;"><strong>touch /root/{0..100}.txt&nbsp; 批量创建文件</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="532" src="https://img-blog.csdnimg.cn/20190106134135947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="992"></strong></p>

<p><strong>删除文件</strong></p>

<p><strong>rm -f [文件名]&nbsp;</strong></p>

<p><strong>-rf&nbsp; 代表强制删除</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="569" src="https://img-blog.csdnimg.cn/20190106134510587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="992"></strong></p>

<p><strong>批量删除文件</strong></p>

<p><strong>rm -f *txt</strong></p>

<p><strong><img alt="" class="has" height="584" src="https://img-blog.csdnimg.cn/20190106134738416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1013"></strong></p>

<p>&nbsp;</p>

<p style="margin-left:0cm;"><strong>复制文件</strong></p>

<p style="margin-left:0cm;"><strong>cp 只能复制文件</strong></p>

<p style="margin-left:0cm;"><strong>cp -r&nbsp; 可以复制目录</strong></p>

<p style="margin-left:0cm;"><strong># cp [option] 源文件 &nbsp;目标文件</strong></p>

<pre class="has"><code>[root@zhang ~]# mkdir /root/{linux,windown}
[root@zhang ~]# ls
anaconda-ks.cfg  linux  mysql57-community-release-el7-8.noarch.rpm  windown
[root@zhang ~]# touch /root/linux/{1,2,3}.txt
[root@zhang ~]# ls
anaconda-ks.cfg  linux  mysql57-community-release-el7-8.noarch.rpm  windown
[root@zhang ~]# cd linux/
[root@zhang linux]# ls
1.txt  2.txt  3.txt
[root@zhang linux]# cd /r
root/ run/  
[root@zhang linux]# cd /root/
[root@zhang ~]# cp /root/linux/1.txt /root/windown/
[root@zhang ~]# cd windown/
[root@zhang windown]# ls
1.txt
[root@zhang windown]# cd ..
[root@zhang ~]# ls
anaconda-ks.cfg  linux  mysql57-community-release-el7-8.noarch.rpm  windown
[root@zhang ~]# cp /root/linux/2.txt /root/windown/2.jpg
[root@zhang ~]# cd windown/
[root@zhang windown]# ls
1.txt  2.jpg
</code></pre>

<p><strong>&nbsp;-r&nbsp;&nbsp; 复制文件目录</strong></p>

<pre class="has"><code>[root@zhang ~]# cp -r /root/linux/ windown/
[root@zhang ~]# ls
anaconda-ks.cfg  linux  mysql57-community-release-el7-8.noarch.rpm  windown
[root@zhang ~]# cd windown/
[root@zhang windown]# ls
1.txt  2.jpg  linux
[root@zhang windown]# cd linux/
[root@zhang linux]# ls
1.txt  2.txt  3.txt
</code></pre>

<p style="margin-left:0cm;"><strong>-fn 强制覆盖</strong></p>

<pre class="has"><code>[root@zhang ~]# cp -fn /root/linux/1.txt /root/windown/</code></pre>

<p style="margin-left:0cm;"><strong>移动文件</strong></p>

<p style="margin-left:0cm;"><strong>#mv 源文件 目标文件</strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;"><strong>文件重名</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="307" src="https://img-blog.csdnimg.cn/2019010613525846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="899"></strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p style="margin-left:0cm;">&nbsp;</p>

<p><strong><img alt="" class="has" height="458" src="https://img-blog.csdnimg.cn/20190106135739271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="939"></strong></p>                                    ]]></description></item><item><title>Linux目录管理</title><link>http://www.cnblogs.com/heian99/archive/2019/01/05/11972345.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Sat, 05 Jan 2019 06:54:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/05/11972345.html</guid><description><![CDATA[
                                            <p style="margin-left:0cm;"><strong>Linux文件目录管理</strong></p>

<p style="margin-left:0cm;"><strong>1：目录管理</strong></p>

<p style="margin-left:0cm;"><strong>1）切换目录</strong></p>

<p style="margin-left:0cm;"><strong># cd&nbsp; [ 目录名称]</strong></p>

<p style="margin-left:0cm;"><strong>2）退到上一目录</strong></p>

<p style="margin-left:0cm;"><strong># cd ..</strong></p>

<p style="margin-left:0cm;"><strong>2：创建目录</strong></p>

<p style="margin-left:0cm;"><strong>mkdir&nbsp; [文件名称] </strong></p>

<p style="margin-left:0cm;"><strong>mkdir -p&nbsp; [文件名称] 递归创建目录</strong></p>

<pre class="has"><code>mkdir -p /root/linux/zhang/wei</code></pre>

<p><strong>利用tree来查看结果</strong></p>

<pre class="has"><code>tree /root/linux</code></pre>

<p><strong>&nbsp;</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="573" src="https://img-blog.csdnimg.cn/20190105144105344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1025"></strong></p>

<p><strong>3：文件管理</strong></p>

<p style="margin-left:0cm;"><strong>1）查看文件</strong></p>

<p style="margin-left:0cm;"><strong>ls&nbsp; &lt;option&gt;&nbsp; [目录名称]</strong></p>

<p style="margin-left:0cm;"><strong>【option】：参数</strong></p>

<p style="margin-left:0cm;"><strong>-l 以详细信息显示出来</strong></p>

<p style="margin-left:0cm;"><strong>-rw-r--r--.&nbsp; 1 root root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 12月&nbsp; 4 21:42 adjtime</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="244" src="https://img-blog.csdnimg.cn/20190105144623577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="951"></strong></p>

<p style="margin-left:0cm;"><strong>解释：前面这些- r d l等符合的意思</strong></p>

<p style="margin-left:0cm;"><strong>-&nbsp; 文件</strong></p>

<p style="margin-left:0cm;"><strong>d&nbsp; 目录</strong></p>

<p style="margin-left:0cm;"><strong>l&nbsp;&nbsp; 软链接文件（link）类似快捷方式</strong></p>

<p style="margin-left:0cm;"><strong>b&nbsp;&nbsp; 块设备文件（block），硬盘，硬盘分区，u盘，光盘</strong></p>

<p style="margin-left:0cm;"><strong>c&nbsp;&nbsp; 字符设备文件（chaeacter）键盘，鼠标，显示器</strong></p>

<p style="margin-left:0cm;"><strong>ls&nbsp; &lt;option&gt;&nbsp; [目录名称]</strong></p>

<p style="margin-left:0cm;"><strong>参数：</strong></p>

<p style="margin-left:0cm;"><strong>-l&nbsp;&nbsp;&nbsp; 更加可视化的显示文件信息</strong></p>

<p style="margin-left:0cm;"><strong>-d&nbsp;&nbsp; 显示目录自身的信息</strong></p>

<p style="margin-left:0cm;"><strong>-a&nbsp;&nbsp;&nbsp; 显示目录的隐藏文件（以.开头的文件）</strong></p>

<p style="margin-left:0cm;"><strong>-t&nbsp;&nbsp;&nbsp;&nbsp; 按文件修改时间降序排列</strong></p>

<p style="margin-left:0cm;"><strong>-S&nbsp;&nbsp;&nbsp;&nbsp; 按文件大小降序排列</strong></p>

<p style="margin-left:0cm;"><strong>各个参数可以组合</strong></p>

<p style="margin-left:0cm;"><strong>du -sh&nbsp; [目录名称] 用来统计文件和目录占的大小</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="206" src="https://img-blog.csdnimg.cn/2019010514493984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="729"></strong></p>

<p style="margin-left:0cm;"><strong>du -ah&nbsp; [目录名称] 用来分享每个文件和目录占的大小</strong></p>

<p style="margin-left:0cm;"><strong><img alt="" class="has" height="439" src="https://img-blog.csdnimg.cn/20190105145107632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="826"></strong></p>

<p style="margin-left:0cm;">&nbsp;</p>

<p>&nbsp;</p>

<p><img alt="" class="has" height="691" src="https://img-blog.csdnimg.cn/20190105150620896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1017"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p style="text-indent:50px;">&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux修改主机名</title><link>http://www.cnblogs.com/heian99/archive/2019/01/04/11972347.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Fri, 04 Jan 2019 11:23:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/04/11972347.html</guid><description><![CDATA[
                                            <p><strong>时间久了，我越来越感觉linux比window好用。</strong></p>

<p><strong>难道这就是传说中的日久生情吗？</strong></p>

<p><strong>学习是持之以恒的，从基础开始，慢慢来，我相信自己有一天会变成大神的。</strong></p>

<p>&nbsp;</p>

<p><strong>Linux就是那么的方便，干什么就是一个命令就完事，不像window那么麻烦。</strong></p>

<p><strong>lLinux改主机名称，这个更加的简单。但是为了更深的记忆，还是再次写一下。</strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><strong>（1）linux一开始安装时就有修改主机名称的选项。</strong></p>

<p><strong>（2）如果在安装完后，想修改主机名称，一个命令就完成。</strong></p>

<p><strong>命令：hostnamectl set-hostname [你想修改的名称]</strong></p>

<pre class="has"><code>hostnamectl set-hostname zhang
</code></pre>

<p><strong><img alt="" class="has" height="409" src="https://img-blog.csdnimg.cn/20190104182515502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="777"></strong></p>

<p><strong>&nbsp;<img alt="" class="has" height="307" src="https://img-blog.csdnimg.cn/20190104191529175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="885"></strong></p>

<p>&nbsp;</p>

<p><strong>等你退出从新登录时，你就会发现linux命令字符串的改变；</strong></p>

<p><strong><img alt="" class="has" height="708" src="https://img-blog.csdnimg.cn/20190104192224721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1030"></strong></p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>Linux创建高级用户并删除</title><link>http://www.cnblogs.com/heian99/archive/2019/01/03/11972348.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 03 Jan 2019 11:30:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/03/11972348.html</guid><description><![CDATA[
                                            <p><strong>Linux创建高级用户并删除</strong></p>

<p><strong>常见window系统可以创建许多用户，但是linux也可以创建许多用户。</strong></p>

<p><strong>方法比window方便简单。</strong></p>

<p><strong>（1）添加一个普通用户 ：nangong（名字自己取）</strong></p>

<p><strong><img alt="" class="has" height="136" src="https://img-blog.csdnimg.cn/20190103184953829.png" width="705"></strong></p>

<pre class="has"><code>useradd nangong
</code></pre>

<p><strong>（2）设置用户nangong的密码</strong></p>

<p><strong><img alt="" class="has" height="313" src="https://img-blog.csdnimg.cn/2019010318542970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="795"></strong></p>

<p>&nbsp;</p>

<pre class="has"><code> passwd nangong
</code></pre>

<p><strong>（3）在root权限下修改/etc/passwd 里的用户nangong的权限</strong></p>

<pre class="has"><code>nangong:x:1000:1000::/home/nangong:/bin/bash

#把两个1000改为0就可以了
nangong:x:0:0::/home/nangong:/bin/bash
</code></pre>

<p><strong><img alt="" class="has" height="633" src="https://img-blog.csdnimg.cn/20190103185748386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="796"></strong></p>

<p><strong><img alt="" class="has" height="748" src="https://img-blog.csdnimg.cn/20190103190130253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="763"></strong></p>

<p><strong>（4）已经成功创建一个高级用户nangong</strong></p>

<p><strong><img alt="" class="has" height="301" src="https://img-blog.csdnimg.cn/20190103190411343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="756"></strong></p>

<p><strong>（a）删除一个用户，前提，那个用户没有在运行中，不然会提示下面的错误</strong></p>

<p><strong><img alt="" class="has" height="412" src="https://img-blog.csdnimg.cn/20190103190706617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="795"></strong></p>

<p><strong>解决方法：（1）切换到那个用户，然后连续按两次ctl+d，退出用户</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （2）使用vipw命令 ，删除nangong那行，保存</strong></p>

<p><strong><img alt="" class="has" height="582" src="https://img-blog.csdnimg.cn/20190103192234370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="765"></strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （3）然后使用vipw -s 命令 ，删除nangong那行，保存</strong></p>

<p><strong><img alt="" class="has" height="674" src="https://img-blog.csdnimg.cn/20190103192413723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1047"></strong></p>

<p>&nbsp;</p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong></p>

<p>&nbsp;</p>

<p><strong>然后就行下来的步骤即可</strong></p>

<p><strong>（b）我们来到/home下，可以看到nangong这个用户</strong></p>

<pre class="has"><code>cd /home</code></pre>

<p><strong><img alt="" class="has" height="196" src="https://img-blog.csdnimg.cn/20190103191012120.png" width="877"></strong></p>

<p><strong>(c)删除这个用户，但是命令不是rm</strong></p>

<p><strong>正确命令：</strong></p>

<pre class="has"><code> userdel -r nangong
</code></pre>

<p><strong><img alt="" class="has" height="251" src="https://img-blog.csdnimg.cn/20190103192650903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="808"></strong></p>

<p><strong>可以直接删除/home 的nangong</strong></p>

<p><strong>命令：</strong></p>

<pre class="has"><code class="language-ruby">rm -rf nangong
</code></pre>

<p>&nbsp;</p>                                    ]]></description></item><item><title>linux命令提示符解析</title><link>http://www.cnblogs.com/heian99/archive/2019/01/03/11972349.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 03 Jan 2019 10:20:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/03/11972349.html</guid><description><![CDATA[
                                            <p><strong>linux命令提示符</strong></p>

<p><strong>命令窗口中[root@chengfeng ~]# 表示什么意思？</strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前登录终端的用户</strong></p>

<p><strong>&nbsp; &nbsp;&nbsp; chengfeng &nbsp; &nbsp; 主机名(/etc/sysconfig/network)</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前用户的家目录</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 表示root用户的终端</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 普通用户的终端</strong></p>

<p><strong><img alt="" class="has" height="109" src="https://img-blog.csdnimg.cn/20190103180010623.png" width="1023"></strong></p>

<p><strong>（1）root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前登录终端的用户</strong></p>

<p><strong><img alt="" class="has" height="141" src="https://img-blog.csdnimg.cn/20190103180215972.png" width="668"></strong></p>

<p><strong>（2）&nbsp;&nbsp; chengfeng &nbsp; &nbsp; 主机名(/etc/sysconfig/network)</strong></p>

<p><strong>&nbsp;<img alt="" class="has" height="230" src="https://img-blog.csdnimg.cn/20190103180408332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1002"></strong></p>

<p><strong>（3）&nbsp;&nbsp; ~ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前用户的家目录</strong></p>

<p><strong>&nbsp;<img alt="" class="has" height="250" src="https://img-blog.csdnimg.cn/20190103180510786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="973"></strong></p>

<p>&nbsp;</p>

<p><strong>（4） # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 表示root用户的终端</strong></p>

<p><strong>&nbsp;<img alt="" class="has" height="188" src="https://img-blog.csdnimg.cn/20190103181750246.png" width="1018"></strong></p>

<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 普通用户的终端</strong></p>

<p><strong>a：添加一个普通的新用户</strong></p>

<p><strong><img alt="" class="has" height="265" src="https://img-blog.csdnimg.cn/2019010318125990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="984"></strong></p>

<p>&nbsp;</p>

<p><strong>&nbsp;b：切换到cat用户下</strong></p>

<p><strong><img alt="" class="has" height="330" src="https://img-blog.csdnimg.cn/20190103181857966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="981"></strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>linux目录结构</title><link>http://www.cnblogs.com/heian99/archive/2019/01/03/11972350.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Thu, 03 Jan 2019 08:50:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/03/11972350.html</guid><description><![CDATA[
                                            <p><strong>linux系统中一切皆文件。</strong></p>

<p><strong>有文件，当然少不了目录。</strong></p>

<p><strong>Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录。</strong></p>

<p><strong><img alt="" class="has" height="753" src="https://img-blog.csdnimg.cn/20190103163530210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="1195"></strong></p>

<p><strong>在此我介绍一下初学者需要先了解的linux目录，关于跟高深的linux目录，后期会做出相应的讲解&nbsp;</strong></p>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>/</strong></td>
			<td><strong>根目录</strong></td>
		</tr><tr><td><strong>/root</strong></td>
			<td><strong>root用户的家目录/宿主目录</strong></td>
		</tr><tr><td><strong>/boot</strong></td>
			<td><strong>启动分区（内核，启动配置文件）</strong></td>
		</tr><tr><td><strong>/dev</strong></td>
			<td><strong>设备文件目录</strong></td>
		</tr><tr><td><strong>/proc,/sys</strong></td>
			<td><strong>为根系统</strong></td>
		</tr><tr><td><strong>/etc</strong></td>
			<td><strong>应用程序的配置文件 &nbsp;&nbsp; *.conf</strong></td>
		</tr><tr><td><strong>/home</strong></td>
			<td><strong>普通用户的家目录/宿主目录</strong></td>
		</tr><tr><td><strong>带有/bin,/sbin</strong></td>
			<td><strong>可执行程序（二进制程序）</strong></td>
		</tr><tr><td><strong>/var</strong></td>
			<td><strong>放置系统执行过程中经常变化的文件，如随时更改的日志文件</strong></td>
		</tr><tr><td><strong>/tmp</strong></td>
			<td><strong>存放临时文件目录，一些命令和应用程序会用的到这个目录</strong></td>
		</tr></tbody></table><p><strong>/：</strong>根目录，位于Linux文件系统目录结构的顶层，一般根目录下只存放目录，不要存放文件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中。<br><strong>/bin，/usr/bin</strong>：该目录为命令文件目录，也称为二进制目录。包含了供系统管理员及普通用户使用的重要的linux命令和二进制（可执行）文件，包含shell解释器等。<br>
/boot： 该目录中存放系统的内核文件和引导装载程序文件，/boot/vmlinuz为linux的内核文件，以及/boot/gurb。建议单独分区，分区大小100M即可。<br><strong>/dev</strong>： 设备（device）文件目录，存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，存放连接到计算机上的设备（终端、磁盘驱动器、光驱及网卡等）的对应文件，包括字符设备和块设备等，常用的是挂载光驱mount /dev/cdrom/mnt。&nbsp;<br><strong>/etc</strong>： 系统配置文件存放的目录，该目录存放系统的大部分配置文件和子目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11（X Window系统有关）、/etc/sysconfig（与网络有关）、/etc/xinetd.d修改配置文件之前记得备份。该目录下的文件由系统管理员来使用，普通用户对大部分文件有只读权限。<br><strong>/home</strong>： 系统默认的用户宿主目录，新增用户账号时，用户的宿主目录都存放在此目录下，~表示当前用户的宿主目录，~test表示用户test的宿主目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据。<br><strong>/lib，/usr/lib，/usr/local/lib</strong>：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，该目录下存放了各种编程语言库。典型的linux系统包含了C、C++和FORTRAN语言的库文件。/lib目录下的库映像文件可以用来启动系统并执行一些命令，目录/lib/modules包含了可加载的内核模块，/lib目录存放了所有重要的库文件，其他的库文件则大部分存放在/usr/lib目录下。<br><strong>/proc</strong>： 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等。<br><strong>/root</strong>：系统管理员root的宿主目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下。<br><strong>/sbin，/usr/sbin，/usr/local/sbin</strong>：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能"查看"而不能设置和使用。<br><strong>/usr</strong>： 应用程序存放目录，/usr/bin 存放应用程序， /usr/share 存放共享数据，/usr/lib<br>
&nbsp;存放不能直接运行的，却是许多程序运行所必需的一些函数库文件，/usr/local 存放软件升级包，/usr/share/doc 系统说明文件存放目录。<br><strong>/usr/share/man</strong>: &nbsp;程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间。<br><strong>/var</strong>： 放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log。/var/log/message：<br>
&nbsp;所有的登录文件存放目录。/var/spool/mail： 邮件存放的目录。 /var/run: 程序或服务启动后。建议单独分区，设置较大的磁盘空间。<br><strong>/tmp</strong>：存放临时文件目录，一些命令和应用程序会用的到这个目录。该目录下的所有文件会被定时删除，以避免临时文件占满整个磁盘。<br>
&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item><item><title>linux基础操作</title><link>http://www.cnblogs.com/heian99/archive/2019/01/02/11972351.html</link><dc:creator>南宫乘风</dc:creator><author>南宫乘风</author><pubDate>Wed, 02 Jan 2019 08:59:00 GMT</pubDate><guid>http://www.cnblogs.com/heian99/archive/2019/01/02/11972351.html</guid><description><![CDATA[
                                            <p><strong>近期要入坑linux运维，在此交流自己的技术和心得。开始自己博客的生涯。（大神勿喷）</strong></p>

<p><strong>成功安装CentOS7后的基础步骤</strong></p>

<p><strong>软件：Vmware Workstation</strong></p>

<p><strong>系统：CentOS7</strong></p>

<p><strong><img alt="" class="has" height="375" src="https://img-blog.csdnimg.cn/2019010216493436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="553"></strong></p>

<p><strong>安装成功的CentOS7界面</strong></p>

<p style="margin-left:0cm;"><strong>安装完毕后操作:</strong></p>

<p style="margin-left:0cm;"><strong>（1）&nbsp;关闭防火墙</strong></p>

<pre class="has"><code>	systemctl   stop  firewalld   # 当前关闭防火墙
	systemctl   disable  firewalld  # 开机禁用防火墙
</code></pre>

<p style="margin-left:0cm;"><strong>（2）禁用SELinux</strong></p>

<pre class="has"><code>sed  -i.bak  ‘s/=enforcing/=disabled/’ /etc/selinux/config</code></pre>

<pre class="has"><code>sed  -i.bak  ‘s/=enforcing/=disabled/’ /etc/sysconfig/selinux</code></pre>

<p><strong>上面两串代码效果一样，只需要运行一个即可</strong></p>

<p style="margin-left:0cm;"><strong>（3）&nbsp; 关机</strong></p>

<pre class="has"><code>shutdown -h now
</code></pre>

<p><strong>（4）创建快照，避免重新安装</strong></p>

<p><strong><img alt="" class="has" height="426" src="https://img-blog.csdnimg.cn/20190102165741149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70" width="554"></strong></p>

<p><strong>（6）安装远程管理软件Xmanager6</strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>                                    ]]></description></item></channel></rss>